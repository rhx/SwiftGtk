import CGLib
import CCairo
import CPango
import CGdkPixbuf
import CGdk
import CGtk
import GLib
import GLibObject
import GIO
import Pango
import Cairo
import PangoCairo
import GdkPixbuf
import Gdk

// MARK: - ScaleButton Class

/// The `ScaleButtonProtocol` protocol exposes the methods and properties of an underlying `GtkScaleButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ScaleButton`.
/// Alternatively, use `ScaleButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkScaleButton` provides a button which pops up a scale widget.
/// 
/// This kind of widget is commonly used for volume controls in multimedia
/// applications, and GTK provides a [class`Gtk.VolumeButton`] subclass that
/// is tailored for this use case.
/// 
/// # CSS nodes
/// 
/// `GtkScaleButton` has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .scale style class.
public protocol ScaleButtonProtocol: WidgetProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkScaleButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkScaleButton` instance.
    var scale_button_ptr: UnsafeMutablePointer<GtkScaleButton>! { get }

    /// Required Initialiser for types conforming to `ScaleButtonProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `ScaleButtonRef` type acts as a lightweight Swift reference to an underlying `GtkScaleButton` instance.
/// It exposes methods that can operate on this data type through `ScaleButtonProtocol` conformance.
/// Use `ScaleButtonRef` only as an `unowned` reference to an existing `GtkScaleButton` instance.
///
/// `GtkScaleButton` provides a button which pops up a scale widget.
/// 
/// This kind of widget is commonly used for volume controls in multimedia
/// applications, and GTK provides a [class`Gtk.VolumeButton`] subclass that
/// is tailored for this use case.
/// 
/// # CSS nodes
/// 
/// `GtkScaleButton` has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .scale style class.
public struct ScaleButtonRef: ScaleButtonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkScaleButton` instance.
    /// For type-safe access, use the generated, typed pointer `scale_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ScaleButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkScaleButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkScaleButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkScaleButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkScaleButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ScaleButtonProtocol`
    @inlinable init<T: ScaleButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ScaleButtonProtocol>(_ other: T) -> ScaleButtonRef { ScaleButtonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a `GtkScaleButton`.
    /// 
    /// The new scale button has a range between `min` and `max`,
    /// with a stepping of `step`.
    @inlinable init( min: CDouble, max: CDouble, step: CDouble, icons: UnsafeMutablePointer<UnsafePointer<CChar>?>! = nil) {
        let rv = gtk_scale_button_new(min, max, step, icons)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ScaleButton` type acts as a reference-counted owner of an underlying `GtkScaleButton` instance.
/// It provides the methods that can operate on this data type through `ScaleButtonProtocol` conformance.
/// Use `ScaleButton` as a strong reference or owner of a `GtkScaleButton` instance.
///
/// `GtkScaleButton` provides a button which pops up a scale widget.
/// 
/// This kind of widget is commonly used for volume controls in multimedia
/// applications, and GTK provides a [class`Gtk.VolumeButton`] subclass that
/// is tailored for this use case.
/// 
/// # CSS nodes
/// 
/// `GtkScaleButton` has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .scale style class.
open class ScaleButton: Widget, ScaleButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkScaleButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkScaleButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkScaleButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkScaleButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkScaleButton`.
    /// i.e., ownership is transferred to the `ScaleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkScaleButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ScaleButtonProtocol`
    /// Will retain `GtkScaleButton`.
    /// - Parameter other: an instance of a related type that implements `ScaleButtonProtocol`
    @inlinable public init<T: ScaleButtonProtocol>(scaleButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScaleButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a `GtkScaleButton`.
    /// 
    /// The new scale button has a range between `min` and `max`,
    /// with a stepping of `step`.
    @inlinable public init( min: CDouble, max: CDouble, step: CDouble, icons: UnsafeMutablePointer<UnsafePointer<CChar>?>! = nil) {
        let rv = gtk_scale_button_new(min, max, step, icons)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ScaleButtonPropertyName: String, PropertyNameProtocol {
    /// The `GtkAdjustment` that is used as the model.
    case adjustment = "adjustment"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The names of the icons to be used by the scale button.
    /// 
    /// The first item in the array will be used in the button
    /// when the current value is the lowest value, the second
    /// item for the highest value. All the subsequent icons will
    /// be used for all the other values, spread evenly over the
    /// range of values.
    /// 
    /// If there's only one icon name in the `icons` array, it will
    /// be used for all the values. If only two icon names are in
    /// the `icons` array, the first one will be used for the bottom
    /// 50% of the scale, and the second one for the top 50%.
    /// 
    /// It is recommended to use at least 3 icons so that the
    /// `GtkScaleButton` reflects the current value of the scale
    /// better for the users.
    case icons = "icons"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// The value of the scale.
    case value = "value"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ScaleButtonProtocol {
    /// Bind a `ScaleButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ScaleButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ScaleButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ScaleButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ScaleButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ScaleButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ScaleButtonSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted to dismiss the popup.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is &lt;kbd&gt;Escape&lt;/kbd&gt;.
    case popdown = "popdown"
    /// Emitted to popup the scale widget.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are &lt;kbd&gt;Space&lt;/kbd&gt;,
    /// &lt;kbd&gt;Enter&lt;/kbd&gt; and &lt;kbd&gt;Return&lt;/kbd&gt;.
    case popup = "popup"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Emitted when the value field has changed.
    case valueChanged = "value-changed"
    /// The `GtkAdjustment` that is used as the model.
    case notifyAdjustment = "notify::adjustment"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The names of the icons to be used by the scale button.
    /// 
    /// The first item in the array will be used in the button
    /// when the current value is the lowest value, the second
    /// item for the highest value. All the subsequent icons will
    /// be used for all the other values, spread evenly over the
    /// range of values.
    /// 
    /// If there's only one icon name in the `icons` array, it will
    /// be used for all the values. If only two icon names are in
    /// the `icons` array, the first one will be used for the bottom
    /// 50% of the scale, and the second one for the top 50%.
    /// 
    /// It is recommended to use at least 3 icons so that the
    /// `GtkScaleButton` reflects the current value of the scale
    /// better for the users.
    case notifyIcons = "notify::icons"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// The value of the scale.
    case notifyValue = "notify::value"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ScaleButton signals
public extension ScaleButtonProtocol {
    /// Connect a Swift signal handler to the given, typed `ScaleButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ScaleButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ScaleButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ScaleButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted to dismiss the popup.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is &lt;kbd&gt;Escape&lt;/kbd&gt;.
    /// - Note: This represents the underlying `popdown` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `popdown` signal is emitted
    @discardableResult @inlinable func onPopdown(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScaleButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ScaleButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScaleButtonRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .popdown,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `popdown` signal for using the `connect(signal:)` methods
    static var popdownSignal: ScaleButtonSignalName { .popdown }
    
    /// Emitted to popup the scale widget.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are &lt;kbd&gt;Space&lt;/kbd&gt;,
    /// &lt;kbd&gt;Enter&lt;/kbd&gt; and &lt;kbd&gt;Return&lt;/kbd&gt;.
    /// - Note: This represents the underlying `popup` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `popup` signal is emitted
    @discardableResult @inlinable func onPopup(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScaleButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ScaleButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScaleButtonRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .popup,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `popup` signal for using the `connect(signal:)` methods
    static var popupSignal: ScaleButtonSignalName { .popup }
    
    /// Emitted when the value field has changed.
    /// - Note: This represents the underlying `value-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter value: the new value
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `valueChanged` signal is emitted
    @discardableResult @inlinable func onValueChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScaleButtonRef, _ value: Double) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScaleButtonRef, Double, Void>
        let cCallback: @convention(c) (gpointer, gdouble, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScaleButtonRef(raw: unownedSelf), Double(arg1))
            return output
        }
        return connect(
            signal: .valueChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `value-changed` signal for using the `connect(signal:)` methods
    static var valueChangedSignal: ScaleButtonSignalName { .valueChanged }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::adjustment` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAdjustment` signal is emitted
    @discardableResult @inlinable func onNotifyAdjustment(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScaleButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScaleButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScaleButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAdjustment,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::adjustment` signal for using the `connect(signal:)` methods
    static var notifyAdjustmentSignal: ScaleButtonSignalName { .notifyAdjustment }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::icons` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIcons` signal is emitted
    @discardableResult @inlinable func onNotifyIcons(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScaleButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScaleButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScaleButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyIcons,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::icons` signal for using the `connect(signal:)` methods
    static var notifyIconsSignal: ScaleButtonSignalName { .notifyIcons }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::value` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyValue` signal is emitted
    @discardableResult @inlinable func onNotifyValue(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScaleButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScaleButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScaleButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyValue,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::value` signal for using the `connect(signal:)` methods
    static var notifyValueSignal: ScaleButtonSignalName { .notifyValue }
    
}

// MARK: ScaleButton Class: ScaleButtonProtocol extension (methods and fields)
public extension ScaleButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkScaleButton` instance.
    @inlinable var scale_button_ptr: UnsafeMutablePointer<GtkScaleButton>! { return ptr?.assumingMemoryBound(to: GtkScaleButton.self) }

    /// Gets the `GtkAdjustment` associated with the `GtkScaleButton`’s scale.
    /// 
    /// See [method`Gtk.Range.get_adjustment`] for details.
    @inlinable func getAdjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scale_button_get_adjustment(scale_button_ptr)))
        return rv
    }

    /// Retrieves the minus button of the `GtkScaleButton`.
    @inlinable func getMinusButton() -> ButtonRef! {
        let rv = ButtonRef(gconstpointer: gconstpointer(gtk_scale_button_get_minus_button(scale_button_ptr)))
        return rv
    }

    /// Retrieves the plus button of the `GtkScaleButton.`
    @inlinable func getPlusButton() -> ButtonRef! {
        let rv = ButtonRef(gconstpointer: gconstpointer(gtk_scale_button_get_plus_button(scale_button_ptr)))
        return rv
    }

    /// Retrieves the popup of the `GtkScaleButton`.
    @inlinable func getPopup() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scale_button_get_popup(scale_button_ptr))) else { return nil }
        return rv
    }

    /// Gets the current value of the scale button.
    @inlinable func getValue() -> CDouble {
        let rv = gtk_scale_button_get_value(scale_button_ptr)
        return rv
    }

    /// Sets the `GtkAdjustment` to be used as a model
    /// for the `GtkScaleButton`’s scale.
    /// 
    /// See [method`Gtk.Range.set_adjustment`] for details.
    @inlinable func set<AdjustmentT: AdjustmentProtocol>(adjustment: AdjustmentT) {
        gtk_scale_button_set_adjustment(scale_button_ptr, adjustment.adjustment_ptr)
    
    }

    /// Sets the icons to be used by the scale button.
    @inlinable func set(icons: UnsafeMutablePointer<UnsafePointer<CChar>?>!) {
        gtk_scale_button_set_icons(scale_button_ptr, icons)
    
    }

    /// Sets the current value of the scale.
    /// 
    /// If the value is outside the minimum or maximum range values,
    /// it will be clamped to fit inside them.
    /// 
    /// The scale button emits the [signal`Gtk.ScaleButton::value-changed`]
    /// signal if the value changes.
    @inlinable func set(value: CDouble) {
        gtk_scale_button_set_value(scale_button_ptr, value)
    
    }
    /// The `GtkAdjustment` that is used as the model.
    @inlinable var adjustment: AdjustmentRef! {
        /// Gets the `GtkAdjustment` associated with the `GtkScaleButton`’s scale.
        /// 
        /// See [method`Gtk.Range.get_adjustment`] for details.
        get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scale_button_get_adjustment(scale_button_ptr)))
            return rv
        }
        /// Sets the `GtkAdjustment` to be used as a model
        /// for the `GtkScaleButton`’s scale.
        /// 
        /// See [method`Gtk.Range.set_adjustment`] for details.
        nonmutating set {
            gtk_scale_button_set_adjustment(scale_button_ptr, UnsafeMutablePointer<GtkAdjustment>(newValue?.adjustment_ptr))
        }
    }

    /// Retrieves the minus button of the `GtkScaleButton`.
    @inlinable var minusButton: ButtonRef! {
        /// Retrieves the minus button of the `GtkScaleButton`.
        get {
            let rv = ButtonRef(gconstpointer: gconstpointer(gtk_scale_button_get_minus_button(scale_button_ptr)))
            return rv
        }
    }

    /// Retrieves the plus button of the `GtkScaleButton.`
    @inlinable var plusButton: ButtonRef! {
        /// Retrieves the plus button of the `GtkScaleButton.`
        get {
            let rv = ButtonRef(gconstpointer: gconstpointer(gtk_scale_button_get_plus_button(scale_button_ptr)))
            return rv
        }
    }

    /// Retrieves the popup of the `GtkScaleButton`.
    @inlinable var popup: WidgetRef! {
        /// Retrieves the popup of the `GtkScaleButton`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scale_button_get_popup(scale_button_ptr))) else { return nil }
            return rv
        }
    }

    /// The value of the scale.
    @inlinable var value: CDouble {
        /// Gets the current value of the scale button.
        get {
            let rv = gtk_scale_button_get_value(scale_button_ptr)
            return rv
        }
        /// Sets the current value of the scale.
        /// 
        /// If the value is outside the minimum or maximum range values,
        /// it will be clamped to fit inside them.
        /// 
        /// The scale button emits the [signal`Gtk.ScaleButton::value-changed`]
        /// signal if the value changes.
        nonmutating set {
            gtk_scale_button_set_value(scale_button_ptr, newValue)
        }
    }

    @inlinable var parentInstance: GtkWidget {
        get {
            let rv = scale_button_ptr.pointee.parent_instance
            return rv
        }
    }

}



// MARK: - Scrollbar Class

/// The `ScrollbarProtocol` protocol exposes the methods and properties of an underlying `GtkScrollbar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Scrollbar`.
/// Alternatively, use `ScrollbarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkScrollbar` widget is a horizontal or vertical scrollbar.
/// 
/// ![An example GtkScrollbar](scrollbar.png)
/// 
/// Its position and movement are controlled by the adjustment that is passed to
/// or created by [ctor`Gtk.Scrollbar.new`]. See [class.Gtk.Adjustment] for more
/// details. The [property`Gtk.Adjustment:value`] field sets the position of the
/// thumb and must be between [property`Gtk.Adjustment:lower`] and
/// [property`Gtk.Adjustment:upper`] - [property`Gtk.Adjustment:page-size`].
/// The [property`Gtk.Adjustment:page-size`] represents the size of the visible
/// scrollable area.
/// 
/// The fields [property`Gtk.Adjustment:step-increment`] and
/// [property`Gtk.Adjustment:page-increment`] fields are added to or subtracted
/// from the [property`Gtk.Adjustment:value`] when the user asks to move by a step
/// (using e.g. the cursor arrow keys) or by a page (using e.g. the Page Down/Up
/// keys).
/// 
/// # CSS nodes
/// 
/// ```
/// scrollbar
/// ╰── range[.fine-tune]
///     ╰── trough
///         ╰── slider
/// ```
/// 
/// `GtkScrollbar` has a main CSS node with name scrollbar and a subnode for its
/// contents. The main node gets the .horizontal or .vertical style classes applied,
/// depending on the scrollbar's orientation.
/// 
/// The range node gets the style class .fine-tune added when the scrollbar is
/// in 'fine-tuning' mode.
/// 
/// Other style classes that may be added to scrollbars inside
/// [class`Gtk.ScrolledWindow`] include the positional classes (.left, .right,
/// .top, .bottom) and style classes related to overlay scrolling (.overlay-indicator,
/// .dragging, .hovering).
/// 
/// # Accessibility
/// 
/// `GtkScrollbar` uses the `GTK_ACCESSIBLE_ROLE_SCROLLBAR` role.
public protocol ScrollbarProtocol: WidgetProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkScrollbar` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkScrollbar` instance.
    var scrollbar_ptr: UnsafeMutablePointer<GtkScrollbar>! { get }

    /// Required Initialiser for types conforming to `ScrollbarProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `ScrollbarRef` type acts as a lightweight Swift reference to an underlying `GtkScrollbar` instance.
/// It exposes methods that can operate on this data type through `ScrollbarProtocol` conformance.
/// Use `ScrollbarRef` only as an `unowned` reference to an existing `GtkScrollbar` instance.
///
/// The `GtkScrollbar` widget is a horizontal or vertical scrollbar.
/// 
/// ![An example GtkScrollbar](scrollbar.png)
/// 
/// Its position and movement are controlled by the adjustment that is passed to
/// or created by [ctor`Gtk.Scrollbar.new`]. See [class.Gtk.Adjustment] for more
/// details. The [property`Gtk.Adjustment:value`] field sets the position of the
/// thumb and must be between [property`Gtk.Adjustment:lower`] and
/// [property`Gtk.Adjustment:upper`] - [property`Gtk.Adjustment:page-size`].
/// The [property`Gtk.Adjustment:page-size`] represents the size of the visible
/// scrollable area.
/// 
/// The fields [property`Gtk.Adjustment:step-increment`] and
/// [property`Gtk.Adjustment:page-increment`] fields are added to or subtracted
/// from the [property`Gtk.Adjustment:value`] when the user asks to move by a step
/// (using e.g. the cursor arrow keys) or by a page (using e.g. the Page Down/Up
/// keys).
/// 
/// # CSS nodes
/// 
/// ```
/// scrollbar
/// ╰── range[.fine-tune]
///     ╰── trough
///         ╰── slider
/// ```
/// 
/// `GtkScrollbar` has a main CSS node with name scrollbar and a subnode for its
/// contents. The main node gets the .horizontal or .vertical style classes applied,
/// depending on the scrollbar's orientation.
/// 
/// The range node gets the style class .fine-tune added when the scrollbar is
/// in 'fine-tuning' mode.
/// 
/// Other style classes that may be added to scrollbars inside
/// [class`Gtk.ScrolledWindow`] include the positional classes (.left, .right,
/// .top, .bottom) and style classes related to overlay scrolling (.overlay-indicator,
/// .dragging, .hovering).
/// 
/// # Accessibility
/// 
/// `GtkScrollbar` uses the `GTK_ACCESSIBLE_ROLE_SCROLLBAR` role.
public struct ScrollbarRef: ScrollbarProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkScrollbar` instance.
    /// For type-safe access, use the generated, typed pointer `scrollbar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ScrollbarRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkScrollbar>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkScrollbar>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkScrollbar>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkScrollbar>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ScrollbarProtocol`
    @inlinable init<T: ScrollbarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ScrollbarProtocol>(_ other: T) -> ScrollbarRef { ScrollbarRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new scrollbar with the given orientation.
    @inlinable init<AdjustmentT: AdjustmentProtocol>( orientation: GtkOrientation, adjustment: AdjustmentT?) {
        let rv = gtk_scrollbar_new(orientation, adjustment?.adjustment_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Scrollbar` type acts as a reference-counted owner of an underlying `GtkScrollbar` instance.
/// It provides the methods that can operate on this data type through `ScrollbarProtocol` conformance.
/// Use `Scrollbar` as a strong reference or owner of a `GtkScrollbar` instance.
///
/// The `GtkScrollbar` widget is a horizontal or vertical scrollbar.
/// 
/// ![An example GtkScrollbar](scrollbar.png)
/// 
/// Its position and movement are controlled by the adjustment that is passed to
/// or created by [ctor`Gtk.Scrollbar.new`]. See [class.Gtk.Adjustment] for more
/// details. The [property`Gtk.Adjustment:value`] field sets the position of the
/// thumb and must be between [property`Gtk.Adjustment:lower`] and
/// [property`Gtk.Adjustment:upper`] - [property`Gtk.Adjustment:page-size`].
/// The [property`Gtk.Adjustment:page-size`] represents the size of the visible
/// scrollable area.
/// 
/// The fields [property`Gtk.Adjustment:step-increment`] and
/// [property`Gtk.Adjustment:page-increment`] fields are added to or subtracted
/// from the [property`Gtk.Adjustment:value`] when the user asks to move by a step
/// (using e.g. the cursor arrow keys) or by a page (using e.g. the Page Down/Up
/// keys).
/// 
/// # CSS nodes
/// 
/// ```
/// scrollbar
/// ╰── range[.fine-tune]
///     ╰── trough
///         ╰── slider
/// ```
/// 
/// `GtkScrollbar` has a main CSS node with name scrollbar and a subnode for its
/// contents. The main node gets the .horizontal or .vertical style classes applied,
/// depending on the scrollbar's orientation.
/// 
/// The range node gets the style class .fine-tune added when the scrollbar is
/// in 'fine-tuning' mode.
/// 
/// Other style classes that may be added to scrollbars inside
/// [class`Gtk.ScrolledWindow`] include the positional classes (.left, .right,
/// .top, .bottom) and style classes related to overlay scrolling (.overlay-indicator,
/// .dragging, .hovering).
/// 
/// # Accessibility
/// 
/// `GtkScrollbar` uses the `GTK_ACCESSIBLE_ROLE_SCROLLBAR` role.
open class Scrollbar: Widget, ScrollbarProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkScrollbar>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkScrollbar>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkScrollbar>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkScrollbar>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkScrollbar`.
    /// i.e., ownership is transferred to the `Scrollbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkScrollbar>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ScrollbarProtocol`
    /// Will retain `GtkScrollbar`.
    /// - Parameter other: an instance of a related type that implements `ScrollbarProtocol`
    @inlinable public init<T: ScrollbarProtocol>(scrollbar other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrollbarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new scrollbar with the given orientation.
    @inlinable public init<AdjustmentT: AdjustmentProtocol>( orientation: GtkOrientation, adjustment: AdjustmentT?) {
        let rv = gtk_scrollbar_new(orientation, adjustment?.adjustment_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ScrollbarPropertyName: String, PropertyNameProtocol {
    /// The `GtkAdjustment` controlled by this scrollbar.
    case adjustment = "adjustment"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ScrollbarProtocol {
    /// Bind a `ScrollbarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ScrollbarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Scrollbar property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ScrollbarPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Scrollbar property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ScrollbarPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ScrollbarSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The `GtkAdjustment` controlled by this scrollbar.
    case notifyAdjustment = "notify::adjustment"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: Scrollbar has no signals
// MARK: Scrollbar Class: ScrollbarProtocol extension (methods and fields)
public extension ScrollbarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkScrollbar` instance.
    @inlinable var scrollbar_ptr: UnsafeMutablePointer<GtkScrollbar>! { return ptr?.assumingMemoryBound(to: GtkScrollbar.self) }

    /// Returns the scrollbar's adjustment.
    @inlinable func getAdjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scrollbar_get_adjustment(scrollbar_ptr)))
        return rv
    }

    /// Makes the scrollbar use the given adjustment.
    @inlinable func set(adjustment: AdjustmentRef? = nil) {
        gtk_scrollbar_set_adjustment(scrollbar_ptr, adjustment?.adjustment_ptr)
    
    }
    /// Makes the scrollbar use the given adjustment.
    @inlinable func set<AdjustmentT: AdjustmentProtocol>(adjustment: AdjustmentT?) {
        gtk_scrollbar_set_adjustment(scrollbar_ptr, adjustment?.adjustment_ptr)
    
    }
    /// The `GtkAdjustment` controlled by this scrollbar.
    @inlinable var adjustment: AdjustmentRef! {
        /// Returns the scrollbar's adjustment.
        get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scrollbar_get_adjustment(scrollbar_ptr)))
            return rv
        }
        /// Makes the scrollbar use the given adjustment.
        nonmutating set {
            gtk_scrollbar_set_adjustment(scrollbar_ptr, UnsafeMutablePointer<GtkAdjustment>(newValue?.adjustment_ptr))
        }
    }


}



// MARK: - ScrolledWindow Class

/// The `ScrolledWindowProtocol` protocol exposes the methods and properties of an underlying `GtkScrolledWindow` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ScrolledWindow`.
/// Alternatively, use `ScrolledWindowRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkScrolledWindow` is a container that makes its child scrollable.
/// 
/// It does so using either internally added scrollbars or externally
/// associated adjustments, and optionally draws a frame around the child.
/// 
/// Widgets with native scrolling support, i.e. those whose classes implement
/// the [iface`Gtk.Scrollable`] interface, are added directly. For other types
/// of widget, the class [class`Gtk.Viewport`] acts as an adaptor, giving
/// scrollability to other widgets. [method`Gtk.ScrolledWindow.set_child`]
/// intelligently accounts for whether or not the added child is a `GtkScrollable`.
/// If it isn’t, then it wraps the child in a `GtkViewport`. Therefore, you can
/// just add any child widget and not worry about the details.
/// 
/// If [method`Gtk.ScrolledWindow.set_child`] has added a `GtkViewport` for you,
/// you can remove both your added child widget from the `GtkViewport`, and the
/// `GtkViewport` from the `GtkScrolledWindow`, like this:
/// 
/// ```c
/// GtkWidget *scrolled_window = gtk_scrolled_window_new ();
/// GtkWidget *child_widget = gtk_button_new ();
/// 
/// // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
/// // add a GtkViewport.
/// gtk_box_append (GTK_BOX (scrolled_window), child_widget);
/// 
/// // Either of these will result in child_widget being unparented:
/// gtk_box_remove (GTK_BOX (scrolled_window), child_widget);
/// // or
/// gtk_box_remove (GTK_BOX (scrolled_window),
///                       gtk_bin_get_child (GTK_BIN (scrolled_window)));
/// ```
/// 
/// Unless [property`Gtk.ScrolledWindow:hscrollbar-policy`] and
/// [property`Gtk.ScrolledWindow:vscrollbar-policy`] are `GTK_POLICY_NEVER` or
/// `GTK_POLICY_EXTERNAL`, `GtkScrolledWindow` adds internal `GtkScrollbar` widgets
/// around its child. The scroll position of the child, and if applicable the
/// scrollbars, is controlled by the [property`Gtk.ScrolledWindow:hadjustment`]
/// and [property`Gtk.ScrolledWindow:vadjustment`] that are associated with the
/// `GtkScrolledWindow`. See the docs on [class`Gtk.Scrollbar`] for the details,
/// but note that the “step_increment” and “page_increment” fields are only
/// effective if the policy causes scrollbars to be present.
/// 
/// If a `GtkScrolledWindow` doesn’t behave quite as you would like, or
/// doesn’t have exactly the right layout, it’s very possible to set up
/// your own scrolling with `GtkScrollbar` and for example a `GtkGrid`.
/// 
/// # Touch support
/// 
/// `GtkScrolledWindow` has built-in support for touch devices. When a
/// touchscreen is used, swiping will move the scrolled window, and will
/// expose 'kinetic' behavior. This can be turned off with the
/// [property`Gtk.ScrolledWindow:kinetic-scrolling`] property if it is undesired.
/// 
/// `GtkScrolledWindow` also displays visual 'overshoot' indication when
/// the content is pulled beyond the end, and this situation can be
/// captured with the [signal`Gtk.ScrolledWindow::edge-overshot`] signal.
/// 
/// If no mouse device is present, the scrollbars will overlaid as
/// narrow, auto-hiding indicators over the content. If traditional
/// scrollbars are desired although no mouse is present, this behaviour
/// can be turned off with the [property`Gtk.ScrolledWindow:overlay-scrolling`]
/// property.
/// 
/// # CSS nodes
/// 
/// `GtkScrolledWindow` has a main CSS node with name scrolledwindow.
/// It gets a .frame style class added when [property`Gtk.ScrolledWindow:has-frame`]
/// is `true`.
/// 
/// It uses subnodes with names overshoot and undershoot to draw the overflow
/// and underflow indications. These nodes get the .left, .right, .top or .bottom
/// style class added depending on where the indication is drawn.
/// 
/// `GtkScrolledWindow` also sets the positional style classes (.left, .right,
/// .top, .bottom) and style classes related to overlay scrolling
/// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
/// 
/// If both scrollbars are visible, the area where they meet is drawn
/// with a subnode named junction.
/// 
/// # Accessibility
/// 
/// `GtkScrolledWindow` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
public protocol ScrolledWindowProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkScrolledWindow` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkScrolledWindow` instance.
    var scrolled_window_ptr: UnsafeMutablePointer<GtkScrolledWindow>! { get }

    /// Required Initialiser for types conforming to `ScrolledWindowProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `ScrolledWindowRef` type acts as a lightweight Swift reference to an underlying `GtkScrolledWindow` instance.
/// It exposes methods that can operate on this data type through `ScrolledWindowProtocol` conformance.
/// Use `ScrolledWindowRef` only as an `unowned` reference to an existing `GtkScrolledWindow` instance.
///
/// `GtkScrolledWindow` is a container that makes its child scrollable.
/// 
/// It does so using either internally added scrollbars or externally
/// associated adjustments, and optionally draws a frame around the child.
/// 
/// Widgets with native scrolling support, i.e. those whose classes implement
/// the [iface`Gtk.Scrollable`] interface, are added directly. For other types
/// of widget, the class [class`Gtk.Viewport`] acts as an adaptor, giving
/// scrollability to other widgets. [method`Gtk.ScrolledWindow.set_child`]
/// intelligently accounts for whether or not the added child is a `GtkScrollable`.
/// If it isn’t, then it wraps the child in a `GtkViewport`. Therefore, you can
/// just add any child widget and not worry about the details.
/// 
/// If [method`Gtk.ScrolledWindow.set_child`] has added a `GtkViewport` for you,
/// you can remove both your added child widget from the `GtkViewport`, and the
/// `GtkViewport` from the `GtkScrolledWindow`, like this:
/// 
/// ```c
/// GtkWidget *scrolled_window = gtk_scrolled_window_new ();
/// GtkWidget *child_widget = gtk_button_new ();
/// 
/// // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
/// // add a GtkViewport.
/// gtk_box_append (GTK_BOX (scrolled_window), child_widget);
/// 
/// // Either of these will result in child_widget being unparented:
/// gtk_box_remove (GTK_BOX (scrolled_window), child_widget);
/// // or
/// gtk_box_remove (GTK_BOX (scrolled_window),
///                       gtk_bin_get_child (GTK_BIN (scrolled_window)));
/// ```
/// 
/// Unless [property`Gtk.ScrolledWindow:hscrollbar-policy`] and
/// [property`Gtk.ScrolledWindow:vscrollbar-policy`] are `GTK_POLICY_NEVER` or
/// `GTK_POLICY_EXTERNAL`, `GtkScrolledWindow` adds internal `GtkScrollbar` widgets
/// around its child. The scroll position of the child, and if applicable the
/// scrollbars, is controlled by the [property`Gtk.ScrolledWindow:hadjustment`]
/// and [property`Gtk.ScrolledWindow:vadjustment`] that are associated with the
/// `GtkScrolledWindow`. See the docs on [class`Gtk.Scrollbar`] for the details,
/// but note that the “step_increment” and “page_increment” fields are only
/// effective if the policy causes scrollbars to be present.
/// 
/// If a `GtkScrolledWindow` doesn’t behave quite as you would like, or
/// doesn’t have exactly the right layout, it’s very possible to set up
/// your own scrolling with `GtkScrollbar` and for example a `GtkGrid`.
/// 
/// # Touch support
/// 
/// `GtkScrolledWindow` has built-in support for touch devices. When a
/// touchscreen is used, swiping will move the scrolled window, and will
/// expose 'kinetic' behavior. This can be turned off with the
/// [property`Gtk.ScrolledWindow:kinetic-scrolling`] property if it is undesired.
/// 
/// `GtkScrolledWindow` also displays visual 'overshoot' indication when
/// the content is pulled beyond the end, and this situation can be
/// captured with the [signal`Gtk.ScrolledWindow::edge-overshot`] signal.
/// 
/// If no mouse device is present, the scrollbars will overlaid as
/// narrow, auto-hiding indicators over the content. If traditional
/// scrollbars are desired although no mouse is present, this behaviour
/// can be turned off with the [property`Gtk.ScrolledWindow:overlay-scrolling`]
/// property.
/// 
/// # CSS nodes
/// 
/// `GtkScrolledWindow` has a main CSS node with name scrolledwindow.
/// It gets a .frame style class added when [property`Gtk.ScrolledWindow:has-frame`]
/// is `true`.
/// 
/// It uses subnodes with names overshoot and undershoot to draw the overflow
/// and underflow indications. These nodes get the .left, .right, .top or .bottom
/// style class added depending on where the indication is drawn.
/// 
/// `GtkScrolledWindow` also sets the positional style classes (.left, .right,
/// .top, .bottom) and style classes related to overlay scrolling
/// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
/// 
/// If both scrollbars are visible, the area where they meet is drawn
/// with a subnode named junction.
/// 
/// # Accessibility
/// 
/// `GtkScrolledWindow` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
public struct ScrolledWindowRef: ScrolledWindowProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkScrolledWindow` instance.
    /// For type-safe access, use the generated, typed pointer `scrolled_window_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ScrolledWindowRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkScrolledWindow>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkScrolledWindow>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkScrolledWindow>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkScrolledWindow>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ScrolledWindowProtocol`
    @inlinable init<T: ScrolledWindowProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ScrolledWindowProtocol>(_ other: T) -> ScrolledWindowRef { ScrolledWindowRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new scrolled window.
    @inlinable init() {
        let rv = gtk_scrolled_window_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ScrolledWindow` type acts as a reference-counted owner of an underlying `GtkScrolledWindow` instance.
/// It provides the methods that can operate on this data type through `ScrolledWindowProtocol` conformance.
/// Use `ScrolledWindow` as a strong reference or owner of a `GtkScrolledWindow` instance.
///
/// `GtkScrolledWindow` is a container that makes its child scrollable.
/// 
/// It does so using either internally added scrollbars or externally
/// associated adjustments, and optionally draws a frame around the child.
/// 
/// Widgets with native scrolling support, i.e. those whose classes implement
/// the [iface`Gtk.Scrollable`] interface, are added directly. For other types
/// of widget, the class [class`Gtk.Viewport`] acts as an adaptor, giving
/// scrollability to other widgets. [method`Gtk.ScrolledWindow.set_child`]
/// intelligently accounts for whether or not the added child is a `GtkScrollable`.
/// If it isn’t, then it wraps the child in a `GtkViewport`. Therefore, you can
/// just add any child widget and not worry about the details.
/// 
/// If [method`Gtk.ScrolledWindow.set_child`] has added a `GtkViewport` for you,
/// you can remove both your added child widget from the `GtkViewport`, and the
/// `GtkViewport` from the `GtkScrolledWindow`, like this:
/// 
/// ```c
/// GtkWidget *scrolled_window = gtk_scrolled_window_new ();
/// GtkWidget *child_widget = gtk_button_new ();
/// 
/// // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
/// // add a GtkViewport.
/// gtk_box_append (GTK_BOX (scrolled_window), child_widget);
/// 
/// // Either of these will result in child_widget being unparented:
/// gtk_box_remove (GTK_BOX (scrolled_window), child_widget);
/// // or
/// gtk_box_remove (GTK_BOX (scrolled_window),
///                       gtk_bin_get_child (GTK_BIN (scrolled_window)));
/// ```
/// 
/// Unless [property`Gtk.ScrolledWindow:hscrollbar-policy`] and
/// [property`Gtk.ScrolledWindow:vscrollbar-policy`] are `GTK_POLICY_NEVER` or
/// `GTK_POLICY_EXTERNAL`, `GtkScrolledWindow` adds internal `GtkScrollbar` widgets
/// around its child. The scroll position of the child, and if applicable the
/// scrollbars, is controlled by the [property`Gtk.ScrolledWindow:hadjustment`]
/// and [property`Gtk.ScrolledWindow:vadjustment`] that are associated with the
/// `GtkScrolledWindow`. See the docs on [class`Gtk.Scrollbar`] for the details,
/// but note that the “step_increment” and “page_increment” fields are only
/// effective if the policy causes scrollbars to be present.
/// 
/// If a `GtkScrolledWindow` doesn’t behave quite as you would like, or
/// doesn’t have exactly the right layout, it’s very possible to set up
/// your own scrolling with `GtkScrollbar` and for example a `GtkGrid`.
/// 
/// # Touch support
/// 
/// `GtkScrolledWindow` has built-in support for touch devices. When a
/// touchscreen is used, swiping will move the scrolled window, and will
/// expose 'kinetic' behavior. This can be turned off with the
/// [property`Gtk.ScrolledWindow:kinetic-scrolling`] property if it is undesired.
/// 
/// `GtkScrolledWindow` also displays visual 'overshoot' indication when
/// the content is pulled beyond the end, and this situation can be
/// captured with the [signal`Gtk.ScrolledWindow::edge-overshot`] signal.
/// 
/// If no mouse device is present, the scrollbars will overlaid as
/// narrow, auto-hiding indicators over the content. If traditional
/// scrollbars are desired although no mouse is present, this behaviour
/// can be turned off with the [property`Gtk.ScrolledWindow:overlay-scrolling`]
/// property.
/// 
/// # CSS nodes
/// 
/// `GtkScrolledWindow` has a main CSS node with name scrolledwindow.
/// It gets a .frame style class added when [property`Gtk.ScrolledWindow:has-frame`]
/// is `true`.
/// 
/// It uses subnodes with names overshoot and undershoot to draw the overflow
/// and underflow indications. These nodes get the .left, .right, .top or .bottom
/// style class added depending on where the indication is drawn.
/// 
/// `GtkScrolledWindow` also sets the positional style classes (.left, .right,
/// .top, .bottom) and style classes related to overlay scrolling
/// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
/// 
/// If both scrollbars are visible, the area where they meet is drawn
/// with a subnode named junction.
/// 
/// # Accessibility
/// 
/// `GtkScrolledWindow` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
open class ScrolledWindow: Widget, ScrolledWindowProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkScrolledWindow>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkScrolledWindow>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkScrolledWindow>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkScrolledWindow>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkScrolledWindow`.
    /// i.e., ownership is transferred to the `ScrolledWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkScrolledWindow>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ScrolledWindowProtocol`
    /// Will retain `GtkScrolledWindow`.
    /// - Parameter other: an instance of a related type that implements `ScrolledWindowProtocol`
    @inlinable public init<T: ScrolledWindowProtocol>(scrolledWindow other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ScrolledWindowProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new scrolled window.
    @inlinable public init() {
        let rv = gtk_scrolled_window_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ScrolledWindowPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    case hadjustment = "hadjustment"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Whether to draw a frame around the contents.
    case hasFrame = "has-frame"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// When the horizontal scrollbar is displayed.
    /// 
    /// Use [method`Gtk.ScrolledWindow.set_policy`] to set
    /// this property.
    case hscrollbarPolicy = "hscrollbar-policy"
    /// Whether kinetic scrolling is enabled or not.
    /// 
    /// Kinetic scrolling only applies to devices with source `GDK_SOURCE_TOUCHSCREEN`.
    case kineticScrolling = "kinetic-scrolling"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The maximum content height of `scrolled_window`.
    case maxContentHeight = "max-content-height"
    /// The maximum content width of `scrolled_window`.
    case maxContentWidth = "max-content-width"
    /// The minimum content height of `scrolled_window`.
    case minContentHeight = "min-content-height"
    /// The minimum content width of `scrolled_window`.
    case minContentWidth = "min-content-width"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// Whether overlay scrolling is enabled or not.
    /// 
    /// If it is, the scrollbars are only added as traditional widgets
    /// when a mouse is present. Otherwise, they are overlaid on top of
    /// the content, as narrow indicators.
    /// 
    /// Note that overlay scrolling can also be globally disabled, with
    /// the [property`Gtk.Settings:gtk-overlay-scrolling`] setting.
    case overlayScrolling = "overlay-scrolling"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the natural height of the child should be calculated and propagated
    /// through the scrolled window’s requested natural height.
    /// 
    /// This is useful in cases where an attempt should be made to allocate exactly
    /// enough space for the natural size of the child.
    case propagateNaturalHeight = "propagate-natural-height"
    /// Whether the natural width of the child should be calculated and propagated
    /// through the scrolled window’s requested natural width.
    /// 
    /// This is useful in cases where an attempt should be made to allocate exactly
    /// enough space for the natural size of the child.
    case propagateNaturalWidth = "propagate-natural-width"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    case vadjustment = "vadjustment"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// When the vertical scrollbar is displayed.
    /// 
    /// Use [method`Gtk.ScrolledWindow.set_policy`] to set
    /// this property.
    case vscrollbarPolicy = "vscrollbar-policy"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
    /// Where the contents are located with respect to the scrollbars.
    case windowPlacement = "window-placement"
}

public extension ScrolledWindowProtocol {
    /// Bind a `ScrolledWindowPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ScrolledWindowPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ScrolledWindow property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ScrolledWindowPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ScrolledWindow property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ScrolledWindowPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ScrolledWindowSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted whenever user initiated scrolling makes the scrolled
    /// window firmly surpass the limits defined by the adjustment
    /// in that orientation.
    /// 
    /// A similar behavior without edge resistance is provided by the
    /// [signal`Gtk.ScrolledWindow::edge-reached`] signal.
    /// 
    /// Note: The `pos` argument is LTR/RTL aware, so callers should be
    /// aware too if intending to provide behavior on horizontal edges.
    case edgeOvershot = "edge-overshot"
    /// Emitted whenever user-initiated scrolling makes the scrolled
    /// window exactly reach the lower or upper limits defined by the
    /// adjustment in that orientation.
    /// 
    /// A similar behavior with edge resistance is provided by the
    /// [signal`Gtk.ScrolledWindow::edge-overshot`] signal.
    /// 
    /// Note: The `pos` argument is LTR/RTL aware, so callers should be
    /// aware too if intending to provide behavior on horizontal edges.
    case edgeReached = "edge-reached"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// Emitted when focus is moved away from the scrolled window by a
    /// keybinding.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// `Ctrl + Tab` to move forward and `Ctrl + Shift + Tab` to
    /// move backward.
    case moveFocusOut = "move-focus-out"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when a keybinding that scrolls is pressed.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The horizontal or vertical adjustment is updated which triggers a
    /// signal that the scrolled window’s child may listen to and scroll itself.
    case scrollChild = "scroll-child"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    case notifyHadjustment = "notify::hadjustment"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Whether to draw a frame around the contents.
    case notifyHasFrame = "notify::has-frame"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// When the horizontal scrollbar is displayed.
    /// 
    /// Use [method`Gtk.ScrolledWindow.set_policy`] to set
    /// this property.
    case notifyHscrollbarPolicy = "notify::hscrollbar-policy"
    /// Whether kinetic scrolling is enabled or not.
    /// 
    /// Kinetic scrolling only applies to devices with source `GDK_SOURCE_TOUCHSCREEN`.
    case notifyKineticScrolling = "notify::kinetic-scrolling"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The maximum content height of `scrolled_window`.
    case notifyMaxContentHeight = "notify::max-content-height"
    /// The maximum content width of `scrolled_window`.
    case notifyMaxContentWidth = "notify::max-content-width"
    /// The minimum content height of `scrolled_window`.
    case notifyMinContentHeight = "notify::min-content-height"
    /// The minimum content width of `scrolled_window`.
    case notifyMinContentWidth = "notify::min-content-width"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// Whether overlay scrolling is enabled or not.
    /// 
    /// If it is, the scrollbars are only added as traditional widgets
    /// when a mouse is present. Otherwise, they are overlaid on top of
    /// the content, as narrow indicators.
    /// 
    /// Note that overlay scrolling can also be globally disabled, with
    /// the [property`Gtk.Settings:gtk-overlay-scrolling`] setting.
    case notifyOverlayScrolling = "notify::overlay-scrolling"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the natural height of the child should be calculated and propagated
    /// through the scrolled window’s requested natural height.
    /// 
    /// This is useful in cases where an attempt should be made to allocate exactly
    /// enough space for the natural size of the child.
    case notifyPropagateNaturalHeight = "notify::propagate-natural-height"
    /// Whether the natural width of the child should be calculated and propagated
    /// through the scrolled window’s requested natural width.
    /// 
    /// This is useful in cases where an attempt should be made to allocate exactly
    /// enough space for the natural size of the child.
    case notifyPropagateNaturalWidth = "notify::propagate-natural-width"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    case notifyVadjustment = "notify::vadjustment"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// When the vertical scrollbar is displayed.
    /// 
    /// Use [method`Gtk.ScrolledWindow.set_policy`] to set
    /// this property.
    case notifyVscrollbarPolicy = "notify::vscrollbar-policy"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
    /// Where the contents are located with respect to the scrollbars.
    case notifyWindowPlacement = "notify::window-placement"
}

// MARK: ScrolledWindow signals
public extension ScrolledWindowProtocol {
    /// Connect a Swift signal handler to the given, typed `ScrolledWindowSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ScrolledWindowSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ScrolledWindowSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ScrolledWindowSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted whenever user initiated scrolling makes the scrolled
    /// window firmly surpass the limits defined by the adjustment
    /// in that orientation.
    /// 
    /// A similar behavior without edge resistance is provided by the
    /// [signal`Gtk.ScrolledWindow::edge-reached`] signal.
    /// 
    /// Note: The `pos` argument is LTR/RTL aware, so callers should be
    /// aware too if intending to provide behavior on horizontal edges.
    /// - Note: This represents the underlying `edge-overshot` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pos: edge side that was hit
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `edgeOvershot` signal is emitted
    @discardableResult @inlinable func onEdgeOvershot(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pos: PositionType) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, PositionType, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), PositionType(arg1))
            return output
        }
        return connect(
            signal: .edgeOvershot,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `edge-overshot` signal for using the `connect(signal:)` methods
    static var edgeOvershotSignal: ScrolledWindowSignalName { .edgeOvershot }
    
    /// Emitted whenever user-initiated scrolling makes the scrolled
    /// window exactly reach the lower or upper limits defined by the
    /// adjustment in that orientation.
    /// 
    /// A similar behavior with edge resistance is provided by the
    /// [signal`Gtk.ScrolledWindow::edge-overshot`] signal.
    /// 
    /// Note: The `pos` argument is LTR/RTL aware, so callers should be
    /// aware too if intending to provide behavior on horizontal edges.
    /// - Note: This represents the underlying `edge-reached` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pos: edge side that was reached
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `edgeReached` signal is emitted
    @discardableResult @inlinable func onEdgeReached(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pos: PositionType) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, PositionType, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), PositionType(arg1))
            return output
        }
        return connect(
            signal: .edgeReached,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `edge-reached` signal for using the `connect(signal:)` methods
    static var edgeReachedSignal: ScrolledWindowSignalName { .edgeReached }
    
    /// Emitted when focus is moved away from the scrolled window by a
    /// keybinding.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// `Ctrl + Tab` to move forward and `Ctrl + Shift + Tab` to
    /// move backward.
    /// - Note: This represents the underlying `move-focus-out` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter directionType: either `GTK_DIR_TAB_FORWARD` or   `GTK_DIR_TAB_BACKWARD`
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `moveFocusOut` signal is emitted
    @discardableResult @inlinable func onMoveFocusOut(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ directionType: DirectionType) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, DirectionType, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), DirectionType(arg1))
            return output
        }
        return connect(
            signal: .moveFocusOut,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `move-focus-out` signal for using the `connect(signal:)` methods
    static var moveFocusOutSignal: ScrolledWindowSignalName { .moveFocusOut }
    
    /// Emitted when a keybinding that scrolls is pressed.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The horizontal or vertical adjustment is updated which triggers a
    /// signal that the scrolled window’s child may listen to and scroll itself.
    /// - Note: This represents the underlying `scroll-child` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter scroll: a `GtkScrollType` describing how much to scroll
    /// - Parameter horizontal: whether the keybinding scrolls the child   horizontally or not
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `scrollChild` signal is emitted
    @discardableResult @inlinable func onScrollChild(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ scroll: ScrollType, _ horizontal: Bool) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<ScrolledWindowRef, ScrollType, Bool, Bool>
        let cCallback: @convention(c) (gpointer, UInt32, gboolean, gpointer) -> gboolean = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(ScrolledWindowRef(raw: unownedSelf), ScrollType(arg1), ((arg2) != 0))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .scrollChild,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `scroll-child` signal for using the `connect(signal:)` methods
    static var scrollChildSignal: ScrolledWindowSignalName { .scrollChild }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::child` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyChild` signal is emitted
    @discardableResult @inlinable func onNotifyChild(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyChild,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::child` signal for using the `connect(signal:)` methods
    static var notifyChildSignal: ScrolledWindowSignalName { .notifyChild }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::hadjustment` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHadjustment` signal is emitted
    @discardableResult @inlinable func onNotifyHadjustment(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyHadjustment,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::hadjustment` signal for using the `connect(signal:)` methods
    static var notifyHadjustmentSignal: ScrolledWindowSignalName { .notifyHadjustment }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::has-frame` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHasFrame` signal is emitted
    @discardableResult @inlinable func onNotifyHasFrame(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyHasFrame,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::has-frame` signal for using the `connect(signal:)` methods
    static var notifyHasFrameSignal: ScrolledWindowSignalName { .notifyHasFrame }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::hscrollbar-policy` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHscrollbarPolicy` signal is emitted
    @discardableResult @inlinable func onNotifyHscrollbarPolicy(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyHscrollbarPolicy,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::hscrollbar-policy` signal for using the `connect(signal:)` methods
    static var notifyHscrollbarPolicySignal: ScrolledWindowSignalName { .notifyHscrollbarPolicy }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::kinetic-scrolling` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyKineticScrolling` signal is emitted
    @discardableResult @inlinable func onNotifyKineticScrolling(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyKineticScrolling,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::kinetic-scrolling` signal for using the `connect(signal:)` methods
    static var notifyKineticScrollingSignal: ScrolledWindowSignalName { .notifyKineticScrolling }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::max-content-height` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMaxContentHeight` signal is emitted
    @discardableResult @inlinable func onNotifyMaxContentHeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMaxContentHeight,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::max-content-height` signal for using the `connect(signal:)` methods
    static var notifyMaxContentHeightSignal: ScrolledWindowSignalName { .notifyMaxContentHeight }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::max-content-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMaxContentWidth` signal is emitted
    @discardableResult @inlinable func onNotifyMaxContentWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMaxContentWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::max-content-width` signal for using the `connect(signal:)` methods
    static var notifyMaxContentWidthSignal: ScrolledWindowSignalName { .notifyMaxContentWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::min-content-height` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMinContentHeight` signal is emitted
    @discardableResult @inlinable func onNotifyMinContentHeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMinContentHeight,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::min-content-height` signal for using the `connect(signal:)` methods
    static var notifyMinContentHeightSignal: ScrolledWindowSignalName { .notifyMinContentHeight }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::min-content-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMinContentWidth` signal is emitted
    @discardableResult @inlinable func onNotifyMinContentWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMinContentWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::min-content-width` signal for using the `connect(signal:)` methods
    static var notifyMinContentWidthSignal: ScrolledWindowSignalName { .notifyMinContentWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::overlay-scrolling` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyOverlayScrolling` signal is emitted
    @discardableResult @inlinable func onNotifyOverlayScrolling(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyOverlayScrolling,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::overlay-scrolling` signal for using the `connect(signal:)` methods
    static var notifyOverlayScrollingSignal: ScrolledWindowSignalName { .notifyOverlayScrolling }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::propagate-natural-height` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPropagateNaturalHeight` signal is emitted
    @discardableResult @inlinable func onNotifyPropagateNaturalHeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPropagateNaturalHeight,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::propagate-natural-height` signal for using the `connect(signal:)` methods
    static var notifyPropagateNaturalHeightSignal: ScrolledWindowSignalName { .notifyPropagateNaturalHeight }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::propagate-natural-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPropagateNaturalWidth` signal is emitted
    @discardableResult @inlinable func onNotifyPropagateNaturalWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPropagateNaturalWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::propagate-natural-width` signal for using the `connect(signal:)` methods
    static var notifyPropagateNaturalWidthSignal: ScrolledWindowSignalName { .notifyPropagateNaturalWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::vadjustment` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVadjustment` signal is emitted
    @discardableResult @inlinable func onNotifyVadjustment(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyVadjustment,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::vadjustment` signal for using the `connect(signal:)` methods
    static var notifyVadjustmentSignal: ScrolledWindowSignalName { .notifyVadjustment }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::vscrollbar-policy` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVscrollbarPolicy` signal is emitted
    @discardableResult @inlinable func onNotifyVscrollbarPolicy(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyVscrollbarPolicy,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::vscrollbar-policy` signal for using the `connect(signal:)` methods
    static var notifyVscrollbarPolicySignal: ScrolledWindowSignalName { .notifyVscrollbarPolicy }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::window-placement` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWindowPlacement` signal is emitted
    @discardableResult @inlinable func onNotifyWindowPlacement(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ScrolledWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ScrolledWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ScrolledWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWindowPlacement,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::window-placement` signal for using the `connect(signal:)` methods
    static var notifyWindowPlacementSignal: ScrolledWindowSignalName { .notifyWindowPlacement }
    
}

// MARK: ScrolledWindow Class: ScrolledWindowProtocol extension (methods and fields)
public extension ScrolledWindowProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkScrolledWindow` instance.
    @inlinable var scrolled_window_ptr: UnsafeMutablePointer<GtkScrolledWindow>! { return ptr?.assumingMemoryBound(to: GtkScrolledWindow.self) }

    /// Gets the child widget of `scrolled_window`.
    @inlinable func getChild() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_child(scrolled_window_ptr))) else { return nil }
        return rv
    }

    /// Returns the horizontal scrollbar’s adjustment.
    /// 
    /// This is the adjustment used to connect the horizontal scrollbar
    /// to the child widget’s horizontal scroll functionality.
    @inlinable func getHadjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_hadjustment(scrolled_window_ptr)))
        return rv
    }

    /// Gets whether the scrolled window draws a frame.
    @inlinable func getHasFrame() -> Bool {
        let rv = ((gtk_scrolled_window_get_has_frame(scrolled_window_ptr)) != 0)
        return rv
    }

    /// Returns the horizontal scrollbar of `scrolled_window`.
    @inlinable func getHscrollbar() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_hscrollbar(scrolled_window_ptr))) else { return nil }
        return rv
    }

    /// Returns the specified kinetic scrolling behavior.
    @inlinable func getKineticScrolling() -> Bool {
        let rv = ((gtk_scrolled_window_get_kinetic_scrolling(scrolled_window_ptr)) != 0)
        return rv
    }

    /// Returns the maximum content height set.
    @inlinable func getMaxContentHeight() -> Int {
        let rv = Int(gtk_scrolled_window_get_max_content_height(scrolled_window_ptr))
        return rv
    }

    /// Returns the maximum content width set.
    @inlinable func getMaxContentWidth() -> Int {
        let rv = Int(gtk_scrolled_window_get_max_content_width(scrolled_window_ptr))
        return rv
    }

    /// Gets the minimal content height of `scrolled_window`.
    @inlinable func getMinContentHeight() -> Int {
        let rv = Int(gtk_scrolled_window_get_min_content_height(scrolled_window_ptr))
        return rv
    }

    /// Gets the minimum content width of `scrolled_window`.
    @inlinable func getMinContentWidth() -> Int {
        let rv = Int(gtk_scrolled_window_get_min_content_width(scrolled_window_ptr))
        return rv
    }

    /// Returns whether overlay scrolling is enabled for this scrolled window.
    @inlinable func getOverlayScrolling() -> Bool {
        let rv = ((gtk_scrolled_window_get_overlay_scrolling(scrolled_window_ptr)) != 0)
        return rv
    }

    /// Gets the placement of the contents with respect to the scrollbars.
    @inlinable func getPlacement() -> GtkCornerType {
        let rv = gtk_scrolled_window_get_placement(scrolled_window_ptr)
        return rv
    }

    /// Retrieves the current policy values for the horizontal and vertical
    /// scrollbars.
    /// 
    /// See [method`Gtk.ScrolledWindow.set_policy`].
    @inlinable func getPolicy(hscrollbarPolicy: UnsafeMutablePointer<GtkPolicyType>! = nil, vscrollbarPolicy: UnsafeMutablePointer<GtkPolicyType>! = nil) {
        gtk_scrolled_window_get_policy(scrolled_window_ptr, hscrollbarPolicy, vscrollbarPolicy)
    
    }

    /// Reports whether the natural height of the child will be calculated
    /// and propagated through the scrolled window’s requested natural height.
    @inlinable func getPropagateNaturalHeight() -> Bool {
        let rv = ((gtk_scrolled_window_get_propagate_natural_height(scrolled_window_ptr)) != 0)
        return rv
    }

    /// Reports whether the natural width of the child will be calculated
    /// and propagated through the scrolled window’s requested natural width.
    @inlinable func getPropagateNaturalWidth() -> Bool {
        let rv = ((gtk_scrolled_window_get_propagate_natural_width(scrolled_window_ptr)) != 0)
        return rv
    }

    /// Returns the vertical scrollbar’s adjustment.
    /// 
    /// This is the adjustment used to connect the vertical
    /// scrollbar to the child widget’s vertical scroll functionality.
    @inlinable func getVadjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_vadjustment(scrolled_window_ptr)))
        return rv
    }

    /// Returns the vertical scrollbar of `scrolled_window`.
    @inlinable func getVscrollbar() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_vscrollbar(scrolled_window_ptr))) else { return nil }
        return rv
    }

    /// Sets the child widget of `scrolled_window`.
    @inlinable func set(child: WidgetRef? = nil) {
        gtk_scrolled_window_set_child(scrolled_window_ptr, child?.widget_ptr)
    
    }
    /// Sets the child widget of `scrolled_window`.
    @inlinable func set<WidgetT: WidgetProtocol>(child: WidgetT?) {
        gtk_scrolled_window_set_child(scrolled_window_ptr, child?.widget_ptr)
    
    }

    /// Sets the `GtkAdjustment` for the horizontal scrollbar.
    @inlinable func set(hadjustment: AdjustmentRef? = nil) {
        gtk_scrolled_window_set_hadjustment(scrolled_window_ptr, hadjustment?.adjustment_ptr)
    
    }
    /// Sets the `GtkAdjustment` for the horizontal scrollbar.
    @inlinable func set<AdjustmentT: AdjustmentProtocol>(hadjustment: AdjustmentT?) {
        gtk_scrolled_window_set_hadjustment(scrolled_window_ptr, hadjustment?.adjustment_ptr)
    
    }

    /// Changes the frame drawn around the contents of `scrolled_window`.
    @inlinable func set(hasFrame: Bool) {
        gtk_scrolled_window_set_has_frame(scrolled_window_ptr, gboolean((hasFrame) ? 1 : 0))
    
    }

    /// Turns kinetic scrolling on or off.
    /// 
    /// Kinetic scrolling only applies to devices with source
    /// `GDK_SOURCE_TOUCHSCREEN`.
    @inlinable func set(kineticScrolling: Bool) {
        gtk_scrolled_window_set_kinetic_scrolling(scrolled_window_ptr, gboolean((kineticScrolling) ? 1 : 0))
    
    }

    /// Sets the maximum height that `scrolled_window` should keep visible.
    /// 
    /// The `scrolled_window` will grow up to this height before it starts
    /// scrolling the content.
    /// 
    /// It is a programming error to set the maximum content height to a value
    /// smaller than [property`Gtk.ScrolledWindow:min-content-height`].
    @inlinable func setMaxContent(height: Int) {
        gtk_scrolled_window_set_max_content_height(scrolled_window_ptr, gint(height))
    
    }

    /// Sets the maximum width that `scrolled_window` should keep visible.
    /// 
    /// The `scrolled_window` will grow up to this width before it starts
    /// scrolling the content.
    /// 
    /// It is a programming error to set the maximum content width to a
    /// value smaller than [property`Gtk.ScrolledWindow:min-content-width`].
    @inlinable func setMaxContent(width: Int) {
        gtk_scrolled_window_set_max_content_width(scrolled_window_ptr, gint(width))
    
    }

    /// Sets the minimum height that `scrolled_window` should keep visible.
    /// 
    /// Note that this can and (usually will) be smaller than the minimum
    /// size of the content.
    /// 
    /// It is a programming error to set the minimum content height to a
    /// value greater than [property`Gtk.ScrolledWindow:max-content-height`].
    @inlinable func setMinContent(height: Int) {
        gtk_scrolled_window_set_min_content_height(scrolled_window_ptr, gint(height))
    
    }

    /// Sets the minimum width that `scrolled_window` should keep visible.
    /// 
    /// Note that this can and (usually will) be smaller than the minimum
    /// size of the content.
    /// 
    /// It is a programming error to set the minimum content width to a
    /// value greater than [property`Gtk.ScrolledWindow:max-content-width`].
    @inlinable func setMinContent(width: Int) {
        gtk_scrolled_window_set_min_content_width(scrolled_window_ptr, gint(width))
    
    }

    /// Enables or disables overlay scrolling for this scrolled window.
    @inlinable func set(overlayScrolling: Bool) {
        gtk_scrolled_window_set_overlay_scrolling(scrolled_window_ptr, gboolean((overlayScrolling) ? 1 : 0))
    
    }

    /// Sets the placement of the contents with respect to the scrollbars
    /// for the scrolled window.
    /// 
    /// The default is `GTK_CORNER_TOP_LEFT`, meaning the child is
    /// in the top left, with the scrollbars underneath and to the right.
    /// Other values in [enum`Gtk.CornerType`] are `GTK_CORNER_TOP_RIGHT`,
    /// `GTK_CORNER_BOTTOM_LEFT`, and `GTK_CORNER_BOTTOM_RIGHT`.
    /// 
    /// See also [method`Gtk.ScrolledWindow.get_placement`] and
    /// [method`Gtk.ScrolledWindow.unset_placement`].
    @inlinable func setPlacement(windowPlacement: GtkCornerType) {
        gtk_scrolled_window_set_placement(scrolled_window_ptr, windowPlacement)
    
    }

    /// Sets the scrollbar policy for the horizontal and vertical scrollbars.
    /// 
    /// The policy determines when the scrollbar should appear; it is a value
    /// from the [enum`Gtk.PolicyType`] enumeration. If `GTK_POLICY_ALWAYS`, the
    /// scrollbar is always present; if `GTK_POLICY_NEVER`, the scrollbar is
    /// never present; if `GTK_POLICY_AUTOMATIC`, the scrollbar is present only
    /// if needed (that is, if the slider part of the bar would be smaller
    /// than the trough — the display is larger than the page size).
    @inlinable func setPolicy(hscrollbarPolicy: GtkPolicyType, vscrollbarPolicy: GtkPolicyType) {
        gtk_scrolled_window_set_policy(scrolled_window_ptr, hscrollbarPolicy, vscrollbarPolicy)
    
    }

    /// Sets whether the natural height of the child should be calculated
    /// and propagated through the scrolled window’s requested natural height.
    @inlinable func setPropagateNaturalHeight(propagate: Bool) {
        gtk_scrolled_window_set_propagate_natural_height(scrolled_window_ptr, gboolean((propagate) ? 1 : 0))
    
    }

    /// Sets whether the natural width of the child should be calculated
    /// and propagated through the scrolled window’s requested natural width.
    @inlinable func setPropagateNaturalWidth(propagate: Bool) {
        gtk_scrolled_window_set_propagate_natural_width(scrolled_window_ptr, gboolean((propagate) ? 1 : 0))
    
    }

    /// Sets the `GtkAdjustment` for the vertical scrollbar.
    @inlinable func set(vadjustment: AdjustmentRef? = nil) {
        gtk_scrolled_window_set_vadjustment(scrolled_window_ptr, vadjustment?.adjustment_ptr)
    
    }
    /// Sets the `GtkAdjustment` for the vertical scrollbar.
    @inlinable func set<AdjustmentT: AdjustmentProtocol>(vadjustment: AdjustmentT?) {
        gtk_scrolled_window_set_vadjustment(scrolled_window_ptr, vadjustment?.adjustment_ptr)
    
    }

    /// Unsets the placement of the contents with respect to the scrollbars.
    /// 
    /// If no window placement is set for a scrolled window,
    /// it defaults to `GTK_CORNER_TOP_LEFT`.
    @inlinable func unsetPlacement() {
        gtk_scrolled_window_unset_placement(scrolled_window_ptr)
    
    }
    /// The child widget.
    @inlinable var child: WidgetRef! {
        /// Gets the child widget of `scrolled_window`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_child(scrolled_window_ptr))) else { return nil }
            return rv
        }
        /// Sets the child widget of `scrolled_window`.
        nonmutating set {
            gtk_scrolled_window_set_child(scrolled_window_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    @inlinable var hadjustment: AdjustmentRef! {
        /// Returns the horizontal scrollbar’s adjustment.
        /// 
        /// This is the adjustment used to connect the horizontal scrollbar
        /// to the child widget’s horizontal scroll functionality.
        get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_hadjustment(scrolled_window_ptr)))
            return rv
        }
        /// Sets the `GtkAdjustment` for the horizontal scrollbar.
        nonmutating set {
            gtk_scrolled_window_set_hadjustment(scrolled_window_ptr, UnsafeMutablePointer<GtkAdjustment>(newValue?.adjustment_ptr))
        }
    }

    /// Gets whether the scrolled window draws a frame.
    @inlinable var hasFrame: Bool {
        /// Gets whether the scrolled window draws a frame.
        get {
            let rv = ((gtk_scrolled_window_get_has_frame(scrolled_window_ptr)) != 0)
            return rv
        }
        /// Changes the frame drawn around the contents of `scrolled_window`.
        nonmutating set {
            gtk_scrolled_window_set_has_frame(scrolled_window_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the horizontal scrollbar of `scrolled_window`.
    @inlinable var hscrollbar: WidgetRef! {
        /// Returns the horizontal scrollbar of `scrolled_window`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_hscrollbar(scrolled_window_ptr))) else { return nil }
            return rv
        }
    }

    /// Returns the specified kinetic scrolling behavior.
    @inlinable var kineticScrolling: Bool {
        /// Returns the specified kinetic scrolling behavior.
        get {
            let rv = ((gtk_scrolled_window_get_kinetic_scrolling(scrolled_window_ptr)) != 0)
            return rv
        }
        /// Turns kinetic scrolling on or off.
        /// 
        /// Kinetic scrolling only applies to devices with source
        /// `GDK_SOURCE_TOUCHSCREEN`.
        nonmutating set {
            gtk_scrolled_window_set_kinetic_scrolling(scrolled_window_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the maximum content height set.
    @inlinable var maxContentHeight: Int {
        /// Returns the maximum content height set.
        get {
            let rv = Int(gtk_scrolled_window_get_max_content_height(scrolled_window_ptr))
            return rv
        }
        /// Sets the maximum height that `scrolled_window` should keep visible.
        /// 
        /// The `scrolled_window` will grow up to this height before it starts
        /// scrolling the content.
        /// 
        /// It is a programming error to set the maximum content height to a value
        /// smaller than [property`Gtk.ScrolledWindow:min-content-height`].
        nonmutating set {
            gtk_scrolled_window_set_max_content_height(scrolled_window_ptr, gint(newValue))
        }
    }

    /// Returns the maximum content width set.
    @inlinable var maxContentWidth: Int {
        /// Returns the maximum content width set.
        get {
            let rv = Int(gtk_scrolled_window_get_max_content_width(scrolled_window_ptr))
            return rv
        }
        /// Sets the maximum width that `scrolled_window` should keep visible.
        /// 
        /// The `scrolled_window` will grow up to this width before it starts
        /// scrolling the content.
        /// 
        /// It is a programming error to set the maximum content width to a
        /// value smaller than [property`Gtk.ScrolledWindow:min-content-width`].
        nonmutating set {
            gtk_scrolled_window_set_max_content_width(scrolled_window_ptr, gint(newValue))
        }
    }

    /// Gets the minimal content height of `scrolled_window`.
    @inlinable var minContentHeight: Int {
        /// Gets the minimal content height of `scrolled_window`.
        get {
            let rv = Int(gtk_scrolled_window_get_min_content_height(scrolled_window_ptr))
            return rv
        }
        /// Sets the minimum height that `scrolled_window` should keep visible.
        /// 
        /// Note that this can and (usually will) be smaller than the minimum
        /// size of the content.
        /// 
        /// It is a programming error to set the minimum content height to a
        /// value greater than [property`Gtk.ScrolledWindow:max-content-height`].
        nonmutating set {
            gtk_scrolled_window_set_min_content_height(scrolled_window_ptr, gint(newValue))
        }
    }

    /// Gets the minimum content width of `scrolled_window`.
    @inlinable var minContentWidth: Int {
        /// Gets the minimum content width of `scrolled_window`.
        get {
            let rv = Int(gtk_scrolled_window_get_min_content_width(scrolled_window_ptr))
            return rv
        }
        /// Sets the minimum width that `scrolled_window` should keep visible.
        /// 
        /// Note that this can and (usually will) be smaller than the minimum
        /// size of the content.
        /// 
        /// It is a programming error to set the minimum content width to a
        /// value greater than [property`Gtk.ScrolledWindow:max-content-width`].
        nonmutating set {
            gtk_scrolled_window_set_min_content_width(scrolled_window_ptr, gint(newValue))
        }
    }

    /// Returns whether overlay scrolling is enabled for this scrolled window.
    @inlinable var overlayScrolling: Bool {
        /// Returns whether overlay scrolling is enabled for this scrolled window.
        get {
            let rv = ((gtk_scrolled_window_get_overlay_scrolling(scrolled_window_ptr)) != 0)
            return rv
        }
        /// Enables or disables overlay scrolling for this scrolled window.
        nonmutating set {
            gtk_scrolled_window_set_overlay_scrolling(scrolled_window_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the placement of the contents with respect to the scrollbars.
    @inlinable var placement: GtkCornerType {
        /// Gets the placement of the contents with respect to the scrollbars.
        get {
            let rv = gtk_scrolled_window_get_placement(scrolled_window_ptr)
            return rv
        }
        /// Sets the placement of the contents with respect to the scrollbars
        /// for the scrolled window.
        /// 
        /// The default is `GTK_CORNER_TOP_LEFT`, meaning the child is
        /// in the top left, with the scrollbars underneath and to the right.
        /// Other values in [enum`Gtk.CornerType`] are `GTK_CORNER_TOP_RIGHT`,
        /// `GTK_CORNER_BOTTOM_LEFT`, and `GTK_CORNER_BOTTOM_RIGHT`.
        /// 
        /// See also [method`Gtk.ScrolledWindow.get_placement`] and
        /// [method`Gtk.ScrolledWindow.unset_placement`].
        nonmutating set {
            gtk_scrolled_window_set_placement(scrolled_window_ptr, newValue)
        }
    }

    /// Reports whether the natural height of the child will be calculated
    /// and propagated through the scrolled window’s requested natural height.
    @inlinable var propagateNaturalHeight: Bool {
        /// Reports whether the natural height of the child will be calculated
        /// and propagated through the scrolled window’s requested natural height.
        get {
            let rv = ((gtk_scrolled_window_get_propagate_natural_height(scrolled_window_ptr)) != 0)
            return rv
        }
        /// Sets whether the natural height of the child should be calculated
        /// and propagated through the scrolled window’s requested natural height.
        nonmutating set {
            gtk_scrolled_window_set_propagate_natural_height(scrolled_window_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Reports whether the natural width of the child will be calculated
    /// and propagated through the scrolled window’s requested natural width.
    @inlinable var propagateNaturalWidth: Bool {
        /// Reports whether the natural width of the child will be calculated
        /// and propagated through the scrolled window’s requested natural width.
        get {
            let rv = ((gtk_scrolled_window_get_propagate_natural_width(scrolled_window_ptr)) != 0)
            return rv
        }
        /// Sets whether the natural width of the child should be calculated
        /// and propagated through the scrolled window’s requested natural width.
        nonmutating set {
            gtk_scrolled_window_set_propagate_natural_width(scrolled_window_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var vadjustment: AdjustmentRef! {
        /// Returns the vertical scrollbar’s adjustment.
        /// 
        /// This is the adjustment used to connect the vertical
        /// scrollbar to the child widget’s vertical scroll functionality.
        get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_vadjustment(scrolled_window_ptr)))
            return rv
        }
        /// Sets the `GtkAdjustment` for the vertical scrollbar.
        nonmutating set {
            gtk_scrolled_window_set_vadjustment(scrolled_window_ptr, UnsafeMutablePointer<GtkAdjustment>(newValue?.adjustment_ptr))
        }
    }

    /// Returns the vertical scrollbar of `scrolled_window`.
    @inlinable var vscrollbar: WidgetRef! {
        /// Returns the vertical scrollbar of `scrolled_window`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_scrolled_window_get_vscrollbar(scrolled_window_ptr))) else { return nil }
            return rv
        }
    }


}



// MARK: - SearchBar Class

/// The `SearchBarProtocol` protocol exposes the methods and properties of an underlying `GtkSearchBar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SearchBar`.
/// Alternatively, use `SearchBarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSearchBar` is a container made to have a search entry.
/// 
/// ![An example GtkSearchBar](search-bar.png)
/// 
/// It can also contain additional widgets, such as drop-down menus,
/// or buttons.  The search bar would appear when a search is started
/// through typing on the keyboard, or the application’s search mode
/// is toggled on.
/// 
/// For keyboard presses to start a search, the search bar must be told
/// of a widget to capture key events from through
/// [method`Gtk.SearchBar.set_key_capture_widget`]. This widget will
/// typically be the top-level window, or a parent container of the
/// search bar. Common shortcuts such as Ctrl+F should be handled as an
/// application action, or through the menu items.
/// 
/// You will also need to tell the search bar about which entry you
/// are using as your search entry using [method`Gtk.SearchBar.connect_entry`].
/// 
/// ## Creating a search bar
/// 
/// The following example shows you how to create a more complex search
/// entry.
/// 
/// [A simple example](https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
/// 
/// # CSS nodes
/// 
/// ```
/// searchbar
/// ╰── revealer
///     ╰── box
///          ├── [child]
///          ╰── [button.close]
/// ```
/// 
/// `GtkSearchBar` has a main CSS node with name searchbar. It has a child
/// node with name revealer that contains a node with name box. The box node
/// contains both the CSS node of the child widget as well as an optional button
/// node which gets the .close style class applied.
/// 
/// # Accessibility
/// 
/// `GtkSearchBar` uses the `GTK_ACCESSIBLE_ROLE_SEARCH` role.
public protocol SearchBarProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkSearchBar` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSearchBar` instance.
    var search_bar_ptr: UnsafeMutablePointer<GtkSearchBar>! { get }

    /// Required Initialiser for types conforming to `SearchBarProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SearchBarRef` type acts as a lightweight Swift reference to an underlying `GtkSearchBar` instance.
/// It exposes methods that can operate on this data type through `SearchBarProtocol` conformance.
/// Use `SearchBarRef` only as an `unowned` reference to an existing `GtkSearchBar` instance.
///
/// `GtkSearchBar` is a container made to have a search entry.
/// 
/// ![An example GtkSearchBar](search-bar.png)
/// 
/// It can also contain additional widgets, such as drop-down menus,
/// or buttons.  The search bar would appear when a search is started
/// through typing on the keyboard, or the application’s search mode
/// is toggled on.
/// 
/// For keyboard presses to start a search, the search bar must be told
/// of a widget to capture key events from through
/// [method`Gtk.SearchBar.set_key_capture_widget`]. This widget will
/// typically be the top-level window, or a parent container of the
/// search bar. Common shortcuts such as Ctrl+F should be handled as an
/// application action, or through the menu items.
/// 
/// You will also need to tell the search bar about which entry you
/// are using as your search entry using [method`Gtk.SearchBar.connect_entry`].
/// 
/// ## Creating a search bar
/// 
/// The following example shows you how to create a more complex search
/// entry.
/// 
/// [A simple example](https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
/// 
/// # CSS nodes
/// 
/// ```
/// searchbar
/// ╰── revealer
///     ╰── box
///          ├── [child]
///          ╰── [button.close]
/// ```
/// 
/// `GtkSearchBar` has a main CSS node with name searchbar. It has a child
/// node with name revealer that contains a node with name box. The box node
/// contains both the CSS node of the child widget as well as an optional button
/// node which gets the .close style class applied.
/// 
/// # Accessibility
/// 
/// `GtkSearchBar` uses the `GTK_ACCESSIBLE_ROLE_SEARCH` role.
public struct SearchBarRef: SearchBarProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSearchBar` instance.
    /// For type-safe access, use the generated, typed pointer `search_bar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SearchBarRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSearchBar>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSearchBar>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSearchBar>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSearchBar>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SearchBarProtocol`
    @inlinable init<T: SearchBarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SearchBarProtocol>(_ other: T) -> SearchBarRef { SearchBarRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a `GtkSearchBar`.
    /// 
    /// You will need to tell it about which widget is going to be your text
    /// entry using [method`Gtk.SearchBar.connect_entry`].
    @inlinable init() {
        let rv = gtk_search_bar_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SearchBar` type acts as a reference-counted owner of an underlying `GtkSearchBar` instance.
/// It provides the methods that can operate on this data type through `SearchBarProtocol` conformance.
/// Use `SearchBar` as a strong reference or owner of a `GtkSearchBar` instance.
///
/// `GtkSearchBar` is a container made to have a search entry.
/// 
/// ![An example GtkSearchBar](search-bar.png)
/// 
/// It can also contain additional widgets, such as drop-down menus,
/// or buttons.  The search bar would appear when a search is started
/// through typing on the keyboard, or the application’s search mode
/// is toggled on.
/// 
/// For keyboard presses to start a search, the search bar must be told
/// of a widget to capture key events from through
/// [method`Gtk.SearchBar.set_key_capture_widget`]. This widget will
/// typically be the top-level window, or a parent container of the
/// search bar. Common shortcuts such as Ctrl+F should be handled as an
/// application action, or through the menu items.
/// 
/// You will also need to tell the search bar about which entry you
/// are using as your search entry using [method`Gtk.SearchBar.connect_entry`].
/// 
/// ## Creating a search bar
/// 
/// The following example shows you how to create a more complex search
/// entry.
/// 
/// [A simple example](https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
/// 
/// # CSS nodes
/// 
/// ```
/// searchbar
/// ╰── revealer
///     ╰── box
///          ├── [child]
///          ╰── [button.close]
/// ```
/// 
/// `GtkSearchBar` has a main CSS node with name searchbar. It has a child
/// node with name revealer that contains a node with name box. The box node
/// contains both the CSS node of the child widget as well as an optional button
/// node which gets the .close style class applied.
/// 
/// # Accessibility
/// 
/// `GtkSearchBar` uses the `GTK_ACCESSIBLE_ROLE_SEARCH` role.
open class SearchBar: Widget, SearchBarProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSearchBar>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSearchBar>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSearchBar>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSearchBar>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSearchBar`.
    /// i.e., ownership is transferred to the `SearchBar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSearchBar>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SearchBarProtocol`
    /// Will retain `GtkSearchBar`.
    /// - Parameter other: an instance of a related type that implements `SearchBarProtocol`
    @inlinable public init<T: SearchBarProtocol>(searchBar other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchBarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a `GtkSearchBar`.
    /// 
    /// You will need to tell it about which widget is going to be your text
    /// entry using [method`Gtk.SearchBar.connect_entry`].
    @inlinable public init() {
        let rv = gtk_search_bar_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SearchBarPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The key capture widget.
    case keyCaptureWidget = "key-capture-widget"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the search mode is on and the search bar shown.
    case searchModeEnabled = "search-mode-enabled"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Whether to show the close button in the search bar.
    case showCloseButton = "show-close-button"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension SearchBarProtocol {
    /// Bind a `SearchBarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SearchBarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SearchBar property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SearchBarPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SearchBar property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SearchBarPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SearchBarSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The key capture widget.
    case notifyKeyCaptureWidget = "notify::key-capture-widget"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the search mode is on and the search bar shown.
    case notifySearchModeEnabled = "notify::search-mode-enabled"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Whether to show the close button in the search bar.
    case notifyShowCloseButton = "notify::show-close-button"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: SearchBar has no signals
// MARK: SearchBar Class: SearchBarProtocol extension (methods and fields)
public extension SearchBarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSearchBar` instance.
    @inlinable var search_bar_ptr: UnsafeMutablePointer<GtkSearchBar>! { return ptr?.assumingMemoryBound(to: GtkSearchBar.self) }

    /// Connects the `GtkEditable widget passed as the one to be used in
    /// this search bar.
    /// 
    /// The entry should be a descendant of the search bar. Calling this
    /// function manually is only required if the entry isn’t the direct
    /// child of the search bar (as in our main example).
    @inlinable func connect<EditableT: EditableProtocol>(entry: EditableT) {
        gtk_search_bar_connect_entry(search_bar_ptr, entry.editable_ptr)
    
    }

    /// Gets the child widget of `bar`.
    @inlinable func getChild() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_search_bar_get_child(search_bar_ptr))) else { return nil }
        return rv
    }

    /// Gets the widget that `bar` is capturing key events from.
    @inlinable func getKeyCaptureWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_search_bar_get_key_capture_widget(search_bar_ptr))) else { return nil }
        return rv
    }

    /// Returns whether the search mode is on or off.
    @inlinable func getSearchMode() -> Bool {
        let rv = ((gtk_search_bar_get_search_mode(search_bar_ptr)) != 0)
        return rv
    }

    /// Returns whether the close button is shown.
    @inlinable func getShowCloseButton() -> Bool {
        let rv = ((gtk_search_bar_get_show_close_button(search_bar_ptr)) != 0)
        return rv
    }

    /// Sets the child widget of `bar`.
    @inlinable func set(child: WidgetRef? = nil) {
        gtk_search_bar_set_child(search_bar_ptr, child?.widget_ptr)
    
    }
    /// Sets the child widget of `bar`.
    @inlinable func set<WidgetT: WidgetProtocol>(child: WidgetT?) {
        gtk_search_bar_set_child(search_bar_ptr, child?.widget_ptr)
    
    }

    /// Sets `widget` as the widget that `bar` will capture key events
    /// from.
    /// 
    /// If key events are handled by the search bar, the bar will
    /// be shown, and the entry populated with the entered text.
    /// 
    /// Note that despite the name of this function, the events
    /// are only 'captured' in the bubble phase, which means that
    /// editable child widgets of `widget` will receive text input
    /// before it gets captured. If that is not desired, you can
    /// capture and forward the events yourself with
    /// [method`Gtk.EventControllerKey.forward`].
    @inlinable func setKeyCapture(widget: WidgetRef? = nil) {
        gtk_search_bar_set_key_capture_widget(search_bar_ptr, widget?.widget_ptr)
    
    }
    /// Sets `widget` as the widget that `bar` will capture key events
    /// from.
    /// 
    /// If key events are handled by the search bar, the bar will
    /// be shown, and the entry populated with the entered text.
    /// 
    /// Note that despite the name of this function, the events
    /// are only 'captured' in the bubble phase, which means that
    /// editable child widgets of `widget` will receive text input
    /// before it gets captured. If that is not desired, you can
    /// capture and forward the events yourself with
    /// [method`Gtk.EventControllerKey.forward`].
    @inlinable func setKeyCapture<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        gtk_search_bar_set_key_capture_widget(search_bar_ptr, widget?.widget_ptr)
    
    }

    /// Switches the search mode on or off.
    @inlinable func set(searchMode: Bool) {
        gtk_search_bar_set_search_mode(search_bar_ptr, gboolean((searchMode) ? 1 : 0))
    
    }

    /// Shows or hides the close button.
    /// 
    /// Applications that already have a “search” toggle button should not
    /// show a close button in their search bar, as it duplicates the role
    /// of the toggle button.
    @inlinable func setShowCloseButton(visible: Bool) {
        gtk_search_bar_set_show_close_button(search_bar_ptr, gboolean((visible) ? 1 : 0))
    
    }
    /// The child widget.
    @inlinable var child: WidgetRef! {
        /// Gets the child widget of `bar`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_search_bar_get_child(search_bar_ptr))) else { return nil }
            return rv
        }
        /// Sets the child widget of `bar`.
        nonmutating set {
            gtk_search_bar_set_child(search_bar_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Gets the widget that `bar` is capturing key events from.
    @inlinable var keyCaptureWidget: WidgetRef! {
        /// Gets the widget that `bar` is capturing key events from.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_search_bar_get_key_capture_widget(search_bar_ptr))) else { return nil }
            return rv
        }
        /// Sets `widget` as the widget that `bar` will capture key events
        /// from.
        /// 
        /// If key events are handled by the search bar, the bar will
        /// be shown, and the entry populated with the entered text.
        /// 
        /// Note that despite the name of this function, the events
        /// are only 'captured' in the bubble phase, which means that
        /// editable child widgets of `widget` will receive text input
        /// before it gets captured. If that is not desired, you can
        /// capture and forward the events yourself with
        /// [method`Gtk.EventControllerKey.forward`].
        nonmutating set {
            gtk_search_bar_set_key_capture_widget(search_bar_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Returns whether the search mode is on or off.
    @inlinable var searchMode: Bool {
        /// Returns whether the search mode is on or off.
        get {
            let rv = ((gtk_search_bar_get_search_mode(search_bar_ptr)) != 0)
            return rv
        }
        /// Switches the search mode on or off.
        nonmutating set {
            gtk_search_bar_set_search_mode(search_bar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the close button is shown.
    @inlinable var showCloseButton: Bool {
        /// Returns whether the close button is shown.
        get {
            let rv = ((gtk_search_bar_get_show_close_button(search_bar_ptr)) != 0)
            return rv
        }
        /// Shows or hides the close button.
        /// 
        /// Applications that already have a “search” toggle button should not
        /// show a close button in their search bar, as it duplicates the role
        /// of the toggle button.
        nonmutating set {
            gtk_search_bar_set_show_close_button(search_bar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - SearchEntry Class

/// The `SearchEntryProtocol` protocol exposes the methods and properties of an underlying `GtkSearchEntry` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SearchEntry`.
/// Alternatively, use `SearchEntryRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSearchEntry` is an entry widget that has been tailored for use
/// as a search entry.
/// 
/// The main API for interacting with a `GtkSearchEntry` as entry
/// is the `GtkEditable` interface.
/// 
/// ![An example GtkSearchEntry](search-entry.png)
/// 
/// It will show an inactive symbolic “find” icon when the search
/// entry is empty, and a symbolic “clear” icon when there is text.
/// Clicking on the “clear” icon will empty the search entry.
/// 
/// To make filtering appear more reactive, it is a good idea to
/// not react to every change in the entry text immediately, but
/// only after a short delay. To support this, `GtkSearchEntry`
/// emits the [signal`Gtk.SearchEntry::search-changed`] signal which
/// can be used instead of the [signal`Gtk.Editable::changed`] signal.
/// 
/// The [signal`Gtk.SearchEntry::previous-match`],
/// [signal`Gtk.SearchEntry::next-match`] and
/// [signal`Gtk.SearchEntry::stop-search`] signals can be used to
/// implement moving between search results and ending the search.
/// 
/// Often, `GtkSearchEntry` will be fed events by means of being
/// placed inside a [class`Gtk.SearchBar`]. If that is not the case,
/// you can use [method`Gtk.SearchEntry.set_key_capture_widget`] to
/// let it capture key input from another widget.
/// 
/// `GtkSearchEntry` provides only minimal API and should be used with
/// the [iface`Gtk.Editable`] API.
/// 
/// ## CSS Nodes
/// 
/// ```
/// entry.search
/// ╰── text
/// ```
/// 
/// `GtkSearchEntry` has a single CSS node with name entry that carries
/// a `.search` style class, and the text node is a child of that.
/// 
/// ## Accessibility
/// 
/// `GtkSearchEntry` uses the `GTK_ACCESSIBLE_ROLE_SEARCH_BOX` role.
public protocol SearchEntryProtocol: WidgetProtocol, EditableProtocol {
        /// Untyped pointer to the underlying `GtkSearchEntry` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSearchEntry` instance.
    var search_entry_ptr: UnsafeMutablePointer<GtkSearchEntry>! { get }

    /// Required Initialiser for types conforming to `SearchEntryProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SearchEntryRef` type acts as a lightweight Swift reference to an underlying `GtkSearchEntry` instance.
/// It exposes methods that can operate on this data type through `SearchEntryProtocol` conformance.
/// Use `SearchEntryRef` only as an `unowned` reference to an existing `GtkSearchEntry` instance.
///
/// `GtkSearchEntry` is an entry widget that has been tailored for use
/// as a search entry.
/// 
/// The main API for interacting with a `GtkSearchEntry` as entry
/// is the `GtkEditable` interface.
/// 
/// ![An example GtkSearchEntry](search-entry.png)
/// 
/// It will show an inactive symbolic “find” icon when the search
/// entry is empty, and a symbolic “clear” icon when there is text.
/// Clicking on the “clear” icon will empty the search entry.
/// 
/// To make filtering appear more reactive, it is a good idea to
/// not react to every change in the entry text immediately, but
/// only after a short delay. To support this, `GtkSearchEntry`
/// emits the [signal`Gtk.SearchEntry::search-changed`] signal which
/// can be used instead of the [signal`Gtk.Editable::changed`] signal.
/// 
/// The [signal`Gtk.SearchEntry::previous-match`],
/// [signal`Gtk.SearchEntry::next-match`] and
/// [signal`Gtk.SearchEntry::stop-search`] signals can be used to
/// implement moving between search results and ending the search.
/// 
/// Often, `GtkSearchEntry` will be fed events by means of being
/// placed inside a [class`Gtk.SearchBar`]. If that is not the case,
/// you can use [method`Gtk.SearchEntry.set_key_capture_widget`] to
/// let it capture key input from another widget.
/// 
/// `GtkSearchEntry` provides only minimal API and should be used with
/// the [iface`Gtk.Editable`] API.
/// 
/// ## CSS Nodes
/// 
/// ```
/// entry.search
/// ╰── text
/// ```
/// 
/// `GtkSearchEntry` has a single CSS node with name entry that carries
/// a `.search` style class, and the text node is a child of that.
/// 
/// ## Accessibility
/// 
/// `GtkSearchEntry` uses the `GTK_ACCESSIBLE_ROLE_SEARCH_BOX` role.
public struct SearchEntryRef: SearchEntryProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSearchEntry` instance.
    /// For type-safe access, use the generated, typed pointer `search_entry_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SearchEntryRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSearchEntry>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSearchEntry>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSearchEntry>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSearchEntry>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SearchEntryProtocol`
    @inlinable init<T: SearchEntryProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SearchEntryProtocol>(_ other: T) -> SearchEntryRef { SearchEntryRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a `GtkSearchEntry`.
    @inlinable init() {
        let rv = gtk_search_entry_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SearchEntry` type acts as a reference-counted owner of an underlying `GtkSearchEntry` instance.
/// It provides the methods that can operate on this data type through `SearchEntryProtocol` conformance.
/// Use `SearchEntry` as a strong reference or owner of a `GtkSearchEntry` instance.
///
/// `GtkSearchEntry` is an entry widget that has been tailored for use
/// as a search entry.
/// 
/// The main API for interacting with a `GtkSearchEntry` as entry
/// is the `GtkEditable` interface.
/// 
/// ![An example GtkSearchEntry](search-entry.png)
/// 
/// It will show an inactive symbolic “find” icon when the search
/// entry is empty, and a symbolic “clear” icon when there is text.
/// Clicking on the “clear” icon will empty the search entry.
/// 
/// To make filtering appear more reactive, it is a good idea to
/// not react to every change in the entry text immediately, but
/// only after a short delay. To support this, `GtkSearchEntry`
/// emits the [signal`Gtk.SearchEntry::search-changed`] signal which
/// can be used instead of the [signal`Gtk.Editable::changed`] signal.
/// 
/// The [signal`Gtk.SearchEntry::previous-match`],
/// [signal`Gtk.SearchEntry::next-match`] and
/// [signal`Gtk.SearchEntry::stop-search`] signals can be used to
/// implement moving between search results and ending the search.
/// 
/// Often, `GtkSearchEntry` will be fed events by means of being
/// placed inside a [class`Gtk.SearchBar`]. If that is not the case,
/// you can use [method`Gtk.SearchEntry.set_key_capture_widget`] to
/// let it capture key input from another widget.
/// 
/// `GtkSearchEntry` provides only minimal API and should be used with
/// the [iface`Gtk.Editable`] API.
/// 
/// ## CSS Nodes
/// 
/// ```
/// entry.search
/// ╰── text
/// ```
/// 
/// `GtkSearchEntry` has a single CSS node with name entry that carries
/// a `.search` style class, and the text node is a child of that.
/// 
/// ## Accessibility
/// 
/// `GtkSearchEntry` uses the `GTK_ACCESSIBLE_ROLE_SEARCH_BOX` role.
open class SearchEntry: Widget, SearchEntryProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSearchEntry>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSearchEntry>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSearchEntry>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSearchEntry>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSearchEntry`.
    /// i.e., ownership is transferred to the `SearchEntry` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSearchEntry>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SearchEntryProtocol`
    /// Will retain `GtkSearchEntry`.
    /// - Parameter other: an instance of a related type that implements `SearchEntryProtocol`
    @inlinable public init<T: SearchEntryProtocol>(searchEntry other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SearchEntryProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a `GtkSearchEntry`.
    @inlinable public init() {
        let rv = gtk_search_entry_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SearchEntryPropertyName: String, PropertyNameProtocol {
    /// Whether to activate the default widget when Enter is pressed.
    case activatesDefault = "activates-default"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// The text that will be displayed in the `GtkSearchEntry`
    /// when it is empty and unfocused.
    case placeholderText = "placeholder-text"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension SearchEntryProtocol {
    /// Bind a `SearchEntryPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SearchEntryPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SearchEntry property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SearchEntryPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SearchEntry property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SearchEntryPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SearchEntrySignalName: String, SignalNameProtocol {
    /// Emitted when the entry is activated.
    /// 
    /// The keybindings for this signal are all forms of the Enter key.
    case activate = "activate"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// Emitted when the user initiates a move to the next match
    /// for the current search string.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// Applications should connect to it, to implement moving
    /// between matches.
    /// 
    /// The default bindings for this signal is Ctrl-g.
    case nextMatch = "next-match"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the user initiates a move to the previous match
    /// for the current search string.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// Applications should connect to it, to implement moving
    /// between matches.
    /// 
    /// The default bindings for this signal is Ctrl-Shift-g.
    case previousMatch = "previous-match"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted with a short delay of 150 milliseconds after the
    /// last change to the entry text.
    case searchChanged = "search-changed"
    /// Emitted when the user initiated a search on the entry.
    case searchStarted = "search-started"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when the user stops a search via keyboard input.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// Applications should connect to it, to implement hiding
    /// the search entry in this case.
    /// 
    /// The default bindings for this signal is Escape.
    case stopSearch = "stop-search"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether to activate the default widget when Enter is pressed.
    case notifyActivatesDefault = "notify::activates-default"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// The text that will be displayed in the `GtkSearchEntry`
    /// when it is empty and unfocused.
    case notifyPlaceholderText = "notify::placeholder-text"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: SearchEntry signals
public extension SearchEntryProtocol {
    /// Connect a Swift signal handler to the given, typed `SearchEntrySignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: SearchEntrySignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `SearchEntrySignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: SearchEntrySignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when the entry is activated.
    /// 
    /// The keybindings for this signal are all forms of the Enter key.
    /// - Note: This represents the underlying `activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `activate` signal is emitted
    @discardableResult @inlinable func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SearchEntryRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .activate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `activate` signal for using the `connect(signal:)` methods
    static var activateSignal: SearchEntrySignalName { .activate }
    
    /// Emitted when the user initiates a move to the next match
    /// for the current search string.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// Applications should connect to it, to implement moving
    /// between matches.
    /// 
    /// The default bindings for this signal is Ctrl-g.
    /// - Note: This represents the underlying `next-match` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `nextMatch` signal is emitted
    @discardableResult @inlinable func onNextMatch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SearchEntryRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .nextMatch,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `next-match` signal for using the `connect(signal:)` methods
    static var nextMatchSignal: SearchEntrySignalName { .nextMatch }
    
    /// Emitted when the user initiates a move to the previous match
    /// for the current search string.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// Applications should connect to it, to implement moving
    /// between matches.
    /// 
    /// The default bindings for this signal is Ctrl-Shift-g.
    /// - Note: This represents the underlying `previous-match` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `previousMatch` signal is emitted
    @discardableResult @inlinable func onPreviousMatch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SearchEntryRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .previousMatch,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `previous-match` signal for using the `connect(signal:)` methods
    static var previousMatchSignal: SearchEntrySignalName { .previousMatch }
    
    /// Emitted with a short delay of 150 milliseconds after the
    /// last change to the entry text.
    /// - Note: This represents the underlying `search-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `searchChanged` signal is emitted
    @discardableResult @inlinable func onSearchChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SearchEntryRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .searchChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `search-changed` signal for using the `connect(signal:)` methods
    static var searchChangedSignal: SearchEntrySignalName { .searchChanged }
    
    /// Emitted when the user initiated a search on the entry.
    /// - Note: This represents the underlying `search-started` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `searchStarted` signal is emitted
    @discardableResult @inlinable func onSearchStarted(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SearchEntryRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .searchStarted,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `search-started` signal for using the `connect(signal:)` methods
    static var searchStartedSignal: SearchEntrySignalName { .searchStarted }
    
    /// Emitted when the user stops a search via keyboard input.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// Applications should connect to it, to implement hiding
    /// the search entry in this case.
    /// 
    /// The default bindings for this signal is Escape.
    /// - Note: This represents the underlying `stop-search` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `stopSearch` signal is emitted
    @discardableResult @inlinable func onStopSearch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SearchEntryRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .stopSearch,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `stop-search` signal for using the `connect(signal:)` methods
    static var stopSearchSignal: SearchEntrySignalName { .stopSearch }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::activates-default` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActivatesDefault` signal is emitted
    @discardableResult @inlinable func onNotifyActivatesDefault(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SearchEntryRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyActivatesDefault,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::activates-default` signal for using the `connect(signal:)` methods
    static var notifyActivatesDefaultSignal: SearchEntrySignalName { .notifyActivatesDefault }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::placeholder-text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPlaceholderText` signal is emitted
    @discardableResult @inlinable func onNotifyPlaceholderText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SearchEntryRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SearchEntryRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SearchEntryRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPlaceholderText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::placeholder-text` signal for using the `connect(signal:)` methods
    static var notifyPlaceholderTextSignal: SearchEntrySignalName { .notifyPlaceholderText }
    
}

// MARK: SearchEntry Class: SearchEntryProtocol extension (methods and fields)
public extension SearchEntryProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSearchEntry` instance.
    @inlinable var search_entry_ptr: UnsafeMutablePointer<GtkSearchEntry>! { return ptr?.assumingMemoryBound(to: GtkSearchEntry.self) }

    /// Gets the widget that `entry` is capturing key events from.
    @inlinable func getKeyCaptureWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_search_entry_get_key_capture_widget(search_entry_ptr))) else { return nil }
        return rv
    }

    /// Sets `widget` as the widget that `entry` will capture key
    /// events from.
    /// 
    /// Key events are consumed by the search entry to start or
    /// continue a search.
    /// 
    /// If the entry is part of a `GtkSearchBar`, it is preferable
    /// to call [method`Gtk.SearchBar.set_key_capture_widget`] instead,
    /// which will reveal the entry in addition to triggering the
    /// search entry.
    /// 
    /// Note that despite the name of this function, the events
    /// are only 'captured' in the bubble phase, which means that
    /// editable child widgets of `widget` will receive text input
    /// before it gets captured. If that is not desired, you can
    /// capture and forward the events yourself with
    /// [method`Gtk.EventControllerKey.forward`].
    @inlinable func setKeyCapture(widget: WidgetRef? = nil) {
        gtk_search_entry_set_key_capture_widget(search_entry_ptr, widget?.widget_ptr)
    
    }
    /// Sets `widget` as the widget that `entry` will capture key
    /// events from.
    /// 
    /// Key events are consumed by the search entry to start or
    /// continue a search.
    /// 
    /// If the entry is part of a `GtkSearchBar`, it is preferable
    /// to call [method`Gtk.SearchBar.set_key_capture_widget`] instead,
    /// which will reveal the entry in addition to triggering the
    /// search entry.
    /// 
    /// Note that despite the name of this function, the events
    /// are only 'captured' in the bubble phase, which means that
    /// editable child widgets of `widget` will receive text input
    /// before it gets captured. If that is not desired, you can
    /// capture and forward the events yourself with
    /// [method`Gtk.EventControllerKey.forward`].
    @inlinable func setKeyCapture<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        gtk_search_entry_set_key_capture_widget(search_entry_ptr, widget?.widget_ptr)
    
    }
    /// Gets the widget that `entry` is capturing key events from.
    @inlinable var keyCaptureWidget: WidgetRef! {
        /// Gets the widget that `entry` is capturing key events from.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_search_entry_get_key_capture_widget(search_entry_ptr))) else { return nil }
            return rv
        }
        /// Sets `widget` as the widget that `entry` will capture key
        /// events from.
        /// 
        /// Key events are consumed by the search entry to start or
        /// continue a search.
        /// 
        /// If the entry is part of a `GtkSearchBar`, it is preferable
        /// to call [method`Gtk.SearchBar.set_key_capture_widget`] instead,
        /// which will reveal the entry in addition to triggering the
        /// search entry.
        /// 
        /// Note that despite the name of this function, the events
        /// are only 'captured' in the bubble phase, which means that
        /// editable child widgets of `widget` will receive text input
        /// before it gets captured. If that is not desired, you can
        /// capture and forward the events yourself with
        /// [method`Gtk.EventControllerKey.forward`].
        nonmutating set {
            gtk_search_entry_set_key_capture_widget(search_entry_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }


}



// MARK: - SelectionFilterModel Class

/// The `SelectionFilterModelProtocol` protocol exposes the methods and properties of an underlying `GtkSelectionFilterModel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SelectionFilterModel`.
/// Alternatively, use `SelectionFilterModelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSelectionFilterModel` is a list model that presents the selection from
/// a `GtkSelectionModel`.
public protocol SelectionFilterModelProtocol: GLibObject.ObjectProtocol, GIO.ListModelProtocol {
        /// Untyped pointer to the underlying `GtkSelectionFilterModel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSelectionFilterModel` instance.
    var selection_filter_model_ptr: UnsafeMutablePointer<GtkSelectionFilterModel>! { get }

    /// Required Initialiser for types conforming to `SelectionFilterModelProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SelectionFilterModelRef` type acts as a lightweight Swift reference to an underlying `GtkSelectionFilterModel` instance.
/// It exposes methods that can operate on this data type through `SelectionFilterModelProtocol` conformance.
/// Use `SelectionFilterModelRef` only as an `unowned` reference to an existing `GtkSelectionFilterModel` instance.
///
/// `GtkSelectionFilterModel` is a list model that presents the selection from
/// a `GtkSelectionModel`.
public struct SelectionFilterModelRef: SelectionFilterModelProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSelectionFilterModel` instance.
    /// For type-safe access, use the generated, typed pointer `selection_filter_model_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SelectionFilterModelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSelectionFilterModel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSelectionFilterModel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSelectionFilterModel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSelectionFilterModel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SelectionFilterModelProtocol`
    @inlinable init<T: SelectionFilterModelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SelectionFilterModelProtocol>(_ other: T) -> SelectionFilterModelRef { SelectionFilterModelRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSelectionFilterModel` that will include the
    /// selected items from the underlying selection model.
    @inlinable init<SelectionModelT: SelectionModelProtocol>( model: SelectionModelT?) {
        let rv = gtk_selection_filter_model_new(model?.selection_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SelectionFilterModel` type acts as a reference-counted owner of an underlying `GtkSelectionFilterModel` instance.
/// It provides the methods that can operate on this data type through `SelectionFilterModelProtocol` conformance.
/// Use `SelectionFilterModel` as a strong reference or owner of a `GtkSelectionFilterModel` instance.
///
/// `GtkSelectionFilterModel` is a list model that presents the selection from
/// a `GtkSelectionModel`.
open class SelectionFilterModel: GLibObject.Object, SelectionFilterModelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSelectionFilterModel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSelectionFilterModel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSelectionFilterModel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSelectionFilterModel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSelectionFilterModel`.
    /// i.e., ownership is transferred to the `SelectionFilterModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSelectionFilterModel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SelectionFilterModelProtocol`
    /// Will retain `GtkSelectionFilterModel`.
    /// - Parameter other: an instance of a related type that implements `SelectionFilterModelProtocol`
    @inlinable public init<T: SelectionFilterModelProtocol>(selectionFilterModel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SelectionFilterModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSelectionFilterModel` that will include the
    /// selected items from the underlying selection model.
    @inlinable public init<SelectionModelT: SelectionModelProtocol>( model: SelectionModelT?) {
        let rv = gtk_selection_filter_model_new(model?.selection_model_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SelectionFilterModelPropertyName: String, PropertyNameProtocol {
    /// The model being filtered.
    case model = "model"
}

public extension SelectionFilterModelProtocol {
    /// Bind a `SelectionFilterModelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SelectionFilterModelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SelectionFilterModel property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SelectionFilterModelPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SelectionFilterModel property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SelectionFilterModelPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SelectionFilterModelSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The model being filtered.
    case notifyModel = "notify::model"
}

// MARK: SelectionFilterModel has no signals
// MARK: SelectionFilterModel Class: SelectionFilterModelProtocol extension (methods and fields)
public extension SelectionFilterModelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSelectionFilterModel` instance.
    @inlinable var selection_filter_model_ptr: UnsafeMutablePointer<GtkSelectionFilterModel>! { return ptr?.assumingMemoryBound(to: GtkSelectionFilterModel.self) }

    /// Gets the model currently filtered or `nil` if none.
    @inlinable func getModel() -> SelectionModelRef! {
        let rv = SelectionModelRef(gconstpointer: gconstpointer(gtk_selection_filter_model_get_model(selection_filter_model_ptr)))
        return rv
    }

    /// Sets the model to be filtered.
    /// 
    /// Note that GTK makes no effort to ensure that `model` conforms to
    /// the item type of `self`. It assumes that the caller knows what they
    /// are doing and have set up an appropriate filter to ensure that item
    /// types match.
    @inlinable func set(model: SelectionModelRef? = nil) {
        gtk_selection_filter_model_set_model(selection_filter_model_ptr, model?.selection_model_ptr)
    
    }
    /// Sets the model to be filtered.
    /// 
    /// Note that GTK makes no effort to ensure that `model` conforms to
    /// the item type of `self`. It assumes that the caller knows what they
    /// are doing and have set up an appropriate filter to ensure that item
    /// types match.
    @inlinable func set<SelectionModelT: SelectionModelProtocol>(model: SelectionModelT?) {
        gtk_selection_filter_model_set_model(selection_filter_model_ptr, model?.selection_model_ptr)
    
    }
    /// The model being filtered.
    @inlinable var model: SelectionModelRef! {
        /// Gets the model currently filtered or `nil` if none.
        get {
            let rv = SelectionModelRef(gconstpointer: gconstpointer(gtk_selection_filter_model_get_model(selection_filter_model_ptr)))
            return rv
        }
        /// Sets the model to be filtered.
        /// 
        /// Note that GTK makes no effort to ensure that `model` conforms to
        /// the item type of `self`. It assumes that the caller knows what they
        /// are doing and have set up an appropriate filter to ensure that item
        /// types match.
        nonmutating set {
            gtk_selection_filter_model_set_model(selection_filter_model_ptr, UnsafeMutablePointer<GtkSelectionModel>(newValue?.selection_model_ptr))
        }
    }


}



// MARK: - Separator Class

/// The `SeparatorProtocol` protocol exposes the methods and properties of an underlying `GtkSeparator` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Separator`.
/// Alternatively, use `SeparatorRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSeparator` is a horizontal or vertical separator widget.
/// 
/// ![An example GtkSeparator](separators.png)
/// 
/// A `GtkSeparator` can be used to group the widgets within a window.
/// It displays a line with a shadow to make it appear sunken into the
/// interface.
/// 
/// # CSS nodes
/// 
/// `GtkSeparator` has a single CSS node with name separator. The node
/// gets one of the .horizontal or .vertical style classes.
/// 
/// # Accessibility
/// 
/// `GtkSeparator` uses the `GTK_ACCESSIBLE_ROLE_SEPARATOR` role.
public protocol SeparatorProtocol: WidgetProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkSeparator` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSeparator` instance.
    var separator_ptr: UnsafeMutablePointer<GtkSeparator>! { get }

    /// Required Initialiser for types conforming to `SeparatorProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SeparatorRef` type acts as a lightweight Swift reference to an underlying `GtkSeparator` instance.
/// It exposes methods that can operate on this data type through `SeparatorProtocol` conformance.
/// Use `SeparatorRef` only as an `unowned` reference to an existing `GtkSeparator` instance.
///
/// `GtkSeparator` is a horizontal or vertical separator widget.
/// 
/// ![An example GtkSeparator](separators.png)
/// 
/// A `GtkSeparator` can be used to group the widgets within a window.
/// It displays a line with a shadow to make it appear sunken into the
/// interface.
/// 
/// # CSS nodes
/// 
/// `GtkSeparator` has a single CSS node with name separator. The node
/// gets one of the .horizontal or .vertical style classes.
/// 
/// # Accessibility
/// 
/// `GtkSeparator` uses the `GTK_ACCESSIBLE_ROLE_SEPARATOR` role.
public struct SeparatorRef: SeparatorProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSeparator` instance.
    /// For type-safe access, use the generated, typed pointer `separator_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SeparatorRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSeparator>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSeparator>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSeparator>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSeparator>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SeparatorProtocol`
    @inlinable init<T: SeparatorProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SeparatorProtocol>(_ other: T) -> SeparatorRef { SeparatorRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSeparator` with the given orientation.
    @inlinable init( orientation: GtkOrientation) {
        let rv = gtk_separator_new(orientation)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Separator` type acts as a reference-counted owner of an underlying `GtkSeparator` instance.
/// It provides the methods that can operate on this data type through `SeparatorProtocol` conformance.
/// Use `Separator` as a strong reference or owner of a `GtkSeparator` instance.
///
/// `GtkSeparator` is a horizontal or vertical separator widget.
/// 
/// ![An example GtkSeparator](separators.png)
/// 
/// A `GtkSeparator` can be used to group the widgets within a window.
/// It displays a line with a shadow to make it appear sunken into the
/// interface.
/// 
/// # CSS nodes
/// 
/// `GtkSeparator` has a single CSS node with name separator. The node
/// gets one of the .horizontal or .vertical style classes.
/// 
/// # Accessibility
/// 
/// `GtkSeparator` uses the `GTK_ACCESSIBLE_ROLE_SEPARATOR` role.
open class Separator: Widget, SeparatorProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSeparator>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSeparator>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSeparator>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSeparator>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSeparator`.
    /// i.e., ownership is transferred to the `Separator` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSeparator>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SeparatorProtocol`
    /// Will retain `GtkSeparator`.
    /// - Parameter other: an instance of a related type that implements `SeparatorProtocol`
    @inlinable public init<T: SeparatorProtocol>(separator other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SeparatorProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSeparator` with the given orientation.
    @inlinable public init( orientation: GtkOrientation) {
        let rv = gtk_separator_new(orientation)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SeparatorPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension SeparatorProtocol {
    /// Bind a `SeparatorPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SeparatorPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Separator property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SeparatorPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Separator property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SeparatorPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SeparatorSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: Separator has no signals
// MARK: Separator Class: SeparatorProtocol extension (methods and fields)
public extension SeparatorProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSeparator` instance.
    @inlinable var separator_ptr: UnsafeMutablePointer<GtkSeparator>! { return ptr?.assumingMemoryBound(to: GtkSeparator.self) }



}



// MARK: - Settings Class

/// The `SettingsProtocol` protocol exposes the methods and properties of an underlying `GtkSettings` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Settings`.
/// Alternatively, use `SettingsRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSettings` provides a mechanism to share global settings between
/// applications.
/// 
/// On the X window system, this sharing is realized by an
/// [XSettings](http://www.freedesktop.org/wiki/Specifications/xsettings-spec)
/// manager that is usually part of the desktop environment, along with
/// utilities that let the user change these settings.
/// 
/// On Wayland, the settings are obtained either via a settings portal,
/// or by reading desktop settings from DConf.
/// 
/// In the absence of these sharing mechanisms, GTK reads default values for
/// settings from `settings.ini` files in `/etc/gtk-4.0`, `$XDG_CONFIG_DIRS/gtk-4.0`
/// and `$XDG_CONFIG_HOME/gtk-4.0`. These files must be valid key files (see
/// `GKeyFile`), and have a section called Settings. Themes can also provide
/// default values for settings by installing a `settings.ini` file
/// next to their `gtk.css` file.
/// 
/// Applications can override system-wide settings by setting the property
/// of the `GtkSettings` object with `g_object_set()`. This should be restricted
/// to special cases though; `GtkSettings` are not meant as an application
/// configuration facility.
/// 
/// There is one `GtkSettings` instance per display. It can be obtained with
/// [type_func`GtkSettings.get_for_display`], but in many cases, it is more
/// convenient to use [method`Gtk.Widget.get_settings`].
public protocol SettingsProtocol: GLibObject.ObjectProtocol, StyleProviderProtocol {
        /// Untyped pointer to the underlying `GtkSettings` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSettings` instance.
    var settings_ptr: UnsafeMutablePointer<GtkSettings>! { get }

    /// Required Initialiser for types conforming to `SettingsProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SettingsRef` type acts as a lightweight Swift reference to an underlying `GtkSettings` instance.
/// It exposes methods that can operate on this data type through `SettingsProtocol` conformance.
/// Use `SettingsRef` only as an `unowned` reference to an existing `GtkSettings` instance.
///
/// `GtkSettings` provides a mechanism to share global settings between
/// applications.
/// 
/// On the X window system, this sharing is realized by an
/// [XSettings](http://www.freedesktop.org/wiki/Specifications/xsettings-spec)
/// manager that is usually part of the desktop environment, along with
/// utilities that let the user change these settings.
/// 
/// On Wayland, the settings are obtained either via a settings portal,
/// or by reading desktop settings from DConf.
/// 
/// In the absence of these sharing mechanisms, GTK reads default values for
/// settings from `settings.ini` files in `/etc/gtk-4.0`, `$XDG_CONFIG_DIRS/gtk-4.0`
/// and `$XDG_CONFIG_HOME/gtk-4.0`. These files must be valid key files (see
/// `GKeyFile`), and have a section called Settings. Themes can also provide
/// default values for settings by installing a `settings.ini` file
/// next to their `gtk.css` file.
/// 
/// Applications can override system-wide settings by setting the property
/// of the `GtkSettings` object with `g_object_set()`. This should be restricted
/// to special cases though; `GtkSettings` are not meant as an application
/// configuration facility.
/// 
/// There is one `GtkSettings` instance per display. It can be obtained with
/// [type_func`GtkSettings.get_for_display`], but in many cases, it is more
/// convenient to use [method`Gtk.Widget.get_settings`].
public struct SettingsRef: SettingsProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSettings` instance.
    /// For type-safe access, use the generated, typed pointer `settings_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SettingsRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSettings>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSettings>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSettings>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSettings>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SettingsProtocol`
    @inlinable init<T: SettingsProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SettingsProtocol>(_ other: T) -> SettingsRef { SettingsRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Gets the `GtkSettings` object for the default display, creating
    /// it if necessary.
    /// 
    /// See [type_func`Gtk.Settings.get_for_display`].
    @inlinable static func getDefault() -> SettingsRef! {
        guard let rv = SettingsRef(gconstpointer: gconstpointer(gtk_settings_get_default())) else { return nil }
        return rv
    }

    /// Gets the `GtkSettings` object for `display`, creating it if necessary.
    @inlinable static func getFor<DisplayT: Gdk.DisplayProtocol>(display: DisplayT) -> SettingsRef! {
        guard let rv = SettingsRef(gconstpointer: gconstpointer(gtk_settings_get_for_display(display.display_ptr))) else { return nil }
        return rv
    }
}

/// The `Settings` type acts as a reference-counted owner of an underlying `GtkSettings` instance.
/// It provides the methods that can operate on this data type through `SettingsProtocol` conformance.
/// Use `Settings` as a strong reference or owner of a `GtkSettings` instance.
///
/// `GtkSettings` provides a mechanism to share global settings between
/// applications.
/// 
/// On the X window system, this sharing is realized by an
/// [XSettings](http://www.freedesktop.org/wiki/Specifications/xsettings-spec)
/// manager that is usually part of the desktop environment, along with
/// utilities that let the user change these settings.
/// 
/// On Wayland, the settings are obtained either via a settings portal,
/// or by reading desktop settings from DConf.
/// 
/// In the absence of these sharing mechanisms, GTK reads default values for
/// settings from `settings.ini` files in `/etc/gtk-4.0`, `$XDG_CONFIG_DIRS/gtk-4.0`
/// and `$XDG_CONFIG_HOME/gtk-4.0`. These files must be valid key files (see
/// `GKeyFile`), and have a section called Settings. Themes can also provide
/// default values for settings by installing a `settings.ini` file
/// next to their `gtk.css` file.
/// 
/// Applications can override system-wide settings by setting the property
/// of the `GtkSettings` object with `g_object_set()`. This should be restricted
/// to special cases though; `GtkSettings` are not meant as an application
/// configuration facility.
/// 
/// There is one `GtkSettings` instance per display. It can be obtained with
/// [type_func`GtkSettings.get_for_display`], but in many cases, it is more
/// convenient to use [method`Gtk.Widget.get_settings`].
open class Settings: GLibObject.Object, SettingsProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSettings>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSettings>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSettings>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSettings>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSettings`.
    /// i.e., ownership is transferred to the `Settings` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSettings>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SettingsProtocol`
    /// Will retain `GtkSettings`.
    /// - Parameter other: an instance of a related type that implements `SettingsProtocol`
    @inlinable public init<T: SettingsProtocol>(settings other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SettingsProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }


    /// Gets the `GtkSettings` object for the default display, creating
    /// it if necessary.
    /// 
    /// See [type_func`Gtk.Settings.get_for_display`].
    @inlinable public static func getDefault() -> Settings! {
        guard let rv = Settings(gconstpointer: gconstpointer(gtk_settings_get_default())) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

    /// Gets the `GtkSettings` object for `display`, creating it if necessary.
    @inlinable public static func getFor<DisplayT: Gdk.DisplayProtocol>(display: DisplayT) -> Settings! {
        guard let rv = Settings(gconstpointer: gconstpointer(gtk_settings_get_for_display(display.display_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum SettingsPropertyName: String, PropertyNameProtocol {
    /// Whether buttons in dialogs should use the alternative button order.
    case gtkAlternativeButtonOrder = "gtk-alternative-button-order"
    /// Controls the direction of the sort indicators in sorted list and tree
    /// views.
    /// 
    /// By default an arrow pointing down means the column is sorted
    /// in ascending order. When set to `true`, this order will be inverted.
    case gtkAlternativeSortArrows = "gtk-alternative-sort-arrows"
    /// Whether the application prefers to use a dark theme.
    /// 
    /// If a GTK theme includes a dark variant, it will be used
    /// instead of the configured theme.
    /// 
    /// Some applications benefit from minimizing the amount of light
    /// pollution that interferes with the content. Good candidates for
    /// dark themes are photo and video editors that make the actual
    /// content get all the attention and minimize the distraction of
    /// the chrome.
    /// 
    /// Dark themes should not be used for documents, where large spaces
    /// are white/light and the dark chrome creates too much contrast
    /// (web browser, text editor...).
    case gtkApplicationPreferDarkTheme = "gtk-application-prefer-dark-theme"
    /// The aspect ratio of the text caret.
    case gtkCursorAspectRatio = "gtk-cursor-aspect-ratio"
    /// Whether the cursor should blink.
    /// 
    /// Also see the [property`Gtk.Settings:gtk-cursor-blink-timeout`] setting,
    /// which allows more flexible control over cursor blinking.
    case gtkCursorBlink = "gtk-cursor-blink"
    /// Length of the cursor blink cycle, in milliseconds.
    case gtkCursorBlinkTime = "gtk-cursor-blink-time"
    /// Time after which the cursor stops blinking, in seconds.
    /// 
    /// The timer is reset after each user interaction.
    /// 
    /// Setting this to zero has the same effect as setting
    /// [property`Gtk.Settings:gtk-cursor-blink`] to `false`.
    case gtkCursorBlinkTimeout = "gtk-cursor-blink-timeout"
    /// Name of the cursor theme to use.
    /// 
    /// Use `nil` to use the default theme.
    case gtkCursorThemeName = "gtk-cursor-theme-name"
    /// The size to use for cursors.
    /// 
    /// 0 means to use the default size.
    case gtkCursorThemeSize = "gtk-cursor-theme-size"
    /// Determines which buttons should be put in the
    /// titlebar of client-side decorated windows, and whether they
    /// should be placed at the left of right.
    /// 
    /// The format of the string is button names, separated by commas.
    /// A colon separates the buttons that should appear on the left
    /// from those on the right. Recognized button names are minimize,
    /// maximize, close, icon (the window icon) and menu (a menu button
    /// for the fallback app menu).
    /// 
    /// For example, "menu:minimize,maximize,close" specifies a menu
    /// on the left, and minimize, maximize and close buttons on the right.
    /// 
    /// Note that buttons will only be shown when they are meaningful.
    /// E.g. a menu button only appears when the desktop shell does not
    /// show the app menu, and a close button only appears on a window
    /// that can be closed.
    /// 
    /// Also note that the setting can be overridden with the
    /// [property`Gtk.HeaderBar:decoration-layout`] property.
    case gtkDecorationLayout = "gtk-decoration-layout"
    /// Whether builtin GTK dialogs such as the file chooser, the
    /// color chooser or the font chooser will use a header bar at
    /// the top to show action widgets, or an action area at the bottom.
    /// 
    /// This setting does not affect custom dialogs using `GtkDialog`
    /// directly, or message dialogs.
    case gtkDialogsUseHeader = "gtk-dialogs-use-header"
    /// The number of pixels the cursor can move before dragging.
    case gtkDndDragThreshold = "gtk-dnd-drag-threshold"
    /// The maximum distance allowed between two clicks for them to be considered
    /// a double click, in pixels.
    case gtkDoubleClickDistance = "gtk-double-click-distance"
    /// The maximum time to allow between two clicks for them to be considered
    /// a double click, in milliseconds.
    case gtkDoubleClickTime = "gtk-double-click-time"
    /// Whether menu items should have visible accelerators which can be
    /// activated.
    case gtkEnableAccels = "gtk-enable-accels"
    /// Whether to enable toolkit-wide animations.
    case gtkEnableAnimations = "gtk-enable-animations"
    /// Whether to play any event sounds at all.
    /// 
    /// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
    /// for more information on event sounds and sound themes.
    /// 
    /// GTK itself does not support event sounds, you have to use a loadable
    /// module like the one that comes with libcanberra.
    case gtkEnableEventSounds = "gtk-enable-event-sounds"
    /// Whether to play event sounds as feedback to user input.
    /// 
    /// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
    /// for more information on event sounds and sound themes.
    /// 
    /// GTK itself does not support event sounds, you have to use a loadable
    /// module like the one that comes with libcanberra.
    case gtkEnableInputFeedbackSounds = "gtk-enable-input-feedback-sounds"
    /// Whether a middle click on a mouse should paste the
    /// 'PRIMARY' clipboard content at the cursor location.
    case gtkEnablePrimaryPaste = "gtk-enable-primary-paste"
    /// How long to show the last input character in hidden
    /// entries.
    /// 
    /// This value is in milliseconds. 0 disables showing the
    /// last char. 600 is a good value for enabling it.
    case gtkEntryPasswordHintTimeout = "gtk-entry-password-hint-timeout"
    case gtkEntrySelectOnFocus = "gtk-entry-select-on-focus"
    /// When `true`, keyboard navigation and other input-related errors
    /// will cause a beep.
    /// 
    /// Since the error bell is implemented using `gdk_surface_beep()`, the
    /// windowing system may offer ways to configure the error bell in many
    /// ways, such as flashing the window or similar visual effects.
    case gtkErrorBell = "gtk-error-bell"
    /// The default font to use.
    /// 
    /// GTK uses the family name and size from this string.
    case gtkFontName = "gtk-font-name"
    /// Timestamp of the curent fontconfig configuration.
    case gtkFontconfigTimestamp = "gtk-fontconfig-timestamp"
    /// Name of the icon theme to use.
    /// 
    /// See [class`Gtk.IconTheme`] for details about how
    /// GTK handles icon themes.
    case gtkIconThemeName = "gtk-icon-theme-name"
    /// Which IM (input method) module should be used by default.
    /// 
    /// This is the input method that will be used if the user has not
    /// explicitly chosen another input method from the IM context menu.
    /// This also can be a colon-separated list of input methods, which GTK
    /// will try in turn until it finds one available on the system.
    /// 
    /// See [class`Gtk.IMContext`].
    case gtkImModule = "gtk-im-module"
    /// Whether GTK should make sure that text can be navigated with
    /// a caret, even if it is not editable.
    /// 
    /// This is useful when using a screen reader.
    case gtkKeynavUseCaret = "gtk-keynav-use-caret"
    /// Whether to select the contents of a selectable
    /// label when it is focused.
    case gtkLabelSelectOnFocus = "gtk-label-select-on-focus"
    /// The time for a button or touch press to be considered a “long press”.
    /// 
    /// See [class`Gtk.GestureLongPress`].
    case gtkLongPressTime = "gtk-long-press-time"
    /// Whether scrolled windows may use overlaid scrolling indicators.
    /// 
    /// If this is set to `false`, scrolled windows will have permanent
    /// scrollbars.
    case gtkOverlayScrolling = "gtk-overlay-scrolling"
    /// If the value of this setting is `true`, clicking the primary button in a
    /// `GtkRange` trough will move the slider, and hence set the range’s value, to
    /// the point that you clicked.
    /// 
    /// If it is `false`, a primary click will cause the slider/value to move
    /// by the range’s page-size towards the point clicked.
    /// 
    /// Whichever action you choose for the primary button, the other action will
    /// be available by holding Shift and primary-clicking, or clicking the middle
    /// mouse button.
    case gtkPrimaryButtonWarpsSlider = "gtk-primary-button-warps-slider"
    /// A comma-separated list of print backends to use in the print
    /// dialog.
    /// 
    /// Available print backends depend on the GTK installation,
    /// and may include "file", "cups", "lpr" or "papi".
    case gtkPrintBackends = "gtk-print-backends"
    /// A command to run for displaying the print preview.
    /// 
    /// The command should contain a ``f`` placeholder, which will get
    /// replaced by the path to the pdf file. The command may also
    /// contain a ``s`` placeholder, which will get replaced by the
    /// path to a file containing the print settings in the format
    /// produced by [method`Gtk.PrintSettings.to_file`].
    /// 
    /// The preview application is responsible for removing the pdf
    /// file and the print settings file when it is done.
    case gtkPrintPreviewCommand = "gtk-print-preview-command"
    /// Whether GTK should keep track of items inside the recently used
    /// resources list.
    /// 
    /// If set to `false`, the list will always be empty.
    case gtkRecentFilesEnabled = "gtk-recent-files-enabled"
    /// The maximum age, in days, of the items inside the recently used
    /// resources list.
    /// 
    /// Items older than this setting will be excised from the list.
    /// If set to 0, the list will always be empty; if set to -1, no
    /// item will be removed.
    case gtkRecentFilesMaxAge = "gtk-recent-files-max-age"
    /// Set to `true` if the desktop environment is displaying
    /// the app menu, `false` if the app should display it itself.
    case gtkShellShowsAppMenu = "gtk-shell-shows-app-menu"
    /// Set to `true` if the desktop environment is displaying
    /// the desktop folder, `false` if not.
    case gtkShellShowsDesktop = "gtk-shell-shows-desktop"
    /// Set to `true` if the desktop environment is displaying
    /// the menubar, `false` if the app should display it itself.
    case gtkShellShowsMenubar = "gtk-shell-shows-menubar"
    /// The XDG sound theme to use for event sounds.
    /// 
    /// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
    /// for more information on event sounds and sound themes.
    /// 
    /// GTK itself does not support event sounds, you have to use
    /// a loadable module like the one that comes with libcanberra.
    case gtkSoundThemeName = "gtk-sound-theme-name"
    /// Whether two cursors should be displayed for mixed left-to-right and
    /// right-to-left text.
    case gtkSplitCursor = "gtk-split-cursor"
    /// Name of the theme to load.
    /// 
    /// See [class`Gtk.CssProvider`] for details about how
    /// GTK finds the CSS stylesheet for a theme.
    case gtkThemeName = "gtk-theme-name"
    /// Determines the action to take when a double-click
    /// occurs on the titlebar of client-side decorated windows.
    /// 
    /// Recognized actions are minimize, toggle-maximize, menu, lower
    /// or none.
    case gtkTitlebarDoubleClick = "gtk-titlebar-double-click"
    /// Determines the action to take when a middle-click
    /// occurs on the titlebar of client-side decorated windows.
    /// 
    /// Recognized actions are minimize, toggle-maximize, menu, lower
    /// or none.
    case gtkTitlebarMiddleClick = "gtk-titlebar-middle-click"
    /// Determines the action to take when a right-click
    /// occurs on the titlebar of client-side decorated windows.
    /// 
    /// Recognized actions are minimize, toggle-maximize, menu, lower
    /// or none.
    case gtkTitlebarRightClick = "gtk-titlebar-right-click"
    /// Whether to antialias fonts.
    /// 
    /// The values are 0 for no, 1 for yes, or -1 for the system default.
    case gtkXftAntialias = "gtk-xft-antialias"
    /// The font resolution, in 1024 * dots/inch.
    /// 
    /// -1 to use the default value.
    case gtkXftDpi = "gtk-xft-dpi"
    /// Whether to enable font hinting.
    /// 
    /// The values are 0 for no, 1 for yes, or -1 for the system default.
    case gtkXftHinting = "gtk-xft-hinting"
    /// What degree of font hinting to use.
    /// 
    /// The possible vaues are hintnone, hintslight,
    /// hintmedium, hintfull.
    case gtkXftHintstyle = "gtk-xft-hintstyle"
    /// The type of subpixel antialiasing to use.
    /// 
    /// The possible values are none, rgb, bgr, vrgb, vbgr.
    case gtkXftRgba = "gtk-xft-rgba"
}

public extension SettingsProtocol {
    /// Bind a `SettingsPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SettingsPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Settings property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SettingsPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Settings property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SettingsPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SettingsSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Whether buttons in dialogs should use the alternative button order.
    case notifyGtkAlternativeButtonOrder = "notify::gtk-alternative-button-order"
    /// Controls the direction of the sort indicators in sorted list and tree
    /// views.
    /// 
    /// By default an arrow pointing down means the column is sorted
    /// in ascending order. When set to `true`, this order will be inverted.
    case notifyGtkAlternativeSortArrows = "notify::gtk-alternative-sort-arrows"
    /// Whether the application prefers to use a dark theme.
    /// 
    /// If a GTK theme includes a dark variant, it will be used
    /// instead of the configured theme.
    /// 
    /// Some applications benefit from minimizing the amount of light
    /// pollution that interferes with the content. Good candidates for
    /// dark themes are photo and video editors that make the actual
    /// content get all the attention and minimize the distraction of
    /// the chrome.
    /// 
    /// Dark themes should not be used for documents, where large spaces
    /// are white/light and the dark chrome creates too much contrast
    /// (web browser, text editor...).
    case notifyGtkApplicationPreferDarkTheme = "notify::gtk-application-prefer-dark-theme"
    /// The aspect ratio of the text caret.
    case notifyGtkCursorAspectRatio = "notify::gtk-cursor-aspect-ratio"
    /// Whether the cursor should blink.
    /// 
    /// Also see the [property`Gtk.Settings:gtk-cursor-blink-timeout`] setting,
    /// which allows more flexible control over cursor blinking.
    case notifyGtkCursorBlink = "notify::gtk-cursor-blink"
    /// Length of the cursor blink cycle, in milliseconds.
    case notifyGtkCursorBlinkTime = "notify::gtk-cursor-blink-time"
    /// Time after which the cursor stops blinking, in seconds.
    /// 
    /// The timer is reset after each user interaction.
    /// 
    /// Setting this to zero has the same effect as setting
    /// [property`Gtk.Settings:gtk-cursor-blink`] to `false`.
    case notifyGtkCursorBlinkTimeout = "notify::gtk-cursor-blink-timeout"
    /// Name of the cursor theme to use.
    /// 
    /// Use `nil` to use the default theme.
    case notifyGtkCursorThemeName = "notify::gtk-cursor-theme-name"
    /// The size to use for cursors.
    /// 
    /// 0 means to use the default size.
    case notifyGtkCursorThemeSize = "notify::gtk-cursor-theme-size"
    /// Determines which buttons should be put in the
    /// titlebar of client-side decorated windows, and whether they
    /// should be placed at the left of right.
    /// 
    /// The format of the string is button names, separated by commas.
    /// A colon separates the buttons that should appear on the left
    /// from those on the right. Recognized button names are minimize,
    /// maximize, close, icon (the window icon) and menu (a menu button
    /// for the fallback app menu).
    /// 
    /// For example, "menu:minimize,maximize,close" specifies a menu
    /// on the left, and minimize, maximize and close buttons on the right.
    /// 
    /// Note that buttons will only be shown when they are meaningful.
    /// E.g. a menu button only appears when the desktop shell does not
    /// show the app menu, and a close button only appears on a window
    /// that can be closed.
    /// 
    /// Also note that the setting can be overridden with the
    /// [property`Gtk.HeaderBar:decoration-layout`] property.
    case notifyGtkDecorationLayout = "notify::gtk-decoration-layout"
    /// Whether builtin GTK dialogs such as the file chooser, the
    /// color chooser or the font chooser will use a header bar at
    /// the top to show action widgets, or an action area at the bottom.
    /// 
    /// This setting does not affect custom dialogs using `GtkDialog`
    /// directly, or message dialogs.
    case notifyGtkDialogsUseHeader = "notify::gtk-dialogs-use-header"
    /// The number of pixels the cursor can move before dragging.
    case notifyGtkDndDragThreshold = "notify::gtk-dnd-drag-threshold"
    /// The maximum distance allowed between two clicks for them to be considered
    /// a double click, in pixels.
    case notifyGtkDoubleClickDistance = "notify::gtk-double-click-distance"
    /// The maximum time to allow between two clicks for them to be considered
    /// a double click, in milliseconds.
    case notifyGtkDoubleClickTime = "notify::gtk-double-click-time"
    /// Whether menu items should have visible accelerators which can be
    /// activated.
    case notifyGtkEnableAccels = "notify::gtk-enable-accels"
    /// Whether to enable toolkit-wide animations.
    case notifyGtkEnableAnimations = "notify::gtk-enable-animations"
    /// Whether to play any event sounds at all.
    /// 
    /// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
    /// for more information on event sounds and sound themes.
    /// 
    /// GTK itself does not support event sounds, you have to use a loadable
    /// module like the one that comes with libcanberra.
    case notifyGtkEnableEventSounds = "notify::gtk-enable-event-sounds"
    /// Whether to play event sounds as feedback to user input.
    /// 
    /// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
    /// for more information on event sounds and sound themes.
    /// 
    /// GTK itself does not support event sounds, you have to use a loadable
    /// module like the one that comes with libcanberra.
    case notifyGtkEnableInputFeedbackSounds = "notify::gtk-enable-input-feedback-sounds"
    /// Whether a middle click on a mouse should paste the
    /// 'PRIMARY' clipboard content at the cursor location.
    case notifyGtkEnablePrimaryPaste = "notify::gtk-enable-primary-paste"
    /// How long to show the last input character in hidden
    /// entries.
    /// 
    /// This value is in milliseconds. 0 disables showing the
    /// last char. 600 is a good value for enabling it.
    case notifyGtkEntryPasswordHintTimeout = "notify::gtk-entry-password-hint-timeout"
    case notifyGtkEntrySelectOnFocus = "notify::gtk-entry-select-on-focus"
    /// When `true`, keyboard navigation and other input-related errors
    /// will cause a beep.
    /// 
    /// Since the error bell is implemented using `gdk_surface_beep()`, the
    /// windowing system may offer ways to configure the error bell in many
    /// ways, such as flashing the window or similar visual effects.
    case notifyGtkErrorBell = "notify::gtk-error-bell"
    /// The default font to use.
    /// 
    /// GTK uses the family name and size from this string.
    case notifyGtkFontName = "notify::gtk-font-name"
    /// Timestamp of the curent fontconfig configuration.
    case notifyGtkFontconfigTimestamp = "notify::gtk-fontconfig-timestamp"
    /// Name of the icon theme to use.
    /// 
    /// See [class`Gtk.IconTheme`] for details about how
    /// GTK handles icon themes.
    case notifyGtkIconThemeName = "notify::gtk-icon-theme-name"
    /// Which IM (input method) module should be used by default.
    /// 
    /// This is the input method that will be used if the user has not
    /// explicitly chosen another input method from the IM context menu.
    /// This also can be a colon-separated list of input methods, which GTK
    /// will try in turn until it finds one available on the system.
    /// 
    /// See [class`Gtk.IMContext`].
    case notifyGtkImModule = "notify::gtk-im-module"
    /// Whether GTK should make sure that text can be navigated with
    /// a caret, even if it is not editable.
    /// 
    /// This is useful when using a screen reader.
    case notifyGtkKeynavUseCaret = "notify::gtk-keynav-use-caret"
    /// Whether to select the contents of a selectable
    /// label when it is focused.
    case notifyGtkLabelSelectOnFocus = "notify::gtk-label-select-on-focus"
    /// The time for a button or touch press to be considered a “long press”.
    /// 
    /// See [class`Gtk.GestureLongPress`].
    case notifyGtkLongPressTime = "notify::gtk-long-press-time"
    /// Whether scrolled windows may use overlaid scrolling indicators.
    /// 
    /// If this is set to `false`, scrolled windows will have permanent
    /// scrollbars.
    case notifyGtkOverlayScrolling = "notify::gtk-overlay-scrolling"
    /// If the value of this setting is `true`, clicking the primary button in a
    /// `GtkRange` trough will move the slider, and hence set the range’s value, to
    /// the point that you clicked.
    /// 
    /// If it is `false`, a primary click will cause the slider/value to move
    /// by the range’s page-size towards the point clicked.
    /// 
    /// Whichever action you choose for the primary button, the other action will
    /// be available by holding Shift and primary-clicking, or clicking the middle
    /// mouse button.
    case notifyGtkPrimaryButtonWarpsSlider = "notify::gtk-primary-button-warps-slider"
    /// A comma-separated list of print backends to use in the print
    /// dialog.
    /// 
    /// Available print backends depend on the GTK installation,
    /// and may include "file", "cups", "lpr" or "papi".
    case notifyGtkPrintBackends = "notify::gtk-print-backends"
    /// A command to run for displaying the print preview.
    /// 
    /// The command should contain a ``f`` placeholder, which will get
    /// replaced by the path to the pdf file. The command may also
    /// contain a ``s`` placeholder, which will get replaced by the
    /// path to a file containing the print settings in the format
    /// produced by [method`Gtk.PrintSettings.to_file`].
    /// 
    /// The preview application is responsible for removing the pdf
    /// file and the print settings file when it is done.
    case notifyGtkPrintPreviewCommand = "notify::gtk-print-preview-command"
    /// Whether GTK should keep track of items inside the recently used
    /// resources list.
    /// 
    /// If set to `false`, the list will always be empty.
    case notifyGtkRecentFilesEnabled = "notify::gtk-recent-files-enabled"
    /// The maximum age, in days, of the items inside the recently used
    /// resources list.
    /// 
    /// Items older than this setting will be excised from the list.
    /// If set to 0, the list will always be empty; if set to -1, no
    /// item will be removed.
    case notifyGtkRecentFilesMaxAge = "notify::gtk-recent-files-max-age"
    /// Set to `true` if the desktop environment is displaying
    /// the app menu, `false` if the app should display it itself.
    case notifyGtkShellShowsAppMenu = "notify::gtk-shell-shows-app-menu"
    /// Set to `true` if the desktop environment is displaying
    /// the desktop folder, `false` if not.
    case notifyGtkShellShowsDesktop = "notify::gtk-shell-shows-desktop"
    /// Set to `true` if the desktop environment is displaying
    /// the menubar, `false` if the app should display it itself.
    case notifyGtkShellShowsMenubar = "notify::gtk-shell-shows-menubar"
    /// The XDG sound theme to use for event sounds.
    /// 
    /// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
    /// for more information on event sounds and sound themes.
    /// 
    /// GTK itself does not support event sounds, you have to use
    /// a loadable module like the one that comes with libcanberra.
    case notifyGtkSoundThemeName = "notify::gtk-sound-theme-name"
    /// Whether two cursors should be displayed for mixed left-to-right and
    /// right-to-left text.
    case notifyGtkSplitCursor = "notify::gtk-split-cursor"
    /// Name of the theme to load.
    /// 
    /// See [class`Gtk.CssProvider`] for details about how
    /// GTK finds the CSS stylesheet for a theme.
    case notifyGtkThemeName = "notify::gtk-theme-name"
    /// Determines the action to take when a double-click
    /// occurs on the titlebar of client-side decorated windows.
    /// 
    /// Recognized actions are minimize, toggle-maximize, menu, lower
    /// or none.
    case notifyGtkTitlebarDoubleClick = "notify::gtk-titlebar-double-click"
    /// Determines the action to take when a middle-click
    /// occurs on the titlebar of client-side decorated windows.
    /// 
    /// Recognized actions are minimize, toggle-maximize, menu, lower
    /// or none.
    case notifyGtkTitlebarMiddleClick = "notify::gtk-titlebar-middle-click"
    /// Determines the action to take when a right-click
    /// occurs on the titlebar of client-side decorated windows.
    /// 
    /// Recognized actions are minimize, toggle-maximize, menu, lower
    /// or none.
    case notifyGtkTitlebarRightClick = "notify::gtk-titlebar-right-click"
    /// Whether to antialias fonts.
    /// 
    /// The values are 0 for no, 1 for yes, or -1 for the system default.
    case notifyGtkXftAntialias = "notify::gtk-xft-antialias"
    /// The font resolution, in 1024 * dots/inch.
    /// 
    /// -1 to use the default value.
    case notifyGtkXftDpi = "notify::gtk-xft-dpi"
    /// Whether to enable font hinting.
    /// 
    /// The values are 0 for no, 1 for yes, or -1 for the system default.
    case notifyGtkXftHinting = "notify::gtk-xft-hinting"
    /// What degree of font hinting to use.
    /// 
    /// The possible vaues are hintnone, hintslight,
    /// hintmedium, hintfull.
    case notifyGtkXftHintstyle = "notify::gtk-xft-hintstyle"
    /// The type of subpixel antialiasing to use.
    /// 
    /// The possible values are none, rgb, bgr, vrgb, vbgr.
    case notifyGtkXftRgba = "notify::gtk-xft-rgba"
}

// MARK: Settings has no signals
// MARK: Settings Class: SettingsProtocol extension (methods and fields)
public extension SettingsProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSettings` instance.
    @inlinable var settings_ptr: UnsafeMutablePointer<GtkSettings>! { return ptr?.assumingMemoryBound(to: GtkSettings.self) }

    /// Undoes the effect of calling `g_object_set()` to install an
    /// application-specific value for a setting.
    /// 
    /// After this call, the setting will again follow the session-wide
    /// value for this setting.
    @inlinable func resetProperty(name: UnsafePointer<CChar>!) {
        gtk_settings_reset_property(settings_ptr, name)
    
    }


}



// MARK: - Shortcut Class

/// The `ShortcutProtocol` protocol exposes the methods and properties of an underlying `GtkShortcut` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Shortcut`.
/// Alternatively, use `ShortcutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkShortcut` describes a keyboard shortcut.
/// 
/// It contains a description of how to trigger the shortcut via a
/// [class`Gtk.ShortcutTrigger`] and a way to activate the shortcut
/// on a widget via a [class`Gtk.ShortcutAction`].
/// 
/// The actual work is usually done via [class`Gtk.ShortcutController`],
/// which decides if and when to activate a shortcut. Using that controller
/// directly however is rarely necessary as various higher level
/// convenience APIs exist on `GtkWidgets` that make it easier to use
/// shortcuts in GTK.
/// 
/// `GtkShortcut` does provide functionality to make it easy for users
/// to work with shortcuts, either by providing informational strings
/// for display purposes or by allowing shortcuts to be configured.
public protocol ShortcutProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkShortcut` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcut` instance.
    var shortcut_ptr: UnsafeMutablePointer<GtkShortcut>! { get }

    /// Required Initialiser for types conforming to `ShortcutProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `ShortcutRef` type acts as a lightweight Swift reference to an underlying `GtkShortcut` instance.
/// It exposes methods that can operate on this data type through `ShortcutProtocol` conformance.
/// Use `ShortcutRef` only as an `unowned` reference to an existing `GtkShortcut` instance.
///
/// A `GtkShortcut` describes a keyboard shortcut.
/// 
/// It contains a description of how to trigger the shortcut via a
/// [class`Gtk.ShortcutTrigger`] and a way to activate the shortcut
/// on a widget via a [class`Gtk.ShortcutAction`].
/// 
/// The actual work is usually done via [class`Gtk.ShortcutController`],
/// which decides if and when to activate a shortcut. Using that controller
/// directly however is rarely necessary as various higher level
/// convenience APIs exist on `GtkWidgets` that make it easier to use
/// shortcuts in GTK.
/// 
/// `GtkShortcut` does provide functionality to make it easy for users
/// to work with shortcuts, either by providing informational strings
/// for display purposes or by allowing shortcuts to be configured.
public struct ShortcutRef: ShortcutProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcut` instance.
    /// For type-safe access, use the generated, typed pointer `shortcut_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcut>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcut>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcut>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcut>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutProtocol`
    @inlinable init<T: ShortcutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutProtocol>(_ other: T) -> ShortcutRef { ShortcutRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkShortcut` that is triggered by
    /// `trigger` and then activates `action`.
    @inlinable init<ShortcutActionT: ShortcutActionProtocol, ShortcutTriggerT: ShortcutTriggerProtocol>( trigger: ShortcutTriggerT?, action: ShortcutActionT?) {
        let rv = gtk_shortcut_new(trigger?.shortcut_trigger_ptr, action?.shortcut_action_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }


    // *** newWithArguments() is not available because it has a varargs (...) parameter!


    // *** newWithArguments() is not available because it has a varargs (...) parameter!

}

/// The `Shortcut` type acts as a reference-counted owner of an underlying `GtkShortcut` instance.
/// It provides the methods that can operate on this data type through `ShortcutProtocol` conformance.
/// Use `Shortcut` as a strong reference or owner of a `GtkShortcut` instance.
///
/// A `GtkShortcut` describes a keyboard shortcut.
/// 
/// It contains a description of how to trigger the shortcut via a
/// [class`Gtk.ShortcutTrigger`] and a way to activate the shortcut
/// on a widget via a [class`Gtk.ShortcutAction`].
/// 
/// The actual work is usually done via [class`Gtk.ShortcutController`],
/// which decides if and when to activate a shortcut. Using that controller
/// directly however is rarely necessary as various higher level
/// convenience APIs exist on `GtkWidgets` that make it easier to use
/// shortcuts in GTK.
/// 
/// `GtkShortcut` does provide functionality to make it easy for users
/// to work with shortcuts, either by providing informational strings
/// for display purposes or by allowing shortcuts to be configured.
open class Shortcut: GLibObject.Object, ShortcutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcut>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcut>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcut>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcut>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcut`.
    /// i.e., ownership is transferred to the `Shortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcut>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutProtocol`
    /// Will retain `GtkShortcut`.
    /// - Parameter other: an instance of a related type that implements `ShortcutProtocol`
    @inlinable public init<T: ShortcutProtocol>(shortcut other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkShortcut` that is triggered by
    /// `trigger` and then activates `action`.
    @inlinable public init<ShortcutActionT: ShortcutActionProtocol, ShortcutTriggerT: ShortcutTriggerProtocol>( trigger: ShortcutTriggerT?, action: ShortcutActionT?) {
        let rv = gtk_shortcut_new(trigger?.shortcut_trigger_ptr, action?.shortcut_action_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


    // *** newWithArguments() is not available because it has a varargs (...) parameter!



    // *** newWithArguments() is not available because it has a varargs (...) parameter!


}

public enum ShortcutPropertyName: String, PropertyNameProtocol {
    /// The action that gets activated by this shortcut.
    case action = "action"
    /// Arguments passed to activation.
    case arguments = "arguments"
    /// The trigger that triggers this shortcut.
    case trigger = "trigger"
}

public extension ShortcutProtocol {
    /// Bind a `ShortcutPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Shortcut property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Shortcut property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ShortcutSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The action that gets activated by this shortcut.
    case notifyAction = "notify::action"
    /// Arguments passed to activation.
    case notifyArguments = "notify::arguments"
    /// The trigger that triggers this shortcut.
    case notifyTrigger = "notify::trigger"
}

// MARK: Shortcut has no signals
// MARK: Shortcut Class: ShortcutProtocol extension (methods and fields)
public extension ShortcutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcut` instance.
    @inlinable var shortcut_ptr: UnsafeMutablePointer<GtkShortcut>! { return ptr?.assumingMemoryBound(to: GtkShortcut.self) }

    /// Gets the action that is activated by this shortcut.
    @inlinable func getAction() -> ShortcutActionRef! {
        let rv = ShortcutActionRef(gconstpointer: gconstpointer(gtk_shortcut_get_action(shortcut_ptr)))
        return rv
    }

    /// Gets the arguments that are passed when activating the shortcut.
    @inlinable func getArguments() -> GLib.VariantRef! {
        let rv = GLib.VariantRef(gtk_shortcut_get_arguments(shortcut_ptr))
        return rv
    }

    /// Gets the trigger used to trigger `self`.
    @inlinable func getTrigger() -> ShortcutTriggerRef! {
        let rv = ShortcutTriggerRef(gconstpointer: gconstpointer(gtk_shortcut_get_trigger(shortcut_ptr)))
        return rv
    }

    /// Sets the new action for `self` to be `action`.
    @inlinable func set(action: ShortcutActionRef? = nil) {
        gtk_shortcut_set_action(shortcut_ptr, action?.shortcut_action_ptr)
    
    }
    /// Sets the new action for `self` to be `action`.
    @inlinable func set<ShortcutActionT: ShortcutActionProtocol>(action: ShortcutActionT?) {
        gtk_shortcut_set_action(shortcut_ptr, action?.shortcut_action_ptr)
    
    }

    /// Sets the arguments to pass when activating the shortcut.
    @inlinable func setArguments(args: GLib.VariantRef? = nil) {
        gtk_shortcut_set_arguments(shortcut_ptr, args?.variant_ptr)
    
    }
    /// Sets the arguments to pass when activating the shortcut.
    @inlinable func setArguments<VariantT: GLib.VariantProtocol>(args: VariantT?) {
        gtk_shortcut_set_arguments(shortcut_ptr, args?.variant_ptr)
    
    }

    /// Sets the new trigger for `self` to be `trigger`.
    @inlinable func set(trigger: ShortcutTriggerRef? = nil) {
        gtk_shortcut_set_trigger(shortcut_ptr, trigger?.shortcut_trigger_ptr)
    
    }
    /// Sets the new trigger for `self` to be `trigger`.
    @inlinable func set<ShortcutTriggerT: ShortcutTriggerProtocol>(trigger: ShortcutTriggerT?) {
        gtk_shortcut_set_trigger(shortcut_ptr, trigger?.shortcut_trigger_ptr)
    
    }
    /// The action that gets activated by this shortcut.
    @inlinable var action: ShortcutActionRef! {
        /// Gets the action that is activated by this shortcut.
        get {
            let rv = ShortcutActionRef(gconstpointer: gconstpointer(gtk_shortcut_get_action(shortcut_ptr)))
            return rv
        }
        /// Sets the new action for `self` to be `action`.
        nonmutating set {
            gtk_shortcut_set_action(shortcut_ptr, UnsafeMutablePointer<GtkShortcutAction>(newValue?.shortcut_action_ptr))
        }
    }

    /// Arguments passed to activation.
    @inlinable var arguments: GLib.VariantRef! {
        /// Gets the arguments that are passed when activating the shortcut.
        get {
            let rv = GLib.VariantRef(gtk_shortcut_get_arguments(shortcut_ptr))
            return rv
        }
        /// Sets the arguments to pass when activating the shortcut.
        nonmutating set {
            gtk_shortcut_set_arguments(shortcut_ptr, UnsafeMutablePointer<GVariant>(newValue?.variant_ptr))
        }
    }

    /// The trigger that triggers this shortcut.
    @inlinable var trigger: ShortcutTriggerRef! {
        /// Gets the trigger used to trigger `self`.
        get {
            let rv = ShortcutTriggerRef(gconstpointer: gconstpointer(gtk_shortcut_get_trigger(shortcut_ptr)))
            return rv
        }
        /// Sets the new trigger for `self` to be `trigger`.
        nonmutating set {
            gtk_shortcut_set_trigger(shortcut_ptr, UnsafeMutablePointer<GtkShortcutTrigger>(newValue?.shortcut_trigger_ptr))
        }
    }


}



// MARK: - ShortcutAction Class

/// The `ShortcutActionProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutAction` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutAction`.
/// Alternatively, use `ShortcutActionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkShortcutAction` encodes an action that can be triggered by a
/// keyboard shortcut.
/// 
/// `GtkShortcutActions` contain functions that allow easy presentation
/// to end users as well as being printed for debugging.
/// 
/// All `GtkShortcutActions` are immutable, you can only specify their
/// properties during construction. If you want to change a action, you
/// have to replace it with a new one. If you need to pass arguments to
/// an action, these are specified by the higher-level `GtkShortcut` object.
/// 
/// To activate a `GtkShortcutAction` manually, [method`Gtk.ShortcutAction.activate`]
/// can be called.
/// 
/// GTK provides various actions:
/// 
///  - [class`Gtk.MnemonicAction`]: a shortcut action that calls
///    `gtk_widget_mnemonic_activate()`
///  - [class`Gtk.CallbackAction`]: a shortcut action that invokes
///    a given callback
///  - [class`Gtk.SignalAction`]: a shortcut action that emits a
///    given signal
///  - [class`Gtk.ActivateAction`]: a shortcut action that calls
///    `gtk_widget_activate()`
///  - [class`Gtk.NamedAction`]: a shortcut action that calls
///    `gtk_widget_activate_action()`
///  - [class`Gtk.NothingAction`]: a shortcut action that does nothing
public protocol ShortcutActionProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkShortcutAction` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutAction` instance.
    var shortcut_action_ptr: UnsafeMutablePointer<GtkShortcutAction>! { get }

    /// Required Initialiser for types conforming to `ShortcutActionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `ShortcutActionRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutAction` instance.
/// It exposes methods that can operate on this data type through `ShortcutActionProtocol` conformance.
/// Use `ShortcutActionRef` only as an `unowned` reference to an existing `GtkShortcutAction` instance.
///
/// `GtkShortcutAction` encodes an action that can be triggered by a
/// keyboard shortcut.
/// 
/// `GtkShortcutActions` contain functions that allow easy presentation
/// to end users as well as being printed for debugging.
/// 
/// All `GtkShortcutActions` are immutable, you can only specify their
/// properties during construction. If you want to change a action, you
/// have to replace it with a new one. If you need to pass arguments to
/// an action, these are specified by the higher-level `GtkShortcut` object.
/// 
/// To activate a `GtkShortcutAction` manually, [method`Gtk.ShortcutAction.activate`]
/// can be called.
/// 
/// GTK provides various actions:
/// 
///  - [class`Gtk.MnemonicAction`]: a shortcut action that calls
///    `gtk_widget_mnemonic_activate()`
///  - [class`Gtk.CallbackAction`]: a shortcut action that invokes
///    a given callback
///  - [class`Gtk.SignalAction`]: a shortcut action that emits a
///    given signal
///  - [class`Gtk.ActivateAction`]: a shortcut action that calls
///    `gtk_widget_activate()`
///  - [class`Gtk.NamedAction`]: a shortcut action that calls
///    `gtk_widget_activate_action()`
///  - [class`Gtk.NothingAction`]: a shortcut action that does nothing
public struct ShortcutActionRef: ShortcutActionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutAction` instance.
    /// For type-safe access, use the generated, typed pointer `shortcut_action_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutActionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutAction>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutAction>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutAction>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutAction>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutActionProtocol`
    @inlinable init<T: ShortcutActionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutActionProtocol>(_ other: T) -> ShortcutActionRef { ShortcutActionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Tries to parse the given string into an action.
    /// 
    /// On success, the parsed action is returned. When parsing
    /// failed, `nil` is returned.
    /// 
    /// The accepted strings are:
    /// 
    /// - `nothing`, for `GtkNothingAction`
    /// - `activate`, for `GtkActivateAction`
    /// - `mnemonic-activate`, for `GtkMnemonicAction`
    /// - ``action(NAME)``, for a `GtkNamedAction` for the action named `NAME`
    /// - ``signal(NAME)``, for a `GtkSignalAction` for the signal `NAME`
    @inlinable init(string: UnsafePointer<CChar>!) {
        let rv = gtk_shortcut_action_parse_string(string)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Tries to parse the given string into an action.
    /// 
    /// On success, the parsed action is returned. When parsing
    /// failed, `nil` is returned.
    /// 
    /// The accepted strings are:
    /// 
    /// - `nothing`, for `GtkNothingAction`
    /// - `activate`, for `GtkActivateAction`
    /// - `mnemonic-activate`, for `GtkMnemonicAction`
    /// - ``action(NAME)``, for a `GtkNamedAction` for the action named `NAME`
    /// - ``signal(NAME)``, for a `GtkSignalAction` for the signal `NAME`
    @inlinable static func parse(string: UnsafePointer<CChar>!) -> ShortcutActionRef! {
        guard let rv = ShortcutActionRef(gconstpointer: gconstpointer(gtk_shortcut_action_parse_string(string))) else { return nil }
        return rv
    }
}

/// The `ShortcutAction` type acts as a reference-counted owner of an underlying `GtkShortcutAction` instance.
/// It provides the methods that can operate on this data type through `ShortcutActionProtocol` conformance.
/// Use `ShortcutAction` as a strong reference or owner of a `GtkShortcutAction` instance.
///
/// `GtkShortcutAction` encodes an action that can be triggered by a
/// keyboard shortcut.
/// 
/// `GtkShortcutActions` contain functions that allow easy presentation
/// to end users as well as being printed for debugging.
/// 
/// All `GtkShortcutActions` are immutable, you can only specify their
/// properties during construction. If you want to change a action, you
/// have to replace it with a new one. If you need to pass arguments to
/// an action, these are specified by the higher-level `GtkShortcut` object.
/// 
/// To activate a `GtkShortcutAction` manually, [method`Gtk.ShortcutAction.activate`]
/// can be called.
/// 
/// GTK provides various actions:
/// 
///  - [class`Gtk.MnemonicAction`]: a shortcut action that calls
///    `gtk_widget_mnemonic_activate()`
///  - [class`Gtk.CallbackAction`]: a shortcut action that invokes
///    a given callback
///  - [class`Gtk.SignalAction`]: a shortcut action that emits a
///    given signal
///  - [class`Gtk.ActivateAction`]: a shortcut action that calls
///    `gtk_widget_activate()`
///  - [class`Gtk.NamedAction`]: a shortcut action that calls
///    `gtk_widget_activate_action()`
///  - [class`Gtk.NothingAction`]: a shortcut action that does nothing
open class ShortcutAction: GLibObject.Object, ShortcutActionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutAction>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutAction>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutAction>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutAction>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutAction`.
    /// i.e., ownership is transferred to the `ShortcutAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutAction>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutActionProtocol`
    /// Will retain `GtkShortcutAction`.
    /// - Parameter other: an instance of a related type that implements `ShortcutActionProtocol`
    @inlinable public init<T: ShortcutActionProtocol>(shortcutAction other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Tries to parse the given string into an action.
    /// 
    /// On success, the parsed action is returned. When parsing
    /// failed, `nil` is returned.
    /// 
    /// The accepted strings are:
    /// 
    /// - `nothing`, for `GtkNothingAction`
    /// - `activate`, for `GtkActivateAction`
    /// - `mnemonic-activate`, for `GtkMnemonicAction`
    /// - ``action(NAME)``, for a `GtkNamedAction` for the action named `NAME`
    /// - ``signal(NAME)``, for a `GtkSignalAction` for the signal `NAME`
    @inlinable public init(string: UnsafePointer<CChar>!) {
        let rv = gtk_shortcut_action_parse_string(string)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Tries to parse the given string into an action.
    /// 
    /// On success, the parsed action is returned. When parsing
    /// failed, `nil` is returned.
    /// 
    /// The accepted strings are:
    /// 
    /// - `nothing`, for `GtkNothingAction`
    /// - `activate`, for `GtkActivateAction`
    /// - `mnemonic-activate`, for `GtkMnemonicAction`
    /// - ``action(NAME)``, for a `GtkNamedAction` for the action named `NAME`
    /// - ``signal(NAME)``, for a `GtkSignalAction` for the signal `NAME`
    @inlinable public static func parse(string: UnsafePointer<CChar>!) -> ShortcutAction! {
        guard let rv = ShortcutAction(gconstpointer: gconstpointer(gtk_shortcut_action_parse_string(string))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

// MARK: no ShortcutAction properties

public enum ShortcutActionSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: ShortcutAction has no signals
// MARK: ShortcutAction Class: ShortcutActionProtocol extension (methods and fields)
public extension ShortcutActionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutAction` instance.
    @inlinable var shortcut_action_ptr: UnsafeMutablePointer<GtkShortcutAction>! { return ptr?.assumingMemoryBound(to: GtkShortcutAction.self) }

    /// Activates the action on the `widget` with the given `args`.
    /// 
    /// Note that some actions ignore the passed in `flags`, `widget` or `args`.
    /// 
    /// Activation of an action can fail for various reasons. If the action
    /// is not supported by the `widget`, if the `args` don't match the action
    /// or if the activation otherwise had no effect, `false` will be returned.
    @inlinable func activate<WidgetT: WidgetProtocol>(flags: ShortcutActionFlags, widget: WidgetT, args: GLib.VariantRef? = nil) -> Bool {
        let rv = ((gtk_shortcut_action_activate(shortcut_action_ptr, flags.value, widget.widget_ptr, args?.variant_ptr)) != 0)
        return rv
    }
    /// Activates the action on the `widget` with the given `args`.
    /// 
    /// Note that some actions ignore the passed in `flags`, `widget` or `args`.
    /// 
    /// Activation of an action can fail for various reasons. If the action
    /// is not supported by the `widget`, if the `args` don't match the action
    /// or if the activation otherwise had no effect, `false` will be returned.
    @inlinable func activate<VariantT: GLib.VariantProtocol, WidgetT: WidgetProtocol>(flags: ShortcutActionFlags, widget: WidgetT, args: VariantT?) -> Bool {
        let rv = ((gtk_shortcut_action_activate(shortcut_action_ptr, flags.value, widget.widget_ptr, args?.variant_ptr)) != 0)
        return rv
    }

    /// Prints the given action into a string for the developer.
    /// 
    /// This is meant for debugging and logging.
    /// 
    /// The form of the representation may change at any time and is
    /// not guaranteed to stay identical.
    @inlinable func print<StringTypeT: StringProtocol>(string: StringTypeT) {
        gtk_shortcut_action_print(shortcut_action_ptr, string.gstring_ptr)
    
    }

    /// Prints the given action into a human-readable string.
    /// 
    /// This is a small wrapper around [method`Gtk.ShortcutAction.print`]
    /// to help when debugging.
    @inlinable func toString() -> String! {
        let rv = gtk_shortcut_action_to_string(shortcut_action_ptr).map({ String(cString: $0) })
        return rv
    }


}



// MARK: - ShortcutController Class

/// The `ShortcutControllerProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutController` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutController`.
/// Alternatively, use `ShortcutControllerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkShortcutController` is an event controller that manages shortcuts.
/// 
/// Most common shortcuts are using this controller implicitly, e.g. by
/// adding a mnemonic underline to a `GtkLabel`, or by installing a key
/// binding using `gtk_widget_class_add_binding()`, or by adding accelerators
/// to global actions using `gtk_application_set_accels_for_action()`.
/// 
/// But it is possible to create your own shortcut controller, and add
/// shortcuts to it.
/// 
/// `GtkShortcutController` implements `GListModel` for querying the
/// shortcuts that have been added to it.
/// 
/// # GtkShortcutController as a GtkBuildable
/// 
/// `GtkShortcutControllers` can be creates in ui files to set up
/// shortcuts in the same place as the widgets.
/// 
/// An example of a UI definition fragment with `GtkShortcutController`:
/// ```xml
///   &lt;object class='GtkButton'&gt;
///     &lt;child&gt;
///       &lt;object class='GtkShortcutController'&gt;
///         &lt;property name='scope'&gt;managed&lt;/property&gt;
///         &lt;child&gt;
///           &lt;object class='GtkShortcut'&gt;
///             &lt;property name='trigger'&gt;&amp;lt;Control&amp;gt;k&lt;/property&gt;
///             &lt;property name='action'&gt;activate&lt;/property&gt;
///           &lt;/object&gt;
///         &lt;/child&gt;
///       &lt;/object&gt;
///     &lt;/child&gt;
///   &lt;/object&gt;
/// ```
/// 
/// This example creates a [class`Gtk.ActivateAction`] for triggering the
/// `activate` signal of the `GtkButton`. See [ctor`Gtk.ShortcutAction.parse_string`]
/// for the syntax for other kinds of `GtkShortcutAction`. See
/// [ctor`Gtk.ShortcutTrigger.parse_string`] to learn more about the syntax
/// for triggers.
public protocol ShortcutControllerProtocol: EventControllerProtocol, GIO.ListModelProtocol, BuildableProtocol {
        /// Untyped pointer to the underlying `GtkShortcutController` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutController` instance.
    var shortcut_controller_ptr: UnsafeMutablePointer<GtkShortcutController>! { get }

    /// Required Initialiser for types conforming to `ShortcutControllerProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `ShortcutControllerRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutController` instance.
/// It exposes methods that can operate on this data type through `ShortcutControllerProtocol` conformance.
/// Use `ShortcutControllerRef` only as an `unowned` reference to an existing `GtkShortcutController` instance.
///
/// `GtkShortcutController` is an event controller that manages shortcuts.
/// 
/// Most common shortcuts are using this controller implicitly, e.g. by
/// adding a mnemonic underline to a `GtkLabel`, or by installing a key
/// binding using `gtk_widget_class_add_binding()`, or by adding accelerators
/// to global actions using `gtk_application_set_accels_for_action()`.
/// 
/// But it is possible to create your own shortcut controller, and add
/// shortcuts to it.
/// 
/// `GtkShortcutController` implements `GListModel` for querying the
/// shortcuts that have been added to it.
/// 
/// # GtkShortcutController as a GtkBuildable
/// 
/// `GtkShortcutControllers` can be creates in ui files to set up
/// shortcuts in the same place as the widgets.
/// 
/// An example of a UI definition fragment with `GtkShortcutController`:
/// ```xml
///   &lt;object class='GtkButton'&gt;
///     &lt;child&gt;
///       &lt;object class='GtkShortcutController'&gt;
///         &lt;property name='scope'&gt;managed&lt;/property&gt;
///         &lt;child&gt;
///           &lt;object class='GtkShortcut'&gt;
///             &lt;property name='trigger'&gt;&amp;lt;Control&amp;gt;k&lt;/property&gt;
///             &lt;property name='action'&gt;activate&lt;/property&gt;
///           &lt;/object&gt;
///         &lt;/child&gt;
///       &lt;/object&gt;
///     &lt;/child&gt;
///   &lt;/object&gt;
/// ```
/// 
/// This example creates a [class`Gtk.ActivateAction`] for triggering the
/// `activate` signal of the `GtkButton`. See [ctor`Gtk.ShortcutAction.parse_string`]
/// for the syntax for other kinds of `GtkShortcutAction`. See
/// [ctor`Gtk.ShortcutTrigger.parse_string`] to learn more about the syntax
/// for triggers.
public struct ShortcutControllerRef: ShortcutControllerProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutController` instance.
    /// For type-safe access, use the generated, typed pointer `shortcut_controller_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutControllerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutController>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutController>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutController>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutController>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutControllerProtocol`
    @inlinable init<T: ShortcutControllerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutControllerProtocol>(_ other: T) -> ShortcutControllerRef { ShortcutControllerRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new shortcut controller.
    @inlinable init() {
        let rv = gtk_shortcut_controller_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new shortcut controller that takes its shortcuts from
    /// the given list model.
    /// 
    /// A controller created by this function does not let you add or
    /// remove individual shortcuts using the shortcut controller api,
    /// but you can change the contents of the model.
    @inlinable init<ListModelT: GIO.ListModelProtocol>(model: ListModelT) {
        let rv = gtk_shortcut_controller_new_for_model(model.list_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new shortcut controller that takes its shortcuts from
    /// the given list model.
    /// 
    /// A controller created by this function does not let you add or
    /// remove individual shortcuts using the shortcut controller api,
    /// but you can change the contents of the model.
    @inlinable static func newFor<ListModelT: GIO.ListModelProtocol>(model: ListModelT) -> EventControllerRef! {
        guard let rv = EventControllerRef(gconstpointer: gconstpointer(gtk_shortcut_controller_new_for_model(model.list_model_ptr))) else { return nil }
        return rv
    }
}

/// The `ShortcutController` type acts as a reference-counted owner of an underlying `GtkShortcutController` instance.
/// It provides the methods that can operate on this data type through `ShortcutControllerProtocol` conformance.
/// Use `ShortcutController` as a strong reference or owner of a `GtkShortcutController` instance.
///
/// `GtkShortcutController` is an event controller that manages shortcuts.
/// 
/// Most common shortcuts are using this controller implicitly, e.g. by
/// adding a mnemonic underline to a `GtkLabel`, or by installing a key
/// binding using `gtk_widget_class_add_binding()`, or by adding accelerators
/// to global actions using `gtk_application_set_accels_for_action()`.
/// 
/// But it is possible to create your own shortcut controller, and add
/// shortcuts to it.
/// 
/// `GtkShortcutController` implements `GListModel` for querying the
/// shortcuts that have been added to it.
/// 
/// # GtkShortcutController as a GtkBuildable
/// 
/// `GtkShortcutControllers` can be creates in ui files to set up
/// shortcuts in the same place as the widgets.
/// 
/// An example of a UI definition fragment with `GtkShortcutController`:
/// ```xml
///   &lt;object class='GtkButton'&gt;
///     &lt;child&gt;
///       &lt;object class='GtkShortcutController'&gt;
///         &lt;property name='scope'&gt;managed&lt;/property&gt;
///         &lt;child&gt;
///           &lt;object class='GtkShortcut'&gt;
///             &lt;property name='trigger'&gt;&amp;lt;Control&amp;gt;k&lt;/property&gt;
///             &lt;property name='action'&gt;activate&lt;/property&gt;
///           &lt;/object&gt;
///         &lt;/child&gt;
///       &lt;/object&gt;
///     &lt;/child&gt;
///   &lt;/object&gt;
/// ```
/// 
/// This example creates a [class`Gtk.ActivateAction`] for triggering the
/// `activate` signal of the `GtkButton`. See [ctor`Gtk.ShortcutAction.parse_string`]
/// for the syntax for other kinds of `GtkShortcutAction`. See
/// [ctor`Gtk.ShortcutTrigger.parse_string`] to learn more about the syntax
/// for triggers.
open class ShortcutController: EventController, ShortcutControllerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutController>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutController>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutController>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutController>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutController`.
    /// i.e., ownership is transferred to the `ShortcutController` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutController>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutControllerProtocol`
    /// Will retain `GtkShortcutController`.
    /// - Parameter other: an instance of a related type that implements `ShortcutControllerProtocol`
    @inlinable public init<T: ShortcutControllerProtocol>(shortcutController other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutControllerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new shortcut controller.
    @inlinable public init() {
        let rv = gtk_shortcut_controller_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new shortcut controller that takes its shortcuts from
    /// the given list model.
    /// 
    /// A controller created by this function does not let you add or
    /// remove individual shortcuts using the shortcut controller api,
    /// but you can change the contents of the model.
    @inlinable public init<ListModelT: GIO.ListModelProtocol>(model: ListModelT) {
        let rv = gtk_shortcut_controller_new_for_model(model.list_model_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new shortcut controller that takes its shortcuts from
    /// the given list model.
    /// 
    /// A controller created by this function does not let you add or
    /// remove individual shortcuts using the shortcut controller api,
    /// but you can change the contents of the model.
    @inlinable public static func newFor<ListModelT: GIO.ListModelProtocol>(model: ListModelT) -> EventController! {
        guard let rv = EventController(gconstpointer: gconstpointer(gtk_shortcut_controller_new_for_model(model.list_model_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum ShortcutControllerPropertyName: String, PropertyNameProtocol {
    /// The modifiers that need to be pressed to allow mnemonics activation.
    case mnemonicModifiers = "mnemonic-modifiers"
    /// A list model to take shortcuts from.
    case model = "model"
    /// The name for this controller, typically used for debugging purposes.
    case name = "name"
    /// The limit for which events this controller will handle.
    case propagationLimit = "propagation-limit"
    /// The propagation phase at which this controller will handle events.
    case propagationPhase = "propagation-phase"
    /// What scope the shortcuts will be handled in.
    case scope = "scope"
    /// The widget receiving the `GdkEvents` that the controller will handle.
    case widget = "widget"
}

public extension ShortcutControllerProtocol {
    /// Bind a `ShortcutControllerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutControllerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ShortcutController property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutControllerPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ShortcutController property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutControllerPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ShortcutControllerSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The modifiers that need to be pressed to allow mnemonics activation.
    case notifyMnemonicModifiers = "notify::mnemonic-modifiers"
    /// A list model to take shortcuts from.
    case notifyModel = "notify::model"
    /// The name for this controller, typically used for debugging purposes.
    case notifyName = "notify::name"
    /// The limit for which events this controller will handle.
    case notifyPropagationLimit = "notify::propagation-limit"
    /// The propagation phase at which this controller will handle events.
    case notifyPropagationPhase = "notify::propagation-phase"
    /// What scope the shortcuts will be handled in.
    case notifyScope = "notify::scope"
    /// The widget receiving the `GdkEvents` that the controller will handle.
    case notifyWidget = "notify::widget"
}

// MARK: ShortcutController has no signals
// MARK: ShortcutController Class: ShortcutControllerProtocol extension (methods and fields)
public extension ShortcutControllerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutController` instance.
    @inlinable var shortcut_controller_ptr: UnsafeMutablePointer<GtkShortcutController>! { return ptr?.assumingMemoryBound(to: GtkShortcutController.self) }

    /// Adds `shortcut` to the list of shortcuts handled by `self`.
    /// 
    /// If this controller uses an external shortcut list, this
    /// function does nothing.
    @inlinable func add<ShortcutT: ShortcutProtocol>(shortcut: ShortcutT) {
        gtk_shortcut_controller_add_shortcut(shortcut_controller_ptr, shortcut.shortcut_ptr)
    
    }

    /// Gets the mnemonics modifiers for when this controller activates its shortcuts.
    @inlinable func getMnemonicsModifiers() -> Gdk.ModifierType {
        let rv = Gdk.ModifierType(gtk_shortcut_controller_get_mnemonics_modifiers(shortcut_controller_ptr))
        return rv
    }

    /// Gets the scope for when this controller activates its shortcuts. See
    /// `gtk_shortcut_controller_set_scope()` for details.
    @inlinable func getScope() -> GtkShortcutScope {
        let rv = gtk_shortcut_controller_get_scope(shortcut_controller_ptr)
        return rv
    }

    /// Removes `shortcut` from the list of shortcuts handled by `self`.
    /// 
    /// If `shortcut` had not been added to `controller` or this controller
    /// uses an external shortcut list, this function does nothing.
    @inlinable func remove<ShortcutT: ShortcutProtocol>(shortcut: ShortcutT) {
        gtk_shortcut_controller_remove_shortcut(shortcut_controller_ptr, shortcut.shortcut_ptr)
    
    }

    /// Sets the controller to have the given `mnemonics_modifiers`.
    /// 
    /// The mnemonics modifiers determines which modifiers need to be pressed to allow
    /// activation of shortcuts with mnemonics triggers.
    /// 
    /// GTK normally uses the Alt modifier for mnemonics, except in `GtkPopoverMenus`,
    /// where mnemonics can be triggered without any modifiers. It should be very
    /// rarely necessary to change this, and doing so is likely to interfere with
    /// other shortcuts.
    /// 
    /// This value is only relevant for local shortcut controllers. Global and managed
    /// shortcut controllers will have their shortcuts activated from other places which
    /// have their own modifiers for activating mnemonics.
    @inlinable func setMnemonics(modifiers: Gdk.ModifierType) {
        gtk_shortcut_controller_set_mnemonics_modifiers(shortcut_controller_ptr, modifiers.value)
    
    }

    /// Sets the controller to have the given `scope`.
    /// 
    /// The scope allows shortcuts to be activated outside of the normal
    /// event propagation. In particular, it allows installing global
    /// keyboard shortcuts that can be activated even when a widget does
    /// not have focus.
    /// 
    /// With `GTK_SHORTCUT_SCOPE_LOCAL`, shortcuts will only be activated
    /// when the widget has focus.
    @inlinable func set(scope: GtkShortcutScope) {
        gtk_shortcut_controller_set_scope(shortcut_controller_ptr, scope)
    
    }
    /// Gets the mnemonics modifiers for when this controller activates its shortcuts.
    @inlinable var mnemonicsModifiers: Gdk.ModifierType {
        /// Gets the mnemonics modifiers for when this controller activates its shortcuts.
        get {
            let rv = Gdk.ModifierType(gtk_shortcut_controller_get_mnemonics_modifiers(shortcut_controller_ptr))
            return rv
        }
        /// Sets the controller to have the given `mnemonics_modifiers`.
        /// 
        /// The mnemonics modifiers determines which modifiers need to be pressed to allow
        /// activation of shortcuts with mnemonics triggers.
        /// 
        /// GTK normally uses the Alt modifier for mnemonics, except in `GtkPopoverMenus`,
        /// where mnemonics can be triggered without any modifiers. It should be very
        /// rarely necessary to change this, and doing so is likely to interfere with
        /// other shortcuts.
        /// 
        /// This value is only relevant for local shortcut controllers. Global and managed
        /// shortcut controllers will have their shortcuts activated from other places which
        /// have their own modifiers for activating mnemonics.
        nonmutating set {
            gtk_shortcut_controller_set_mnemonics_modifiers(shortcut_controller_ptr, newValue.value)
        }
    }

    /// What scope the shortcuts will be handled in.
    @inlinable var scope: GtkShortcutScope {
        /// Gets the scope for when this controller activates its shortcuts. See
        /// `gtk_shortcut_controller_set_scope()` for details.
        get {
            let rv = gtk_shortcut_controller_get_scope(shortcut_controller_ptr)
            return rv
        }
        /// Sets the controller to have the given `scope`.
        /// 
        /// The scope allows shortcuts to be activated outside of the normal
        /// event propagation. In particular, it allows installing global
        /// keyboard shortcuts that can be activated even when a widget does
        /// not have focus.
        /// 
        /// With `GTK_SHORTCUT_SCOPE_LOCAL`, shortcuts will only be activated
        /// when the widget has focus.
        nonmutating set {
            gtk_shortcut_controller_set_scope(shortcut_controller_ptr, newValue)
        }
    }


}



// MARK: - ShortcutLabel Class

/// The `ShortcutLabelProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutLabel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutLabel`.
/// Alternatively, use `ShortcutLabelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkShortcutLabel` displays a single keyboard shortcut or gesture.
/// 
/// The main use case for `GtkShortcutLabel` is inside a [class`Gtk.ShortcutsWindow`].
public protocol ShortcutLabelProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkShortcutLabel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutLabel` instance.
    var shortcut_label_ptr: UnsafeMutablePointer<GtkShortcutLabel>! { get }

    /// Required Initialiser for types conforming to `ShortcutLabelProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `ShortcutLabelRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutLabel` instance.
/// It exposes methods that can operate on this data type through `ShortcutLabelProtocol` conformance.
/// Use `ShortcutLabelRef` only as an `unowned` reference to an existing `GtkShortcutLabel` instance.
///
/// `GtkShortcutLabel` displays a single keyboard shortcut or gesture.
/// 
/// The main use case for `GtkShortcutLabel` is inside a [class`Gtk.ShortcutsWindow`].
public struct ShortcutLabelRef: ShortcutLabelProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutLabel` instance.
    /// For type-safe access, use the generated, typed pointer `shortcut_label_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutLabelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutLabel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutLabel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutLabel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutLabel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutLabelProtocol`
    @inlinable init<T: ShortcutLabelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutLabelProtocol>(_ other: T) -> ShortcutLabelRef { ShortcutLabelRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkShortcutLabel` with `accelerator` set.
    @inlinable init( accelerator: UnsafePointer<CChar>!) {
        let rv = gtk_shortcut_label_new(accelerator)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `ShortcutLabel` type acts as a reference-counted owner of an underlying `GtkShortcutLabel` instance.
/// It provides the methods that can operate on this data type through `ShortcutLabelProtocol` conformance.
/// Use `ShortcutLabel` as a strong reference or owner of a `GtkShortcutLabel` instance.
///
/// `GtkShortcutLabel` displays a single keyboard shortcut or gesture.
/// 
/// The main use case for `GtkShortcutLabel` is inside a [class`Gtk.ShortcutsWindow`].
open class ShortcutLabel: Widget, ShortcutLabelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutLabel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutLabel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutLabel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutLabel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutLabel`.
    /// i.e., ownership is transferred to the `ShortcutLabel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutLabel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutLabelProtocol`
    /// Will retain `GtkShortcutLabel`.
    /// - Parameter other: an instance of a related type that implements `ShortcutLabelProtocol`
    @inlinable public init<T: ShortcutLabelProtocol>(shortcutLabel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutLabelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkShortcutLabel` with `accelerator` set.
    @inlinable public init( accelerator: UnsafePointer<CChar>!) {
        let rv = gtk_shortcut_label_new(accelerator)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ShortcutLabelPropertyName: String, PropertyNameProtocol {
    /// The accelerator that `self` displays.
    /// 
    /// See [property`Gtk.ShortcutsShortcut:accelerator`]
    /// for the accepted syntax.
    case accelerator = "accelerator"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// The text that is displayed when no accelerator is set.
    case disabledText = "disabled-text"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ShortcutLabelProtocol {
    /// Bind a `ShortcutLabelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutLabelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ShortcutLabel property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutLabelPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ShortcutLabel property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutLabelPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ShortcutLabelSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The accelerator that `self` displays.
    /// 
    /// See [property`Gtk.ShortcutsShortcut:accelerator`]
    /// for the accepted syntax.
    case notifyAccelerator = "notify::accelerator"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// The text that is displayed when no accelerator is set.
    case notifyDisabledText = "notify::disabled-text"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ShortcutLabel has no signals
// MARK: ShortcutLabel Class: ShortcutLabelProtocol extension (methods and fields)
public extension ShortcutLabelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutLabel` instance.
    @inlinable var shortcut_label_ptr: UnsafeMutablePointer<GtkShortcutLabel>! { return ptr?.assumingMemoryBound(to: GtkShortcutLabel.self) }

    /// Retrieves the current accelerator of `self`.
    @inlinable func getAccelerator() -> String! {
        let rv = gtk_shortcut_label_get_accelerator(shortcut_label_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Retrieves the text that is displayed when no accelerator is set.
    @inlinable func getDisabledText() -> String! {
        let rv = gtk_shortcut_label_get_disabled_text(shortcut_label_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Sets the accelerator to be displayed by `self`.
    @inlinable func set(accelerator: UnsafePointer<CChar>!) {
        gtk_shortcut_label_set_accelerator(shortcut_label_ptr, accelerator)
    
    }

    /// Sets the text to be displayed by `self` when no accelerator is set.
    @inlinable func set(disabledText: UnsafePointer<CChar>!) {
        gtk_shortcut_label_set_disabled_text(shortcut_label_ptr, disabledText)
    
    }
    /// The accelerator that `self` displays.
    /// 
    /// See [property`Gtk.ShortcutsShortcut:accelerator`]
    /// for the accepted syntax.
    @inlinable var accelerator: String! {
        /// Retrieves the current accelerator of `self`.
        get {
            let rv = gtk_shortcut_label_get_accelerator(shortcut_label_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the accelerator to be displayed by `self`.
        nonmutating set {
            gtk_shortcut_label_set_accelerator(shortcut_label_ptr, newValue)
        }
    }

    /// Retrieves the text that is displayed when no accelerator is set.
    @inlinable var disabledText: String! {
        /// Retrieves the text that is displayed when no accelerator is set.
        get {
            let rv = gtk_shortcut_label_get_disabled_text(shortcut_label_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the text to be displayed by `self` when no accelerator is set.
        nonmutating set {
            gtk_shortcut_label_set_disabled_text(shortcut_label_ptr, newValue)
        }
    }


}



// MARK: - ShortcutTrigger Class

/// The `ShortcutTriggerProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutTrigger` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutTrigger`.
/// Alternatively, use `ShortcutTriggerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkShortcutTrigger` tracks how a `GtkShortcut` should be activated.
/// 
/// To find out if a `GtkShortcutTrigger` triggers, you can call
/// [method`Gtk.ShortcutTrigger.trigger`] on a `GdkEvent`.
/// 
/// `GtkShortcutTriggers` contain functions that allow easy presentation
/// to end users as well as being printed for debugging.
/// 
/// All `GtkShortcutTriggers` are immutable, you can only specify their
/// properties during construction. If you want to change a trigger, you
/// have to replace it with a new one.
public protocol ShortcutTriggerProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkShortcutTrigger` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutTrigger` instance.
    var shortcut_trigger_ptr: UnsafeMutablePointer<GtkShortcutTrigger>! { get }

    /// Required Initialiser for types conforming to `ShortcutTriggerProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `ShortcutTriggerRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutTrigger` instance.
/// It exposes methods that can operate on this data type through `ShortcutTriggerProtocol` conformance.
/// Use `ShortcutTriggerRef` only as an `unowned` reference to an existing `GtkShortcutTrigger` instance.
///
/// `GtkShortcutTrigger` tracks how a `GtkShortcut` should be activated.
/// 
/// To find out if a `GtkShortcutTrigger` triggers, you can call
/// [method`Gtk.ShortcutTrigger.trigger`] on a `GdkEvent`.
/// 
/// `GtkShortcutTriggers` contain functions that allow easy presentation
/// to end users as well as being printed for debugging.
/// 
/// All `GtkShortcutTriggers` are immutable, you can only specify their
/// properties during construction. If you want to change a trigger, you
/// have to replace it with a new one.
public struct ShortcutTriggerRef: ShortcutTriggerProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutTrigger` instance.
    /// For type-safe access, use the generated, typed pointer `shortcut_trigger_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutTriggerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutTrigger>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutTrigger>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutTrigger>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutTrigger>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutTriggerProtocol`
    @inlinable init<T: ShortcutTriggerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutTriggerProtocol>(_ other: T) -> ShortcutTriggerRef { ShortcutTriggerRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Tries to parse the given string into a trigger.
    /// 
    /// On success, the parsed trigger is returned.
    /// When parsing failed, `nil` is returned.
    /// 
    /// The accepted strings are:
    /// 
    ///   - `never`, for `GtkNeverTrigger`
    ///   - a string parsed by `gtk_accelerator_parse()`, for a `GtkKeyvalTrigger`, e.g. `&lt;Control&gt;C`
    ///   - underscore, followed by a single character, for `GtkMnemonicTrigger`, e.g. `_l`
    ///   - two valid trigger strings, separated by a `|` character, for a
    ///     `GtkAlternativeTrigger`: `&lt;Control&gt;q|&lt;Control&gt;w`
    /// 
    /// Note that you will have to escape the `&lt;` and `&gt;` characters when specifying
    /// triggers in XML files, such as GtkBuilder ui files. Use `&lt;` instead of
    /// `&lt;` and `&gt;` instead of `&gt;`.
    @inlinable init(string: UnsafePointer<CChar>!) {
        let rv = gtk_shortcut_trigger_parse_string(string)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Tries to parse the given string into a trigger.
    /// 
    /// On success, the parsed trigger is returned.
    /// When parsing failed, `nil` is returned.
    /// 
    /// The accepted strings are:
    /// 
    ///   - `never`, for `GtkNeverTrigger`
    ///   - a string parsed by `gtk_accelerator_parse()`, for a `GtkKeyvalTrigger`, e.g. `&lt;Control&gt;C`
    ///   - underscore, followed by a single character, for `GtkMnemonicTrigger`, e.g. `_l`
    ///   - two valid trigger strings, separated by a `|` character, for a
    ///     `GtkAlternativeTrigger`: `&lt;Control&gt;q|&lt;Control&gt;w`
    /// 
    /// Note that you will have to escape the `&lt;` and `&gt;` characters when specifying
    /// triggers in XML files, such as GtkBuilder ui files. Use `&lt;` instead of
    /// `&lt;` and `&gt;` instead of `&gt;`.
    @inlinable static func parse(string: UnsafePointer<CChar>!) -> ShortcutTriggerRef! {
        guard let rv = ShortcutTriggerRef(gconstpointer: gconstpointer(gtk_shortcut_trigger_parse_string(string))) else { return nil }
        return rv
    }
}

/// The `ShortcutTrigger` type acts as a reference-counted owner of an underlying `GtkShortcutTrigger` instance.
/// It provides the methods that can operate on this data type through `ShortcutTriggerProtocol` conformance.
/// Use `ShortcutTrigger` as a strong reference or owner of a `GtkShortcutTrigger` instance.
///
/// `GtkShortcutTrigger` tracks how a `GtkShortcut` should be activated.
/// 
/// To find out if a `GtkShortcutTrigger` triggers, you can call
/// [method`Gtk.ShortcutTrigger.trigger`] on a `GdkEvent`.
/// 
/// `GtkShortcutTriggers` contain functions that allow easy presentation
/// to end users as well as being printed for debugging.
/// 
/// All `GtkShortcutTriggers` are immutable, you can only specify their
/// properties during construction. If you want to change a trigger, you
/// have to replace it with a new one.
open class ShortcutTrigger: GLibObject.Object, ShortcutTriggerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutTrigger>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutTrigger>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutTrigger>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutTrigger>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutTrigger`.
    /// i.e., ownership is transferred to the `ShortcutTrigger` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutTrigger>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutTriggerProtocol`
    /// Will retain `GtkShortcutTrigger`.
    /// - Parameter other: an instance of a related type that implements `ShortcutTriggerProtocol`
    @inlinable public init<T: ShortcutTriggerProtocol>(shortcutTrigger other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutTriggerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Tries to parse the given string into a trigger.
    /// 
    /// On success, the parsed trigger is returned.
    /// When parsing failed, `nil` is returned.
    /// 
    /// The accepted strings are:
    /// 
    ///   - `never`, for `GtkNeverTrigger`
    ///   - a string parsed by `gtk_accelerator_parse()`, for a `GtkKeyvalTrigger`, e.g. `&lt;Control&gt;C`
    ///   - underscore, followed by a single character, for `GtkMnemonicTrigger`, e.g. `_l`
    ///   - two valid trigger strings, separated by a `|` character, for a
    ///     `GtkAlternativeTrigger`: `&lt;Control&gt;q|&lt;Control&gt;w`
    /// 
    /// Note that you will have to escape the `&lt;` and `&gt;` characters when specifying
    /// triggers in XML files, such as GtkBuilder ui files. Use `&lt;` instead of
    /// `&lt;` and `&gt;` instead of `&gt;`.
    @inlinable public init(string: UnsafePointer<CChar>!) {
        let rv = gtk_shortcut_trigger_parse_string(string)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Tries to parse the given string into a trigger.
    /// 
    /// On success, the parsed trigger is returned.
    /// When parsing failed, `nil` is returned.
    /// 
    /// The accepted strings are:
    /// 
    ///   - `never`, for `GtkNeverTrigger`
    ///   - a string parsed by `gtk_accelerator_parse()`, for a `GtkKeyvalTrigger`, e.g. `&lt;Control&gt;C`
    ///   - underscore, followed by a single character, for `GtkMnemonicTrigger`, e.g. `_l`
    ///   - two valid trigger strings, separated by a `|` character, for a
    ///     `GtkAlternativeTrigger`: `&lt;Control&gt;q|&lt;Control&gt;w`
    /// 
    /// Note that you will have to escape the `&lt;` and `&gt;` characters when specifying
    /// triggers in XML files, such as GtkBuilder ui files. Use `&lt;` instead of
    /// `&lt;` and `&gt;` instead of `&gt;`.
    @inlinable public static func parse(string: UnsafePointer<CChar>!) -> ShortcutTrigger! {
        guard let rv = ShortcutTrigger(gconstpointer: gconstpointer(gtk_shortcut_trigger_parse_string(string))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

// MARK: no ShortcutTrigger properties

public enum ShortcutTriggerSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: ShortcutTrigger has no signals
// MARK: ShortcutTrigger Class: ShortcutTriggerProtocol extension (methods and fields)
public extension ShortcutTriggerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutTrigger` instance.
    @inlinable var shortcut_trigger_ptr: UnsafeMutablePointer<GtkShortcutTrigger>! { return ptr?.assumingMemoryBound(to: GtkShortcutTrigger.self) }

    /// The types of `trigger1` and `trigger2` are `gconstpointer` only to allow
    /// use of this function as a `GCompareFunc`.
    /// 
    /// They must each be a `GtkShortcutTrigger`.
    @inlinable func compare<ShortcutTriggerT: ShortcutTriggerProtocol>(trigger2: ShortcutTriggerT) -> Int {
        let rv = Int(gtk_shortcut_trigger_compare(shortcut_trigger_ptr, trigger2.shortcut_trigger_ptr))
        return rv
    }

    /// Checks if `trigger1` and `trigger2` trigger under the same conditions.
    /// 
    /// The types of `one` and `two` are `gconstpointer` only to allow use of this
    /// function with `GHashTable`. They must each be a `GtkShortcutTrigger`.
    @inlinable func equal<ShortcutTriggerT: ShortcutTriggerProtocol>(trigger2: ShortcutTriggerT) -> Bool {
        let rv = ((gtk_shortcut_trigger_equal(shortcut_trigger_ptr, trigger2.shortcut_trigger_ptr)) != 0)
        return rv
    }

    /// Generates a hash value for a `GtkShortcutTrigger`.
    /// 
    /// The output of this function is guaranteed to be the same for a given
    /// value only per-process. It may change between different processor
    /// architectures or even different versions of GTK. Do not use this
    /// function as a basis for building protocols or file formats.
    /// 
    /// The types of `trigger` is `gconstpointer` only to allow use of this
    /// function with `GHashTable`. They must each be a `GtkShortcutTrigger`.
    @inlinable func hash() -> Int {
        let rv = Int(gtk_shortcut_trigger_hash(shortcut_trigger_ptr))
        return rv
    }

    /// Prints the given trigger into a string for the developer.
    /// This is meant for debugging and logging.
    /// 
    /// The form of the representation may change at any time
    /// and is not guaranteed to stay identical.
    @inlinable func print<StringTypeT: StringProtocol>(string: StringTypeT) {
        gtk_shortcut_trigger_print(shortcut_trigger_ptr, string.gstring_ptr)
    
    }

    /// Prints the given trigger into a string.
    /// 
    /// This function is returning a translated string for presentation
    /// to end users for example in menu items or in help texts.
    /// 
    /// The `display` in use may influence the resulting string in
    /// various forms, such as resolving hardware keycodes or by
    /// causing display-specific modifier names.
    /// 
    /// The form of the representation may change at any time and is
    /// not guaranteed to stay identical.
    @inlinable func printLabel<DisplayT: Gdk.DisplayProtocol, StringTypeT: StringProtocol>(display: DisplayT, string: StringTypeT) -> Bool {
        let rv = ((gtk_shortcut_trigger_print_label(shortcut_trigger_ptr, display.display_ptr, string.gstring_ptr)) != 0)
        return rv
    }

    /// Gets textual representation for the given trigger.
    /// 
    /// This function is returning a translated string for
    /// presentation to end users for example in menu items
    /// or in help texts.
    /// 
    /// The `display` in use may influence the resulting string in
    /// various forms, such as resolving hardware keycodes or by
    /// causing display-specific modifier names.
    /// 
    /// The form of the representation may change at any time and is
    /// not guaranteed to stay identical.
    @inlinable func toLabel<DisplayT: Gdk.DisplayProtocol>(display: DisplayT) -> String! {
        let rv = gtk_shortcut_trigger_to_label(shortcut_trigger_ptr, display.display_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Prints the given trigger into a human-readable string.
    /// 
    /// This is a small wrapper around [method`Gtk.ShortcutTrigger.print`]
    /// to help when debugging.
    @inlinable func toString() -> String! {
        let rv = gtk_shortcut_trigger_to_string(shortcut_trigger_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Checks if the given `event` triggers `self`.
    @inlinable func trigger<EventT: Gdk.EventProtocol>(event: EventT, enableMnemonics: Bool) -> GdkKeyMatch {
        let rv = gtk_shortcut_trigger_trigger(shortcut_trigger_ptr, event.event_ptr, gboolean((enableMnemonics) ? 1 : 0))
        return rv
    }


}



// MARK: - ShortcutsGroup Class

/// The `ShortcutsGroupProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutsGroup` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutsGroup`.
/// Alternatively, use `ShortcutsGroupRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkShortcutsGroup` represents a group of related keyboard shortcuts
/// or gestures.
/// 
/// The group has a title. It may optionally be associated with a view
/// of the application, which can be used to show only relevant shortcuts
/// depending on the application context.
/// 
/// This widget is only meant to be used with [class`Gtk.ShortcutsWindow`].
public protocol ShortcutsGroupProtocol: BoxProtocol {
        /// Untyped pointer to the underlying `GtkShortcutsGroup` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutsGroup` instance.
    var shortcuts_group_ptr: UnsafeMutablePointer<GtkShortcutsGroup>! { get }

    /// Required Initialiser for types conforming to `ShortcutsGroupProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `ShortcutsGroupRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutsGroup` instance.
/// It exposes methods that can operate on this data type through `ShortcutsGroupProtocol` conformance.
/// Use `ShortcutsGroupRef` only as an `unowned` reference to an existing `GtkShortcutsGroup` instance.
///
/// A `GtkShortcutsGroup` represents a group of related keyboard shortcuts
/// or gestures.
/// 
/// The group has a title. It may optionally be associated with a view
/// of the application, which can be used to show only relevant shortcuts
/// depending on the application context.
/// 
/// This widget is only meant to be used with [class`Gtk.ShortcutsWindow`].
public struct ShortcutsGroupRef: ShortcutsGroupProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutsGroup` instance.
    /// For type-safe access, use the generated, typed pointer `shortcuts_group_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutsGroupRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutsGroup>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutsGroup>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutsGroup>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutsGroup>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutsGroupProtocol`
    @inlinable init<T: ShortcutsGroupProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutsGroupProtocol>(_ other: T) -> ShortcutsGroupRef { ShortcutsGroupRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ShortcutsGroup` type acts as a reference-counted owner of an underlying `GtkShortcutsGroup` instance.
/// It provides the methods that can operate on this data type through `ShortcutsGroupProtocol` conformance.
/// Use `ShortcutsGroup` as a strong reference or owner of a `GtkShortcutsGroup` instance.
///
/// A `GtkShortcutsGroup` represents a group of related keyboard shortcuts
/// or gestures.
/// 
/// The group has a title. It may optionally be associated with a view
/// of the application, which can be used to show only relevant shortcuts
/// depending on the application context.
/// 
/// This widget is only meant to be used with [class`Gtk.ShortcutsWindow`].
open class ShortcutsGroup: Box, ShortcutsGroupProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutsGroup>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutsGroup>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutsGroup>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutsGroup>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutsGroup`.
    /// i.e., ownership is transferred to the `ShortcutsGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutsGroup>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutsGroupProtocol`
    /// Will retain `GtkShortcutsGroup`.
    /// - Parameter other: an instance of a related type that implements `ShortcutsGroupProtocol`
    @inlinable public init<T: ShortcutsGroupProtocol>(shortcutsGroup other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsGroupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ShortcutsGroupPropertyName: String, PropertyNameProtocol {
    /// The size group for the accelerator portion of shortcuts in this group.
    /// 
    /// This is used internally by GTK, and must not be modified by applications.
    case accelSizeGroup = "accel-size-group"
    /// The position of the baseline aligned widgets if extra space is available.
    case baselinePosition = "baseline-position"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// A rough measure for the number of lines in this group.
    /// 
    /// This is used internally by GTK, and is not useful for applications.
    case height = "height"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// Whether the children should all be the same size.
    case homogeneous = "homogeneous"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// The amount of space between children.
    case spacing = "spacing"
    /// The title for this group of shortcuts.
    case title = "title"
    /// The size group for the textual portion of shortcuts in this group.
    /// 
    /// This is used internally by GTK, and must not be modified by applications.
    case titleSizeGroup = "title-size-group"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// An optional view that the shortcuts in this group are relevant for.
    /// 
    /// The group will be hidden if the [property`Gtk.ShortcutsWindow:view-name`]
    /// property does not match the view of this group.
    /// 
    /// Set this to `nil` to make the group always visible.
    case view = "view"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ShortcutsGroupProtocol {
    /// Bind a `ShortcutsGroupPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutsGroupPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ShortcutsGroup property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutsGroupPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ShortcutsGroup property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutsGroupPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ShortcutsGroupSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The size group for the accelerator portion of shortcuts in this group.
    /// 
    /// This is used internally by GTK, and must not be modified by applications.
    case notifyAccelSizeGroup = "notify::accel-size-group"
    /// The position of the baseline aligned widgets if extra space is available.
    case notifyBaselinePosition = "notify::baseline-position"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// A rough measure for the number of lines in this group.
    /// 
    /// This is used internally by GTK, and is not useful for applications.
    case notifyHeight = "notify::height"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Whether the children should all be the same size.
    case notifyHomogeneous = "notify::homogeneous"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// The amount of space between children.
    case notifySpacing = "notify::spacing"
    /// The title for this group of shortcuts.
    case notifyTitle = "notify::title"
    /// The size group for the textual portion of shortcuts in this group.
    /// 
    /// This is used internally by GTK, and must not be modified by applications.
    case notifyTitleSizeGroup = "notify::title-size-group"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// An optional view that the shortcuts in this group are relevant for.
    /// 
    /// The group will be hidden if the [property`Gtk.ShortcutsWindow:view-name`]
    /// property does not match the view of this group.
    /// 
    /// Set this to `nil` to make the group always visible.
    case notifyView = "notify::view"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ShortcutsGroup has no signals
// MARK: ShortcutsGroup Class: ShortcutsGroupProtocol extension (methods and fields)
public extension ShortcutsGroupProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutsGroup` instance.
    @inlinable var shortcuts_group_ptr: UnsafeMutablePointer<GtkShortcutsGroup>! { return ptr?.assumingMemoryBound(to: GtkShortcutsGroup.self) }



}



// MARK: - ShortcutsSection Class

/// The `ShortcutsSectionProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutsSection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutsSection`.
/// Alternatively, use `ShortcutsSectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkShortcutsSection` collects all the keyboard shortcuts and gestures
/// for a major application mode.
/// 
/// If your application needs multiple sections, you should give each
/// section a unique [property`Gtk.ShortcutsSection:section-name`] and
/// a [property`Gtk.ShortcutsSection:title`] that can be shown in the
/// section selector of the [class`Gtk.ShortcutsWindow`].
/// 
/// The [property`Gtk.ShortcutsSection:max-height`] property can be used
/// to influence how the groups in the section are distributed over pages
/// and columns.
/// 
/// This widget is only meant to be used with [class`Gtk.ShortcutsWindow`].
public protocol ShortcutsSectionProtocol: BoxProtocol {
        /// Untyped pointer to the underlying `GtkShortcutsSection` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutsSection` instance.
    var shortcuts_section_ptr: UnsafeMutablePointer<GtkShortcutsSection>! { get }

    /// Required Initialiser for types conforming to `ShortcutsSectionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `ShortcutsSectionRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutsSection` instance.
/// It exposes methods that can operate on this data type through `ShortcutsSectionProtocol` conformance.
/// Use `ShortcutsSectionRef` only as an `unowned` reference to an existing `GtkShortcutsSection` instance.
///
/// A `GtkShortcutsSection` collects all the keyboard shortcuts and gestures
/// for a major application mode.
/// 
/// If your application needs multiple sections, you should give each
/// section a unique [property`Gtk.ShortcutsSection:section-name`] and
/// a [property`Gtk.ShortcutsSection:title`] that can be shown in the
/// section selector of the [class`Gtk.ShortcutsWindow`].
/// 
/// The [property`Gtk.ShortcutsSection:max-height`] property can be used
/// to influence how the groups in the section are distributed over pages
/// and columns.
/// 
/// This widget is only meant to be used with [class`Gtk.ShortcutsWindow`].
public struct ShortcutsSectionRef: ShortcutsSectionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutsSection` instance.
    /// For type-safe access, use the generated, typed pointer `shortcuts_section_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutsSectionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutsSection>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutsSection>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutsSection>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutsSection>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutsSectionProtocol`
    @inlinable init<T: ShortcutsSectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutsSectionProtocol>(_ other: T) -> ShortcutsSectionRef { ShortcutsSectionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ShortcutsSection` type acts as a reference-counted owner of an underlying `GtkShortcutsSection` instance.
/// It provides the methods that can operate on this data type through `ShortcutsSectionProtocol` conformance.
/// Use `ShortcutsSection` as a strong reference or owner of a `GtkShortcutsSection` instance.
///
/// A `GtkShortcutsSection` collects all the keyboard shortcuts and gestures
/// for a major application mode.
/// 
/// If your application needs multiple sections, you should give each
/// section a unique [property`Gtk.ShortcutsSection:section-name`] and
/// a [property`Gtk.ShortcutsSection:title`] that can be shown in the
/// section selector of the [class`Gtk.ShortcutsWindow`].
/// 
/// The [property`Gtk.ShortcutsSection:max-height`] property can be used
/// to influence how the groups in the section are distributed over pages
/// and columns.
/// 
/// This widget is only meant to be used with [class`Gtk.ShortcutsWindow`].
open class ShortcutsSection: Box, ShortcutsSectionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutsSection>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutsSection>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutsSection>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutsSection>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutsSection`.
    /// i.e., ownership is transferred to the `ShortcutsSection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutsSection>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutsSectionProtocol`
    /// Will retain `GtkShortcutsSection`.
    /// - Parameter other: an instance of a related type that implements `ShortcutsSectionProtocol`
    @inlinable public init<T: ShortcutsSectionProtocol>(shortcutsSection other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsSectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ShortcutsSectionPropertyName: String, PropertyNameProtocol {
    /// The position of the baseline aligned widgets if extra space is available.
    case baselinePosition = "baseline-position"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// Whether the children should all be the same size.
    case homogeneous = "homogeneous"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The maximum number of lines to allow per column.
    /// 
    /// This property can be used to influence how the groups in this
    /// section are distributed across pages and columns. The default
    /// value of 15 should work in most cases.
    case maxHeight = "max-height"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// A unique name to identify this section among the sections
    /// added to the `GtkShortcutsWindow`.
    /// 
    /// Setting the [property`Gtk.ShortcutsWindow:section-name`] property
    /// to this string will make this section shown in the `GtkShortcutsWindow`.
    case sectionName = "section-name"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// The amount of space between children.
    case spacing = "spacing"
    /// The string to show in the section selector of the `GtkShortcutsWindow`
    /// for this section.
    /// 
    /// If there is only one section, you don't need to set a title,
    /// since the section selector will not be shown in this case.
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// A view name to filter the groups in this section by.
    /// 
    /// See [property`Gtk.ShortcutsGroup:view`].
    /// 
    /// Applications are expected to use the
    /// [property`Gtk.ShortcutsWindow:view-name`] property
    /// for this purpose.
    case viewName = "view-name"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ShortcutsSectionProtocol {
    /// Bind a `ShortcutsSectionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutsSectionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ShortcutsSection property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutsSectionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ShortcutsSection property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutsSectionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ShortcutsSectionSignalName: String, SignalNameProtocol {
    case changeCurrentPage = "change-current-page"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The position of the baseline aligned widgets if extra space is available.
    case notifyBaselinePosition = "notify::baseline-position"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Whether the children should all be the same size.
    case notifyHomogeneous = "notify::homogeneous"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The maximum number of lines to allow per column.
    /// 
    /// This property can be used to influence how the groups in this
    /// section are distributed across pages and columns. The default
    /// value of 15 should work in most cases.
    case notifyMaxHeight = "notify::max-height"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// A unique name to identify this section among the sections
    /// added to the `GtkShortcutsWindow`.
    /// 
    /// Setting the [property`Gtk.ShortcutsWindow:section-name`] property
    /// to this string will make this section shown in the `GtkShortcutsWindow`.
    case notifySectionName = "notify::section-name"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// The amount of space between children.
    case notifySpacing = "notify::spacing"
    /// The string to show in the section selector of the `GtkShortcutsWindow`
    /// for this section.
    /// 
    /// If there is only one section, you don't need to set a title,
    /// since the section selector will not be shown in this case.
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// A view name to filter the groups in this section by.
    /// 
    /// See [property`Gtk.ShortcutsGroup:view`].
    /// 
    /// Applications are expected to use the
    /// [property`Gtk.ShortcutsWindow:view-name`] property
    /// for this purpose.
    case notifyViewName = "notify::view-name"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ShortcutsSection signals
public extension ShortcutsSectionProtocol {
    /// Connect a Swift signal handler to the given, typed `ShortcutsSectionSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ShortcutsSectionSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ShortcutsSectionSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ShortcutsSectionSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// - Note: This represents the underlying `change-current-page` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter object: none
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `changeCurrentPage` signal is emitted
    @discardableResult @inlinable func onChangeCurrentPage(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsSectionRef, _ object: Int) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsSectionRef, Int, Bool>
        let cCallback: @convention(c) (gpointer, gint, gpointer) -> gboolean = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(ShortcutsSectionRef(raw: unownedSelf), Int(arg1))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .changeCurrentPage,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `change-current-page` signal for using the `connect(signal:)` methods
    static var changeCurrentPageSignal: ShortcutsSectionSignalName { .changeCurrentPage }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::max-height` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMaxHeight` signal is emitted
    @discardableResult @inlinable func onNotifyMaxHeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsSectionRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsSectionRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsSectionRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMaxHeight,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::max-height` signal for using the `connect(signal:)` methods
    static var notifyMaxHeightSignal: ShortcutsSectionSignalName { .notifyMaxHeight }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::section-name` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySectionName` signal is emitted
    @discardableResult @inlinable func onNotifySectionName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsSectionRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsSectionRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsSectionRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySectionName,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::section-name` signal for using the `connect(signal:)` methods
    static var notifySectionNameSignal: ShortcutsSectionSignalName { .notifySectionName }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::title` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTitle` signal is emitted
    @discardableResult @inlinable func onNotifyTitle(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsSectionRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsSectionRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsSectionRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyTitle,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::title` signal for using the `connect(signal:)` methods
    static var notifyTitleSignal: ShortcutsSectionSignalName { .notifyTitle }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::view-name` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyViewName` signal is emitted
    @discardableResult @inlinable func onNotifyViewName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsSectionRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsSectionRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsSectionRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyViewName,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::view-name` signal for using the `connect(signal:)` methods
    static var notifyViewNameSignal: ShortcutsSectionSignalName { .notifyViewName }
    
}

// MARK: ShortcutsSection Class: ShortcutsSectionProtocol extension (methods and fields)
public extension ShortcutsSectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutsSection` instance.
    @inlinable var shortcuts_section_ptr: UnsafeMutablePointer<GtkShortcutsSection>! { return ptr?.assumingMemoryBound(to: GtkShortcutsSection.self) }



}



// MARK: - ShortcutsShortcut Class

/// The `ShortcutsShortcutProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutsShortcut` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutsShortcut`.
/// Alternatively, use `ShortcutsShortcutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkShortcutsShortcut` represents a single keyboard shortcut or gesture
/// with a short text.
/// 
/// This widget is only meant to be used with `GtkShortcutsWindow`.
public protocol ShortcutsShortcutProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkShortcutsShortcut` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutsShortcut` instance.
    var shortcuts_shortcut_ptr: UnsafeMutablePointer<GtkShortcutsShortcut>! { get }

    /// Required Initialiser for types conforming to `ShortcutsShortcutProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `ShortcutsShortcutRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutsShortcut` instance.
/// It exposes methods that can operate on this data type through `ShortcutsShortcutProtocol` conformance.
/// Use `ShortcutsShortcutRef` only as an `unowned` reference to an existing `GtkShortcutsShortcut` instance.
///
/// A `GtkShortcutsShortcut` represents a single keyboard shortcut or gesture
/// with a short text.
/// 
/// This widget is only meant to be used with `GtkShortcutsWindow`.
public struct ShortcutsShortcutRef: ShortcutsShortcutProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutsShortcut` instance.
    /// For type-safe access, use the generated, typed pointer `shortcuts_shortcut_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutsShortcutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutsShortcut>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutsShortcut>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutsShortcut>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutsShortcut>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutsShortcutProtocol`
    @inlinable init<T: ShortcutsShortcutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutsShortcutProtocol>(_ other: T) -> ShortcutsShortcutRef { ShortcutsShortcutRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ShortcutsShortcut` type acts as a reference-counted owner of an underlying `GtkShortcutsShortcut` instance.
/// It provides the methods that can operate on this data type through `ShortcutsShortcutProtocol` conformance.
/// Use `ShortcutsShortcut` as a strong reference or owner of a `GtkShortcutsShortcut` instance.
///
/// A `GtkShortcutsShortcut` represents a single keyboard shortcut or gesture
/// with a short text.
/// 
/// This widget is only meant to be used with `GtkShortcutsWindow`.
open class ShortcutsShortcut: Widget, ShortcutsShortcutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutsShortcut>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutsShortcut>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutsShortcut>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutsShortcut>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutsShortcut`.
    /// i.e., ownership is transferred to the `ShortcutsShortcut` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutsShortcut>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutsShortcutProtocol`
    /// Will retain `GtkShortcutsShortcut`.
    /// - Parameter other: an instance of a related type that implements `ShortcutsShortcutProtocol`
    @inlinable public init<T: ShortcutsShortcutProtocol>(shortcutsShortcut other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsShortcutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ShortcutsShortcutPropertyName: String, PropertyNameProtocol {
    /// The size group for the accelerator portion of this shortcut.
    /// 
    /// This is used internally by GTK, and must not be modified by applications.
    case accelSizeGroup = "accel-size-group"
    /// The `accelerator(s)` represented by this object.
    /// 
    /// This property is used if [property`Gtk.ShortcutsShortcut:shortcut-type`]
    /// is set to `GTK_SHORTCUT_ACCELERATOR`.
    /// 
    /// The syntax of this property is (an extension of) the syntax understood
    /// by [func`Gtk.accelerator_parse`]. Multiple accelerators can be specified
    /// by separating them with a space, but keep in mind that the available width
    /// is limited.
    /// 
    /// It is also possible to specify ranges of shortcuts, using "..." between
    /// the keys. Sequences of keys can be specified using a "+" or "&" between
    /// the keys.
    /// 
    /// Examples:
    /// 
    /// - A single shortcut: &lt;ctl&gt;&lt;alt&gt;delete
    /// - Two alternative shortcuts: &lt;shift&gt;a Home
    /// - A range of shortcuts: &lt;alt&gt;1...&lt;alt&gt;9
    /// - Several keys pressed together: Control_L&Control_R
    /// - A sequence of shortcuts or keys: &lt;ctl&gt;c+&lt;ctl&gt;x
    /// 
    /// Use "+" instead of "&" when the keys may (or have to be) pressed
    /// sequentially (e.g use "t+t" for 'press the t key twice').
    /// 
    /// Note that &lt;, &gt; and & need to be escaped as &lt;, &gt; and &amp; when used
    /// in .ui files.
    case accelerator = "accelerator"
    /// A detailed action name.
    /// 
    /// If this is set for a shortcut of type `GTK_SHORTCUT_ACCELERATOR`,
    /// then GTK will use the accelerators that are associated with the
    /// action via [method`Gtk.Application.set_accels_for_action`], and
    /// setting [property`Gtk.ShortcutsShortcut:accelerator`] is not necessary.
    case actionName = "action-name"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// The text direction for which this shortcut is active.
    /// 
    /// If the shortcut is used regardless of the text direction,
    /// set this property to `GTK_TEXT_DIR_NONE`.
    case direction = "direction"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// An icon to represent the shortcut or gesture.
    /// 
    /// This property is used if [property`Gtk.ShortcutsShortcut:shortcut-type`]
    /// is set to `GTK_SHORTCUT_GESTURE`.
    /// 
    /// For the other predefined gesture types, GTK provides an icon on its own.
    case icon = "icon"
    /// `true` if an icon has been set.
    case iconSet = "icon-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// The type of shortcut that is represented.
    case shortcutType = "shortcut-type"
    /// The subtitle for the shortcut or gesture.
    /// 
    /// This is typically used for gestures and should be a short, one-line
    /// text that describes the gesture itself. For the predefined gesture
    /// types, GTK provides a subtitle on its own.
    case subtitle = "subtitle"
    /// `true` if a subtitle has been set.
    case subtitleSet = "subtitle-set"
    /// The textual description for the shortcut or gesture represented by
    /// this object.
    /// 
    /// This should be a short string that can fit in a single line.
    case title = "title"
    /// The size group for the textual portion of this shortcut.
    /// 
    /// This is used internally by GTK, and must not be modified by applications.
    case titleSizeGroup = "title-size-group"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ShortcutsShortcutProtocol {
    /// Bind a `ShortcutsShortcutPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutsShortcutPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ShortcutsShortcut property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutsShortcutPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ShortcutsShortcut property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutsShortcutPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ShortcutsShortcutSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The size group for the accelerator portion of this shortcut.
    /// 
    /// This is used internally by GTK, and must not be modified by applications.
    case notifyAccelSizeGroup = "notify::accel-size-group"
    /// The `accelerator(s)` represented by this object.
    /// 
    /// This property is used if [property`Gtk.ShortcutsShortcut:shortcut-type`]
    /// is set to `GTK_SHORTCUT_ACCELERATOR`.
    /// 
    /// The syntax of this property is (an extension of) the syntax understood
    /// by [func`Gtk.accelerator_parse`]. Multiple accelerators can be specified
    /// by separating them with a space, but keep in mind that the available width
    /// is limited.
    /// 
    /// It is also possible to specify ranges of shortcuts, using "..." between
    /// the keys. Sequences of keys can be specified using a "+" or "&" between
    /// the keys.
    /// 
    /// Examples:
    /// 
    /// - A single shortcut: &lt;ctl&gt;&lt;alt&gt;delete
    /// - Two alternative shortcuts: &lt;shift&gt;a Home
    /// - A range of shortcuts: &lt;alt&gt;1...&lt;alt&gt;9
    /// - Several keys pressed together: Control_L&Control_R
    /// - A sequence of shortcuts or keys: &lt;ctl&gt;c+&lt;ctl&gt;x
    /// 
    /// Use "+" instead of "&" when the keys may (or have to be) pressed
    /// sequentially (e.g use "t+t" for 'press the t key twice').
    /// 
    /// Note that &lt;, &gt; and & need to be escaped as &lt;, &gt; and &amp; when used
    /// in .ui files.
    case notifyAccelerator = "notify::accelerator"
    /// A detailed action name.
    /// 
    /// If this is set for a shortcut of type `GTK_SHORTCUT_ACCELERATOR`,
    /// then GTK will use the accelerators that are associated with the
    /// action via [method`Gtk.Application.set_accels_for_action`], and
    /// setting [property`Gtk.ShortcutsShortcut:accelerator`] is not necessary.
    case notifyActionName = "notify::action-name"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// The text direction for which this shortcut is active.
    /// 
    /// If the shortcut is used regardless of the text direction,
    /// set this property to `GTK_TEXT_DIR_NONE`.
    case notifyDirection = "notify::direction"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// An icon to represent the shortcut or gesture.
    /// 
    /// This property is used if [property`Gtk.ShortcutsShortcut:shortcut-type`]
    /// is set to `GTK_SHORTCUT_GESTURE`.
    /// 
    /// For the other predefined gesture types, GTK provides an icon on its own.
    case notifyIcon = "notify::icon"
    /// `true` if an icon has been set.
    case notifyIconSet = "notify::icon-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// The type of shortcut that is represented.
    case notifyShortcutType = "notify::shortcut-type"
    /// The subtitle for the shortcut or gesture.
    /// 
    /// This is typically used for gestures and should be a short, one-line
    /// text that describes the gesture itself. For the predefined gesture
    /// types, GTK provides a subtitle on its own.
    case notifySubtitle = "notify::subtitle"
    /// `true` if a subtitle has been set.
    case notifySubtitleSet = "notify::subtitle-set"
    /// The textual description for the shortcut or gesture represented by
    /// this object.
    /// 
    /// This should be a short string that can fit in a single line.
    case notifyTitle = "notify::title"
    /// The size group for the textual portion of this shortcut.
    /// 
    /// This is used internally by GTK, and must not be modified by applications.
    case notifyTitleSizeGroup = "notify::title-size-group"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ShortcutsShortcut has no signals
// MARK: ShortcutsShortcut Class: ShortcutsShortcutProtocol extension (methods and fields)
public extension ShortcutsShortcutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutsShortcut` instance.
    @inlinable var shortcuts_shortcut_ptr: UnsafeMutablePointer<GtkShortcutsShortcut>! { return ptr?.assumingMemoryBound(to: GtkShortcutsShortcut.self) }



}



// MARK: - ShortcutsWindow Class

/// The `ShortcutsWindowProtocol` protocol exposes the methods and properties of an underlying `GtkShortcutsWindow` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ShortcutsWindow`.
/// Alternatively, use `ShortcutsWindowRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkShortcutsWindow` shows information about the keyboard shortcuts
/// and gestures of an application.
/// 
/// The shortcuts can be grouped, and you can have multiple sections in this
/// window, corresponding to the major modes of your application.
/// 
/// Additionally, the shortcuts can be filtered by the current view, to avoid
/// showing information that is not relevant in the current application context.
/// 
/// The recommended way to construct a `GtkShortcutsWindow` is with
/// [class`Gtk.Builder`], by populating a `GtkShortcutsWindow` with one or
/// more `GtkShortcutsSection` objects, which contain `GtkShortcutsGroups`
/// that in turn contain objects of class `GtkShortcutsShortcut`.
/// 
/// # A simple example:
/// 
/// ![](gedit-shortcuts.png)
/// 
/// This example has as single section. As you can see, the shortcut groups
/// are arranged in columns, and spread across several pages if there are too
/// many to find on a single page.
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
/// 
/// # An example with multiple views:
/// 
/// ![](clocks-shortcuts.png)
/// 
/// This example shows a `GtkShortcutsWindow` that has been configured to show only
/// the shortcuts relevant to the "stopwatch" view.
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
/// 
/// # An example with multiple sections:
/// 
/// ![](builder-shortcuts.png)
/// 
/// This example shows a `GtkShortcutsWindow` with two sections, "Editor Shortcuts"
/// and "Terminal Shortcuts".
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
public protocol ShortcutsWindowProtocol: WindowProtocol {
        /// Untyped pointer to the underlying `GtkShortcutsWindow` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkShortcutsWindow` instance.
    var shortcuts_window_ptr: UnsafeMutablePointer<GtkShortcutsWindow>! { get }

    /// Required Initialiser for types conforming to `ShortcutsWindowProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `ShortcutsWindowRef` type acts as a lightweight Swift reference to an underlying `GtkShortcutsWindow` instance.
/// It exposes methods that can operate on this data type through `ShortcutsWindowProtocol` conformance.
/// Use `ShortcutsWindowRef` only as an `unowned` reference to an existing `GtkShortcutsWindow` instance.
///
/// A `GtkShortcutsWindow` shows information about the keyboard shortcuts
/// and gestures of an application.
/// 
/// The shortcuts can be grouped, and you can have multiple sections in this
/// window, corresponding to the major modes of your application.
/// 
/// Additionally, the shortcuts can be filtered by the current view, to avoid
/// showing information that is not relevant in the current application context.
/// 
/// The recommended way to construct a `GtkShortcutsWindow` is with
/// [class`Gtk.Builder`], by populating a `GtkShortcutsWindow` with one or
/// more `GtkShortcutsSection` objects, which contain `GtkShortcutsGroups`
/// that in turn contain objects of class `GtkShortcutsShortcut`.
/// 
/// # A simple example:
/// 
/// ![](gedit-shortcuts.png)
/// 
/// This example has as single section. As you can see, the shortcut groups
/// are arranged in columns, and spread across several pages if there are too
/// many to find on a single page.
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
/// 
/// # An example with multiple views:
/// 
/// ![](clocks-shortcuts.png)
/// 
/// This example shows a `GtkShortcutsWindow` that has been configured to show only
/// the shortcuts relevant to the "stopwatch" view.
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
/// 
/// # An example with multiple sections:
/// 
/// ![](builder-shortcuts.png)
/// 
/// This example shows a `GtkShortcutsWindow` with two sections, "Editor Shortcuts"
/// and "Terminal Shortcuts".
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
public struct ShortcutsWindowRef: ShortcutsWindowProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkShortcutsWindow` instance.
    /// For type-safe access, use the generated, typed pointer `shortcuts_window_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ShortcutsWindowRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkShortcutsWindow>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkShortcutsWindow>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkShortcutsWindow>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkShortcutsWindow>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ShortcutsWindowProtocol`
    @inlinable init<T: ShortcutsWindowProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ShortcutsWindowProtocol>(_ other: T) -> ShortcutsWindowRef { ShortcutsWindowRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `ShortcutsWindow` type acts as a reference-counted owner of an underlying `GtkShortcutsWindow` instance.
/// It provides the methods that can operate on this data type through `ShortcutsWindowProtocol` conformance.
/// Use `ShortcutsWindow` as a strong reference or owner of a `GtkShortcutsWindow` instance.
///
/// A `GtkShortcutsWindow` shows information about the keyboard shortcuts
/// and gestures of an application.
/// 
/// The shortcuts can be grouped, and you can have multiple sections in this
/// window, corresponding to the major modes of your application.
/// 
/// Additionally, the shortcuts can be filtered by the current view, to avoid
/// showing information that is not relevant in the current application context.
/// 
/// The recommended way to construct a `GtkShortcutsWindow` is with
/// [class`Gtk.Builder`], by populating a `GtkShortcutsWindow` with one or
/// more `GtkShortcutsSection` objects, which contain `GtkShortcutsGroups`
/// that in turn contain objects of class `GtkShortcutsShortcut`.
/// 
/// # A simple example:
/// 
/// ![](gedit-shortcuts.png)
/// 
/// This example has as single section. As you can see, the shortcut groups
/// are arranged in columns, and spread across several pages if there are too
/// many to find on a single page.
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
/// 
/// # An example with multiple views:
/// 
/// ![](clocks-shortcuts.png)
/// 
/// This example shows a `GtkShortcutsWindow` that has been configured to show only
/// the shortcuts relevant to the "stopwatch" view.
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
/// 
/// # An example with multiple sections:
/// 
/// ![](builder-shortcuts.png)
/// 
/// This example shows a `GtkShortcutsWindow` with two sections, "Editor Shortcuts"
/// and "Terminal Shortcuts".
/// 
/// The .ui file for this example can be found [here](https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
open class ShortcutsWindow: Window, ShortcutsWindowProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkShortcutsWindow>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkShortcutsWindow>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkShortcutsWindow>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkShortcutsWindow>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkShortcutsWindow`.
    /// i.e., ownership is transferred to the `ShortcutsWindow` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkShortcutsWindow>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ShortcutsWindowProtocol`
    /// Will retain `GtkShortcutsWindow`.
    /// - Parameter other: an instance of a related type that implements `ShortcutsWindowProtocol`
    @inlinable public init<T: ShortcutsWindowProtocol>(shortcutsWindow other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ShortcutsWindowProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ShortcutsWindowPropertyName: String, PropertyNameProtocol {
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case application = "application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the window should have a frame (also known as *decorations*).
    case decorated = "decorated"
    /// The default height of the window.
    case defaultHeight = "default-height"
    /// The default widget.
    case defaultWidget = "default-widget"
    /// The default width of the window.
    case defaultWidth = "default-width"
    /// Whether the window frame should have a close button.
    case deletable = "deletable"
    /// If this window should be destroyed when the parent is destroyed.
    case destroyWithParent = "destroy-with-parent"
    /// The display that will display this window.
    case display = "display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case focusVisible = "focus-visible"
    /// The focus widget.
    case focusWidget = "focus-widget"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.fullscreen`] or [method`Gtk.Window.unfullscreen`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case fullscreened = "fullscreened"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the window frame should handle F10 for activating
    /// menubars.
    case handleMenubarAccel = "handle-menubar-accel"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// If this window should be hidden when the users clicks the close button.
    case hideOnClose = "hide-on-close"
    /// Specifies the name of the themed icon to use as the window icon.
    /// 
    /// See [class`Gtk.IconTheme`] for more details.
    case iconName = "icon-name"
    /// Whether the toplevel is the currently active window.
    case isActive = "is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.maximize`] or [method`Gtk.Window.unmaximize`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case maximized = "maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case mnemonicsVisible = "mnemonics-visible"
    /// If `true`, the window is modal.
    case modal = "modal"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// If `true`, users can resize the window.
    case resizable = "resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// The name of the section to show.
    /// 
    /// This should be the section-name of one of the `GtkShortcutsSection`
    /// objects that are in this shortcuts window.
    case sectionName = "section-name"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// A write-only property for setting window's startup notification identifier.
    case startupId = "startup-id"
    /// The title of the window.
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The transient parent of the window.
    case transientFor = "transient-for"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// The view name by which to filter the contents.
    /// 
    /// This should correspond to the [property`Gtk.ShortcutsGroup:view`]
    /// property of some of the [class`Gtk.ShortcutsGroup`] objects that
    /// are inside this shortcuts window.
    /// 
    /// Set this to `nil` to show all groups.
    case viewName = "view-name"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ShortcutsWindowProtocol {
    /// Bind a `ShortcutsWindowPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ShortcutsWindowPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ShortcutsWindow property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ShortcutsWindowPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ShortcutsWindow property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ShortcutsWindowPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ShortcutsWindowSignalName: String, SignalNameProtocol {
    /// Emitted when the user activates the default widget
    /// of `window`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    case activateDefault = "activate-default"
    /// Emitted when the user activates the currently focused
    /// widget of `window`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    case activateFocus = "activate-focus"
    /// Emitted when the user uses a keybinding to close the window.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is the Escape key.
    case close = "close"
    /// Emitted when the user clicks on the close button of the window.
    case closeRequest = "close-request"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when the user enables or disables interactive debugging.
    /// 
    /// When `toggle` is `true`, interactive debugging is toggled on or off,
    /// when it is `false`, the debugger will be pointed at the widget
    /// under the pointer.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are Ctrl-Shift-I
    /// and Ctrl-Shift-D.
    case enableDebugging = "enable-debugging"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// emitted when the set of accelerators or mnemonics that
    /// are associated with `window` changes.
    case keysChanged = "keys-changed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when the user uses a keybinding to start a search.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is Control-F.
    case search = "search"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case notifyApplication = "notify::application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the window should have a frame (also known as *decorations*).
    case notifyDecorated = "notify::decorated"
    /// The default height of the window.
    case notifyDefaultHeight = "notify::default-height"
    /// The default widget.
    case notifyDefaultWidget = "notify::default-widget"
    /// The default width of the window.
    case notifyDefaultWidth = "notify::default-width"
    /// Whether the window frame should have a close button.
    case notifyDeletable = "notify::deletable"
    /// If this window should be destroyed when the parent is destroyed.
    case notifyDestroyWithParent = "notify::destroy-with-parent"
    /// The display that will display this window.
    case notifyDisplay = "notify::display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case notifyFocusVisible = "notify::focus-visible"
    /// The focus widget.
    case notifyFocusWidget = "notify::focus-widget"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.fullscreen`] or [method`Gtk.Window.unfullscreen`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case notifyFullscreened = "notify::fullscreened"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the window frame should handle F10 for activating
    /// menubars.
    case notifyHandleMenubarAccel = "notify::handle-menubar-accel"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// If this window should be hidden when the users clicks the close button.
    case notifyHideOnClose = "notify::hide-on-close"
    /// Specifies the name of the themed icon to use as the window icon.
    /// 
    /// See [class`Gtk.IconTheme`] for more details.
    case notifyIconName = "notify::icon-name"
    /// Whether the toplevel is the currently active window.
    case notifyIsActive = "notify::is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.maximize`] or [method`Gtk.Window.unmaximize`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case notifyMaximized = "notify::maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case notifyMnemonicsVisible = "notify::mnemonics-visible"
    /// If `true`, the window is modal.
    case notifyModal = "notify::modal"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// If `true`, users can resize the window.
    case notifyResizable = "notify::resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// The name of the section to show.
    /// 
    /// This should be the section-name of one of the `GtkShortcutsSection`
    /// objects that are in this shortcuts window.
    case notifySectionName = "notify::section-name"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// A write-only property for setting window's startup notification identifier.
    case notifyStartupId = "notify::startup-id"
    /// The title of the window.
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The transient parent of the window.
    case notifyTransientFor = "notify::transient-for"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// The view name by which to filter the contents.
    /// 
    /// This should correspond to the [property`Gtk.ShortcutsGroup:view`]
    /// property of some of the [class`Gtk.ShortcutsGroup`] objects that
    /// are inside this shortcuts window.
    /// 
    /// Set this to `nil` to show all groups.
    case notifyViewName = "notify::view-name"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ShortcutsWindow signals
public extension ShortcutsWindowProtocol {
    /// Connect a Swift signal handler to the given, typed `ShortcutsWindowSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ShortcutsWindowSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ShortcutsWindowSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ShortcutsWindowSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when the user uses a keybinding to close the window.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is the Escape key.
    /// - Note: This represents the underlying `close` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `close` signal is emitted
    @discardableResult @inlinable func onClose(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsWindowRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ShortcutsWindowRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsWindowRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .close,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `close` signal for using the `connect(signal:)` methods
    static var closeSignal: ShortcutsWindowSignalName { .close }
    
    /// Emitted when the user uses a keybinding to start a search.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is Control-F.
    /// - Note: This represents the underlying `search` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `search` signal is emitted
    @discardableResult @inlinable func onSearch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsWindowRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ShortcutsWindowRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsWindowRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .search,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `search` signal for using the `connect(signal:)` methods
    static var searchSignal: ShortcutsWindowSignalName { .search }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::section-name` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySectionName` signal is emitted
    @discardableResult @inlinable func onNotifySectionName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySectionName,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::section-name` signal for using the `connect(signal:)` methods
    static var notifySectionNameSignal: ShortcutsWindowSignalName { .notifySectionName }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::view-name` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyViewName` signal is emitted
    @discardableResult @inlinable func onNotifyViewName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ShortcutsWindowRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ShortcutsWindowRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ShortcutsWindowRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyViewName,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::view-name` signal for using the `connect(signal:)` methods
    static var notifyViewNameSignal: ShortcutsWindowSignalName { .notifyViewName }
    
}

// MARK: ShortcutsWindow Class: ShortcutsWindowProtocol extension (methods and fields)
public extension ShortcutsWindowProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkShortcutsWindow` instance.
    @inlinable var shortcuts_window_ptr: UnsafeMutablePointer<GtkShortcutsWindow>! { return ptr?.assumingMemoryBound(to: GtkShortcutsWindow.self) }



}



// MARK: - SignalAction Class

/// The `SignalActionProtocol` protocol exposes the methods and properties of an underlying `GtkSignalAction` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SignalAction`.
/// Alternatively, use `SignalActionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkShortcut`Action that emits a signal.
/// 
/// Signals that are used in this way are referred to as keybinding signals,
/// and they are expected to be defined with the `G_SIGNAL_ACTION` flag.
public protocol SignalActionProtocol: ShortcutActionProtocol {
        /// Untyped pointer to the underlying `GtkSignalAction` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSignalAction` instance.
    var signal_action_ptr: UnsafeMutablePointer<GtkSignalAction>! { get }

    /// Required Initialiser for types conforming to `SignalActionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SignalActionRef` type acts as a lightweight Swift reference to an underlying `GtkSignalAction` instance.
/// It exposes methods that can operate on this data type through `SignalActionProtocol` conformance.
/// Use `SignalActionRef` only as an `unowned` reference to an existing `GtkSignalAction` instance.
///
/// A `GtkShortcut`Action that emits a signal.
/// 
/// Signals that are used in this way are referred to as keybinding signals,
/// and they are expected to be defined with the `G_SIGNAL_ACTION` flag.
public struct SignalActionRef: SignalActionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSignalAction` instance.
    /// For type-safe access, use the generated, typed pointer `signal_action_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SignalActionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSignalAction>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSignalAction>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSignalAction>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSignalAction>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SignalActionProtocol`
    @inlinable init<T: SignalActionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SignalActionProtocol>(_ other: T) -> SignalActionRef { SignalActionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `SignalAction` type acts as a reference-counted owner of an underlying `GtkSignalAction` instance.
/// It provides the methods that can operate on this data type through `SignalActionProtocol` conformance.
/// Use `SignalAction` as a strong reference or owner of a `GtkSignalAction` instance.
///
/// A `GtkShortcut`Action that emits a signal.
/// 
/// Signals that are used in this way are referred to as keybinding signals,
/// and they are expected to be defined with the `G_SIGNAL_ACTION` flag.
open class SignalAction: ShortcutAction, SignalActionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSignalAction>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSignalAction>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSignalAction>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSignalAction>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSignalAction`.
    /// i.e., ownership is transferred to the `SignalAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSignalAction>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SignalActionProtocol`
    /// Will retain `GtkSignalAction`.
    /// - Parameter other: an instance of a related type that implements `SignalActionProtocol`
    @inlinable public init<T: SignalActionProtocol>(signalAction other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum SignalActionPropertyName: String, PropertyNameProtocol {
    /// The name of the signal to emit.
    case signalName = "signal-name"
}

public extension SignalActionProtocol {
    /// Bind a `SignalActionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SignalActionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SignalAction property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SignalActionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SignalAction property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SignalActionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SignalActionSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The name of the signal to emit.
    case notifySignalName = "notify::signal-name"
}

// MARK: SignalAction has no signals
// MARK: SignalAction Class: SignalActionProtocol extension (methods and fields)
public extension SignalActionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSignalAction` instance.
    @inlinable var signal_action_ptr: UnsafeMutablePointer<GtkSignalAction>! { return ptr?.assumingMemoryBound(to: GtkSignalAction.self) }

    /// Returns the name of the signal that will be emitted.
    @inlinable func getSignalName() -> String! {
        let rv = gtk_signal_action_get_signal_name(signal_action_ptr).map({ String(cString: $0) })
        return rv
    }
    /// Returns the name of the signal that will be emitted.
    @inlinable var signalName: String! {
        /// Returns the name of the signal that will be emitted.
        get {
            let rv = gtk_signal_action_get_signal_name(signal_action_ptr).map({ String(cString: $0) })
            return rv
        }
    }


}



// MARK: - SignalListItemFactory Class

/// The `SignalListItemFactoryProtocol` protocol exposes the methods and properties of an underlying `GtkSignalListItemFactory` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SignalListItemFactory`.
/// Alternatively, use `SignalListItemFactoryRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSignalListItemFactory` is a `GtkListItemFactory` that emits signals
/// to to manage listitems.
/// 
/// Signals are emitted for every listitem in the same order:
/// 
///  1. [signal`Gtk.SignalListItemFactory::setup`] is emitted to set up permanent
///  things on the listitem. This usually means constructing the widgets used in
///  the row and adding them to the listitem.
/// 
///  2. [signal`Gtk.SignalListItemFactory::bind`] is emitted to bind the item passed
///  via [property`Gtk.ListItem:item`] to the widgets that have been created in
///  step 1 or to add item-specific widgets. Signals are connected to listen to
///  changes - both to changes in the item to update the widgets or to changes
///  in the widgets to update the item. After this signal has been called, the
///  listitem may be shown in a list widget.
/// 
///  3. [signal`Gtk.SignalListItemFactory::unbind`] is emitted to undo everything
///  done in step 2. Usually this means disconnecting signal handlers. Once this
///  signal has been called, the listitem will no longer be used in a list
///  widget.
/// 
///  4. [signal`Gtk.SignalListItemFactory::bind`] and
///  [signal`Gtk.SignalListItemFactory::unbind`] may be emitted multiple times
///  again to bind the listitem for use with new items. By reusing listitems,
///  potentially costly setup can be avoided. However, it means code needs to
///  make sure to properly clean up the listitem in step 3 so that no information
///  from the previous use leaks into the next use.
/// 
/// 5. [signal`Gtk.SignalListItemFactory::teardown`] is emitted to allow undoing
/// the effects of [signal`Gtk.SignalListItemFactory::setup`]. After this signal
/// was emitted on a listitem, the listitem will be destroyed and not be used again.
/// 
/// Note that during the signal emissions, changing properties on the
/// `GtkListItems` passed will not trigger notify signals as the listitem's
/// notifications are frozen. See `g_object_freeze_notify()` for details.
/// 
/// For tracking changes in other properties in the `GtkListItem`, the
/// `notify` signal is recommended. The signal can be connected in the
/// [signal`Gtk.SignalListItemFactory::setup`] signal and removed again during
/// [signal`Gtk.SignalListItemFactory::teardown`].
public protocol SignalListItemFactoryProtocol: ListItemFactoryProtocol {
        /// Untyped pointer to the underlying `GtkSignalListItemFactory` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSignalListItemFactory` instance.
    var signal_list_item_factory_ptr: UnsafeMutablePointer<GtkSignalListItemFactory>! { get }

    /// Required Initialiser for types conforming to `SignalListItemFactoryProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SignalListItemFactoryRef` type acts as a lightweight Swift reference to an underlying `GtkSignalListItemFactory` instance.
/// It exposes methods that can operate on this data type through `SignalListItemFactoryProtocol` conformance.
/// Use `SignalListItemFactoryRef` only as an `unowned` reference to an existing `GtkSignalListItemFactory` instance.
///
/// `GtkSignalListItemFactory` is a `GtkListItemFactory` that emits signals
/// to to manage listitems.
/// 
/// Signals are emitted for every listitem in the same order:
/// 
///  1. [signal`Gtk.SignalListItemFactory::setup`] is emitted to set up permanent
///  things on the listitem. This usually means constructing the widgets used in
///  the row and adding them to the listitem.
/// 
///  2. [signal`Gtk.SignalListItemFactory::bind`] is emitted to bind the item passed
///  via [property`Gtk.ListItem:item`] to the widgets that have been created in
///  step 1 or to add item-specific widgets. Signals are connected to listen to
///  changes - both to changes in the item to update the widgets or to changes
///  in the widgets to update the item. After this signal has been called, the
///  listitem may be shown in a list widget.
/// 
///  3. [signal`Gtk.SignalListItemFactory::unbind`] is emitted to undo everything
///  done in step 2. Usually this means disconnecting signal handlers. Once this
///  signal has been called, the listitem will no longer be used in a list
///  widget.
/// 
///  4. [signal`Gtk.SignalListItemFactory::bind`] and
///  [signal`Gtk.SignalListItemFactory::unbind`] may be emitted multiple times
///  again to bind the listitem for use with new items. By reusing listitems,
///  potentially costly setup can be avoided. However, it means code needs to
///  make sure to properly clean up the listitem in step 3 so that no information
///  from the previous use leaks into the next use.
/// 
/// 5. [signal`Gtk.SignalListItemFactory::teardown`] is emitted to allow undoing
/// the effects of [signal`Gtk.SignalListItemFactory::setup`]. After this signal
/// was emitted on a listitem, the listitem will be destroyed and not be used again.
/// 
/// Note that during the signal emissions, changing properties on the
/// `GtkListItems` passed will not trigger notify signals as the listitem's
/// notifications are frozen. See `g_object_freeze_notify()` for details.
/// 
/// For tracking changes in other properties in the `GtkListItem`, the
/// `notify` signal is recommended. The signal can be connected in the
/// [signal`Gtk.SignalListItemFactory::setup`] signal and removed again during
/// [signal`Gtk.SignalListItemFactory::teardown`].
public struct SignalListItemFactoryRef: SignalListItemFactoryProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSignalListItemFactory` instance.
    /// For type-safe access, use the generated, typed pointer `signal_list_item_factory_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SignalListItemFactoryRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSignalListItemFactory>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSignalListItemFactory>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSignalListItemFactory>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSignalListItemFactory>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SignalListItemFactoryProtocol`
    @inlinable init<T: SignalListItemFactoryProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SignalListItemFactoryProtocol>(_ other: T) -> SignalListItemFactoryRef { SignalListItemFactoryRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSignalListItemFactory`.
    /// 
    /// You need to connect signal handlers before you use it.
    @inlinable init() {
        let rv = gtk_signal_list_item_factory_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SignalListItemFactory` type acts as a reference-counted owner of an underlying `GtkSignalListItemFactory` instance.
/// It provides the methods that can operate on this data type through `SignalListItemFactoryProtocol` conformance.
/// Use `SignalListItemFactory` as a strong reference or owner of a `GtkSignalListItemFactory` instance.
///
/// `GtkSignalListItemFactory` is a `GtkListItemFactory` that emits signals
/// to to manage listitems.
/// 
/// Signals are emitted for every listitem in the same order:
/// 
///  1. [signal`Gtk.SignalListItemFactory::setup`] is emitted to set up permanent
///  things on the listitem. This usually means constructing the widgets used in
///  the row and adding them to the listitem.
/// 
///  2. [signal`Gtk.SignalListItemFactory::bind`] is emitted to bind the item passed
///  via [property`Gtk.ListItem:item`] to the widgets that have been created in
///  step 1 or to add item-specific widgets. Signals are connected to listen to
///  changes - both to changes in the item to update the widgets or to changes
///  in the widgets to update the item. After this signal has been called, the
///  listitem may be shown in a list widget.
/// 
///  3. [signal`Gtk.SignalListItemFactory::unbind`] is emitted to undo everything
///  done in step 2. Usually this means disconnecting signal handlers. Once this
///  signal has been called, the listitem will no longer be used in a list
///  widget.
/// 
///  4. [signal`Gtk.SignalListItemFactory::bind`] and
///  [signal`Gtk.SignalListItemFactory::unbind`] may be emitted multiple times
///  again to bind the listitem for use with new items. By reusing listitems,
///  potentially costly setup can be avoided. However, it means code needs to
///  make sure to properly clean up the listitem in step 3 so that no information
///  from the previous use leaks into the next use.
/// 
/// 5. [signal`Gtk.SignalListItemFactory::teardown`] is emitted to allow undoing
/// the effects of [signal`Gtk.SignalListItemFactory::setup`]. After this signal
/// was emitted on a listitem, the listitem will be destroyed and not be used again.
/// 
/// Note that during the signal emissions, changing properties on the
/// `GtkListItems` passed will not trigger notify signals as the listitem's
/// notifications are frozen. See `g_object_freeze_notify()` for details.
/// 
/// For tracking changes in other properties in the `GtkListItem`, the
/// `notify` signal is recommended. The signal can be connected in the
/// [signal`Gtk.SignalListItemFactory::setup`] signal and removed again during
/// [signal`Gtk.SignalListItemFactory::teardown`].
open class SignalListItemFactory: ListItemFactory, SignalListItemFactoryProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSignalListItemFactory>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSignalListItemFactory>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSignalListItemFactory>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSignalListItemFactory>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSignalListItemFactory`.
    /// i.e., ownership is transferred to the `SignalListItemFactory` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSignalListItemFactory>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SignalListItemFactoryProtocol`
    /// Will retain `GtkSignalListItemFactory`.
    /// - Parameter other: an instance of a related type that implements `SignalListItemFactoryProtocol`
    @inlinable public init<T: SignalListItemFactoryProtocol>(signalListItemFactory other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SignalListItemFactoryProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSignalListItemFactory`.
    /// 
    /// You need to connect signal handlers before you use it.
    @inlinable public init() {
        let rv = gtk_signal_list_item_factory_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no SignalListItemFactory properties

public enum SignalListItemFactorySignalName: String, SignalNameProtocol {
    /// Emitted when a new [property`Gtk.ListItem:item`] has been set
    /// on the `listitem` and should be bound for use.
    /// 
    /// After this signal was emitted, the listitem might be shown in
    /// a [class`Gtk.ListView`] or other list widget.
    /// 
    /// The [signal`Gtk.SignalListItemFactory::unbind`] signal is the
    /// opposite of this signal and can be used to undo everything done
    /// in this signal.
    case bind = "bind"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when a new listitem has been created and needs to be setup for use.
    /// 
    /// It is the first signal emitted for every listitem.
    /// 
    /// The [signal`Gtk.SignalListItemFactory::teardown`] signal is the opposite
    /// of this signal and can be used to undo everything done in this signal.
    case setup = "setup"
    /// Emitted when a listitem is about to be destroyed.
    /// 
    /// It is the last signal ever emitted for this `listitem`.
    /// 
    /// This signal is the opposite of the [signal`Gtk.SignalListItemFactory::setup`]
    /// signal and should be used to undo everything done in that signal.
    case teardown = "teardown"
    /// Emitted when a listitem has been removed from use in a list widget
    /// and its new [property`Gtk.ListItem:item`] is about to be unset.
    /// 
    /// This signal is the opposite of the [signal`Gtk.SignalListItemFactory::bind`]
    /// signal and should be used to undo everything done in that signal.
    case unbind = "unbind"

}

// MARK: SignalListItemFactory signals
public extension SignalListItemFactoryProtocol {
    /// Connect a Swift signal handler to the given, typed `SignalListItemFactorySignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: SignalListItemFactorySignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `SignalListItemFactorySignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: SignalListItemFactorySignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when a new [property`Gtk.ListItem:item`] has been set
    /// on the `listitem` and should be bound for use.
    /// 
    /// After this signal was emitted, the listitem might be shown in
    /// a [class`Gtk.ListView`] or other list widget.
    /// 
    /// The [signal`Gtk.SignalListItemFactory::unbind`] signal is the
    /// opposite of this signal and can be used to undo everything done
    /// in this signal.
    /// - Note: This represents the underlying `bind` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter listitem: The `GtkListItem` to bind
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `bind` signal is emitted
    @discardableResult @inlinable func onBind(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SignalListItemFactoryRef, _ listitem: ListItemRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SignalListItemFactoryRef, ListItemRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SignalListItemFactoryRef(raw: unownedSelf), ListItemRef(raw: arg1))
            return output
        }
        return connect(
            signal: .bind,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `bind` signal for using the `connect(signal:)` methods
    static var bindSignal: SignalListItemFactorySignalName { .bind }
    
    /// Emitted when a new listitem has been created and needs to be setup for use.
    /// 
    /// It is the first signal emitted for every listitem.
    /// 
    /// The [signal`Gtk.SignalListItemFactory::teardown`] signal is the opposite
    /// of this signal and can be used to undo everything done in this signal.
    /// - Note: This represents the underlying `setup` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter listitem: The `GtkListItem` to set up
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `setup` signal is emitted
    @discardableResult @inlinable func onSetup(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SignalListItemFactoryRef, _ listitem: ListItemRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SignalListItemFactoryRef, ListItemRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SignalListItemFactoryRef(raw: unownedSelf), ListItemRef(raw: arg1))
            return output
        }
        return connect(
            signal: .setup,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `setup` signal for using the `connect(signal:)` methods
    static var setupSignal: SignalListItemFactorySignalName { .setup }
    
    /// Emitted when a listitem is about to be destroyed.
    /// 
    /// It is the last signal ever emitted for this `listitem`.
    /// 
    /// This signal is the opposite of the [signal`Gtk.SignalListItemFactory::setup`]
    /// signal and should be used to undo everything done in that signal.
    /// - Note: This represents the underlying `teardown` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter listitem: The `GtkListItem` to teardown
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `teardown` signal is emitted
    @discardableResult @inlinable func onTeardown(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SignalListItemFactoryRef, _ listitem: ListItemRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SignalListItemFactoryRef, ListItemRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SignalListItemFactoryRef(raw: unownedSelf), ListItemRef(raw: arg1))
            return output
        }
        return connect(
            signal: .teardown,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `teardown` signal for using the `connect(signal:)` methods
    static var teardownSignal: SignalListItemFactorySignalName { .teardown }
    
    /// Emitted when a listitem has been removed from use in a list widget
    /// and its new [property`Gtk.ListItem:item`] is about to be unset.
    /// 
    /// This signal is the opposite of the [signal`Gtk.SignalListItemFactory::bind`]
    /// signal and should be used to undo everything done in that signal.
    /// - Note: This represents the underlying `unbind` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter listitem: The `GtkListItem` to unbind
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `unbind` signal is emitted
    @discardableResult @inlinable func onUnbind(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SignalListItemFactoryRef, _ listitem: ListItemRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SignalListItemFactoryRef, ListItemRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SignalListItemFactoryRef(raw: unownedSelf), ListItemRef(raw: arg1))
            return output
        }
        return connect(
            signal: .unbind,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `unbind` signal for using the `connect(signal:)` methods
    static var unbindSignal: SignalListItemFactorySignalName { .unbind }
    
    
}

// MARK: SignalListItemFactory Class: SignalListItemFactoryProtocol extension (methods and fields)
public extension SignalListItemFactoryProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSignalListItemFactory` instance.
    @inlinable var signal_list_item_factory_ptr: UnsafeMutablePointer<GtkSignalListItemFactory>! { return ptr?.assumingMemoryBound(to: GtkSignalListItemFactory.self) }



}



// MARK: - SingleSelection Class

/// The `SingleSelectionProtocol` protocol exposes the methods and properties of an underlying `GtkSingleSelection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SingleSelection`.
/// Alternatively, use `SingleSelectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSingleSelection` is a `GtkSelectionModel` that allows selecting a single
/// item.
/// 
/// Note that the selection is *persistent* -- if the selected item is removed
/// and re-added in the same `items-changed` emission, it stays selected.
/// In particular, this means that changing the sort order of an underlying sort
/// model will preserve the selection.
public protocol SingleSelectionProtocol: GLibObject.ObjectProtocol, GIO.ListModelProtocol, SelectionModelProtocol {
        /// Untyped pointer to the underlying `GtkSingleSelection` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSingleSelection` instance.
    var single_selection_ptr: UnsafeMutablePointer<GtkSingleSelection>! { get }

    /// Required Initialiser for types conforming to `SingleSelectionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SingleSelectionRef` type acts as a lightweight Swift reference to an underlying `GtkSingleSelection` instance.
/// It exposes methods that can operate on this data type through `SingleSelectionProtocol` conformance.
/// Use `SingleSelectionRef` only as an `unowned` reference to an existing `GtkSingleSelection` instance.
///
/// `GtkSingleSelection` is a `GtkSelectionModel` that allows selecting a single
/// item.
/// 
/// Note that the selection is *persistent* -- if the selected item is removed
/// and re-added in the same `items-changed` emission, it stays selected.
/// In particular, this means that changing the sort order of an underlying sort
/// model will preserve the selection.
public struct SingleSelectionRef: SingleSelectionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSingleSelection` instance.
    /// For type-safe access, use the generated, typed pointer `single_selection_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SingleSelectionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSingleSelection>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSingleSelection>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSingleSelection>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSingleSelection>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SingleSelectionProtocol`
    @inlinable init<T: SingleSelectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SingleSelectionProtocol>(_ other: T) -> SingleSelectionRef { SingleSelectionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new selection to handle `model`.
    @inlinable init<ListModelT: GIO.ListModelProtocol>( model: ListModelT?) {
        let rv = gtk_single_selection_new(model?.list_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SingleSelection` type acts as a reference-counted owner of an underlying `GtkSingleSelection` instance.
/// It provides the methods that can operate on this data type through `SingleSelectionProtocol` conformance.
/// Use `SingleSelection` as a strong reference or owner of a `GtkSingleSelection` instance.
///
/// `GtkSingleSelection` is a `GtkSelectionModel` that allows selecting a single
/// item.
/// 
/// Note that the selection is *persistent* -- if the selected item is removed
/// and re-added in the same `items-changed` emission, it stays selected.
/// In particular, this means that changing the sort order of an underlying sort
/// model will preserve the selection.
open class SingleSelection: GLibObject.Object, SingleSelectionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSingleSelection>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSingleSelection>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSingleSelection>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSingleSelection>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSingleSelection`.
    /// i.e., ownership is transferred to the `SingleSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSingleSelection>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SingleSelectionProtocol`
    /// Will retain `GtkSingleSelection`.
    /// - Parameter other: an instance of a related type that implements `SingleSelectionProtocol`
    @inlinable public init<T: SingleSelectionProtocol>(singleSelection other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SingleSelectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new selection to handle `model`.
    @inlinable public init<ListModelT: GIO.ListModelProtocol>( model: ListModelT?) {
        let rv = gtk_single_selection_new(model?.list_model_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SingleSelectionPropertyName: String, PropertyNameProtocol {
    /// If the selection will always select an item.
    case autoselect = "autoselect"
    /// If unselecting the selected item is allowed.
    case canUnselect = "can-unselect"
    /// The model being managed.
    case model = "model"
    /// Position of the selected item.
    case selected = "selected"
    /// The selected item.
    case selectedItem = "selected-item"
}

public extension SingleSelectionProtocol {
    /// Bind a `SingleSelectionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SingleSelectionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SingleSelection property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SingleSelectionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SingleSelection property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SingleSelectionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SingleSelectionSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// If the selection will always select an item.
    case notifyAutoselect = "notify::autoselect"
    /// If unselecting the selected item is allowed.
    case notifyCanUnselect = "notify::can-unselect"
    /// The model being managed.
    case notifyModel = "notify::model"
    /// Position of the selected item.
    case notifySelected = "notify::selected"
    /// The selected item.
    case notifySelectedItem = "notify::selected-item"
}

// MARK: SingleSelection has no signals
// MARK: SingleSelection Class: SingleSelectionProtocol extension (methods and fields)
public extension SingleSelectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSingleSelection` instance.
    @inlinable var single_selection_ptr: UnsafeMutablePointer<GtkSingleSelection>! { return ptr?.assumingMemoryBound(to: GtkSingleSelection.self) }

    /// Checks if autoselect has been enabled or disabled via
    /// `gtk_single_selection_set_autoselect()`.
    @inlinable func getAutoselect() -> Bool {
        let rv = ((gtk_single_selection_get_autoselect(single_selection_ptr)) != 0)
        return rv
    }

    /// If `true`, `gtk_selection_model_unselect_item()` is supported and allows
    /// unselecting the selected item.
    @inlinable func getCanUnselect() -> Bool {
        let rv = ((gtk_single_selection_get_can_unselect(single_selection_ptr)) != 0)
        return rv
    }

    /// Gets the model that `self` is wrapping.
    @inlinable func getModel() -> GIO.ListModelRef! {
        let rv = GIO.ListModelRef(gtk_single_selection_get_model(single_selection_ptr))
        return rv
    }

    /// Gets the position of the selected item.
    /// 
    /// If no item is selected, `GTK_INVALID_LIST_POSITION` is returned.
    @inlinable func getSelected() -> Int {
        let rv = Int(gtk_single_selection_get_selected(single_selection_ptr))
        return rv
    }

    /// Gets the selected item.
    /// 
    /// If no item is selected, `nil` is returned.
    @inlinable func getSelectedItem() -> GLibObject.ObjectRef! {
        let rv = GLibObject.ObjectRef(gpointer: gtk_single_selection_get_selected_item(single_selection_ptr))
        return rv
    }

    /// Enables or disables autoselect.
    /// 
    /// If `autoselect` is `true`, `self` will enforce that an item is always
    /// selected. It will select a new item when the currently selected
    /// item is deleted and it will disallow unselecting the current item.
    @inlinable func set(autoselect: Bool) {
        gtk_single_selection_set_autoselect(single_selection_ptr, gboolean((autoselect) ? 1 : 0))
    
    }

    /// If `true`, unselecting the current item via
    /// `gtk_selection_model_unselect_item()` is supported.
    /// 
    /// Note that setting [property`Gtk.SingleSelection:autoselect`] will
    /// cause unselecting to not work, so it practically makes no sense
    /// to set both at the same time the same time.
    @inlinable func set(canUnselect: Bool) {
        gtk_single_selection_set_can_unselect(single_selection_ptr, gboolean((canUnselect) ? 1 : 0))
    
    }

    /// Sets the model that `self` should wrap.
    /// 
    /// If `model` is `nil`, `self` will be empty.
    @inlinable func set(model: GIO.ListModelRef? = nil) {
        gtk_single_selection_set_model(single_selection_ptr, model?.list_model_ptr)
    
    }
    /// Sets the model that `self` should wrap.
    /// 
    /// If `model` is `nil`, `self` will be empty.
    @inlinable func set<ListModelT: GIO.ListModelProtocol>(model: ListModelT?) {
        gtk_single_selection_set_model(single_selection_ptr, model?.list_model_ptr)
    
    }

    /// Selects the item at the given position.
    /// 
    /// If the list does not have an item at `position` or
    /// `GTK_INVALID_LIST_POSITION` is given, the behavior depends on the
    /// value of the [property`Gtk.SingleSelection:autoselect`] property:
    /// If it is set, no change will occur and the old item will stay
    /// selected. If it is unset, the selection will be unset and no item
    /// will be selected.
    @inlinable func setSelected(position: Int) {
        gtk_single_selection_set_selected(single_selection_ptr, guint(position))
    
    }
    /// If the selection will always select an item.
    @inlinable var autoselect: Bool {
        /// Checks if autoselect has been enabled or disabled via
        /// `gtk_single_selection_set_autoselect()`.
        get {
            let rv = ((gtk_single_selection_get_autoselect(single_selection_ptr)) != 0)
            return rv
        }
        /// Enables or disables autoselect.
        /// 
        /// If `autoselect` is `true`, `self` will enforce that an item is always
        /// selected. It will select a new item when the currently selected
        /// item is deleted and it will disallow unselecting the current item.
        nonmutating set {
            gtk_single_selection_set_autoselect(single_selection_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// If `true`, `gtk_selection_model_unselect_item()` is supported and allows
    /// unselecting the selected item.
    @inlinable var canUnselect: Bool {
        /// If `true`, `gtk_selection_model_unselect_item()` is supported and allows
        /// unselecting the selected item.
        get {
            let rv = ((gtk_single_selection_get_can_unselect(single_selection_ptr)) != 0)
            return rv
        }
        /// If `true`, unselecting the current item via
        /// `gtk_selection_model_unselect_item()` is supported.
        /// 
        /// Note that setting [property`Gtk.SingleSelection:autoselect`] will
        /// cause unselecting to not work, so it practically makes no sense
        /// to set both at the same time the same time.
        nonmutating set {
            gtk_single_selection_set_can_unselect(single_selection_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The model being managed.
    @inlinable var model: GIO.ListModelRef! {
        /// Gets the model that `self` is wrapping.
        get {
            let rv = GIO.ListModelRef(gtk_single_selection_get_model(single_selection_ptr))
            return rv
        }
        /// Sets the model that `self` should wrap.
        /// 
        /// If `model` is `nil`, `self` will be empty.
        nonmutating set {
            gtk_single_selection_set_model(single_selection_ptr, UnsafeMutablePointer<GListModel>(newValue?.list_model_ptr))
        }
    }

    /// Position of the selected item.
    @inlinable var selected: Int {
        /// Gets the position of the selected item.
        /// 
        /// If no item is selected, `GTK_INVALID_LIST_POSITION` is returned.
        get {
            let rv = Int(gtk_single_selection_get_selected(single_selection_ptr))
            return rv
        }
        /// Selects the item at the given position.
        /// 
        /// If the list does not have an item at `position` or
        /// `GTK_INVALID_LIST_POSITION` is given, the behavior depends on the
        /// value of the [property`Gtk.SingleSelection:autoselect`] property:
        /// If it is set, no change will occur and the old item will stay
        /// selected. If it is unset, the selection will be unset and no item
        /// will be selected.
        nonmutating set {
            gtk_single_selection_set_selected(single_selection_ptr, guint(newValue))
        }
    }

    /// Gets the selected item.
    /// 
    /// If no item is selected, `nil` is returned.
    @inlinable var selectedItem: GLibObject.ObjectRef! {
        /// Gets the selected item.
        /// 
        /// If no item is selected, `nil` is returned.
        get {
            let rv = GLibObject.ObjectRef(gpointer: gtk_single_selection_get_selected_item(single_selection_ptr))
            return rv
        }
    }


}



// MARK: - SizeGroup Class

/// The `SizeGroupProtocol` protocol exposes the methods and properties of an underlying `GtkSizeGroup` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SizeGroup`.
/// Alternatively, use `SizeGroupRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSizeGroup` groups widgets together so they all request the same size.
/// 
/// This is typically useful when you want a column of widgets to have the
/// same size, but you can’t use a `GtkGrid`.
/// 
/// In detail, the size requested for each widget in a `GtkSizeGroup` is
/// the maximum of the sizes that would have been requested for each
/// widget in the size group if they were not in the size group. The mode
/// of the size group (see [method`Gtk.SizeGroup.set_mode`]) determines whether
/// this applies to the horizontal size, the vertical size, or both sizes.
/// 
/// Note that size groups only affect the amount of space requested, not
/// the size that the widgets finally receive. If you want the widgets in
/// a `GtkSizeGroup` to actually be the same size, you need to pack them in
/// such a way that they get the size they request and not more.
/// 
/// `GtkSizeGroup` objects are referenced by each widget in the size group,
/// so once you have added all widgets to a `GtkSizeGroup`, you can drop
/// the initial reference to the size group with `g_object_unref()`. If the
/// widgets in the size group are subsequently destroyed, then they will
/// be removed from the size group and drop their references on the size
/// group; when all widgets have been removed, the size group will be
/// freed.
/// 
/// Widgets can be part of multiple size groups; GTK will compute the
/// horizontal size of a widget from the horizontal requisition of all
/// widgets that can be reached from the widget by a chain of size groups
/// of type `GTK_SIZE_GROUP_HORIZONTAL` or `GTK_SIZE_GROUP_BOTH`, and the
/// vertical size from the vertical requisition of all widgets that can be
/// reached from the widget by a chain of size groups of type
/// `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH`.
/// 
/// Note that only non-contextual sizes of every widget are ever consulted
/// by size groups (since size groups have no knowledge of what size a widget
/// will be allocated in one dimension, it cannot derive how much height
/// a widget will receive for a given width). When grouping widgets that
/// trade height for width in mode `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH:`
/// the height for the minimum width will be the requested height for all
/// widgets in the group. The same is of course true when horizontally grouping
/// width for height widgets.
/// 
/// Widgets that trade height-for-width should set a reasonably large minimum
/// width by way of [property`Gtk.Label:width-chars`] for instance. Widgets with
/// static sizes as well as widgets that grow (such as ellipsizing text) need no
/// such considerations.
/// 
/// # GtkSizeGroup as GtkBuildable
/// 
/// Size groups can be specified in a UI definition by placing an &lt;object&gt;
/// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
/// widgets that belong to the size group are specified by a &lt;widgets&gt; element
/// that may contain multiple &lt;widget&gt; elements, one for each member of the
/// size group. The ”name” attribute gives the id of the widget.
/// 
/// An example of a UI definition fragment with `GtkSizeGroup`:
/// ```xml
/// &lt;object class="GtkSizeGroup"&gt;
///   &lt;property name="mode"&gt;horizontal&lt;/property&gt;
///   &lt;widgets&gt;
///     &lt;widget name="radio1"/&gt;
///     &lt;widget name="radio2"/&gt;
///   &lt;/widgets&gt;
/// &lt;/object&gt;
/// ```
public protocol SizeGroupProtocol: GLibObject.ObjectProtocol, BuildableProtocol {
        /// Untyped pointer to the underlying `GtkSizeGroup` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSizeGroup` instance.
    var size_group_ptr: UnsafeMutablePointer<GtkSizeGroup>! { get }

    /// Required Initialiser for types conforming to `SizeGroupProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SizeGroupRef` type acts as a lightweight Swift reference to an underlying `GtkSizeGroup` instance.
/// It exposes methods that can operate on this data type through `SizeGroupProtocol` conformance.
/// Use `SizeGroupRef` only as an `unowned` reference to an existing `GtkSizeGroup` instance.
///
/// `GtkSizeGroup` groups widgets together so they all request the same size.
/// 
/// This is typically useful when you want a column of widgets to have the
/// same size, but you can’t use a `GtkGrid`.
/// 
/// In detail, the size requested for each widget in a `GtkSizeGroup` is
/// the maximum of the sizes that would have been requested for each
/// widget in the size group if they were not in the size group. The mode
/// of the size group (see [method`Gtk.SizeGroup.set_mode`]) determines whether
/// this applies to the horizontal size, the vertical size, or both sizes.
/// 
/// Note that size groups only affect the amount of space requested, not
/// the size that the widgets finally receive. If you want the widgets in
/// a `GtkSizeGroup` to actually be the same size, you need to pack them in
/// such a way that they get the size they request and not more.
/// 
/// `GtkSizeGroup` objects are referenced by each widget in the size group,
/// so once you have added all widgets to a `GtkSizeGroup`, you can drop
/// the initial reference to the size group with `g_object_unref()`. If the
/// widgets in the size group are subsequently destroyed, then they will
/// be removed from the size group and drop their references on the size
/// group; when all widgets have been removed, the size group will be
/// freed.
/// 
/// Widgets can be part of multiple size groups; GTK will compute the
/// horizontal size of a widget from the horizontal requisition of all
/// widgets that can be reached from the widget by a chain of size groups
/// of type `GTK_SIZE_GROUP_HORIZONTAL` or `GTK_SIZE_GROUP_BOTH`, and the
/// vertical size from the vertical requisition of all widgets that can be
/// reached from the widget by a chain of size groups of type
/// `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH`.
/// 
/// Note that only non-contextual sizes of every widget are ever consulted
/// by size groups (since size groups have no knowledge of what size a widget
/// will be allocated in one dimension, it cannot derive how much height
/// a widget will receive for a given width). When grouping widgets that
/// trade height for width in mode `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH:`
/// the height for the minimum width will be the requested height for all
/// widgets in the group. The same is of course true when horizontally grouping
/// width for height widgets.
/// 
/// Widgets that trade height-for-width should set a reasonably large minimum
/// width by way of [property`Gtk.Label:width-chars`] for instance. Widgets with
/// static sizes as well as widgets that grow (such as ellipsizing text) need no
/// such considerations.
/// 
/// # GtkSizeGroup as GtkBuildable
/// 
/// Size groups can be specified in a UI definition by placing an &lt;object&gt;
/// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
/// widgets that belong to the size group are specified by a &lt;widgets&gt; element
/// that may contain multiple &lt;widget&gt; elements, one for each member of the
/// size group. The ”name” attribute gives the id of the widget.
/// 
/// An example of a UI definition fragment with `GtkSizeGroup`:
/// ```xml
/// &lt;object class="GtkSizeGroup"&gt;
///   &lt;property name="mode"&gt;horizontal&lt;/property&gt;
///   &lt;widgets&gt;
///     &lt;widget name="radio1"/&gt;
///     &lt;widget name="radio2"/&gt;
///   &lt;/widgets&gt;
/// &lt;/object&gt;
/// ```
public struct SizeGroupRef: SizeGroupProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSizeGroup` instance.
    /// For type-safe access, use the generated, typed pointer `size_group_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SizeGroupRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSizeGroup>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSizeGroup>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSizeGroup>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSizeGroup>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SizeGroupProtocol`
    @inlinable init<T: SizeGroupProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SizeGroupProtocol>(_ other: T) -> SizeGroupRef { SizeGroupRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Create a new `GtkSizeGroup`.
    @inlinable init( mode: GtkSizeGroupMode) {
        let rv = gtk_size_group_new(mode)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SizeGroup` type acts as a reference-counted owner of an underlying `GtkSizeGroup` instance.
/// It provides the methods that can operate on this data type through `SizeGroupProtocol` conformance.
/// Use `SizeGroup` as a strong reference or owner of a `GtkSizeGroup` instance.
///
/// `GtkSizeGroup` groups widgets together so they all request the same size.
/// 
/// This is typically useful when you want a column of widgets to have the
/// same size, but you can’t use a `GtkGrid`.
/// 
/// In detail, the size requested for each widget in a `GtkSizeGroup` is
/// the maximum of the sizes that would have been requested for each
/// widget in the size group if they were not in the size group. The mode
/// of the size group (see [method`Gtk.SizeGroup.set_mode`]) determines whether
/// this applies to the horizontal size, the vertical size, or both sizes.
/// 
/// Note that size groups only affect the amount of space requested, not
/// the size that the widgets finally receive. If you want the widgets in
/// a `GtkSizeGroup` to actually be the same size, you need to pack them in
/// such a way that they get the size they request and not more.
/// 
/// `GtkSizeGroup` objects are referenced by each widget in the size group,
/// so once you have added all widgets to a `GtkSizeGroup`, you can drop
/// the initial reference to the size group with `g_object_unref()`. If the
/// widgets in the size group are subsequently destroyed, then they will
/// be removed from the size group and drop their references on the size
/// group; when all widgets have been removed, the size group will be
/// freed.
/// 
/// Widgets can be part of multiple size groups; GTK will compute the
/// horizontal size of a widget from the horizontal requisition of all
/// widgets that can be reached from the widget by a chain of size groups
/// of type `GTK_SIZE_GROUP_HORIZONTAL` or `GTK_SIZE_GROUP_BOTH`, and the
/// vertical size from the vertical requisition of all widgets that can be
/// reached from the widget by a chain of size groups of type
/// `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH`.
/// 
/// Note that only non-contextual sizes of every widget are ever consulted
/// by size groups (since size groups have no knowledge of what size a widget
/// will be allocated in one dimension, it cannot derive how much height
/// a widget will receive for a given width). When grouping widgets that
/// trade height for width in mode `GTK_SIZE_GROUP_VERTICAL` or `GTK_SIZE_GROUP_BOTH:`
/// the height for the minimum width will be the requested height for all
/// widgets in the group. The same is of course true when horizontally grouping
/// width for height widgets.
/// 
/// Widgets that trade height-for-width should set a reasonably large minimum
/// width by way of [property`Gtk.Label:width-chars`] for instance. Widgets with
/// static sizes as well as widgets that grow (such as ellipsizing text) need no
/// such considerations.
/// 
/// # GtkSizeGroup as GtkBuildable
/// 
/// Size groups can be specified in a UI definition by placing an &lt;object&gt;
/// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
/// widgets that belong to the size group are specified by a &lt;widgets&gt; element
/// that may contain multiple &lt;widget&gt; elements, one for each member of the
/// size group. The ”name” attribute gives the id of the widget.
/// 
/// An example of a UI definition fragment with `GtkSizeGroup`:
/// ```xml
/// &lt;object class="GtkSizeGroup"&gt;
///   &lt;property name="mode"&gt;horizontal&lt;/property&gt;
///   &lt;widgets&gt;
///     &lt;widget name="radio1"/&gt;
///     &lt;widget name="radio2"/&gt;
///   &lt;/widgets&gt;
/// &lt;/object&gt;
/// ```
open class SizeGroup: GLibObject.Object, SizeGroupProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSizeGroup>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSizeGroup>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSizeGroup>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSizeGroup>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSizeGroup`.
    /// i.e., ownership is transferred to the `SizeGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSizeGroup>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SizeGroupProtocol`
    /// Will retain `GtkSizeGroup`.
    /// - Parameter other: an instance of a related type that implements `SizeGroupProtocol`
    @inlinable public init<T: SizeGroupProtocol>(sizeGroup other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SizeGroupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Create a new `GtkSizeGroup`.
    @inlinable public init( mode: GtkSizeGroupMode) {
        let rv = gtk_size_group_new(mode)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SizeGroupPropertyName: String, PropertyNameProtocol {
    /// The direction in which the size group affects requested sizes.
    case mode = "mode"
}

public extension SizeGroupProtocol {
    /// Bind a `SizeGroupPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SizeGroupPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SizeGroup property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SizeGroupPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SizeGroup property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SizeGroupPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SizeGroupSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The direction in which the size group affects requested sizes.
    case notifyMode = "notify::mode"
}

// MARK: SizeGroup has no signals
// MARK: SizeGroup Class: SizeGroupProtocol extension (methods and fields)
public extension SizeGroupProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSizeGroup` instance.
    @inlinable var size_group_ptr: UnsafeMutablePointer<GtkSizeGroup>! { return ptr?.assumingMemoryBound(to: GtkSizeGroup.self) }

    /// Adds a widget to a `GtkSizeGroup`.
    /// 
    /// In the future, the requisition
    /// of the widget will be determined as the maximum of its requisition
    /// and the requisition of the other widgets in the size group.
    /// Whether this applies horizontally, vertically, or in both directions
    /// depends on the mode of the size group.
    /// See [method`Gtk.SizeGroup.set_mode`].
    /// 
    /// When the widget is destroyed or no longer referenced elsewhere, it
    /// will be removed from the size group.
    @inlinable func add<WidgetT: WidgetProtocol>(widget: WidgetT) {
        gtk_size_group_add_widget(size_group_ptr, widget.widget_ptr)
    
    }

    /// Gets the current mode of the size group.
    @inlinable func getMode() -> GtkSizeGroupMode {
        let rv = gtk_size_group_get_mode(size_group_ptr)
        return rv
    }

    /// Returns the list of widgets associated with `size_group`.
    @inlinable func getWidgets() -> GLib.SListRef! {
        let rv = GLib.SListRef(gtk_size_group_get_widgets(size_group_ptr))
        return rv
    }

    /// Removes a widget from a `GtkSizeGroup`.
    @inlinable func remove<WidgetT: WidgetProtocol>(widget: WidgetT) {
        gtk_size_group_remove_widget(size_group_ptr, widget.widget_ptr)
    
    }

    /// Sets the `GtkSizeGroupMode` of the size group.
    /// 
    /// The mode of the size group determines whether the widgets in the
    /// size group should all have the same horizontal requisition
    /// (`GTK_SIZE_GROUP_HORIZONTAL`) all have the same vertical requisition
    /// (`GTK_SIZE_GROUP_VERTICAL`), or should all have the same requisition
    /// in both directions (`GTK_SIZE_GROUP_BOTH`).
    @inlinable func set(mode: GtkSizeGroupMode) {
        gtk_size_group_set_mode(size_group_ptr, mode)
    
    }
    /// The direction in which the size group affects requested sizes.
    @inlinable var mode: GtkSizeGroupMode {
        /// Gets the current mode of the size group.
        get {
            let rv = gtk_size_group_get_mode(size_group_ptr)
            return rv
        }
        /// Sets the `GtkSizeGroupMode` of the size group.
        /// 
        /// The mode of the size group determines whether the widgets in the
        /// size group should all have the same horizontal requisition
        /// (`GTK_SIZE_GROUP_HORIZONTAL`) all have the same vertical requisition
        /// (`GTK_SIZE_GROUP_VERTICAL`), or should all have the same requisition
        /// in both directions (`GTK_SIZE_GROUP_BOTH`).
        nonmutating set {
            gtk_size_group_set_mode(size_group_ptr, newValue)
        }
    }

    /// Returns the list of widgets associated with `size_group`.
    @inlinable var widgets: GLib.SListRef! {
        /// Returns the list of widgets associated with `size_group`.
        get {
            let rv = GLib.SListRef(gtk_size_group_get_widgets(size_group_ptr))
            return rv
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = size_group_ptr.pointee.parent_instance
            return rv
        }
    }

}



// MARK: - SliceListModel Class

/// The `SliceListModelProtocol` protocol exposes the methods and properties of an underlying `GtkSliceListModel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SliceListModel`.
/// Alternatively, use `SliceListModelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSliceListModel` is a list model that presents a slice of another model.
/// 
/// This is useful when implementing paging by setting the size to the number
/// of elements per page and updating the offset whenever a different page is
/// opened.
public protocol SliceListModelProtocol: GLibObject.ObjectProtocol, GIO.ListModelProtocol {
        /// Untyped pointer to the underlying `GtkSliceListModel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSliceListModel` instance.
    var slice_list_model_ptr: UnsafeMutablePointer<GtkSliceListModel>! { get }

    /// Required Initialiser for types conforming to `SliceListModelProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SliceListModelRef` type acts as a lightweight Swift reference to an underlying `GtkSliceListModel` instance.
/// It exposes methods that can operate on this data type through `SliceListModelProtocol` conformance.
/// Use `SliceListModelRef` only as an `unowned` reference to an existing `GtkSliceListModel` instance.
///
/// `GtkSliceListModel` is a list model that presents a slice of another model.
/// 
/// This is useful when implementing paging by setting the size to the number
/// of elements per page and updating the offset whenever a different page is
/// opened.
public struct SliceListModelRef: SliceListModelProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSliceListModel` instance.
    /// For type-safe access, use the generated, typed pointer `slice_list_model_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SliceListModelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSliceListModel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSliceListModel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSliceListModel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSliceListModel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SliceListModelProtocol`
    @inlinable init<T: SliceListModelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SliceListModelProtocol>(_ other: T) -> SliceListModelRef { SliceListModelRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new slice model.
    /// 
    /// It presents the slice from `offset` to offset + `size`
    /// of the given `model`.
    @inlinable init<ListModelT: GIO.ListModelProtocol>( model: ListModelT?, offset: Int, size: Int) {
        let rv = gtk_slice_list_model_new(model?.list_model_ptr, guint(offset), guint(size))
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SliceListModel` type acts as a reference-counted owner of an underlying `GtkSliceListModel` instance.
/// It provides the methods that can operate on this data type through `SliceListModelProtocol` conformance.
/// Use `SliceListModel` as a strong reference or owner of a `GtkSliceListModel` instance.
///
/// `GtkSliceListModel` is a list model that presents a slice of another model.
/// 
/// This is useful when implementing paging by setting the size to the number
/// of elements per page and updating the offset whenever a different page is
/// opened.
open class SliceListModel: GLibObject.Object, SliceListModelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSliceListModel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSliceListModel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSliceListModel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSliceListModel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSliceListModel`.
    /// i.e., ownership is transferred to the `SliceListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSliceListModel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SliceListModelProtocol`
    /// Will retain `GtkSliceListModel`.
    /// - Parameter other: an instance of a related type that implements `SliceListModelProtocol`
    @inlinable public init<T: SliceListModelProtocol>(sliceListModel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SliceListModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new slice model.
    /// 
    /// It presents the slice from `offset` to offset + `size`
    /// of the given `model`.
    @inlinable public init<ListModelT: GIO.ListModelProtocol>( model: ListModelT?, offset: Int, size: Int) {
        let rv = gtk_slice_list_model_new(model?.list_model_ptr, guint(offset), guint(size))
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SliceListModelPropertyName: String, PropertyNameProtocol {
    /// Child model to take slice from.
    case model = "model"
    /// Offset of slice.
    case offset = "offset"
    /// Maximum size of slice.
    case size = "size"
}

public extension SliceListModelProtocol {
    /// Bind a `SliceListModelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SliceListModelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SliceListModel property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SliceListModelPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SliceListModel property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SliceListModelPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SliceListModelSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Child model to take slice from.
    case notifyModel = "notify::model"
    /// Offset of slice.
    case notifyOffset = "notify::offset"
    /// Maximum size of slice.
    case notifySize = "notify::size"
}

// MARK: SliceListModel has no signals
// MARK: SliceListModel Class: SliceListModelProtocol extension (methods and fields)
public extension SliceListModelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSliceListModel` instance.
    @inlinable var slice_list_model_ptr: UnsafeMutablePointer<GtkSliceListModel>! { return ptr?.assumingMemoryBound(to: GtkSliceListModel.self) }

    /// Gets the model that is currently being used or `nil` if none.
    @inlinable func getModel() -> GIO.ListModelRef! {
        let rv = GIO.ListModelRef(gtk_slice_list_model_get_model(slice_list_model_ptr))
        return rv
    }

    /// Gets the offset set via `gtk_slice_list_model_set_offset()`.
    @inlinable func getOffset() -> Int {
        let rv = Int(gtk_slice_list_model_get_offset(slice_list_model_ptr))
        return rv
    }

    /// Gets the size set via `gtk_slice_list_model_set_size()`.
    @inlinable func getSize() -> Int {
        let rv = Int(gtk_slice_list_model_get_size(slice_list_model_ptr))
        return rv
    }

    /// Sets the model to show a slice of.
    /// 
    /// The model's item type must conform to `self`'s item type.
    @inlinable func set(model: GIO.ListModelRef? = nil) {
        gtk_slice_list_model_set_model(slice_list_model_ptr, model?.list_model_ptr)
    
    }
    /// Sets the model to show a slice of.
    /// 
    /// The model's item type must conform to `self`'s item type.
    @inlinable func set<ListModelT: GIO.ListModelProtocol>(model: ListModelT?) {
        gtk_slice_list_model_set_model(slice_list_model_ptr, model?.list_model_ptr)
    
    }

    /// Sets the offset into the original model for this slice.
    /// 
    /// If the offset is too large for the sliced model,
    /// `self` will end up empty.
    @inlinable func set(offset: Int) {
        gtk_slice_list_model_set_offset(slice_list_model_ptr, guint(offset))
    
    }

    /// Sets the maximum size. `self` will never have more items
    /// than `size`.
    /// 
    /// It can however have fewer items if the offset is too large
    /// or the model sliced from doesn't have enough items.
    @inlinable func set(size: Int) {
        gtk_slice_list_model_set_size(slice_list_model_ptr, guint(size))
    
    }
    /// Child model to take slice from.
    @inlinable var model: GIO.ListModelRef! {
        /// Gets the model that is currently being used or `nil` if none.
        get {
            let rv = GIO.ListModelRef(gtk_slice_list_model_get_model(slice_list_model_ptr))
            return rv
        }
        /// Sets the model to show a slice of.
        /// 
        /// The model's item type must conform to `self`'s item type.
        nonmutating set {
            gtk_slice_list_model_set_model(slice_list_model_ptr, UnsafeMutablePointer<GListModel>(newValue?.list_model_ptr))
        }
    }

    /// Offset of slice.
    @inlinable var offset: Int {
        /// Gets the offset set via `gtk_slice_list_model_set_offset()`.
        get {
            let rv = Int(gtk_slice_list_model_get_offset(slice_list_model_ptr))
            return rv
        }
        /// Sets the offset into the original model for this slice.
        /// 
        /// If the offset is too large for the sliced model,
        /// `self` will end up empty.
        nonmutating set {
            gtk_slice_list_model_set_offset(slice_list_model_ptr, guint(newValue))
        }
    }

    /// Maximum size of slice.
    @inlinable var size: Int {
        /// Gets the size set via `gtk_slice_list_model_set_size()`.
        get {
            let rv = Int(gtk_slice_list_model_get_size(slice_list_model_ptr))
            return rv
        }
        /// Sets the maximum size. `self` will never have more items
        /// than `size`.
        /// 
        /// It can however have fewer items if the offset is too large
        /// or the model sliced from doesn't have enough items.
        nonmutating set {
            gtk_slice_list_model_set_size(slice_list_model_ptr, guint(newValue))
        }
    }


}



// MARK: - Snapshot Class

/// The `SnapshotProtocol` protocol exposes the methods and properties of an underlying `GtkSnapshot` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Snapshot`.
/// Alternatively, use `SnapshotRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSnapshot` assists in creating `GskRenderNodes` for widgets.
/// 
/// It functions in a similar way to a cairo context, and maintains a stack
/// of render nodes and their associated transformations.
/// 
/// The node at the top of the stack is the the one that gtk_snapshot_append_…
/// functions operate on. Use the gtk_snapshot_push_… functions and
/// `gtk_snapshot_pop()` to change the current node.
/// 
/// The typical way to obtain a `GtkSnapshot` object is as an argument to
/// the `GtkWidgetClass.snapshot()` vfunc. If you need to create your own
/// `GtkSnapshot`, use [ctor`Gtk.Snapshot.new`].
public protocol SnapshotProtocol: Gdk.SnapshotProtocol {
        /// Untyped pointer to the underlying `GtkSnapshot` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSnapshot` instance.
    var snapshot_ptr: UnsafeMutablePointer<GtkSnapshot>! { get }

    /// Required Initialiser for types conforming to `SnapshotProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SnapshotRef` type acts as a lightweight Swift reference to an underlying `GtkSnapshot` instance.
/// It exposes methods that can operate on this data type through `SnapshotProtocol` conformance.
/// Use `SnapshotRef` only as an `unowned` reference to an existing `GtkSnapshot` instance.
///
/// `GtkSnapshot` assists in creating `GskRenderNodes` for widgets.
/// 
/// It functions in a similar way to a cairo context, and maintains a stack
/// of render nodes and their associated transformations.
/// 
/// The node at the top of the stack is the the one that gtk_snapshot_append_…
/// functions operate on. Use the gtk_snapshot_push_… functions and
/// `gtk_snapshot_pop()` to change the current node.
/// 
/// The typical way to obtain a `GtkSnapshot` object is as an argument to
/// the `GtkWidgetClass.snapshot()` vfunc. If you need to create your own
/// `GtkSnapshot`, use [ctor`Gtk.Snapshot.new`].
public struct SnapshotRef: SnapshotProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSnapshot` instance.
    /// For type-safe access, use the generated, typed pointer `snapshot_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SnapshotRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSnapshot>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSnapshot>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSnapshot>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSnapshot>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SnapshotProtocol`
    @inlinable init<T: SnapshotProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SnapshotProtocol>(_ other: T) -> SnapshotRef { SnapshotRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSnapshot`.
    @inlinable init() {
        let rv = gtk_snapshot_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Snapshot` type acts as a reference-counted owner of an underlying `GtkSnapshot` instance.
/// It provides the methods that can operate on this data type through `SnapshotProtocol` conformance.
/// Use `Snapshot` as a strong reference or owner of a `GtkSnapshot` instance.
///
/// `GtkSnapshot` assists in creating `GskRenderNodes` for widgets.
/// 
/// It functions in a similar way to a cairo context, and maintains a stack
/// of render nodes and their associated transformations.
/// 
/// The node at the top of the stack is the the one that gtk_snapshot_append_…
/// functions operate on. Use the gtk_snapshot_push_… functions and
/// `gtk_snapshot_pop()` to change the current node.
/// 
/// The typical way to obtain a `GtkSnapshot` object is as an argument to
/// the `GtkWidgetClass.snapshot()` vfunc. If you need to create your own
/// `GtkSnapshot`, use [ctor`Gtk.Snapshot.new`].
open class Snapshot: Gdk.Snapshot, SnapshotProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init(_ op: UnsafeMutablePointer<GtkSnapshot>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init(_ op: UnsafePointer<GtkSnapshot>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(_ op: UnsafePointer<GtkSnapshot>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(_ op: UnsafeMutablePointer<GtkSnapshot>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSnapshot`.
    /// i.e., ownership is transferred to the `Snapshot` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init(retaining op: UnsafeMutablePointer<GtkSnapshot>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SnapshotProtocol`
    /// Will retain `GtkSnapshot`.
    /// - Parameter other: an instance of a related type that implements `SnapshotProtocol`
    @inlinable public init<T: SnapshotProtocol>(_ other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SnapshotProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSnapshot`.
    @inlinable public init() {
        let rv = gtk_snapshot_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no Snapshot properties

public enum SnapshotSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: Snapshot has no signals
// MARK: Snapshot Class: SnapshotProtocol extension (methods and fields)
public extension SnapshotProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSnapshot` instance.
    @inlinable var snapshot_ptr: UnsafeMutablePointer<GtkSnapshot>! { return ptr?.assumingMemoryBound(to: GtkSnapshot.self) }

    /// Appends a stroked border rectangle inside the given `outline`.
    /// 
    /// The four sides of the border can have different widths and colors.
    @inlinable func appendBorder(outline: UnsafePointer<GskRoundedRect>!, borderWidth: UnsafePointer<CFloat>!, borderColor: UnsafePointer<GdkRGBA>!) {
        gtk_snapshot_append_border(snapshot_ptr, outline, borderWidth, borderColor)
    
    }

    /// Creates a new `GskCairoNode` and appends it to the current
    /// render node of `snapshot`, without changing the current node.
    @inlinable func appendCairo(bounds: UnsafePointer<graphene_rect_t>!) -> Cairo.ContextRef! {
        let rv = Cairo.ContextRef(gtk_snapshot_append_cairo(snapshot_ptr, bounds))
        return rv
    }

    /// Creates a new render node drawing the `color` into the
    /// given `bounds` and appends it to the current render node
    /// of `snapshot`.
    /// 
    /// You should try to avoid calling this function if
    /// `color` is transparent.
    @inlinable func append<RGBAT: Gdk.RGBAProtocol>(color: RGBAT, bounds: UnsafePointer<graphene_rect_t>!) {
        gtk_snapshot_append_color(snapshot_ptr, color.rgba_ptr, bounds)
    
    }

    /// Appends a conic gradient node with the given stops to `snapshot`.
    @inlinable func appendConicGradient(bounds: UnsafePointer<graphene_rect_t>!, center: UnsafePointer<graphene_point_t>!, rotation: CFloat, stops: UnsafePointer<GskColorStop>!, nStops: Int) {
        gtk_snapshot_append_conic_gradient(snapshot_ptr, bounds, center, rotation, stops, gsize(nStops))
    
    }

    /// Appends an inset shadow into the box given by `outline`.
    @inlinable func appendInsetShadow<RGBAT: Gdk.RGBAProtocol>(outline: UnsafePointer<GskRoundedRect>!, color: RGBAT, dx: CFloat, dy: CFloat, spread: CFloat, blurRadius: CFloat) {
        gtk_snapshot_append_inset_shadow(snapshot_ptr, outline, color.rgba_ptr, dx, dy, spread, blurRadius)
    
    }

    @inlinable func append<LayoutT: Pango.LayoutProtocol, RGBAT: Gdk.RGBAProtocol>(layout: LayoutT, color: RGBAT) {
        gtk_snapshot_append_layout(snapshot_ptr, layout.layout_ptr, color.rgba_ptr)
    
    }

    /// Appends a linear gradient node with the given stops to `snapshot`.
    @inlinable func appendLinearGradient(bounds: UnsafePointer<graphene_rect_t>!, startPoint: UnsafePointer<graphene_point_t>!, endPoint: UnsafePointer<graphene_point_t>!, stops: UnsafePointer<GskColorStop>!, nStops: Int) {
        gtk_snapshot_append_linear_gradient(snapshot_ptr, bounds, startPoint, endPoint, stops, gsize(nStops))
    
    }

    /// Appends `node` to the current render node of `snapshot`,
    /// without changing the current node.
    /// 
    /// If `snapshot` does not have a current node yet, `node`
    /// will become the initial node.
    @inlinable func append(node: UnsafeMutablePointer<GskRenderNode>!) {
        gtk_snapshot_append_node(snapshot_ptr, node)
    
    }

    /// Appends an outset shadow node around the box given by `outline`.
    @inlinable func appendOutsetShadow<RGBAT: Gdk.RGBAProtocol>(outline: UnsafePointer<GskRoundedRect>!, color: RGBAT, dx: CFloat, dy: CFloat, spread: CFloat, blurRadius: CFloat) {
        gtk_snapshot_append_outset_shadow(snapshot_ptr, outline, color.rgba_ptr, dx, dy, spread, blurRadius)
    
    }

    /// Appends a radial gradient node with the given stops to `snapshot`.
    @inlinable func appendRadialGradient(bounds: UnsafePointer<graphene_rect_t>!, center: UnsafePointer<graphene_point_t>!, hradius: CFloat, vradius: CFloat, start: CFloat, end: CFloat, stops: UnsafePointer<GskColorStop>!, nStops: Int) {
        gtk_snapshot_append_radial_gradient(snapshot_ptr, bounds, center, hradius, vradius, start, end, stops, gsize(nStops))
    
    }

    /// Appends a repeating linear gradient node with the given stops to `snapshot`.
    @inlinable func appendRepeatingLinearGradient(bounds: UnsafePointer<graphene_rect_t>!, startPoint: UnsafePointer<graphene_point_t>!, endPoint: UnsafePointer<graphene_point_t>!, stops: UnsafePointer<GskColorStop>!, nStops: Int) {
        gtk_snapshot_append_repeating_linear_gradient(snapshot_ptr, bounds, startPoint, endPoint, stops, gsize(nStops))
    
    }

    /// Appends a repeating radial gradient node with the given stops to `snapshot`.
    @inlinable func appendRepeatingRadialGradient(bounds: UnsafePointer<graphene_rect_t>!, center: UnsafePointer<graphene_point_t>!, hradius: CFloat, vradius: CFloat, start: CFloat, end: CFloat, stops: UnsafePointer<GskColorStop>!, nStops: Int) {
        gtk_snapshot_append_repeating_radial_gradient(snapshot_ptr, bounds, center, hradius, vradius, start, end, stops, gsize(nStops))
    
    }

    /// Creates a new render node drawing the `texture`
    /// into the given `bounds` and appends it to the
    /// current render node of `snapshot`.
    @inlinable func append<TextureT: Gdk.TextureProtocol>(texture: TextureT, bounds: UnsafePointer<graphene_rect_t>!) {
        gtk_snapshot_append_texture(snapshot_ptr, texture.texture_ptr, bounds)
    
    }

    /// Returns the node that was constructed by `snapshot`
    /// and frees `snapshot`.
    @inlinable func freeToNode() -> UnsafeMutablePointer<GskRenderNode>! {
        let rv = gtk_snapshot_free_to_node(snapshot_ptr)
        return rv
    }

    /// Returns a paintable for the node that was
    /// constructed by `snapshot` and frees `snapshot`.
    @inlinable func freeToPaintable(size: UnsafePointer<graphene_size_t>? = nil) -> Gdk.PaintableRef! {
        let rv = Gdk.PaintableRef(gtk_snapshot_free_to_paintable(snapshot_ptr, size))
        return rv
    }

    /// Removes the top element from the stack of render nodes and
    /// adds it to the nearest `GskGLShaderNode` below it.
    /// 
    /// This must be called the same number of times as the number
    /// of textures is needed for the shader in
    /// [method`Gtk.Snapshot.push_gl_shader`].
    @inlinable func glShaderPopTexture() {
        gtk_snapshot_gl_shader_pop_texture(snapshot_ptr)
    
    }

    /// Applies a perspective projection transform.
    /// 
    /// See [method`Gsk.Transform.perspective`] for a discussion on the details.
    @inlinable func perspective(depth: CFloat) {
        gtk_snapshot_perspective(snapshot_ptr, depth)
    
    }

    /// Removes the top element from the stack of render nodes,
    /// and appends it to the node underneath it.
    @inlinable func pop() {
        gtk_snapshot_pop(snapshot_ptr)
    
    }

    /// Blends together two images with the given blend mode.
    /// 
    /// Until the first call to [method`Gtk.Snapshot.pop`], the
    /// bottom image for the blend operation will be recorded.
    /// After that call, the top image to be blended will be
    /// recorded until the second call to [method`Gtk.Snapshot.pop`].
    /// 
    /// Calling this function requires two subsequent calls
    /// to [method`Gtk.Snapshot.pop`].
    @inlinable func pushBlend(blendMode: GskBlendMode) {
        gtk_snapshot_push_blend(snapshot_ptr, blendMode)
    
    }

    /// Blurs an image.
    /// 
    /// The image is recorded until the next call to [method`Gtk.Snapshot.pop`].
    @inlinable func pushBlur(radius: CDouble) {
        gtk_snapshot_push_blur(snapshot_ptr, radius)
    
    }

    /// Clips an image to a rectangle.
    /// 
    /// The image is recorded until the next call to [method`Gtk.Snapshot.pop`].
    @inlinable func pushClip(bounds: UnsafePointer<graphene_rect_t>!) {
        gtk_snapshot_push_clip(snapshot_ptr, bounds)
    
    }

    /// Modifies the colors of an image by applying an affine transformation
    /// in RGB space.
    /// 
    /// The image is recorded until the next call to [method`Gtk.Snapshot.pop`].
    @inlinable func push(colorMatrix: UnsafePointer<graphene_matrix_t>!, colorOffset: UnsafePointer<graphene_vec4_t>!) {
        gtk_snapshot_push_color_matrix(snapshot_ptr, colorMatrix, colorOffset)
    
    }

    /// Snapshots a cross-fade operation between two images with the
    /// given `progress`.
    /// 
    /// Until the first call to [method`Gtk.Snapshot.pop`], the start image
    /// will be snapshot. After that call, the end image will be recorded
    /// until the second call to [method`Gtk.Snapshot.pop`].
    /// 
    /// Calling this function requires two subsequent calls
    /// to [method`Gtk.Snapshot.pop`].
    @inlinable func pushCrossFade(progress: CDouble) {
        gtk_snapshot_push_cross_fade(snapshot_ptr, progress)
    
    }


    // *** pushDebug() is not available because it has a varargs (...) parameter!


    /// Push a `GskGLShaderNode`.
    /// 
    /// The node uses the given [class`Gsk.GLShader`] and uniform values
    /// Additionally this takes a list of `n_children` other nodes
    /// which will be passed to the `GskGLShaderNode`.
    /// 
    /// The `take_args` argument is a block of data to use for uniform
    /// arguments, as per types and offsets defined by the `shader`.
    /// Normally this is generated by [method`Gsk.GLShader.format_args`]
    /// or [struct`Gsk.ShaderArgsBuilder`].
    /// 
    /// The snapshotter takes ownership of `take_args`, so the caller should
    /// not free it after this.
    /// 
    /// If the renderer doesn't support GL shaders, or if there is any
    /// problem when compiling the shader, then the node will draw pink.
    /// You should use [method`Gsk.GLShader.compile`] to ensure the `shader`
    /// will work for the renderer before using it.
    /// 
    /// If the shader requires textures (see [method`Gsk.GLShader.get_n_textures`]),
    /// then it is expected that you call [method`Gtk.Snapshot.gl_shader_pop_texture`]
    /// the number of times that are required. Each of these calls will generate
    /// a node that is added as a child to the `GskGLShaderNode`, which in turn
    /// will render these offscreen and pass as a texture to the shader.
    /// 
    /// Once all textures (if any) are pop:ed, you must call the regular
    /// [method`Gtk.Snapshot.pop`].
    /// 
    /// If you want to use pre-existing textures as input to the shader rather
    /// than rendering new ones, use [method`Gtk.Snapshot.append_texture`] to
    /// push a texture node. These will be used directly rather than being
    /// re-rendered.
    /// 
    /// For details on how to write shaders, see [class`Gsk.GLShader`].
    @inlinable func pushGl<BytesT: GLib.BytesProtocol>(shader: UnsafeMutablePointer<GskGLShader>!, bounds: UnsafePointer<graphene_rect_t>!, takeArgs: BytesT) {
        gtk_snapshot_push_gl_shader(snapshot_ptr, shader, bounds, takeArgs.bytes_ptr)
    
    }

    /// Modifies the opacity of an image.
    /// 
    /// The image is recorded until the next call to [method`Gtk.Snapshot.pop`].
    @inlinable func push(opacity: CDouble) {
        gtk_snapshot_push_opacity(snapshot_ptr, opacity)
    
    }

    /// Creates a node that repeats the child node.
    /// 
    /// The child is recorded until the next call to [method`Gtk.Snapshot.pop`].
    @inlinable func pushRepeat(bounds: UnsafePointer<graphene_rect_t>!, childBounds: UnsafePointer<graphene_rect_t>? = nil) {
        gtk_snapshot_push_repeat(snapshot_ptr, bounds, childBounds)
    
    }

    /// Clips an image to a rounded rectangle.
    /// 
    /// The image is recorded until the next call to [method`Gtk.Snapshot.pop`].
    @inlinable func pushRoundedClip(bounds: UnsafePointer<GskRoundedRect>!) {
        gtk_snapshot_push_rounded_clip(snapshot_ptr, bounds)
    
    }

    /// Applies a shadow to an image.
    /// 
    /// The image is recorded until the next call to [method`Gtk.Snapshot.pop`].
    @inlinable func push(shadow: UnsafePointer<GskShadow>!, nShadows: Int) {
        gtk_snapshot_push_shadow(snapshot_ptr, shadow, gsize(nShadows))
    
    }

    /// Creates a render node for the CSS background according to `context`,
    /// and appends it to the current node of `snapshot`, without changing
    /// the current node.
    @inlinable func renderBackground<StyleContextT: StyleContextProtocol>(context: StyleContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_snapshot_render_background(snapshot_ptr, context.style_context_ptr, x, y, width, height)
    
    }

    /// Creates a render node for the focus outline according to `context`,
    /// and appends it to the current node of `snapshot`, without changing
    /// the current node.
    @inlinable func renderFocus<StyleContextT: StyleContextProtocol>(context: StyleContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_snapshot_render_focus(snapshot_ptr, context.style_context_ptr, x, y, width, height)
    
    }

    /// Creates a render node for the CSS border according to `context`,
    /// and appends it to the current node of `snapshot`, without changing
    /// the current node.
    @inlinable func renderFrame<StyleContextT: StyleContextProtocol>(context: StyleContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_snapshot_render_frame(snapshot_ptr, context.style_context_ptr, x, y, width, height)
    
    }

    /// Draws a text caret using `snapshot` at the specified index of `layout`.
    @inlinable func renderInsertionCursor<LayoutT: Pango.LayoutProtocol, StyleContextT: StyleContextProtocol>(context: StyleContextT, x: CDouble, y: CDouble, layout: LayoutT, index: Int, direction: PangoDirection) {
        gtk_snapshot_render_insertion_cursor(snapshot_ptr, context.style_context_ptr, x, y, layout.layout_ptr, gint(index), direction)
    
    }

    /// Creates a render node for rendering `layout` according to the style
    /// information in `context`, and appends it to the current node of `snapshot`,
    /// without changing the current node.
    @inlinable func renderLayout<LayoutT: Pango.LayoutProtocol, StyleContextT: StyleContextProtocol>(context: StyleContextT, x: CDouble, y: CDouble, layout: LayoutT) {
        gtk_snapshot_render_layout(snapshot_ptr, context.style_context_ptr, x, y, layout.layout_ptr)
    
    }

    /// Restores `snapshot` to the state saved by a preceding call to
    /// `gtk_snapshot_save()` and removes that state from the stack of
    /// saved states.
    @inlinable func restore() {
        gtk_snapshot_restore(snapshot_ptr)
    
    }

    /// Rotates @`snapshot`'s coordinate system by `angle` degrees in 2D space -
    /// or in 3D speak, rotates around the Z axis.
    /// 
    /// To rotate around other axes, use [method`Gsk.Transform.rotate_3d`].
    @inlinable func rotate(angle: CFloat) {
        gtk_snapshot_rotate(snapshot_ptr, angle)
    
    }

    /// Rotates `snapshot`'s coordinate system by `angle` degrees around `axis`.
    /// 
    /// For a rotation in 2D space, use [method`Gsk.Transform.rotate`].
    @inlinable func rotate3d(angle: CFloat, axis: UnsafePointer<graphene_vec3_t>!) {
        gtk_snapshot_rotate_3d(snapshot_ptr, angle, axis)
    
    }

    /// Makes a copy of the current state of `snapshot` and saves it
    /// on an internal stack.
    /// 
    /// When [method`Gtk.Snapshot.restore`] is called, `snapshot` will
    /// be restored to the saved state. Multiple calls to
    /// `gtk_snapshot_save()` and `gtk_snapshot_restore()` can be nested;
    /// each call to `gtk_snapshot_restore()` restores the state from
    /// the matching paired `gtk_snapshot_save()`.
    /// 
    /// It is necessary to clear all saved states with corresponding
    /// calls to `gtk_snapshot_restore()`.
    @inlinable func save() {
        gtk_snapshot_save(snapshot_ptr)
    
    }

    /// Scales `snapshot`'s coordinate system in 2-dimensional space by
    /// the given factors.
    /// 
    /// Use [method`Gtk.Snapshot.scale_3d`] to scale in all 3 dimensions.
    @inlinable func scale(factorX: CFloat, factorY: CFloat) {
        gtk_snapshot_scale(snapshot_ptr, factorX, factorY)
    
    }

    /// Scales `snapshot`'s coordinate system by the given factors.
    @inlinable func scale3d(factorX: CFloat, factorY: CFloat, factorZ: CFloat) {
        gtk_snapshot_scale_3d(snapshot_ptr, factorX, factorY, factorZ)
    
    }

    /// Returns the render node that was constructed
    /// by `snapshot`.
    /// 
    /// After calling this function, it is no longer possible to
    /// add more nodes to `snapshot`. The only function that should
    /// be called after this is `g_object_unref()`.
    @inlinable func toNode() -> UnsafeMutablePointer<GskRenderNode>! {
        let rv = gtk_snapshot_to_node(snapshot_ptr)
        return rv
    }

    /// Returns a paintable encapsulating the render node
    /// that was constructed by `snapshot`.
    /// 
    /// After calling this function, it is no longer possible to
    /// add more nodes to `snapshot`. The only function that should
    /// be called after this is `g_object_unref()`.
    @inlinable func toPaintable(size: UnsafePointer<graphene_size_t>? = nil) -> Gdk.PaintableRef! {
        let rv = Gdk.PaintableRef(gtk_snapshot_to_paintable(snapshot_ptr, size))
        return rv
    }

    /// Transforms `snapshot`'s coordinate system with the given `transform`.
    @inlinable func transform(transform: UnsafeMutablePointer<GskTransform>? = nil) {
        gtk_snapshot_transform(snapshot_ptr, transform)
    
    }

    /// Transforms `snapshot`'s coordinate system with the given `matrix`.
    @inlinable func transform(matrix: UnsafePointer<graphene_matrix_t>!) {
        gtk_snapshot_transform_matrix(snapshot_ptr, matrix)
    
    }

    /// Translates `snapshot`'s coordinate system by `point` in 2-dimensional space.
    @inlinable func translate(point: UnsafePointer<graphene_point_t>!) {
        gtk_snapshot_translate(snapshot_ptr, point)
    
    }

    /// Translates `snapshot`'s coordinate system by `point`.
    @inlinable func translate3d(point: UnsafePointer<graphene_point3d_t>!) {
        gtk_snapshot_translate_3d(snapshot_ptr, point)
    
    }


}



// MARK: - SortListModel Class

/// The `SortListModelProtocol` protocol exposes the methods and properties of an underlying `GtkSortListModel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SortListModel`.
/// Alternatively, use `SortListModelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSortListModel` is a list model that sorts the elements of
/// the underlying model according to a `GtkSorter`.
/// 
/// The model can be set up to do incremental sorting, so that
/// sorting long lists doesn't block the UI. See
/// [method`Gtk.SortListModel.set_incremental`] for details.
/// 
/// `GtkSortListModel` is a generic model and because of that it
/// cannot take advantage of any external knowledge when sorting.
/// If you run into performance issues with `GtkSortListModel`,
/// it is strongly recommended that you write your own sorting list
/// model.
public protocol SortListModelProtocol: GLibObject.ObjectProtocol, GIO.ListModelProtocol {
        /// Untyped pointer to the underlying `GtkSortListModel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSortListModel` instance.
    var sort_list_model_ptr: UnsafeMutablePointer<GtkSortListModel>! { get }

    /// Required Initialiser for types conforming to `SortListModelProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SortListModelRef` type acts as a lightweight Swift reference to an underlying `GtkSortListModel` instance.
/// It exposes methods that can operate on this data type through `SortListModelProtocol` conformance.
/// Use `SortListModelRef` only as an `unowned` reference to an existing `GtkSortListModel` instance.
///
/// `GtkSortListModel` is a list model that sorts the elements of
/// the underlying model according to a `GtkSorter`.
/// 
/// The model can be set up to do incremental sorting, so that
/// sorting long lists doesn't block the UI. See
/// [method`Gtk.SortListModel.set_incremental`] for details.
/// 
/// `GtkSortListModel` is a generic model and because of that it
/// cannot take advantage of any external knowledge when sorting.
/// If you run into performance issues with `GtkSortListModel`,
/// it is strongly recommended that you write your own sorting list
/// model.
public struct SortListModelRef: SortListModelProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSortListModel` instance.
    /// For type-safe access, use the generated, typed pointer `sort_list_model_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SortListModelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSortListModel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSortListModel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSortListModel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSortListModel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SortListModelProtocol`
    @inlinable init<T: SortListModelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SortListModelProtocol>(_ other: T) -> SortListModelRef { SortListModelRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new sort list model that uses the `sorter` to sort `model`.
    @inlinable init<ListModelT: GIO.ListModelProtocol, SorterT: SorterProtocol>( model: ListModelT?, sorter: SorterT?) {
        let rv = gtk_sort_list_model_new(model?.list_model_ptr, sorter?.sorter_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `SortListModel` type acts as a reference-counted owner of an underlying `GtkSortListModel` instance.
/// It provides the methods that can operate on this data type through `SortListModelProtocol` conformance.
/// Use `SortListModel` as a strong reference or owner of a `GtkSortListModel` instance.
///
/// `GtkSortListModel` is a list model that sorts the elements of
/// the underlying model according to a `GtkSorter`.
/// 
/// The model can be set up to do incremental sorting, so that
/// sorting long lists doesn't block the UI. See
/// [method`Gtk.SortListModel.set_incremental`] for details.
/// 
/// `GtkSortListModel` is a generic model and because of that it
/// cannot take advantage of any external knowledge when sorting.
/// If you run into performance issues with `GtkSortListModel`,
/// it is strongly recommended that you write your own sorting list
/// model.
open class SortListModel: GLibObject.Object, SortListModelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSortListModel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSortListModel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSortListModel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSortListModel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSortListModel`.
    /// i.e., ownership is transferred to the `SortListModel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSortListModel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SortListModelProtocol`
    /// Will retain `GtkSortListModel`.
    /// - Parameter other: an instance of a related type that implements `SortListModelProtocol`
    @inlinable public init<T: SortListModelProtocol>(sortListModel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SortListModelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new sort list model that uses the `sorter` to sort `model`.
    @inlinable public init<ListModelT: GIO.ListModelProtocol, SorterT: SorterProtocol>( model: ListModelT?, sorter: SorterT?) {
        let rv = gtk_sort_list_model_new(model?.list_model_ptr, sorter?.sorter_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SortListModelPropertyName: String, PropertyNameProtocol {
    /// If the model should sort items incrementally.
    case incremental = "incremental"
    /// The model being sorted.
    case model = "model"
    /// Estimate of unsorted items remaining.
    case pending = "pending"
    /// The sorter for this model.
    case sorter = "sorter"
}

public extension SortListModelProtocol {
    /// Bind a `SortListModelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SortListModelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SortListModel property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SortListModelPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SortListModel property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SortListModelPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SortListModelSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// If the model should sort items incrementally.
    case notifyIncremental = "notify::incremental"
    /// The model being sorted.
    case notifyModel = "notify::model"
    /// Estimate of unsorted items remaining.
    case notifyPending = "notify::pending"
    /// The sorter for this model.
    case notifySorter = "notify::sorter"
}

// MARK: SortListModel has no signals
// MARK: SortListModel Class: SortListModelProtocol extension (methods and fields)
public extension SortListModelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSortListModel` instance.
    @inlinable var sort_list_model_ptr: UnsafeMutablePointer<GtkSortListModel>! { return ptr?.assumingMemoryBound(to: GtkSortListModel.self) }

    /// Returns whether incremental sorting is enabled.
    /// 
    /// See [method`Gtk.SortListModel.set_incremental`].
    @inlinable func getIncremental() -> Bool {
        let rv = ((gtk_sort_list_model_get_incremental(sort_list_model_ptr)) != 0)
        return rv
    }

    /// Gets the model currently sorted or `nil` if none.
    @inlinable func getModel() -> GIO.ListModelRef! {
        let rv = GIO.ListModelRef(gtk_sort_list_model_get_model(sort_list_model_ptr))
        return rv
    }

    /// Estimates progress of an ongoing sorting operation.
    /// 
    /// The estimate is the number of items that would still need to be
    /// sorted to finish the sorting operation if this was a linear
    /// algorithm. So this number is not related to how many items are
    /// already correctly sorted.
    /// 
    /// If you want to estimate the progress, you can use code like this:
    /// ```c
    /// pending = gtk_sort_list_model_get_pending (self);
    /// model = gtk_sort_list_model_get_model (self);
    /// progress = 1.0 - pending / (double) MAX (1, g_list_model_get_n_items (model));
    /// ```
    /// 
    /// If no sort operation is ongoing - in particular when
    /// [property`Gtk.SortListModel:incremental`] is `false` - this
    /// function returns 0.
    @inlinable func getPending() -> Int {
        let rv = Int(gtk_sort_list_model_get_pending(sort_list_model_ptr))
        return rv
    }

    /// Gets the sorter that is used to sort `self`.
    @inlinable func getSorter() -> SorterRef! {
        let rv = SorterRef(gconstpointer: gconstpointer(gtk_sort_list_model_get_sorter(sort_list_model_ptr)))
        return rv
    }

    /// Sets the sort model to do an incremental sort.
    /// 
    /// When incremental sorting is enabled, the `GtkSortListModel` will not do
    /// a complete sort immediately, but will instead queue an idle handler that
    /// incrementally sorts the items towards their correct position. This of
    /// course means that items do not instantly appear in the right place. It
    /// also means that the total sorting time is a lot slower.
    /// 
    /// When your filter blocks the UI while sorting, you might consider
    /// turning this on. Depending on your model and sorters, this may become
    /// interesting around 10,000 to 100,000 items.
    /// 
    /// By default, incremental sorting is disabled.
    /// 
    /// See [method`Gtk.SortListModel.get_pending`] for progress information
    /// about an ongoing incremental sorting operation.
    @inlinable func set(incremental: Bool) {
        gtk_sort_list_model_set_incremental(sort_list_model_ptr, gboolean((incremental) ? 1 : 0))
    
    }

    /// Sets the model to be sorted.
    /// 
    /// The `model`'s item type must conform to the item type of `self`.
    @inlinable func set(model: GIO.ListModelRef? = nil) {
        gtk_sort_list_model_set_model(sort_list_model_ptr, model?.list_model_ptr)
    
    }
    /// Sets the model to be sorted.
    /// 
    /// The `model`'s item type must conform to the item type of `self`.
    @inlinable func set<ListModelT: GIO.ListModelProtocol>(model: ListModelT?) {
        gtk_sort_list_model_set_model(sort_list_model_ptr, model?.list_model_ptr)
    
    }

    /// Sets a new sorter on `self`.
    @inlinable func set(sorter: SorterRef? = nil) {
        gtk_sort_list_model_set_sorter(sort_list_model_ptr, sorter?.sorter_ptr)
    
    }
    /// Sets a new sorter on `self`.
    @inlinable func set<SorterT: SorterProtocol>(sorter: SorterT?) {
        gtk_sort_list_model_set_sorter(sort_list_model_ptr, sorter?.sorter_ptr)
    
    }
    /// If the model should sort items incrementally.
    @inlinable var incremental: Bool {
        /// Returns whether incremental sorting is enabled.
        /// 
        /// See [method`Gtk.SortListModel.set_incremental`].
        get {
            let rv = ((gtk_sort_list_model_get_incremental(sort_list_model_ptr)) != 0)
            return rv
        }
        /// Sets the sort model to do an incremental sort.
        /// 
        /// When incremental sorting is enabled, the `GtkSortListModel` will not do
        /// a complete sort immediately, but will instead queue an idle handler that
        /// incrementally sorts the items towards their correct position. This of
        /// course means that items do not instantly appear in the right place. It
        /// also means that the total sorting time is a lot slower.
        /// 
        /// When your filter blocks the UI while sorting, you might consider
        /// turning this on. Depending on your model and sorters, this may become
        /// interesting around 10,000 to 100,000 items.
        /// 
        /// By default, incremental sorting is disabled.
        /// 
        /// See [method`Gtk.SortListModel.get_pending`] for progress information
        /// about an ongoing incremental sorting operation.
        nonmutating set {
            gtk_sort_list_model_set_incremental(sort_list_model_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The model being sorted.
    @inlinable var model: GIO.ListModelRef! {
        /// Gets the model currently sorted or `nil` if none.
        get {
            let rv = GIO.ListModelRef(gtk_sort_list_model_get_model(sort_list_model_ptr))
            return rv
        }
        /// Sets the model to be sorted.
        /// 
        /// The `model`'s item type must conform to the item type of `self`.
        nonmutating set {
            gtk_sort_list_model_set_model(sort_list_model_ptr, UnsafeMutablePointer<GListModel>(newValue?.list_model_ptr))
        }
    }

    /// Estimate of unsorted items remaining.
    @inlinable var pending: Int {
        /// Estimates progress of an ongoing sorting operation.
        /// 
        /// The estimate is the number of items that would still need to be
        /// sorted to finish the sorting operation if this was a linear
        /// algorithm. So this number is not related to how many items are
        /// already correctly sorted.
        /// 
        /// If you want to estimate the progress, you can use code like this:
        /// ```c
        /// pending = gtk_sort_list_model_get_pending (self);
        /// model = gtk_sort_list_model_get_model (self);
        /// progress = 1.0 - pending / (double) MAX (1, g_list_model_get_n_items (model));
        /// ```
        /// 
        /// If no sort operation is ongoing - in particular when
        /// [property`Gtk.SortListModel:incremental`] is `false` - this
        /// function returns 0.
        get {
            let rv = Int(gtk_sort_list_model_get_pending(sort_list_model_ptr))
            return rv
        }
    }

    /// The sorter for this model.
    @inlinable var sorter: SorterRef! {
        /// Gets the sorter that is used to sort `self`.
        get {
            let rv = SorterRef(gconstpointer: gconstpointer(gtk_sort_list_model_get_sorter(sort_list_model_ptr)))
            return rv
        }
        /// Sets a new sorter on `self`.
        nonmutating set {
            gtk_sort_list_model_set_sorter(sort_list_model_ptr, UnsafeMutablePointer<GtkSorter>(newValue?.sorter_ptr))
        }
    }


}



// MARK: - Sorter Class

/// The `SorterProtocol` protocol exposes the methods and properties of an underlying `GtkSorter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Sorter`.
/// Alternatively, use `SorterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSorter` is an object to describe sorting criteria.
/// 
/// Its primary user is [class`Gtk.SortListModel`]
/// 
/// The model will use a sorter to determine the order in which
/// its items should appear by calling [method`Gtk.Sorter.compare`]
/// for pairs of items.
/// 
/// Sorters may change their sorting behavior through their lifetime.
/// In that case, they will emit the [signal`Gtk.Sorter::changed`] signal
/// to notify that the sort order is no longer valid and should be updated
/// by calling `gtk_sorter_compare()` again.
/// 
/// GTK provides various pre-made sorter implementations for common sorting
/// operations. [class`Gtk.ColumnView`] has built-in support for sorting lists
/// via the [property`Gtk.ColumnViewColumn:sorter`] property, where the user can
/// change the sorting by clicking on list headers.
/// 
/// Of course, in particular for large lists, it is also possible to subclass
/// `GtkSorter` and provide one's own sorter.
public protocol SorterProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkSorter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSorter` instance.
    var sorter_ptr: UnsafeMutablePointer<GtkSorter>! { get }

    /// Required Initialiser for types conforming to `SorterProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SorterRef` type acts as a lightweight Swift reference to an underlying `GtkSorter` instance.
/// It exposes methods that can operate on this data type through `SorterProtocol` conformance.
/// Use `SorterRef` only as an `unowned` reference to an existing `GtkSorter` instance.
///
/// `GtkSorter` is an object to describe sorting criteria.
/// 
/// Its primary user is [class`Gtk.SortListModel`]
/// 
/// The model will use a sorter to determine the order in which
/// its items should appear by calling [method`Gtk.Sorter.compare`]
/// for pairs of items.
/// 
/// Sorters may change their sorting behavior through their lifetime.
/// In that case, they will emit the [signal`Gtk.Sorter::changed`] signal
/// to notify that the sort order is no longer valid and should be updated
/// by calling `gtk_sorter_compare()` again.
/// 
/// GTK provides various pre-made sorter implementations for common sorting
/// operations. [class`Gtk.ColumnView`] has built-in support for sorting lists
/// via the [property`Gtk.ColumnViewColumn:sorter`] property, where the user can
/// change the sorting by clicking on list headers.
/// 
/// Of course, in particular for large lists, it is also possible to subclass
/// `GtkSorter` and provide one's own sorter.
public struct SorterRef: SorterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSorter` instance.
    /// For type-safe access, use the generated, typed pointer `sorter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SorterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSorter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSorter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSorter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SorterProtocol`
    @inlinable init<T: SorterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SorterProtocol>(_ other: T) -> SorterRef { SorterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `Sorter` type acts as a reference-counted owner of an underlying `GtkSorter` instance.
/// It provides the methods that can operate on this data type through `SorterProtocol` conformance.
/// Use `Sorter` as a strong reference or owner of a `GtkSorter` instance.
///
/// `GtkSorter` is an object to describe sorting criteria.
/// 
/// Its primary user is [class`Gtk.SortListModel`]
/// 
/// The model will use a sorter to determine the order in which
/// its items should appear by calling [method`Gtk.Sorter.compare`]
/// for pairs of items.
/// 
/// Sorters may change their sorting behavior through their lifetime.
/// In that case, they will emit the [signal`Gtk.Sorter::changed`] signal
/// to notify that the sort order is no longer valid and should be updated
/// by calling `gtk_sorter_compare()` again.
/// 
/// GTK provides various pre-made sorter implementations for common sorting
/// operations. [class`Gtk.ColumnView`] has built-in support for sorting lists
/// via the [property`Gtk.ColumnViewColumn:sorter`] property, where the user can
/// change the sorting by clicking on list headers.
/// 
/// Of course, in particular for large lists, it is also possible to subclass
/// `GtkSorter` and provide one's own sorter.
open class Sorter: GLibObject.Object, SorterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSorter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSorter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSorter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSorter`.
    /// i.e., ownership is transferred to the `Sorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSorter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SorterProtocol`
    /// Will retain `GtkSorter`.
    /// - Parameter other: an instance of a related type that implements `SorterProtocol`
    @inlinable public init<T: SorterProtocol>(sorter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no Sorter properties

public enum SorterSignalName: String, SignalNameProtocol {
    /// Emitted whenever the sorter changed.
    /// 
    /// Users of the sorter should then update the sort order
    /// again via `gtk_sorter_compare()`.
    /// 
    /// [class`Gtk.SortListModel`] handles this signal automatically.
    /// 
    /// Depending on the `change` parameter, it may be possible to update
    /// the sort order without a full resorting. Refer to the
    /// [enum`Gtk.SorterChange`] documentation for details.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: Sorter signals
public extension SorterProtocol {
    /// Connect a Swift signal handler to the given, typed `SorterSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: SorterSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `SorterSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: SorterSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted whenever the sorter changed.
    /// 
    /// Users of the sorter should then update the sort order
    /// again via `gtk_sorter_compare()`.
    /// 
    /// [class`Gtk.SortListModel`] handles this signal automatically.
    /// 
    /// Depending on the `change` parameter, it may be possible to update
    /// the sort order without a full resorting. Refer to the
    /// [enum`Gtk.SorterChange`] documentation for details.
    /// - Note: This represents the underlying `changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter change: how the sorter changed
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `changed` signal is emitted
    @discardableResult @inlinable func onChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SorterRef, _ change: SorterChange) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SorterRef, SorterChange, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SorterRef(raw: unownedSelf), SorterChange(arg1))
            return output
        }
        return connect(
            signal: .changed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `changed` signal for using the `connect(signal:)` methods
    static var changedSignal: SorterSignalName { .changed }
    
    
}

// MARK: Sorter Class: SorterProtocol extension (methods and fields)
public extension SorterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSorter` instance.
    @inlinable var sorter_ptr: UnsafeMutablePointer<GtkSorter>! { return ptr?.assumingMemoryBound(to: GtkSorter.self) }

    /// Emits the [signal`Gtk.Sorter::changed`] signal to notify all users
    /// of the sorter that it has changed.
    /// 
    /// Users of the sorter should then update the sort order via
    /// `gtk_sorter_compare()`.
    /// 
    /// Depending on the `change` parameter, it may be possible to update
    /// the sort order without a full resorting. Refer to the
    /// [enum`Gtk.SorterChange`] documentation for details.
    /// 
    /// This function is intended for implementors of `GtkSorter`
    /// subclasses and should not be called from other functions.
    @inlinable func changed(change: GtkSorterChange) {
        gtk_sorter_changed(sorter_ptr, change)
    
    }

    /// Compares two given items according to the sort order implemented
    /// by the sorter.
    /// 
    /// Sorters implement a partial order:
    /// 
    /// * It is reflexive, ie a = a
    /// * It is antisymmetric, ie if a &lt; b and b &lt; a, then a = b
    /// * It is transitive, ie given any 3 items with a ≤ b and b ≤ c,
    ///   then a ≤ c
    /// 
    /// The sorter may signal it conforms to additional constraints
    /// via the return value of [method`Gtk.Sorter.get_order`].
    @inlinable func compare<ObjectT: GLibObject.ObjectProtocol>(item1: ObjectT, item2: ObjectT) -> GtkOrdering {
        let rv = gtk_sorter_compare(sorter_ptr, item1.object_ptr, item2.object_ptr)
        return rv
    }

    /// Gets the order that `self` conforms to.
    /// 
    /// See [enum`Gtk.SorterOrder`] for details
    /// of the possible return values.
    /// 
    /// This function is intended to allow optimizations.
    @inlinable func getOrder() -> GtkSorterOrder {
        let rv = gtk_sorter_get_order(sorter_ptr)
        return rv
    }
    /// Gets the order that `self` conforms to.
    /// 
    /// See [enum`Gtk.SorterOrder`] for details
    /// of the possible return values.
    /// 
    /// This function is intended to allow optimizations.
    @inlinable var order: GtkSorterOrder {
        /// Gets the order that `self` conforms to.
        /// 
        /// See [enum`Gtk.SorterOrder`] for details
        /// of the possible return values.
        /// 
        /// This function is intended to allow optimizations.
        get {
            let rv = gtk_sorter_get_order(sorter_ptr)
            return rv
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = sorter_ptr.pointee.parent_instance
            return rv
        }
    }

}



// MARK: - SpinButton Class

/// The `SpinButtonProtocol` protocol exposes the methods and properties of an underlying `GtkSpinButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `SpinButton`.
/// Alternatively, use `SpinButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkSpinButton` is an ideal way to allow the user to set the
/// value of some attribute.
/// 
/// ![An example GtkSpinButton](spinbutton.png)
/// 
/// Rather than having to directly type a number into a `GtkEntry`,
/// `GtkSpinButton` allows the user to click on one of two arrows
/// to increment or decrement the displayed value. A value can still be
/// typed in, with the bonus that it can be checked to ensure it is in a
/// given range.
/// 
/// The main properties of a `GtkSpinButton` are through an adjustment.
/// See the [class`Gtk.Adjustment`] documentation for more details about
/// an adjustment's properties.
/// 
/// Note that `GtkSpinButton` will by default make its entry large enough
/// to accommodate the lower and upper bounds of the adjustment. If this
/// is not desired, the automatic sizing can be turned off by explicitly
/// setting [property`Gtk.Editable:width-chars`] to a value != -1.
/// 
/// ## Using a GtkSpinButton to get an integer
/// 
/// ```c
/// // Provides a function to retrieve an integer value from a GtkSpinButton
/// // and creates a spin button to model percentage values.
/// 
/// int
/// grab_int_value (GtkSpinButton *button,
///                 gpointer       user_data)
/// {
///   return gtk_spin_button_get_value_as_int (button);
/// }
/// 
/// void
/// create_integer_spin_button (void)
/// {
/// 
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
/// 
///   adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
/// 
///   window = gtk_window_new ();
/// 
///   // creates the spinbutton, with no decimal places
///   button = gtk_spin_button_new (adjustment, 1.0, 0);
///   gtk_window_set_child (GTK_WINDOW (window), button);
/// 
///   gtk_widget_show (window);
/// }
/// ```
/// 
/// ## Using a GtkSpinButton to get a floating point value
/// 
/// ```c
/// // Provides a function to retrieve a floating point value from a
/// // GtkSpinButton, and creates a high precision spin button.
/// 
/// float
/// grab_float_value (GtkSpinButton *button,
///                   gpointer       user_data)
/// {
///   return gtk_spin_button_get_value (button);
/// }
/// 
/// void
/// create_floating_spin_button (void)
/// {
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
/// 
///   adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
/// 
///   window = gtk_window_new ();
/// 
///   // creates the spinbutton, with three decimal places
///   button = gtk_spin_button_new (adjustment, 0.001, 3);
///   gtk_window_set_child (GTK_WINDOW (window), button);
/// 
///   gtk_widget_show (window);
/// }
/// ```
/// 
/// # CSS nodes
/// 
/// ```
/// spinbutton.horizontal
/// ├── text
/// │    ├── undershoot.left
/// │    ╰── undershoot.right
/// ├── button.down
/// ╰── button.up
/// ```
/// 
/// ```
/// spinbutton.vertical
/// ├── button.up
/// ├── text
/// │    ├── undershoot.left
/// │    ╰── undershoot.right
/// ╰── button.down
/// ```
/// 
/// `GtkSpinButton`s main CSS node has the name spinbutton. It creates subnodes
/// for the entry and the two buttons, with these names. The button nodes have
/// the style classes .up and .down. The `GtkText` subnodes (if present) are put
/// below the text node. The orientation of the spin button is reflected in
/// the .vertical or .horizontal style class on the main node.
/// 
/// # Accessiblity
/// 
/// `GtkSpinButton` uses the `GTK_ACCESSIBLE_ROLE_SPIN_BUTTON` role.
public protocol SpinButtonProtocol: WidgetProtocol, CellEditableProtocol, EditableProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkSpinButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSpinButton` instance.
    var spin_button_ptr: UnsafeMutablePointer<GtkSpinButton>! { get }

    /// Required Initialiser for types conforming to `SpinButtonProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SpinButtonRef` type acts as a lightweight Swift reference to an underlying `GtkSpinButton` instance.
/// It exposes methods that can operate on this data type through `SpinButtonProtocol` conformance.
/// Use `SpinButtonRef` only as an `unowned` reference to an existing `GtkSpinButton` instance.
///
/// A `GtkSpinButton` is an ideal way to allow the user to set the
/// value of some attribute.
/// 
/// ![An example GtkSpinButton](spinbutton.png)
/// 
/// Rather than having to directly type a number into a `GtkEntry`,
/// `GtkSpinButton` allows the user to click on one of two arrows
/// to increment or decrement the displayed value. A value can still be
/// typed in, with the bonus that it can be checked to ensure it is in a
/// given range.
/// 
/// The main properties of a `GtkSpinButton` are through an adjustment.
/// See the [class`Gtk.Adjustment`] documentation for more details about
/// an adjustment's properties.
/// 
/// Note that `GtkSpinButton` will by default make its entry large enough
/// to accommodate the lower and upper bounds of the adjustment. If this
/// is not desired, the automatic sizing can be turned off by explicitly
/// setting [property`Gtk.Editable:width-chars`] to a value != -1.
/// 
/// ## Using a GtkSpinButton to get an integer
/// 
/// ```c
/// // Provides a function to retrieve an integer value from a GtkSpinButton
/// // and creates a spin button to model percentage values.
/// 
/// int
/// grab_int_value (GtkSpinButton *button,
///                 gpointer       user_data)
/// {
///   return gtk_spin_button_get_value_as_int (button);
/// }
/// 
/// void
/// create_integer_spin_button (void)
/// {
/// 
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
/// 
///   adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
/// 
///   window = gtk_window_new ();
/// 
///   // creates the spinbutton, with no decimal places
///   button = gtk_spin_button_new (adjustment, 1.0, 0);
///   gtk_window_set_child (GTK_WINDOW (window), button);
/// 
///   gtk_widget_show (window);
/// }
/// ```
/// 
/// ## Using a GtkSpinButton to get a floating point value
/// 
/// ```c
/// // Provides a function to retrieve a floating point value from a
/// // GtkSpinButton, and creates a high precision spin button.
/// 
/// float
/// grab_float_value (GtkSpinButton *button,
///                   gpointer       user_data)
/// {
///   return gtk_spin_button_get_value (button);
/// }
/// 
/// void
/// create_floating_spin_button (void)
/// {
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
/// 
///   adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
/// 
///   window = gtk_window_new ();
/// 
///   // creates the spinbutton, with three decimal places
///   button = gtk_spin_button_new (adjustment, 0.001, 3);
///   gtk_window_set_child (GTK_WINDOW (window), button);
/// 
///   gtk_widget_show (window);
/// }
/// ```
/// 
/// # CSS nodes
/// 
/// ```
/// spinbutton.horizontal
/// ├── text
/// │    ├── undershoot.left
/// │    ╰── undershoot.right
/// ├── button.down
/// ╰── button.up
/// ```
/// 
/// ```
/// spinbutton.vertical
/// ├── button.up
/// ├── text
/// │    ├── undershoot.left
/// │    ╰── undershoot.right
/// ╰── button.down
/// ```
/// 
/// `GtkSpinButton`s main CSS node has the name spinbutton. It creates subnodes
/// for the entry and the two buttons, with these names. The button nodes have
/// the style classes .up and .down. The `GtkText` subnodes (if present) are put
/// below the text node. The orientation of the spin button is reflected in
/// the .vertical or .horizontal style class on the main node.
/// 
/// # Accessiblity
/// 
/// `GtkSpinButton` uses the `GTK_ACCESSIBLE_ROLE_SPIN_BUTTON` role.
public struct SpinButtonRef: SpinButtonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSpinButton` instance.
    /// For type-safe access, use the generated, typed pointer `spin_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SpinButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSpinButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSpinButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSpinButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSpinButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SpinButtonProtocol`
    @inlinable init<T: SpinButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SpinButtonProtocol>(_ other: T) -> SpinButtonRef { SpinButtonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSpinButton`.
    @inlinable init<AdjustmentT: AdjustmentProtocol>( adjustment: AdjustmentT?, climbRate: CDouble, digits: Int) {
        let rv = gtk_spin_button_new(adjustment?.adjustment_ptr, climbRate, guint(digits))
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkSpinButton` with the given properties.
    /// 
    /// This is a convenience constructor that allows creation
    /// of a numeric `GtkSpinButton` without manually creating
    /// an adjustment. The value is initially set to the minimum
    /// value and a page increment of 10 * `step` is the default.
    /// The precision of the spin button is equivalent to the
    /// precision of `step`.
    /// 
    /// Note that the way in which the precision is derived works
    /// best if `step` is a power of ten. If the resulting precision
    /// is not suitable for your needs, use
    /// [method`Gtk.SpinButton.set_digits`] to correct it.
    @inlinable init(range min: CDouble, max: CDouble, step: CDouble) {
        let rv = gtk_spin_button_new_with_range(min, max, step)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkSpinButton` with the given properties.
    /// 
    /// This is a convenience constructor that allows creation
    /// of a numeric `GtkSpinButton` without manually creating
    /// an adjustment. The value is initially set to the minimum
    /// value and a page increment of 10 * `step` is the default.
    /// The precision of the spin button is equivalent to the
    /// precision of `step`.
    /// 
    /// Note that the way in which the precision is derived works
    /// best if `step` is a power of ten. If the resulting precision
    /// is not suitable for your needs, use
    /// [method`Gtk.SpinButton.set_digits`] to correct it.
    @inlinable static func newWith(range min: CDouble, max: CDouble, step: CDouble) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_spin_button_new_with_range(min, max, step))) else { return nil }
        return rv
    }
}

/// The `SpinButton` type acts as a reference-counted owner of an underlying `GtkSpinButton` instance.
/// It provides the methods that can operate on this data type through `SpinButtonProtocol` conformance.
/// Use `SpinButton` as a strong reference or owner of a `GtkSpinButton` instance.
///
/// A `GtkSpinButton` is an ideal way to allow the user to set the
/// value of some attribute.
/// 
/// ![An example GtkSpinButton](spinbutton.png)
/// 
/// Rather than having to directly type a number into a `GtkEntry`,
/// `GtkSpinButton` allows the user to click on one of two arrows
/// to increment or decrement the displayed value. A value can still be
/// typed in, with the bonus that it can be checked to ensure it is in a
/// given range.
/// 
/// The main properties of a `GtkSpinButton` are through an adjustment.
/// See the [class`Gtk.Adjustment`] documentation for more details about
/// an adjustment's properties.
/// 
/// Note that `GtkSpinButton` will by default make its entry large enough
/// to accommodate the lower and upper bounds of the adjustment. If this
/// is not desired, the automatic sizing can be turned off by explicitly
/// setting [property`Gtk.Editable:width-chars`] to a value != -1.
/// 
/// ## Using a GtkSpinButton to get an integer
/// 
/// ```c
/// // Provides a function to retrieve an integer value from a GtkSpinButton
/// // and creates a spin button to model percentage values.
/// 
/// int
/// grab_int_value (GtkSpinButton *button,
///                 gpointer       user_data)
/// {
///   return gtk_spin_button_get_value_as_int (button);
/// }
/// 
/// void
/// create_integer_spin_button (void)
/// {
/// 
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
/// 
///   adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
/// 
///   window = gtk_window_new ();
/// 
///   // creates the spinbutton, with no decimal places
///   button = gtk_spin_button_new (adjustment, 1.0, 0);
///   gtk_window_set_child (GTK_WINDOW (window), button);
/// 
///   gtk_widget_show (window);
/// }
/// ```
/// 
/// ## Using a GtkSpinButton to get a floating point value
/// 
/// ```c
/// // Provides a function to retrieve a floating point value from a
/// // GtkSpinButton, and creates a high precision spin button.
/// 
/// float
/// grab_float_value (GtkSpinButton *button,
///                   gpointer       user_data)
/// {
///   return gtk_spin_button_get_value (button);
/// }
/// 
/// void
/// create_floating_spin_button (void)
/// {
///   GtkWidget *window, *button;
///   GtkAdjustment *adjustment;
/// 
///   adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
/// 
///   window = gtk_window_new ();
/// 
///   // creates the spinbutton, with three decimal places
///   button = gtk_spin_button_new (adjustment, 0.001, 3);
///   gtk_window_set_child (GTK_WINDOW (window), button);
/// 
///   gtk_widget_show (window);
/// }
/// ```
/// 
/// # CSS nodes
/// 
/// ```
/// spinbutton.horizontal
/// ├── text
/// │    ├── undershoot.left
/// │    ╰── undershoot.right
/// ├── button.down
/// ╰── button.up
/// ```
/// 
/// ```
/// spinbutton.vertical
/// ├── button.up
/// ├── text
/// │    ├── undershoot.left
/// │    ╰── undershoot.right
/// ╰── button.down
/// ```
/// 
/// `GtkSpinButton`s main CSS node has the name spinbutton. It creates subnodes
/// for the entry and the two buttons, with these names. The button nodes have
/// the style classes .up and .down. The `GtkText` subnodes (if present) are put
/// below the text node. The orientation of the spin button is reflected in
/// the .vertical or .horizontal style class on the main node.
/// 
/// # Accessiblity
/// 
/// `GtkSpinButton` uses the `GTK_ACCESSIBLE_ROLE_SPIN_BUTTON` role.
open class SpinButton: Widget, SpinButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSpinButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSpinButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSpinButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSpinButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSpinButton`.
    /// i.e., ownership is transferred to the `SpinButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSpinButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SpinButtonProtocol`
    /// Will retain `GtkSpinButton`.
    /// - Parameter other: an instance of a related type that implements `SpinButtonProtocol`
    @inlinable public init<T: SpinButtonProtocol>(spinButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSpinButton`.
    @inlinable public init<AdjustmentT: AdjustmentProtocol>( adjustment: AdjustmentT?, climbRate: CDouble, digits: Int) {
        let rv = gtk_spin_button_new(adjustment?.adjustment_ptr, climbRate, guint(digits))
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkSpinButton` with the given properties.
    /// 
    /// This is a convenience constructor that allows creation
    /// of a numeric `GtkSpinButton` without manually creating
    /// an adjustment. The value is initially set to the minimum
    /// value and a page increment of 10 * `step` is the default.
    /// The precision of the spin button is equivalent to the
    /// precision of `step`.
    /// 
    /// Note that the way in which the precision is derived works
    /// best if `step` is a power of ten. If the resulting precision
    /// is not suitable for your needs, use
    /// [method`Gtk.SpinButton.set_digits`] to correct it.
    @inlinable public init(range min: CDouble, max: CDouble, step: CDouble) {
        let rv = gtk_spin_button_new_with_range(min, max, step)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkSpinButton` with the given properties.
    /// 
    /// This is a convenience constructor that allows creation
    /// of a numeric `GtkSpinButton` without manually creating
    /// an adjustment. The value is initially set to the minimum
    /// value and a page increment of 10 * `step` is the default.
    /// The precision of the spin button is equivalent to the
    /// precision of `step`.
    /// 
    /// Note that the way in which the precision is derived works
    /// best if `step` is a power of ten. If the resulting precision
    /// is not suitable for your needs, use
    /// [method`Gtk.SpinButton.set_digits`] to correct it.
    @inlinable public static func newWith(range min: CDouble, max: CDouble, step: CDouble) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_spin_button_new_with_range(min, max, step))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum SpinButtonPropertyName: String, PropertyNameProtocol {
    /// The adjustment that holds the value of the spin button.
    case adjustment = "adjustment"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The acceleration rate when you hold down a button or key.
    case climbRate = "climb-rate"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// The number of decimal places to display.
    case digits = "digits"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// Whether non-numeric characters should be ignored.
    case numeric = "numeric"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Whether erroneous values are automatically changed to the spin buttons
    /// nearest step increment.
    case snapToTicks = "snap-to-ticks"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// Whether the spin button should update always, or only when the value
    /// is acceptable.
    case updatePolicy = "update-policy"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// The current value.
    case value = "value"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
    /// Whether a spin button should wrap upon reaching its limits.
    case wrap = "wrap"
}

public extension SpinButtonProtocol {
    /// Bind a `SpinButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SpinButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a SpinButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SpinButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a SpinButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SpinButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SpinButtonSignalName: String, SignalNameProtocol {
    /// Emitted when the user initiates a value change.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// The default bindings for this signal are Up/Down and PageUp/PageDown.
    case changeValue = "change-value"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted to convert the users input into a double value.
    /// 
    /// The signal handler is expected to use [method`Gtk.Editable.get_text`]
    /// to retrieve the text of the spinbutton and set `new_value` to the
    /// new value.
    /// 
    /// The default conversion uses `g_strtod()`.
    case input = "input"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted to tweak the formatting of the value for display.
    /// 
    /// ```c
    /// // show leading zeros
    /// static gboolean
    /// on_output (GtkSpinButton *spin,
    ///            gpointer       data)
    /// {
    ///    GtkAdjustment *adjustment;
    ///    char *text;
    ///    int value;
    /// 
    ///    adjustment = gtk_spin_button_get_adjustment (spin);
    ///    value = (int)gtk_adjustment_get_value (adjustment);
    ///    text = g_strdup_printf ("`02d`", value);
    ///    gtk_spin_button_set_text (spin, text):
    ///    g_free (text);
    /// 
    ///    return TRUE;
    /// }
    /// ```
    case output = "output"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Emitted when the value is changed.
    /// 
    /// Also see the [signal`Gtk.SpinButton::output`] signal.
    case valueChanged = "value-changed"
    /// Emitted right after the spinbutton wraps from its maximum
    /// to its minimum value or vice-versa.
    case wrapped = "wrapped"
    /// The adjustment that holds the value of the spin button.
    case notifyAdjustment = "notify::adjustment"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The acceleration rate when you hold down a button or key.
    case notifyClimbRate = "notify::climb-rate"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// The number of decimal places to display.
    case notifyDigits = "notify::digits"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// Whether non-numeric characters should be ignored.
    case notifyNumeric = "notify::numeric"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Whether erroneous values are automatically changed to the spin buttons
    /// nearest step increment.
    case notifySnapToTicks = "notify::snap-to-ticks"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// Whether the spin button should update always, or only when the value
    /// is acceptable.
    case notifyUpdatePolicy = "notify::update-policy"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// The current value.
    case notifyValue = "notify::value"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
    /// Whether a spin button should wrap upon reaching its limits.
    case notifyWrap = "notify::wrap"
}

// MARK: SpinButton signals
public extension SpinButtonProtocol {
    /// Connect a Swift signal handler to the given, typed `SpinButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: SpinButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `SpinButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: SpinButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted to convert the users input into a double value.
    /// 
    /// The signal handler is expected to use [method`Gtk.Editable.get_text`]
    /// to retrieve the text of the spinbutton and set `new_value` to the
    /// new value.
    /// 
    /// The default conversion uses `g_strtod()`.
    /// - Note: This represents the underlying `input` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter newValue: return location for the new value
    /// - Parameter handler: `true` for a successful conversion, `false` if the input   was not handled, and `GTK_INPUT_ERROR` if the conversion failed.
    /// - Warning: a `onInput` wrapper for this signal could not be generated because it contains unimplemented features: { (1) argument with ownership transfer is not allowed, (2)  `out` or `inout` argument direction is not allowed }
    /// - Note: Instead, you can connect `inputSignal` using the `connect(signal:)` methods
    static var inputSignal: SpinButtonSignalName { .input }
    /// Emitted when the user initiates a value change.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// The default bindings for this signal are Up/Down and PageUp/PageDown.
    /// - Note: This represents the underlying `change-value` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter scroll: a `GtkScrollType` to specify the speed and amount of change
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `changeValue` signal is emitted
    @discardableResult @inlinable func onChangeValue(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ scroll: ScrollType) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ScrollType, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ScrollType(arg1))
            return output
        }
        return connect(
            signal: .changeValue,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `change-value` signal for using the `connect(signal:)` methods
    static var changeValueSignal: SpinButtonSignalName { .changeValue }
    
    /// Emitted to tweak the formatting of the value for display.
    /// 
    /// ```c
    /// // show leading zeros
    /// static gboolean
    /// on_output (GtkSpinButton *spin,
    ///            gpointer       data)
    /// {
    ///    GtkAdjustment *adjustment;
    ///    char *text;
    ///    int value;
    /// 
    ///    adjustment = gtk_spin_button_get_adjustment (spin);
    ///    value = (int)gtk_adjustment_get_value (adjustment);
    ///    text = g_strdup_printf ("`02d`", value);
    ///    gtk_spin_button_set_text (spin, text):
    ///    g_free (text);
    /// 
    ///    return TRUE;
    /// }
    /// ```
    /// - Note: This represents the underlying `output` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: `true` if the value has been displayed
    /// Run the given callback whenever the `output` signal is emitted
    @discardableResult @inlinable func onOutput(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SpinButtonRef, Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(SpinButtonRef(raw: unownedSelf))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .output,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `output` signal for using the `connect(signal:)` methods
    static var outputSignal: SpinButtonSignalName { .output }
    
    /// Emitted when the value is changed.
    /// 
    /// Also see the [signal`Gtk.SpinButton::output`] signal.
    /// - Note: This represents the underlying `value-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `valueChanged` signal is emitted
    @discardableResult @inlinable func onValueChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SpinButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .valueChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `value-changed` signal for using the `connect(signal:)` methods
    static var valueChangedSignal: SpinButtonSignalName { .valueChanged }
    
    /// Emitted right after the spinbutton wraps from its maximum
    /// to its minimum value or vice-versa.
    /// - Note: This represents the underlying `wrapped` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `wrapped` signal is emitted
    @discardableResult @inlinable func onWrapped(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SpinButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .wrapped,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `wrapped` signal for using the `connect(signal:)` methods
    static var wrappedSignal: SpinButtonSignalName { .wrapped }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::adjustment` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAdjustment` signal is emitted
    @discardableResult @inlinable func onNotifyAdjustment(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAdjustment,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::adjustment` signal for using the `connect(signal:)` methods
    static var notifyAdjustmentSignal: SpinButtonSignalName { .notifyAdjustment }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::climb-rate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyClimbRate` signal is emitted
    @discardableResult @inlinable func onNotifyClimbRate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyClimbRate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::climb-rate` signal for using the `connect(signal:)` methods
    static var notifyClimbRateSignal: SpinButtonSignalName { .notifyClimbRate }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::digits` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyDigits` signal is emitted
    @discardableResult @inlinable func onNotifyDigits(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyDigits,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::digits` signal for using the `connect(signal:)` methods
    static var notifyDigitsSignal: SpinButtonSignalName { .notifyDigits }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::numeric` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyNumeric` signal is emitted
    @discardableResult @inlinable func onNotifyNumeric(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyNumeric,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::numeric` signal for using the `connect(signal:)` methods
    static var notifyNumericSignal: SpinButtonSignalName { .notifyNumeric }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::snap-to-ticks` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySnapToTicks` signal is emitted
    @discardableResult @inlinable func onNotifySnapToTicks(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySnapToTicks,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::snap-to-ticks` signal for using the `connect(signal:)` methods
    static var notifySnapToTicksSignal: SpinButtonSignalName { .notifySnapToTicks }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::update-policy` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUpdatePolicy` signal is emitted
    @discardableResult @inlinable func onNotifyUpdatePolicy(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyUpdatePolicy,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::update-policy` signal for using the `connect(signal:)` methods
    static var notifyUpdatePolicySignal: SpinButtonSignalName { .notifyUpdatePolicy }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::value` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyValue` signal is emitted
    @discardableResult @inlinable func onNotifyValue(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyValue,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::value` signal for using the `connect(signal:)` methods
    static var notifyValueSignal: SpinButtonSignalName { .notifyValue }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::wrap` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWrap` signal is emitted
    @discardableResult @inlinable func onNotifyWrap(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SpinButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SpinButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SpinButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWrap,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::wrap` signal for using the `connect(signal:)` methods
    static var notifyWrapSignal: SpinButtonSignalName { .notifyWrap }
    
}

// MARK: SpinButton Class: SpinButtonProtocol extension (methods and fields)
public extension SpinButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSpinButton` instance.
    @inlinable var spin_button_ptr: UnsafeMutablePointer<GtkSpinButton>! { return ptr?.assumingMemoryBound(to: GtkSpinButton.self) }

    /// Changes the properties of an existing spin button.
    /// 
    /// The adjustment, climb rate, and number of decimal places
    /// are updated accordingly.
    @inlinable func configure(adjustment: AdjustmentRef? = nil, climbRate: CDouble, digits: Int) {
        gtk_spin_button_configure(spin_button_ptr, adjustment?.adjustment_ptr, climbRate, guint(digits))
    
    }
    /// Changes the properties of an existing spin button.
    /// 
    /// The adjustment, climb rate, and number of decimal places
    /// are updated accordingly.
    @inlinable func configure<AdjustmentT: AdjustmentProtocol>(adjustment: AdjustmentT?, climbRate: CDouble, digits: Int) {
        gtk_spin_button_configure(spin_button_ptr, adjustment?.adjustment_ptr, climbRate, guint(digits))
    
    }

    /// Get the adjustment associated with a `GtkSpinButton`.
    @inlinable func getAdjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_spin_button_get_adjustment(spin_button_ptr)))
        return rv
    }

    /// Returns the acceleration rate for repeated changes.
    @inlinable func getClimbRate() -> CDouble {
        let rv = gtk_spin_button_get_climb_rate(spin_button_ptr)
        return rv
    }

    /// Fetches the precision of `spin_button`.
    @inlinable func getDigits() -> Int {
        let rv = Int(gtk_spin_button_get_digits(spin_button_ptr))
        return rv
    }

    /// Gets the current step and page the increments
    /// used by `spin_button`.
    /// 
    /// See [method`Gtk.SpinButton.set_increments`].
    @inlinable func getIncrements(step: UnsafeMutablePointer<CDouble>! = nil, page: UnsafeMutablePointer<CDouble>! = nil) {
        gtk_spin_button_get_increments(spin_button_ptr, step, page)
    
    }

    /// Returns whether non-numeric text can be typed into the spin button.
    @inlinable func getNumeric() -> Bool {
        let rv = ((gtk_spin_button_get_numeric(spin_button_ptr)) != 0)
        return rv
    }

    /// Gets the range allowed for `spin_button`.
    /// 
    /// See [method`Gtk.SpinButton.set_range`].
    @inlinable func getRange(min: UnsafeMutablePointer<CDouble>! = nil, max: UnsafeMutablePointer<CDouble>! = nil) {
        gtk_spin_button_get_range(spin_button_ptr, min, max)
    
    }

    /// Returns whether the values are corrected to the nearest step.
    @inlinable func getSnapToTicks() -> Bool {
        let rv = ((gtk_spin_button_get_snap_to_ticks(spin_button_ptr)) != 0)
        return rv
    }

    /// Gets the update behavior of a spin button.
    /// 
    /// See [method`Gtk.SpinButton.set_update_policy`].
    @inlinable func getUpdatePolicy() -> GtkSpinButtonUpdatePolicy {
        let rv = gtk_spin_button_get_update_policy(spin_button_ptr)
        return rv
    }

    /// Get the value in the `spin_button`.
    @inlinable func getValue() -> CDouble {
        let rv = gtk_spin_button_get_value(spin_button_ptr)
        return rv
    }

    /// Get the value `spin_button` represented as an integer.
    @inlinable func getValueAsInt() -> Int {
        let rv = Int(gtk_spin_button_get_value_as_int(spin_button_ptr))
        return rv
    }

    /// Returns whether the spin button’s value wraps around to the
    /// opposite limit when the upper or lower limit of the range is
    /// exceeded.
    @inlinable func getWrap() -> Bool {
        let rv = ((gtk_spin_button_get_wrap(spin_button_ptr)) != 0)
        return rv
    }

    /// Replaces the `GtkAdjustment` associated with `spin_button`.
    @inlinable func set<AdjustmentT: AdjustmentProtocol>(adjustment: AdjustmentT) {
        gtk_spin_button_set_adjustment(spin_button_ptr, adjustment.adjustment_ptr)
    
    }

    /// Sets the acceleration rate for repeated changes when you
    /// hold down a button or key.
    @inlinable func set(climbRate: CDouble) {
        gtk_spin_button_set_climb_rate(spin_button_ptr, climbRate)
    
    }

    /// Set the precision to be displayed by `spin_button`.
    /// 
    /// Up to 20 digit precision is allowed.
    @inlinable func set(digits: Int) {
        gtk_spin_button_set_digits(spin_button_ptr, guint(digits))
    
    }

    /// Sets the step and page increments for spin_button.
    /// 
    /// This affects how quickly the value changes when
    /// the spin button’s arrows are activated.
    @inlinable func setIncrements(step: CDouble, page: CDouble) {
        gtk_spin_button_set_increments(spin_button_ptr, step, page)
    
    }

    /// Sets the flag that determines if non-numeric text can be typed
    /// into the spin button.
    @inlinable func set(numeric: Bool) {
        gtk_spin_button_set_numeric(spin_button_ptr, gboolean((numeric) ? 1 : 0))
    
    }

    /// Sets the minimum and maximum allowable values for `spin_button`.
    /// 
    /// If the current value is outside this range, it will be adjusted
    /// to fit within the range, otherwise it will remain unchanged.
    @inlinable func setRange(min: CDouble, max: CDouble) {
        gtk_spin_button_set_range(spin_button_ptr, min, max)
    
    }

    /// Sets the policy as to whether values are corrected to the
    /// nearest step increment when a spin button is activated after
    /// providing an invalid value.
    @inlinable func set(snapToTicks: Bool) {
        gtk_spin_button_set_snap_to_ticks(spin_button_ptr, gboolean((snapToTicks) ? 1 : 0))
    
    }

    /// Sets the update behavior of a spin button.
    /// 
    /// This determines whether the spin button is always
    /// updated or only when a valid value is set.
    @inlinable func setUpdate(policy: GtkSpinButtonUpdatePolicy) {
        gtk_spin_button_set_update_policy(spin_button_ptr, policy)
    
    }

    /// Sets the value of `spin_button`.
    @inlinable func set(value: CDouble) {
        gtk_spin_button_set_value(spin_button_ptr, value)
    
    }

    /// Sets the flag that determines if a spin button value wraps
    /// around to the opposite limit when the upper or lower limit
    /// of the range is exceeded.
    @inlinable func set(wrap: Bool) {
        gtk_spin_button_set_wrap(spin_button_ptr, gboolean((wrap) ? 1 : 0))
    
    }

    /// Increment or decrement a spin button’s value in a specified
    /// direction by a specified amount.
    @inlinable func spin(direction: GtkSpinType, increment: CDouble) {
        gtk_spin_button_spin(spin_button_ptr, direction, increment)
    
    }

    /// Manually force an update of the spin button.
    @inlinable func update() {
        gtk_spin_button_update(spin_button_ptr)
    
    }
    /// The adjustment that holds the value of the spin button.
    @inlinable var adjustment: AdjustmentRef! {
        /// Get the adjustment associated with a `GtkSpinButton`.
        get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_spin_button_get_adjustment(spin_button_ptr)))
            return rv
        }
        /// Replaces the `GtkAdjustment` associated with `spin_button`.
        nonmutating set {
            gtk_spin_button_set_adjustment(spin_button_ptr, UnsafeMutablePointer<GtkAdjustment>(newValue?.adjustment_ptr))
        }
    }

    /// Returns the acceleration rate for repeated changes.
    @inlinable var climbRate: CDouble {
        /// Returns the acceleration rate for repeated changes.
        get {
            let rv = gtk_spin_button_get_climb_rate(spin_button_ptr)
            return rv
        }
        /// Sets the acceleration rate for repeated changes when you
        /// hold down a button or key.
        nonmutating set {
            gtk_spin_button_set_climb_rate(spin_button_ptr, newValue)
        }
    }

    /// The number of decimal places to display.
    @inlinable var digits: Int {
        /// Fetches the precision of `spin_button`.
        get {
            let rv = Int(gtk_spin_button_get_digits(spin_button_ptr))
            return rv
        }
        /// Set the precision to be displayed by `spin_button`.
        /// 
        /// Up to 20 digit precision is allowed.
        nonmutating set {
            gtk_spin_button_set_digits(spin_button_ptr, guint(newValue))
        }
    }

    /// Whether non-numeric characters should be ignored.
    @inlinable var numeric: Bool {
        /// Returns whether non-numeric text can be typed into the spin button.
        get {
            let rv = ((gtk_spin_button_get_numeric(spin_button_ptr)) != 0)
            return rv
        }
        /// Sets the flag that determines if non-numeric text can be typed
        /// into the spin button.
        nonmutating set {
            gtk_spin_button_set_numeric(spin_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the values are corrected to the nearest step.
    @inlinable var snapToTicks: Bool {
        /// Returns whether the values are corrected to the nearest step.
        get {
            let rv = ((gtk_spin_button_get_snap_to_ticks(spin_button_ptr)) != 0)
            return rv
        }
        /// Sets the policy as to whether values are corrected to the
        /// nearest step increment when a spin button is activated after
        /// providing an invalid value.
        nonmutating set {
            gtk_spin_button_set_snap_to_ticks(spin_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the update behavior of a spin button.
    /// 
    /// See [method`Gtk.SpinButton.set_update_policy`].
    @inlinable var updatePolicy: GtkSpinButtonUpdatePolicy {
        /// Gets the update behavior of a spin button.
        /// 
        /// See [method`Gtk.SpinButton.set_update_policy`].
        get {
            let rv = gtk_spin_button_get_update_policy(spin_button_ptr)
            return rv
        }
        /// Sets the update behavior of a spin button.
        /// 
        /// This determines whether the spin button is always
        /// updated or only when a valid value is set.
        nonmutating set {
            gtk_spin_button_set_update_policy(spin_button_ptr, newValue)
        }
    }

    /// The current value.
    @inlinable var value: CDouble {
        /// Get the value in the `spin_button`.
        get {
            let rv = gtk_spin_button_get_value(spin_button_ptr)
            return rv
        }
        /// Sets the value of `spin_button`.
        nonmutating set {
            gtk_spin_button_set_value(spin_button_ptr, newValue)
        }
    }

    /// Get the value `spin_button` represented as an integer.
    @inlinable var valueAsInt: Int {
        /// Get the value `spin_button` represented as an integer.
        get {
            let rv = Int(gtk_spin_button_get_value_as_int(spin_button_ptr))
            return rv
        }
    }

    /// Whether a spin button should wrap upon reaching its limits.
    @inlinable var wrap: Bool {
        /// Returns whether the spin button’s value wraps around to the
        /// opposite limit when the upper or lower limit of the range is
        /// exceeded.
        get {
            let rv = ((gtk_spin_button_get_wrap(spin_button_ptr)) != 0)
            return rv
        }
        /// Sets the flag that determines if a spin button value wraps
        /// around to the opposite limit when the upper or lower limit
        /// of the range is exceeded.
        nonmutating set {
            gtk_spin_button_set_wrap(spin_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - Spinner Class

/// The `SpinnerProtocol` protocol exposes the methods and properties of an underlying `GtkSpinner` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Spinner`.
/// Alternatively, use `SpinnerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkSpinner` widget displays an icon-size spinning animation.
/// 
/// It is often used as an alternative to a [class`Gtk.ProgressBar`]
/// for displaying indefinite activity, instead of actual progress.
/// 
/// ![An example GtkSpinner](spinner.png)
/// 
/// To start the animation, use [method`Gtk.Spinner.start`], to stop it
/// use [method`Gtk.Spinner.stop`].
/// 
/// # CSS nodes
/// 
/// `GtkSpinner` has a single CSS node with the name spinner.
/// When the animation is active, the :checked pseudoclass is
/// added to this node.
public protocol SpinnerProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkSpinner` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSpinner` instance.
    var spinner_ptr: UnsafeMutablePointer<GtkSpinner>! { get }

    /// Required Initialiser for types conforming to `SpinnerProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SpinnerRef` type acts as a lightweight Swift reference to an underlying `GtkSpinner` instance.
/// It exposes methods that can operate on this data type through `SpinnerProtocol` conformance.
/// Use `SpinnerRef` only as an `unowned` reference to an existing `GtkSpinner` instance.
///
/// A `GtkSpinner` widget displays an icon-size spinning animation.
/// 
/// It is often used as an alternative to a [class`Gtk.ProgressBar`]
/// for displaying indefinite activity, instead of actual progress.
/// 
/// ![An example GtkSpinner](spinner.png)
/// 
/// To start the animation, use [method`Gtk.Spinner.start`], to stop it
/// use [method`Gtk.Spinner.stop`].
/// 
/// # CSS nodes
/// 
/// `GtkSpinner` has a single CSS node with the name spinner.
/// When the animation is active, the :checked pseudoclass is
/// added to this node.
public struct SpinnerRef: SpinnerProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSpinner` instance.
    /// For type-safe access, use the generated, typed pointer `spinner_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SpinnerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSpinner>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSpinner>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSpinner>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSpinner>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SpinnerProtocol`
    @inlinable init<T: SpinnerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SpinnerProtocol>(_ other: T) -> SpinnerRef { SpinnerRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Returns a new spinner widget. Not yet started.
    @inlinable init() {
        let rv = gtk_spinner_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Spinner` type acts as a reference-counted owner of an underlying `GtkSpinner` instance.
/// It provides the methods that can operate on this data type through `SpinnerProtocol` conformance.
/// Use `Spinner` as a strong reference or owner of a `GtkSpinner` instance.
///
/// A `GtkSpinner` widget displays an icon-size spinning animation.
/// 
/// It is often used as an alternative to a [class`Gtk.ProgressBar`]
/// for displaying indefinite activity, instead of actual progress.
/// 
/// ![An example GtkSpinner](spinner.png)
/// 
/// To start the animation, use [method`Gtk.Spinner.start`], to stop it
/// use [method`Gtk.Spinner.stop`].
/// 
/// # CSS nodes
/// 
/// `GtkSpinner` has a single CSS node with the name spinner.
/// When the animation is active, the :checked pseudoclass is
/// added to this node.
open class Spinner: Widget, SpinnerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSpinner>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSpinner>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSpinner>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSpinner>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSpinner`.
    /// i.e., ownership is transferred to the `Spinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSpinner>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SpinnerProtocol`
    /// Will retain `GtkSpinner`.
    /// - Parameter other: an instance of a related type that implements `SpinnerProtocol`
    @inlinable public init<T: SpinnerProtocol>(spinner other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SpinnerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Returns a new spinner widget. Not yet started.
    @inlinable public init() {
        let rv = gtk_spinner_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SpinnerPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Whether the spinner is spinning
    case spinning = "spinning"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension SpinnerProtocol {
    /// Bind a `SpinnerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SpinnerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Spinner property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SpinnerPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Spinner property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SpinnerPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SpinnerSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Whether the spinner is spinning
    case notifySpinning = "notify::spinning"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: Spinner has no signals
// MARK: Spinner Class: SpinnerProtocol extension (methods and fields)
public extension SpinnerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSpinner` instance.
    @inlinable var spinner_ptr: UnsafeMutablePointer<GtkSpinner>! { return ptr?.assumingMemoryBound(to: GtkSpinner.self) }

    /// Returns whether the spinner is spinning.
    @inlinable func getSpinning() -> Bool {
        let rv = ((gtk_spinner_get_spinning(spinner_ptr)) != 0)
        return rv
    }

    /// Sets the activity of the spinner.
    @inlinable func set(spinning: Bool) {
        gtk_spinner_set_spinning(spinner_ptr, gboolean((spinning) ? 1 : 0))
    
    }

    /// Starts the animation of the spinner.
    @inlinable func start() {
        gtk_spinner_start(spinner_ptr)
    
    }

    /// Stops the animation of the spinner.
    @inlinable func stop() {
        gtk_spinner_stop(spinner_ptr)
    
    }
    /// Whether the spinner is spinning
    @inlinable var spinning: Bool {
        /// Returns whether the spinner is spinning.
        get {
            let rv = ((gtk_spinner_get_spinning(spinner_ptr)) != 0)
            return rv
        }
        /// Sets the activity of the spinner.
        nonmutating set {
            gtk_spinner_set_spinning(spinner_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - Stack Class

/// The `StackProtocol` protocol exposes the methods and properties of an underlying `GtkStack` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Stack`.
/// Alternatively, use `StackRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkStack` is a container which only shows one of its children
/// at a time.
/// 
/// In contrast to `GtkNotebook`, `GtkStack` does not provide a means
/// for users to change the visible child. Instead, a separate widget
/// such as [class`Gtk.StackSwitcher`] or [class`Gtk.StackSidebar`] can
/// be used with `GtkStack` to provide this functionality.
/// 
/// Transitions between pages can be animated as slides or fades. This
/// can be controlled with [method`Gtk.Stack.set_transition_type`].
/// These animations respect the [property`Gtk.Settings:gtk-enable-animations`]
/// setting.
/// 
/// `GtkStack` maintains a [class`Gtk.StackPage`] object for each added
/// child, which holds additional per-child properties. You
/// obtain the `GtkStackPage` for a child with [method`Gtk.Stack.get_page`]
/// and you can obtain a `GtkSelectionModel` containing all the pages
/// with [method`Gtk.Stack.get_pages`].
/// 
/// # GtkStack as GtkBuildable
/// 
/// To set child-specific properties in a .ui file, create `GtkStackPage`
/// objects explicitly, and set the child widget as a property on it:
/// 
/// ```xml
///   &lt;object class="GtkStack" id="stack"&gt;
///     &lt;child&gt;
///       &lt;object class="GtkStackPage"&gt;
///         &lt;property name="name"&gt;page1&lt;/property&gt;
///         &lt;property name="title"&gt;In the beginning…&lt;/property&gt;
///         &lt;property name="child"&gt;
///           &lt;object class="GtkLabel"&gt;
///             &lt;property name="label"&gt;It was dark&lt;/property&gt;
///           &lt;/object&gt;
///         &lt;/property&gt;
///       &lt;/object&gt;
///     &lt;/child&gt;
/// ```
/// 
/// # CSS nodes
/// 
/// `GtkStack` has a single CSS node named stack.
/// 
/// # Accessibility
/// 
/// `GtkStack` uses the `GTK_ACCESSIBLE_ROLE_TAB_PANEL` for the stack
/// pages, which are the accessible parent objects of the child widgets.
public protocol StackProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkStack` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStack` instance.
    var stack_ptr: UnsafeMutablePointer<GtkStack>! { get }

    /// Required Initialiser for types conforming to `StackProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `StackRef` type acts as a lightweight Swift reference to an underlying `GtkStack` instance.
/// It exposes methods that can operate on this data type through `StackProtocol` conformance.
/// Use `StackRef` only as an `unowned` reference to an existing `GtkStack` instance.
///
/// `GtkStack` is a container which only shows one of its children
/// at a time.
/// 
/// In contrast to `GtkNotebook`, `GtkStack` does not provide a means
/// for users to change the visible child. Instead, a separate widget
/// such as [class`Gtk.StackSwitcher`] or [class`Gtk.StackSidebar`] can
/// be used with `GtkStack` to provide this functionality.
/// 
/// Transitions between pages can be animated as slides or fades. This
/// can be controlled with [method`Gtk.Stack.set_transition_type`].
/// These animations respect the [property`Gtk.Settings:gtk-enable-animations`]
/// setting.
/// 
/// `GtkStack` maintains a [class`Gtk.StackPage`] object for each added
/// child, which holds additional per-child properties. You
/// obtain the `GtkStackPage` for a child with [method`Gtk.Stack.get_page`]
/// and you can obtain a `GtkSelectionModel` containing all the pages
/// with [method`Gtk.Stack.get_pages`].
/// 
/// # GtkStack as GtkBuildable
/// 
/// To set child-specific properties in a .ui file, create `GtkStackPage`
/// objects explicitly, and set the child widget as a property on it:
/// 
/// ```xml
///   &lt;object class="GtkStack" id="stack"&gt;
///     &lt;child&gt;
///       &lt;object class="GtkStackPage"&gt;
///         &lt;property name="name"&gt;page1&lt;/property&gt;
///         &lt;property name="title"&gt;In the beginning…&lt;/property&gt;
///         &lt;property name="child"&gt;
///           &lt;object class="GtkLabel"&gt;
///             &lt;property name="label"&gt;It was dark&lt;/property&gt;
///           &lt;/object&gt;
///         &lt;/property&gt;
///       &lt;/object&gt;
///     &lt;/child&gt;
/// ```
/// 
/// # CSS nodes
/// 
/// `GtkStack` has a single CSS node named stack.
/// 
/// # Accessibility
/// 
/// `GtkStack` uses the `GTK_ACCESSIBLE_ROLE_TAB_PANEL` for the stack
/// pages, which are the accessible parent objects of the child widgets.
public struct StackRef: StackProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStack` instance.
    /// For type-safe access, use the generated, typed pointer `stack_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StackRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStack>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStack>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStack>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStack>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StackProtocol`
    @inlinable init<T: StackProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StackProtocol>(_ other: T) -> StackRef { StackRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkStack`.
    @inlinable init() {
        let rv = gtk_stack_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Stack` type acts as a reference-counted owner of an underlying `GtkStack` instance.
/// It provides the methods that can operate on this data type through `StackProtocol` conformance.
/// Use `Stack` as a strong reference or owner of a `GtkStack` instance.
///
/// `GtkStack` is a container which only shows one of its children
/// at a time.
/// 
/// In contrast to `GtkNotebook`, `GtkStack` does not provide a means
/// for users to change the visible child. Instead, a separate widget
/// such as [class`Gtk.StackSwitcher`] or [class`Gtk.StackSidebar`] can
/// be used with `GtkStack` to provide this functionality.
/// 
/// Transitions between pages can be animated as slides or fades. This
/// can be controlled with [method`Gtk.Stack.set_transition_type`].
/// These animations respect the [property`Gtk.Settings:gtk-enable-animations`]
/// setting.
/// 
/// `GtkStack` maintains a [class`Gtk.StackPage`] object for each added
/// child, which holds additional per-child properties. You
/// obtain the `GtkStackPage` for a child with [method`Gtk.Stack.get_page`]
/// and you can obtain a `GtkSelectionModel` containing all the pages
/// with [method`Gtk.Stack.get_pages`].
/// 
/// # GtkStack as GtkBuildable
/// 
/// To set child-specific properties in a .ui file, create `GtkStackPage`
/// objects explicitly, and set the child widget as a property on it:
/// 
/// ```xml
///   &lt;object class="GtkStack" id="stack"&gt;
///     &lt;child&gt;
///       &lt;object class="GtkStackPage"&gt;
///         &lt;property name="name"&gt;page1&lt;/property&gt;
///         &lt;property name="title"&gt;In the beginning…&lt;/property&gt;
///         &lt;property name="child"&gt;
///           &lt;object class="GtkLabel"&gt;
///             &lt;property name="label"&gt;It was dark&lt;/property&gt;
///           &lt;/object&gt;
///         &lt;/property&gt;
///       &lt;/object&gt;
///     &lt;/child&gt;
/// ```
/// 
/// # CSS nodes
/// 
/// `GtkStack` has a single CSS node named stack.
/// 
/// # Accessibility
/// 
/// `GtkStack` uses the `GTK_ACCESSIBLE_ROLE_TAB_PANEL` for the stack
/// pages, which are the accessible parent objects of the child widgets.
open class Stack: Widget, StackProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStack>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStack>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStack>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStack>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStack`.
    /// i.e., ownership is transferred to the `Stack` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStack>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StackProtocol`
    /// Will retain `GtkStack`.
    /// - Parameter other: an instance of a related type that implements `StackProtocol`
    @inlinable public init<T: StackProtocol>(stack other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkStack`.
    @inlinable public init() {
        let rv = gtk_stack_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StackPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// `true` if the stack allocates the same width for all children.
    case hhomogeneous = "hhomogeneous"
    /// Whether or not the size should smoothly change during the transition.
    case interpolateSize = "interpolate-size"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// A selection model with the stack pages.
    case pages = "pages"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The animation duration, in milliseconds.
    case transitionDuration = "transition-duration"
    /// Whether or not the transition is currently running.
    case transitionRunning = "transition-running"
    /// The type of animation used to transition.
    case transitionType = "transition-type"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// `true` if the stack allocates the same height for all children.
    case vhomogeneous = "vhomogeneous"
    /// Whether the widget is visible.
    case visible = "visible"
    /// The widget currently visible in the stack.
    case visibleChild = "visible-child"
    /// The name of the widget currently visible in the stack.
    case visibleChildName = "visible-child-name"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension StackProtocol {
    /// Bind a `StackPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StackPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Stack property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StackPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Stack property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StackPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum StackSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// `true` if the stack allocates the same width for all children.
    case notifyHhomogeneous = "notify::hhomogeneous"
    /// Whether or not the size should smoothly change during the transition.
    case notifyInterpolateSize = "notify::interpolate-size"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// A selection model with the stack pages.
    case notifyPages = "notify::pages"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The animation duration, in milliseconds.
    case notifyTransitionDuration = "notify::transition-duration"
    /// Whether or not the transition is currently running.
    case notifyTransitionRunning = "notify::transition-running"
    /// The type of animation used to transition.
    case notifyTransitionType = "notify::transition-type"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// `true` if the stack allocates the same height for all children.
    case notifyVhomogeneous = "notify::vhomogeneous"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// The widget currently visible in the stack.
    case notifyVisibleChild = "notify::visible-child"
    /// The name of the widget currently visible in the stack.
    case notifyVisibleChildName = "notify::visible-child-name"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: Stack has no signals
// MARK: Stack Class: StackProtocol extension (methods and fields)
public extension StackProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStack` instance.
    @inlinable var stack_ptr: UnsafeMutablePointer<GtkStack>! { return ptr?.assumingMemoryBound(to: GtkStack.self) }

    /// Adds a child to `stack`.
    @inlinable func add<WidgetT: WidgetProtocol>(child: WidgetT) -> StackPageRef! {
        let rv = StackPageRef(gconstpointer: gconstpointer(gtk_stack_add_child(stack_ptr, child.widget_ptr)))
        return rv
    }

    /// Adds a child to `stack`.
    /// 
    /// The child is identified by the `name`.
    @inlinable func addNamed<WidgetT: WidgetProtocol>(child: WidgetT, name: UnsafePointer<CChar>? = nil) -> StackPageRef! {
        let rv = StackPageRef(gconstpointer: gconstpointer(gtk_stack_add_named(stack_ptr, child.widget_ptr, name)))
        return rv
    }

    /// Adds a child to `stack`.
    /// 
    /// The child is identified by the `name`. The `title`
    /// will be used by `GtkStackSwitcher` to represent
    /// `child` in a tab bar, so it should be short.
    @inlinable func addTitled<WidgetT: WidgetProtocol>(child: WidgetT, name: UnsafePointer<CChar>? = nil, title: UnsafePointer<CChar>!) -> StackPageRef! {
        let rv = StackPageRef(gconstpointer: gconstpointer(gtk_stack_add_titled(stack_ptr, child.widget_ptr, name, title)))
        return rv
    }

    /// Finds the child with the name given as the argument.
    /// 
    /// Returns `nil` if there is no child with this name.
    @inlinable func getChildBy(name: UnsafePointer<CChar>!) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_stack_get_child_by_name(stack_ptr, name))) else { return nil }
        return rv
    }

    /// Gets whether `stack` is horizontally homogeneous.
    @inlinable func getHhomogeneous() -> Bool {
        let rv = ((gtk_stack_get_hhomogeneous(stack_ptr)) != 0)
        return rv
    }

    /// Returns whether the `GtkStack` is set up to interpolate between
    /// the sizes of children on page switch.
    @inlinable func getInterpolateSize() -> Bool {
        let rv = ((gtk_stack_get_interpolate_size(stack_ptr)) != 0)
        return rv
    }

    /// Returns the `GtkStackPage` object for `child`.
    @inlinable func getPage<WidgetT: WidgetProtocol>(child: WidgetT) -> StackPageRef! {
        let rv = StackPageRef(gconstpointer: gconstpointer(gtk_stack_get_page(stack_ptr, child.widget_ptr)))
        return rv
    }

    /// Returns a `GListModel` that contains the pages of the stack.
    /// 
    /// This can be used to keep an up-to-date view. The model also
    /// implements [iface`Gtk.SelectionModel`] and can be used to track
    /// and modify the visible page.
    @inlinable func getPages() -> SelectionModelRef! {
        let rv = SelectionModelRef(gconstpointer: gconstpointer(gtk_stack_get_pages(stack_ptr)))
        return rv
    }

    /// Returns the amount of time (in milliseconds) that
    /// transitions between pages in `stack` will take.
    @inlinable func getTransitionDuration() -> Int {
        let rv = Int(gtk_stack_get_transition_duration(stack_ptr))
        return rv
    }

    /// Returns whether the `stack` is currently in a transition from one page to
    /// another.
    @inlinable func getTransitionRunning() -> Bool {
        let rv = ((gtk_stack_get_transition_running(stack_ptr)) != 0)
        return rv
    }

    /// Gets the type of animation that will be used
    /// for transitions between pages in `stack`.
    @inlinable func getTransitionType() -> GtkStackTransitionType {
        let rv = gtk_stack_get_transition_type(stack_ptr)
        return rv
    }

    /// Gets whether `stack` is vertically homogeneous.
    @inlinable func getVhomogeneous() -> Bool {
        let rv = ((gtk_stack_get_vhomogeneous(stack_ptr)) != 0)
        return rv
    }

    /// Gets the currently visible child of `stack`.
    /// 
    /// Returns `nil` if there are no visible children.
    @inlinable func getVisibleChild() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_stack_get_visible_child(stack_ptr))) else { return nil }
        return rv
    }

    /// Returns the name of the currently visible child of `stack`.
    /// 
    /// Returns `nil` if there is no visible child.
    @inlinable func getVisibleChildName() -> String! {
        let rv = gtk_stack_get_visible_child_name(stack_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Removes a child widget from `stack`.
    @inlinable func remove<WidgetT: WidgetProtocol>(child: WidgetT) {
        gtk_stack_remove(stack_ptr, child.widget_ptr)
    
    }

    /// Sets the `GtkStack` to be horizontally homogeneous or not.
    /// 
    /// If it is homogeneous, the `GtkStack` will request the same
    /// width for all its children. If it isn't, the stack
    /// may change width when a different child becomes visible.
    @inlinable func set(hhomogeneous: Bool) {
        gtk_stack_set_hhomogeneous(stack_ptr, gboolean((hhomogeneous) ? 1 : 0))
    
    }

    /// Sets whether or not `stack` will interpolate its size when
    /// changing the visible child.
    /// 
    /// If the [property`Gtk.Stack:interpolate-size`] property is set
    /// to `true`, `stack` will interpolate its size between the current
    /// one and the one it'll take after changing the visible child,
    /// according to the set transition duration.
    @inlinable func set(interpolateSize: Bool) {
        gtk_stack_set_interpolate_size(stack_ptr, gboolean((interpolateSize) ? 1 : 0))
    
    }

    /// Sets the duration that transitions between pages in `stack`
    /// will take.
    @inlinable func setTransition(duration: Int) {
        gtk_stack_set_transition_duration(stack_ptr, guint(duration))
    
    }

    /// Sets the type of animation that will be used for
    /// transitions between pages in `stack`.
    /// 
    /// Available types include various kinds of fades and slides.
    /// 
    /// The transition type can be changed without problems
    /// at runtime, so it is possible to change the animation
    /// based on the page that is about to become current.
    @inlinable func setTransitionType(transition: GtkStackTransitionType) {
        gtk_stack_set_transition_type(stack_ptr, transition)
    
    }

    /// Sets the `GtkStack` to be vertically homogeneous or not.
    /// 
    /// If it is homogeneous, the `GtkStack` will request the same
    /// height for all its children. If it isn't, the stack
    /// may change height when a different child becomes visible.
    @inlinable func set(vhomogeneous: Bool) {
        gtk_stack_set_vhomogeneous(stack_ptr, gboolean((vhomogeneous) ? 1 : 0))
    
    }

    /// Makes `child` the visible child of `stack`.
    /// 
    /// If `child` is different from the currently visible child,
    /// the transition between the two will be animated with the
    /// current transition type of `stack`.
    /// 
    /// Note that the `child` widget has to be visible itself
    /// (see [method`Gtk.Widget.show`]) in order to become the visible
    /// child of `stack`.
    @inlinable func setVisible<WidgetT: WidgetProtocol>(child: WidgetT) {
        gtk_stack_set_visible_child(stack_ptr, child.widget_ptr)
    
    }

    /// Makes the child with the given name visible.
    /// 
    /// Note that the child widget has to be visible itself
    /// (see [method`Gtk.Widget.show`]) in order to become the visible
    /// child of `stack`.
    @inlinable func setVisibleChildFull(name: UnsafePointer<CChar>!, transition: GtkStackTransitionType) {
        gtk_stack_set_visible_child_full(stack_ptr, name, transition)
    
    }

    /// Makes the child with the given name visible.
    /// 
    /// If `child` is different from the currently visible child,
    /// the transition between the two will be animated with the
    /// current transition type of `stack`.
    /// 
    /// Note that the child widget has to be visible itself
    /// (see [method`Gtk.Widget.show`]) in order to become the visible
    /// child of `stack`.
    @inlinable func setVisibleChild(name: UnsafePointer<CChar>!) {
        gtk_stack_set_visible_child_name(stack_ptr, name)
    
    }
    /// `true` if the stack allocates the same width for all children.
    @inlinable var hhomogeneous: Bool {
        /// Gets whether `stack` is horizontally homogeneous.
        get {
            let rv = ((gtk_stack_get_hhomogeneous(stack_ptr)) != 0)
            return rv
        }
        /// Sets the `GtkStack` to be horizontally homogeneous or not.
        /// 
        /// If it is homogeneous, the `GtkStack` will request the same
        /// width for all its children. If it isn't, the stack
        /// may change width when a different child becomes visible.
        nonmutating set {
            gtk_stack_set_hhomogeneous(stack_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the `GtkStack` is set up to interpolate between
    /// the sizes of children on page switch.
    @inlinable var interpolateSize: Bool {
        /// Returns whether the `GtkStack` is set up to interpolate between
        /// the sizes of children on page switch.
        get {
            let rv = ((gtk_stack_get_interpolate_size(stack_ptr)) != 0)
            return rv
        }
        /// Sets whether or not `stack` will interpolate its size when
        /// changing the visible child.
        /// 
        /// If the [property`Gtk.Stack:interpolate-size`] property is set
        /// to `true`, `stack` will interpolate its size between the current
        /// one and the one it'll take after changing the visible child,
        /// according to the set transition duration.
        nonmutating set {
            gtk_stack_set_interpolate_size(stack_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// A selection model with the stack pages.
    @inlinable var pages: SelectionModelRef! {
        /// Returns a `GListModel` that contains the pages of the stack.
        /// 
        /// This can be used to keep an up-to-date view. The model also
        /// implements [iface`Gtk.SelectionModel`] and can be used to track
        /// and modify the visible page.
        get {
            let rv = SelectionModelRef(gconstpointer: gconstpointer(gtk_stack_get_pages(stack_ptr)))
            return rv
        }
    }

    /// Returns the amount of time (in milliseconds) that
    /// transitions between pages in `stack` will take.
    @inlinable var transitionDuration: Int {
        /// Returns the amount of time (in milliseconds) that
        /// transitions between pages in `stack` will take.
        get {
            let rv = Int(gtk_stack_get_transition_duration(stack_ptr))
            return rv
        }
        /// Sets the duration that transitions between pages in `stack`
        /// will take.
        nonmutating set {
            gtk_stack_set_transition_duration(stack_ptr, guint(newValue))
        }
    }

    /// Returns whether the `stack` is currently in a transition from one page to
    /// another.
    @inlinable var transitionRunning: Bool {
        /// Returns whether the `stack` is currently in a transition from one page to
        /// another.
        get {
            let rv = ((gtk_stack_get_transition_running(stack_ptr)) != 0)
            return rv
        }
    }

    /// Gets the type of animation that will be used
    /// for transitions between pages in `stack`.
    @inlinable var transitionType: GtkStackTransitionType {
        /// Gets the type of animation that will be used
        /// for transitions between pages in `stack`.
        get {
            let rv = gtk_stack_get_transition_type(stack_ptr)
            return rv
        }
        /// Sets the type of animation that will be used for
        /// transitions between pages in `stack`.
        /// 
        /// Available types include various kinds of fades and slides.
        /// 
        /// The transition type can be changed without problems
        /// at runtime, so it is possible to change the animation
        /// based on the page that is about to become current.
        nonmutating set {
            gtk_stack_set_transition_type(stack_ptr, newValue)
        }
    }

    /// `true` if the stack allocates the same height for all children.
    @inlinable var vhomogeneous: Bool {
        /// Gets whether `stack` is vertically homogeneous.
        get {
            let rv = ((gtk_stack_get_vhomogeneous(stack_ptr)) != 0)
            return rv
        }
        /// Sets the `GtkStack` to be vertically homogeneous or not.
        /// 
        /// If it is homogeneous, the `GtkStack` will request the same
        /// height for all its children. If it isn't, the stack
        /// may change height when a different child becomes visible.
        nonmutating set {
            gtk_stack_set_vhomogeneous(stack_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the currently visible child of `stack`.
    /// 
    /// Returns `nil` if there are no visible children.
    @inlinable var visibleChild: WidgetRef! {
        /// Gets the currently visible child of `stack`.
        /// 
        /// Returns `nil` if there are no visible children.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_stack_get_visible_child(stack_ptr))) else { return nil }
            return rv
        }
        /// Makes `child` the visible child of `stack`.
        /// 
        /// If `child` is different from the currently visible child,
        /// the transition between the two will be animated with the
        /// current transition type of `stack`.
        /// 
        /// Note that the `child` widget has to be visible itself
        /// (see [method`Gtk.Widget.show`]) in order to become the visible
        /// child of `stack`.
        nonmutating set {
            gtk_stack_set_visible_child(stack_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Returns the name of the currently visible child of `stack`.
    /// 
    /// Returns `nil` if there is no visible child.
    @inlinable var visibleChildName: String! {
        /// Returns the name of the currently visible child of `stack`.
        /// 
        /// Returns `nil` if there is no visible child.
        get {
            let rv = gtk_stack_get_visible_child_name(stack_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Makes the child with the given name visible.
        /// 
        /// If `child` is different from the currently visible child,
        /// the transition between the two will be animated with the
        /// current transition type of `stack`.
        /// 
        /// Note that the child widget has to be visible itself
        /// (see [method`Gtk.Widget.show`]) in order to become the visible
        /// child of `stack`.
        nonmutating set {
            gtk_stack_set_visible_child_name(stack_ptr, newValue)
        }
    }


}



// MARK: - StackPage Class

/// The `StackPageProtocol` protocol exposes the methods and properties of an underlying `GtkStackPage` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StackPage`.
/// Alternatively, use `StackPageRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkStackPage` is an auxiliary class used by `GtkStack`.
public protocol StackPageProtocol: GLibObject.ObjectProtocol, AccessibleProtocol {
        /// Untyped pointer to the underlying `GtkStackPage` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStackPage` instance.
    var stack_page_ptr: UnsafeMutablePointer<GtkStackPage>! { get }

    /// Required Initialiser for types conforming to `StackPageProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `StackPageRef` type acts as a lightweight Swift reference to an underlying `GtkStackPage` instance.
/// It exposes methods that can operate on this data type through `StackPageProtocol` conformance.
/// Use `StackPageRef` only as an `unowned` reference to an existing `GtkStackPage` instance.
///
/// `GtkStackPage` is an auxiliary class used by `GtkStack`.
public struct StackPageRef: StackPageProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStackPage` instance.
    /// For type-safe access, use the generated, typed pointer `stack_page_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StackPageRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStackPage>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStackPage>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStackPage>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStackPage>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StackPageProtocol`
    @inlinable init<T: StackPageProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StackPageProtocol>(_ other: T) -> StackPageRef { StackPageRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `StackPage` type acts as a reference-counted owner of an underlying `GtkStackPage` instance.
/// It provides the methods that can operate on this data type through `StackPageProtocol` conformance.
/// Use `StackPage` as a strong reference or owner of a `GtkStackPage` instance.
///
/// `GtkStackPage` is an auxiliary class used by `GtkStack`.
open class StackPage: GLibObject.Object, StackPageProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStackPage>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStackPage>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStackPage>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStackPage>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStackPage`.
    /// i.e., ownership is transferred to the `StackPage` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStackPage>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StackPageProtocol`
    /// Will retain `GtkStackPage`.
    /// - Parameter other: an instance of a related type that implements `StackPageProtocol`
    @inlinable public init<T: StackPageProtocol>(stackPage other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackPageProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum StackPagePropertyName: String, PropertyNameProtocol {
    /// The child that this page is for.
    case child = "child"
    /// The icon name of the child page.
    case iconName = "icon-name"
    /// The name of the child page.
    case name = "name"
    /// Whether the page requires the user attention.
    /// 
    /// This is used by the [class`Gtk.StackSwitcher`] to change the
    /// appearance of the corresponding button when a page needs
    /// attention and it is not the current one.
    case needsAttention = "needs-attention"
    /// The title of the child page.
    case title = "title"
    /// If set, an underline in the title indicates a mnemonic.
    case useUnderline = "use-underline"
    /// Whether this page is visible.
    case visible = "visible"
}

public extension StackPageProtocol {
    /// Bind a `StackPagePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StackPagePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StackPage property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StackPagePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StackPage property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StackPagePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum StackPageSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The child that this page is for.
    case notifyChild = "notify::child"
    /// The icon name of the child page.
    case notifyIconName = "notify::icon-name"
    /// The name of the child page.
    case notifyName = "notify::name"
    /// Whether the page requires the user attention.
    /// 
    /// This is used by the [class`Gtk.StackSwitcher`] to change the
    /// appearance of the corresponding button when a page needs
    /// attention and it is not the current one.
    case notifyNeedsAttention = "notify::needs-attention"
    /// The title of the child page.
    case notifyTitle = "notify::title"
    /// If set, an underline in the title indicates a mnemonic.
    case notifyUseUnderline = "notify::use-underline"
    /// Whether this page is visible.
    case notifyVisible = "notify::visible"
}

// MARK: StackPage has no signals
// MARK: StackPage Class: StackPageProtocol extension (methods and fields)
public extension StackPageProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStackPage` instance.
    @inlinable var stack_page_ptr: UnsafeMutablePointer<GtkStackPage>! { return ptr?.assumingMemoryBound(to: GtkStackPage.self) }

    /// Returns the stack child to which `self` belongs.
    @inlinable func getChild() -> WidgetRef! {
        let rv = WidgetRef(gconstpointer: gconstpointer(gtk_stack_page_get_child(stack_page_ptr)))
        return rv
    }

    /// Returns the icon name of the page.
    @inlinable func getIconName() -> String! {
        let rv = gtk_stack_page_get_icon_name(stack_page_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns the name of the page.
    @inlinable func getName() -> String! {
        let rv = gtk_stack_page_get_name(stack_page_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns whether the page is marked as “needs attention”.
    @inlinable func getNeedsAttention() -> Bool {
        let rv = ((gtk_stack_page_get_needs_attention(stack_page_ptr)) != 0)
        return rv
    }

    /// Gets the page title.
    @inlinable func getTitle() -> String! {
        let rv = gtk_stack_page_get_title(stack_page_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Gets whether underlines in the page title indicate mnemonics.
    @inlinable func getUseUnderline() -> Bool {
        let rv = ((gtk_stack_page_get_use_underline(stack_page_ptr)) != 0)
        return rv
    }

    /// Returns whether `page` is visible in its `GtkStack`.
    /// 
    /// This is independent from the [property`Gtk.Widget:visible`]
    /// property of its widget.
    @inlinable func getVisible() -> Bool {
        let rv = ((gtk_stack_page_get_visible(stack_page_ptr)) != 0)
        return rv
    }

    /// Sets the icon name of the page.
    @inlinable func setIconName(setting: UnsafePointer<CChar>!) {
        gtk_stack_page_set_icon_name(stack_page_ptr, setting)
    
    }

    /// Sets the name of the page.
    @inlinable func setName(setting: UnsafePointer<CChar>!) {
        gtk_stack_page_set_name(stack_page_ptr, setting)
    
    }

    /// Sets whether the page is marked as “needs attention”.
    @inlinable func setNeedsAttention(setting: Bool) {
        gtk_stack_page_set_needs_attention(stack_page_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Sets the page title.
    @inlinable func setTitle(setting: UnsafePointer<CChar>!) {
        gtk_stack_page_set_title(stack_page_ptr, setting)
    
    }

    /// Sets whether underlines in the page title indicate mnemonics.
    @inlinable func setUseUnderline(setting: Bool) {
        gtk_stack_page_set_use_underline(stack_page_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Sets whether `page` is visible in its `GtkStack`.
    @inlinable func set(visible: Bool) {
        gtk_stack_page_set_visible(stack_page_ptr, gboolean((visible) ? 1 : 0))
    
    }
    /// The child that this page is for.
    @inlinable var child: WidgetRef! {
        /// Returns the stack child to which `self` belongs.
        get {
            let rv = WidgetRef(gconstpointer: gconstpointer(gtk_stack_page_get_child(stack_page_ptr)))
            return rv
        }
    }

    /// Returns the icon name of the page.
    @inlinable var iconName: String! {
        /// Returns the icon name of the page.
        get {
            let rv = gtk_stack_page_get_icon_name(stack_page_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the icon name of the page.
        nonmutating set {
            gtk_stack_page_set_icon_name(stack_page_ptr, newValue)
        }
    }

    /// The name of the child page.
    @inlinable var name: String! {
        /// Returns the name of the page.
        get {
            let rv = gtk_stack_page_get_name(stack_page_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the name of the page.
        nonmutating set {
            gtk_stack_page_set_name(stack_page_ptr, newValue)
        }
    }

    /// Returns whether the page is marked as “needs attention”.
    @inlinable var needsAttention: Bool {
        /// Returns whether the page is marked as “needs attention”.
        get {
            let rv = ((gtk_stack_page_get_needs_attention(stack_page_ptr)) != 0)
            return rv
        }
        /// Sets whether the page is marked as “needs attention”.
        nonmutating set {
            gtk_stack_page_set_needs_attention(stack_page_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The title of the child page.
    @inlinable var title: String! {
        /// Gets the page title.
        get {
            let rv = gtk_stack_page_get_title(stack_page_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the page title.
        nonmutating set {
            gtk_stack_page_set_title(stack_page_ptr, newValue)
        }
    }

    /// Gets whether underlines in the page title indicate mnemonics.
    @inlinable var useUnderline: Bool {
        /// Gets whether underlines in the page title indicate mnemonics.
        get {
            let rv = ((gtk_stack_page_get_use_underline(stack_page_ptr)) != 0)
            return rv
        }
        /// Sets whether underlines in the page title indicate mnemonics.
        nonmutating set {
            gtk_stack_page_set_use_underline(stack_page_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Whether this page is visible.
    @inlinable var visible: Bool {
        /// Returns whether `page` is visible in its `GtkStack`.
        /// 
        /// This is independent from the [property`Gtk.Widget:visible`]
        /// property of its widget.
        get {
            let rv = ((gtk_stack_page_get_visible(stack_page_ptr)) != 0)
            return rv
        }
        /// Sets whether `page` is visible in its `GtkStack`.
        nonmutating set {
            gtk_stack_page_set_visible(stack_page_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - StackSidebar Class

/// The `StackSidebarProtocol` protocol exposes the methods and properties of an underlying `GtkStackSidebar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StackSidebar`.
/// Alternatively, use `StackSidebarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkStackSidebar` uses a sidebar to switch between `GtkStack` pages.
/// 
/// In order to use a `GtkStackSidebar`, you simply use a `GtkStack` to
/// organize your UI flow, and add the sidebar to your sidebar area. You
/// can use [method`Gtk.StackSidebar.set_stack`] to connect the `GtkStackSidebar`
/// to the `GtkStack`.
/// 
/// # CSS nodes
/// 
/// `GtkStackSidebar` has a single CSS node with name stacksidebar and
/// style class .sidebar.
/// 
/// When circumstances require it, `GtkStackSidebar` adds the
/// .needs-attention style class to the widgets representing the stack
/// pages.
public protocol StackSidebarProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkStackSidebar` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStackSidebar` instance.
    var stack_sidebar_ptr: UnsafeMutablePointer<GtkStackSidebar>! { get }

    /// Required Initialiser for types conforming to `StackSidebarProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `StackSidebarRef` type acts as a lightweight Swift reference to an underlying `GtkStackSidebar` instance.
/// It exposes methods that can operate on this data type through `StackSidebarProtocol` conformance.
/// Use `StackSidebarRef` only as an `unowned` reference to an existing `GtkStackSidebar` instance.
///
/// A `GtkStackSidebar` uses a sidebar to switch between `GtkStack` pages.
/// 
/// In order to use a `GtkStackSidebar`, you simply use a `GtkStack` to
/// organize your UI flow, and add the sidebar to your sidebar area. You
/// can use [method`Gtk.StackSidebar.set_stack`] to connect the `GtkStackSidebar`
/// to the `GtkStack`.
/// 
/// # CSS nodes
/// 
/// `GtkStackSidebar` has a single CSS node with name stacksidebar and
/// style class .sidebar.
/// 
/// When circumstances require it, `GtkStackSidebar` adds the
/// .needs-attention style class to the widgets representing the stack
/// pages.
public struct StackSidebarRef: StackSidebarProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStackSidebar` instance.
    /// For type-safe access, use the generated, typed pointer `stack_sidebar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StackSidebarRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStackSidebar>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStackSidebar>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStackSidebar>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStackSidebar>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StackSidebarProtocol`
    @inlinable init<T: StackSidebarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StackSidebarProtocol>(_ other: T) -> StackSidebarRef { StackSidebarRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkStackSidebar`.
    @inlinable init() {
        let rv = gtk_stack_sidebar_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `StackSidebar` type acts as a reference-counted owner of an underlying `GtkStackSidebar` instance.
/// It provides the methods that can operate on this data type through `StackSidebarProtocol` conformance.
/// Use `StackSidebar` as a strong reference or owner of a `GtkStackSidebar` instance.
///
/// A `GtkStackSidebar` uses a sidebar to switch between `GtkStack` pages.
/// 
/// In order to use a `GtkStackSidebar`, you simply use a `GtkStack` to
/// organize your UI flow, and add the sidebar to your sidebar area. You
/// can use [method`Gtk.StackSidebar.set_stack`] to connect the `GtkStackSidebar`
/// to the `GtkStack`.
/// 
/// # CSS nodes
/// 
/// `GtkStackSidebar` has a single CSS node with name stacksidebar and
/// style class .sidebar.
/// 
/// When circumstances require it, `GtkStackSidebar` adds the
/// .needs-attention style class to the widgets representing the stack
/// pages.
open class StackSidebar: Widget, StackSidebarProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStackSidebar>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStackSidebar>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStackSidebar>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStackSidebar>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStackSidebar`.
    /// i.e., ownership is transferred to the `StackSidebar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStackSidebar>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StackSidebarProtocol`
    /// Will retain `GtkStackSidebar`.
    /// - Parameter other: an instance of a related type that implements `StackSidebarProtocol`
    @inlinable public init<T: StackSidebarProtocol>(stackSidebar other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSidebarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkStackSidebar`.
    @inlinable public init() {
        let rv = gtk_stack_sidebar_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StackSidebarPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// The stack.
    case stack = "stack"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension StackSidebarProtocol {
    /// Bind a `StackSidebarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StackSidebarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StackSidebar property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StackSidebarPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StackSidebar property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StackSidebarPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum StackSidebarSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// The stack.
    case notifyStack = "notify::stack"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: StackSidebar has no signals
// MARK: StackSidebar Class: StackSidebarProtocol extension (methods and fields)
public extension StackSidebarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStackSidebar` instance.
    @inlinable var stack_sidebar_ptr: UnsafeMutablePointer<GtkStackSidebar>! { return ptr?.assumingMemoryBound(to: GtkStackSidebar.self) }

    /// Retrieves the stack.
    @inlinable func getStack() -> StackRef! {
        let rv = StackRef(gconstpointer: gconstpointer(gtk_stack_sidebar_get_stack(stack_sidebar_ptr)))
        return rv
    }

    /// Set the `GtkStack` associated with this `GtkStackSidebar`.
    /// 
    /// The sidebar widget will automatically update according to
    /// the order and items within the given `GtkStack`.
    @inlinable func set<StackT: StackProtocol>(stack: StackT) {
        gtk_stack_sidebar_set_stack(stack_sidebar_ptr, stack.stack_ptr)
    
    }
    /// The stack.
    @inlinable var stack: StackRef! {
        /// Retrieves the stack.
        get {
            let rv = StackRef(gconstpointer: gconstpointer(gtk_stack_sidebar_get_stack(stack_sidebar_ptr)))
            return rv
        }
        /// Set the `GtkStack` associated with this `GtkStackSidebar`.
        /// 
        /// The sidebar widget will automatically update according to
        /// the order and items within the given `GtkStack`.
        nonmutating set {
            gtk_stack_sidebar_set_stack(stack_sidebar_ptr, UnsafeMutablePointer<GtkStack>(newValue?.stack_ptr))
        }
    }


}



// MARK: - StackSwitcher Class

/// The `StackSwitcherProtocol` protocol exposes the methods and properties of an underlying `GtkStackSwitcher` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StackSwitcher`.
/// Alternatively, use `StackSwitcherRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkStackSwitcher` shows a row of buttons to switch between `GtkStack`
/// pages.
/// 
/// ![An example GtkStackSwitcher](stackswitcher.png)
/// 
/// It acts as a controller for the associated `GtkStack`.
/// 
/// All the content for the buttons comes from the properties of the stacks
/// [class`Gtk.StackPage`] objects; the button visibility in a `GtkStackSwitcher`
/// widget is controlled by the visibility of the child in the `GtkStack`.
/// 
/// It is possible to associate multiple `GtkStackSwitcher` widgets
/// with the same `GtkStack` widget.
/// 
/// # CSS nodes
/// 
/// `GtkStackSwitcher` has a single CSS node named stackswitcher and
/// style class .stack-switcher.
/// 
/// When circumstances require it, `GtkStackSwitcher` adds the
/// .needs-attention style class to the widgets representing the
/// stack pages.
/// 
/// # Accessibility
/// 
/// `GtkStackSwitcher` uses the `GTK_ACCESSIBLE_ROLE_TAB_LIST` role
/// and uses the `GTK_ACCESSIBLE_ROLE_TAB` for its buttons.
public protocol StackSwitcherProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkStackSwitcher` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStackSwitcher` instance.
    var stack_switcher_ptr: UnsafeMutablePointer<GtkStackSwitcher>! { get }

    /// Required Initialiser for types conforming to `StackSwitcherProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `StackSwitcherRef` type acts as a lightweight Swift reference to an underlying `GtkStackSwitcher` instance.
/// It exposes methods that can operate on this data type through `StackSwitcherProtocol` conformance.
/// Use `StackSwitcherRef` only as an `unowned` reference to an existing `GtkStackSwitcher` instance.
///
/// The `GtkStackSwitcher` shows a row of buttons to switch between `GtkStack`
/// pages.
/// 
/// ![An example GtkStackSwitcher](stackswitcher.png)
/// 
/// It acts as a controller for the associated `GtkStack`.
/// 
/// All the content for the buttons comes from the properties of the stacks
/// [class`Gtk.StackPage`] objects; the button visibility in a `GtkStackSwitcher`
/// widget is controlled by the visibility of the child in the `GtkStack`.
/// 
/// It is possible to associate multiple `GtkStackSwitcher` widgets
/// with the same `GtkStack` widget.
/// 
/// # CSS nodes
/// 
/// `GtkStackSwitcher` has a single CSS node named stackswitcher and
/// style class .stack-switcher.
/// 
/// When circumstances require it, `GtkStackSwitcher` adds the
/// .needs-attention style class to the widgets representing the
/// stack pages.
/// 
/// # Accessibility
/// 
/// `GtkStackSwitcher` uses the `GTK_ACCESSIBLE_ROLE_TAB_LIST` role
/// and uses the `GTK_ACCESSIBLE_ROLE_TAB` for its buttons.
public struct StackSwitcherRef: StackSwitcherProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStackSwitcher` instance.
    /// For type-safe access, use the generated, typed pointer `stack_switcher_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StackSwitcherRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStackSwitcher>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStackSwitcher>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStackSwitcher>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStackSwitcher>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StackSwitcherProtocol`
    @inlinable init<T: StackSwitcherProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StackSwitcherProtocol>(_ other: T) -> StackSwitcherRef { StackSwitcherRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Create a new `GtkStackSwitcher`.
    @inlinable init() {
        let rv = gtk_stack_switcher_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `StackSwitcher` type acts as a reference-counted owner of an underlying `GtkStackSwitcher` instance.
/// It provides the methods that can operate on this data type through `StackSwitcherProtocol` conformance.
/// Use `StackSwitcher` as a strong reference or owner of a `GtkStackSwitcher` instance.
///
/// The `GtkStackSwitcher` shows a row of buttons to switch between `GtkStack`
/// pages.
/// 
/// ![An example GtkStackSwitcher](stackswitcher.png)
/// 
/// It acts as a controller for the associated `GtkStack`.
/// 
/// All the content for the buttons comes from the properties of the stacks
/// [class`Gtk.StackPage`] objects; the button visibility in a `GtkStackSwitcher`
/// widget is controlled by the visibility of the child in the `GtkStack`.
/// 
/// It is possible to associate multiple `GtkStackSwitcher` widgets
/// with the same `GtkStack` widget.
/// 
/// # CSS nodes
/// 
/// `GtkStackSwitcher` has a single CSS node named stackswitcher and
/// style class .stack-switcher.
/// 
/// When circumstances require it, `GtkStackSwitcher` adds the
/// .needs-attention style class to the widgets representing the
/// stack pages.
/// 
/// # Accessibility
/// 
/// `GtkStackSwitcher` uses the `GTK_ACCESSIBLE_ROLE_TAB_LIST` role
/// and uses the `GTK_ACCESSIBLE_ROLE_TAB` for its buttons.
open class StackSwitcher: Widget, StackSwitcherProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStackSwitcher>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStackSwitcher>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStackSwitcher>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStackSwitcher>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStackSwitcher`.
    /// i.e., ownership is transferred to the `StackSwitcher` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStackSwitcher>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StackSwitcherProtocol`
    /// Will retain `GtkStackSwitcher`.
    /// - Parameter other: an instance of a related type that implements `StackSwitcherProtocol`
    @inlinable public init<T: StackSwitcherProtocol>(stackSwitcher other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StackSwitcherProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Create a new `GtkStackSwitcher`.
    @inlinable public init() {
        let rv = gtk_stack_switcher_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StackSwitcherPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// The stack.
    case stack = "stack"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension StackSwitcherProtocol {
    /// Bind a `StackSwitcherPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StackSwitcherPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StackSwitcher property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StackSwitcherPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StackSwitcher property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StackSwitcherPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum StackSwitcherSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// The stack.
    case notifyStack = "notify::stack"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: StackSwitcher has no signals
// MARK: StackSwitcher Class: StackSwitcherProtocol extension (methods and fields)
public extension StackSwitcherProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStackSwitcher` instance.
    @inlinable var stack_switcher_ptr: UnsafeMutablePointer<GtkStackSwitcher>! { return ptr?.assumingMemoryBound(to: GtkStackSwitcher.self) }

    /// Retrieves the stack.
    @inlinable func getStack() -> StackRef! {
        let rv = StackRef(gconstpointer: gconstpointer(gtk_stack_switcher_get_stack(stack_switcher_ptr)))
        return rv
    }

    /// Sets the stack to control.
    @inlinable func set(stack: StackRef? = nil) {
        gtk_stack_switcher_set_stack(stack_switcher_ptr, stack?.stack_ptr)
    
    }
    /// Sets the stack to control.
    @inlinable func set<StackT: StackProtocol>(stack: StackT?) {
        gtk_stack_switcher_set_stack(stack_switcher_ptr, stack?.stack_ptr)
    
    }
    /// The stack.
    @inlinable var stack: StackRef! {
        /// Retrieves the stack.
        get {
            let rv = StackRef(gconstpointer: gconstpointer(gtk_stack_switcher_get_stack(stack_switcher_ptr)))
            return rv
        }
        /// Sets the stack to control.
        nonmutating set {
            gtk_stack_switcher_set_stack(stack_switcher_ptr, UnsafeMutablePointer<GtkStack>(newValue?.stack_ptr))
        }
    }


}



// MARK: - Statusbar Class

/// The `StatusbarProtocol` protocol exposes the methods and properties of an underlying `GtkStatusbar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Statusbar`.
/// Alternatively, use `StatusbarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// A `GtkStatusbar` widget is usually placed along the bottom of an application's
/// main [class`Gtk.Window`].
/// 
/// ![An example GtkStatusbar](statusbar.png)
/// 
/// A `GtkStatusBar` may provide a regular commentary of the application's
/// status (as is usually the case in a web browser, for example), or may be
/// used to simply output a message when the status changes, (when an upload
/// is complete in an FTP client, for example).
/// 
/// Status bars in GTK maintain a stack of messages. The message at
/// the top of the each bar’s stack is the one that will currently be displayed.
/// 
/// Any messages added to a statusbar’s stack must specify a context id that
/// is used to uniquely identify the source of a message. This context id can
/// be generated by [method`Gtk.Statusbar.get_context_id`], given a message and
/// the statusbar that it will be added to. Note that messages are stored in a
/// stack, and when choosing which message to display, the stack structure is
/// adhered to, regardless of the context identifier of a message.
/// 
/// One could say that a statusbar maintains one stack of messages for
/// display purposes, but allows multiple message producers to maintain
/// sub-stacks of the messages they produced (via context ids).
/// 
/// Status bars are created using [ctor`Gtk.Statusbar.new`].
/// 
/// Messages are added to the bar’s stack with [method`Gtk.Statusbar.push`].
/// 
/// The message at the top of the stack can be removed using
/// [method`Gtk.Statusbar.pop`]. A message can be removed from anywhere in the
/// stack if its message id was recorded at the time it was added. This is done
/// using [method`Gtk.Statusbar.remove`].
/// 
/// ## CSS node
/// 
/// `GtkStatusbar` has a single CSS node with name `statusbar`.
public protocol StatusbarProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkStatusbar` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStatusbar` instance.
    var statusbar_ptr: UnsafeMutablePointer<GtkStatusbar>! { get }

    /// Required Initialiser for types conforming to `StatusbarProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `StatusbarRef` type acts as a lightweight Swift reference to an underlying `GtkStatusbar` instance.
/// It exposes methods that can operate on this data type through `StatusbarProtocol` conformance.
/// Use `StatusbarRef` only as an `unowned` reference to an existing `GtkStatusbar` instance.
///
/// A `GtkStatusbar` widget is usually placed along the bottom of an application's
/// main [class`Gtk.Window`].
/// 
/// ![An example GtkStatusbar](statusbar.png)
/// 
/// A `GtkStatusBar` may provide a regular commentary of the application's
/// status (as is usually the case in a web browser, for example), or may be
/// used to simply output a message when the status changes, (when an upload
/// is complete in an FTP client, for example).
/// 
/// Status bars in GTK maintain a stack of messages. The message at
/// the top of the each bar’s stack is the one that will currently be displayed.
/// 
/// Any messages added to a statusbar’s stack must specify a context id that
/// is used to uniquely identify the source of a message. This context id can
/// be generated by [method`Gtk.Statusbar.get_context_id`], given a message and
/// the statusbar that it will be added to. Note that messages are stored in a
/// stack, and when choosing which message to display, the stack structure is
/// adhered to, regardless of the context identifier of a message.
/// 
/// One could say that a statusbar maintains one stack of messages for
/// display purposes, but allows multiple message producers to maintain
/// sub-stacks of the messages they produced (via context ids).
/// 
/// Status bars are created using [ctor`Gtk.Statusbar.new`].
/// 
/// Messages are added to the bar’s stack with [method`Gtk.Statusbar.push`].
/// 
/// The message at the top of the stack can be removed using
/// [method`Gtk.Statusbar.pop`]. A message can be removed from anywhere in the
/// stack if its message id was recorded at the time it was added. This is done
/// using [method`Gtk.Statusbar.remove`].
/// 
/// ## CSS node
/// 
/// `GtkStatusbar` has a single CSS node with name `statusbar`.
public struct StatusbarRef: StatusbarProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStatusbar` instance.
    /// For type-safe access, use the generated, typed pointer `statusbar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StatusbarRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStatusbar>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStatusbar>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStatusbar>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStatusbar>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StatusbarProtocol`
    @inlinable init<T: StatusbarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StatusbarProtocol>(_ other: T) -> StatusbarRef { StatusbarRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkStatusbar` ready for messages.
    @inlinable init() {
        let rv = gtk_statusbar_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Statusbar` type acts as a reference-counted owner of an underlying `GtkStatusbar` instance.
/// It provides the methods that can operate on this data type through `StatusbarProtocol` conformance.
/// Use `Statusbar` as a strong reference or owner of a `GtkStatusbar` instance.
///
/// A `GtkStatusbar` widget is usually placed along the bottom of an application's
/// main [class`Gtk.Window`].
/// 
/// ![An example GtkStatusbar](statusbar.png)
/// 
/// A `GtkStatusBar` may provide a regular commentary of the application's
/// status (as is usually the case in a web browser, for example), or may be
/// used to simply output a message when the status changes, (when an upload
/// is complete in an FTP client, for example).
/// 
/// Status bars in GTK maintain a stack of messages. The message at
/// the top of the each bar’s stack is the one that will currently be displayed.
/// 
/// Any messages added to a statusbar’s stack must specify a context id that
/// is used to uniquely identify the source of a message. This context id can
/// be generated by [method`Gtk.Statusbar.get_context_id`], given a message and
/// the statusbar that it will be added to. Note that messages are stored in a
/// stack, and when choosing which message to display, the stack structure is
/// adhered to, regardless of the context identifier of a message.
/// 
/// One could say that a statusbar maintains one stack of messages for
/// display purposes, but allows multiple message producers to maintain
/// sub-stacks of the messages they produced (via context ids).
/// 
/// Status bars are created using [ctor`Gtk.Statusbar.new`].
/// 
/// Messages are added to the bar’s stack with [method`Gtk.Statusbar.push`].
/// 
/// The message at the top of the stack can be removed using
/// [method`Gtk.Statusbar.pop`]. A message can be removed from anywhere in the
/// stack if its message id was recorded at the time it was added. This is done
/// using [method`Gtk.Statusbar.remove`].
/// 
/// ## CSS node
/// 
/// `GtkStatusbar` has a single CSS node with name `statusbar`.
open class Statusbar: Widget, StatusbarProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStatusbar>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStatusbar>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStatusbar>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStatusbar>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStatusbar`.
    /// i.e., ownership is transferred to the `Statusbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStatusbar>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StatusbarProtocol`
    /// Will retain `GtkStatusbar`.
    /// - Parameter other: an instance of a related type that implements `StatusbarProtocol`
    @inlinable public init<T: StatusbarProtocol>(statusbar other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StatusbarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkStatusbar` ready for messages.
    @inlinable public init() {
        let rv = gtk_statusbar_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StatusbarPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension StatusbarProtocol {
    /// Bind a `StatusbarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StatusbarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Statusbar property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StatusbarPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Statusbar property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StatusbarPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum StatusbarSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted whenever a new message is popped off a statusbar's stack.
    case textPopped = "text-popped"
    /// Emitted whenever a new message gets pushed onto a statusbar's stack.
    case textPushed = "text-pushed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: Statusbar signals
public extension StatusbarProtocol {
    /// Connect a Swift signal handler to the given, typed `StatusbarSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: StatusbarSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `StatusbarSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: StatusbarSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted whenever a new message is popped off a statusbar's stack.
    /// - Note: This represents the underlying `text-popped` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter contextId: the context id of the relevant message/statusbar
    /// - Parameter text: the message that was just popped
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `textPopped` signal is emitted
    @discardableResult @inlinable func onTextPopped(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: StatusbarRef, _ contextId: UInt, _ text: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<StatusbarRef, UInt, String, Void>
        let cCallback: @convention(c) (gpointer, guint, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(StatusbarRef(raw: unownedSelf), UInt(arg1), arg2.map({ String(cString: $0) })!)
            return output
        }
        return connect(
            signal: .textPopped,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `text-popped` signal for using the `connect(signal:)` methods
    static var textPoppedSignal: StatusbarSignalName { .textPopped }
    
    /// Emitted whenever a new message gets pushed onto a statusbar's stack.
    /// - Note: This represents the underlying `text-pushed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter contextId: the context id of the relevant message/statusbar
    /// - Parameter text: the message that was pushed
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `textPushed` signal is emitted
    @discardableResult @inlinable func onTextPushed(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: StatusbarRef, _ contextId: UInt, _ text: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<StatusbarRef, UInt, String, Void>
        let cCallback: @convention(c) (gpointer, guint, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(StatusbarRef(raw: unownedSelf), UInt(arg1), arg2.map({ String(cString: $0) })!)
            return output
        }
        return connect(
            signal: .textPushed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `text-pushed` signal for using the `connect(signal:)` methods
    static var textPushedSignal: StatusbarSignalName { .textPushed }
    
    
}

// MARK: Statusbar Class: StatusbarProtocol extension (methods and fields)
public extension StatusbarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStatusbar` instance.
    @inlinable var statusbar_ptr: UnsafeMutablePointer<GtkStatusbar>! { return ptr?.assumingMemoryBound(to: GtkStatusbar.self) }

    /// Returns a new context identifier, given a description
    /// of the actual context.
    /// 
    /// Note that the description is not shown in the UI.
    @inlinable func getContextId(contextDescription: UnsafePointer<CChar>!) -> Int {
        let rv = Int(gtk_statusbar_get_context_id(statusbar_ptr, contextDescription))
        return rv
    }

    /// Removes the first message in the `GtkStatusbar`’s stack
    /// with the given context id.
    /// 
    /// Note that this may not change the displayed message,
    /// if the message at the top of the stack has a different
    /// context id.
    @inlinable func pop(contextId: Int) {
        gtk_statusbar_pop(statusbar_ptr, guint(contextId))
    
    }

    /// Pushes a new message onto a statusbar’s stack.
    @inlinable func push(contextId: Int, text: UnsafePointer<CChar>!) -> Int {
        let rv = Int(gtk_statusbar_push(statusbar_ptr, guint(contextId), text))
        return rv
    }

    /// Forces the removal of a message from a statusbar’s stack.
    /// The exact `context_id` and `message_id` must be specified.
    @inlinable func remove(contextId: Int, messageId: Int) {
        gtk_statusbar_remove(statusbar_ptr, guint(contextId), guint(messageId))
    
    }

    /// Forces the removal of all messages from a statusbar's
    /// stack with the exact `context_id`.
    @inlinable func removeAll(contextId: Int) {
        gtk_statusbar_remove_all(statusbar_ptr, guint(contextId))
    
    }


}



// MARK: - StringFilter Class

/// The `StringFilterProtocol` protocol exposes the methods and properties of an underlying `GtkStringFilter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StringFilter`.
/// Alternatively, use `StringFilterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkStringFilter` determines whether to include items by comparing
/// strings to a fixed search term.
/// 
/// The strings are obtained from the items by evaluating a `GtkExpression`
/// set with [method`Gtk.StringFilter.set_expression`], and they are
/// compared against a search term set with [method`Gtk.StringFilter.set_search`].
/// 
/// `GtkStringFilter` has several different modes of comparison - it
/// can match the whole string, just a prefix, or any substring. Use
/// [method`Gtk.StringFilter.set_match_mode`] choose a mode.
/// 
/// It is also possible to make case-insensitive comparisons, with
/// [method`Gtk.StringFilter.set_ignore_case`].
public protocol StringFilterProtocol: FilterProtocol {
        /// Untyped pointer to the underlying `GtkStringFilter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStringFilter` instance.
    var string_filter_ptr: UnsafeMutablePointer<GtkStringFilter>! { get }

    /// Required Initialiser for types conforming to `StringFilterProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `StringFilterRef` type acts as a lightweight Swift reference to an underlying `GtkStringFilter` instance.
/// It exposes methods that can operate on this data type through `StringFilterProtocol` conformance.
/// Use `StringFilterRef` only as an `unowned` reference to an existing `GtkStringFilter` instance.
///
/// `GtkStringFilter` determines whether to include items by comparing
/// strings to a fixed search term.
/// 
/// The strings are obtained from the items by evaluating a `GtkExpression`
/// set with [method`Gtk.StringFilter.set_expression`], and they are
/// compared against a search term set with [method`Gtk.StringFilter.set_search`].
/// 
/// `GtkStringFilter` has several different modes of comparison - it
/// can match the whole string, just a prefix, or any substring. Use
/// [method`Gtk.StringFilter.set_match_mode`] choose a mode.
/// 
/// It is also possible to make case-insensitive comparisons, with
/// [method`Gtk.StringFilter.set_ignore_case`].
public struct StringFilterRef: StringFilterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStringFilter` instance.
    /// For type-safe access, use the generated, typed pointer `string_filter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StringFilterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStringFilter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStringFilter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStringFilter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStringFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StringFilterProtocol`
    @inlinable init<T: StringFilterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StringFilterProtocol>(_ other: T) -> StringFilterRef { StringFilterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new string filter.
    /// 
    /// You will want to set up the filter by providing a string to search for
    /// and by providing a property to look up on the item.
    @inlinable init<ExpressionT: ExpressionProtocol>( expression: ExpressionT?) {
        let rv = gtk_string_filter_new(expression?.expression_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `StringFilter` type acts as a reference-counted owner of an underlying `GtkStringFilter` instance.
/// It provides the methods that can operate on this data type through `StringFilterProtocol` conformance.
/// Use `StringFilter` as a strong reference or owner of a `GtkStringFilter` instance.
///
/// `GtkStringFilter` determines whether to include items by comparing
/// strings to a fixed search term.
/// 
/// The strings are obtained from the items by evaluating a `GtkExpression`
/// set with [method`Gtk.StringFilter.set_expression`], and they are
/// compared against a search term set with [method`Gtk.StringFilter.set_search`].
/// 
/// `GtkStringFilter` has several different modes of comparison - it
/// can match the whole string, just a prefix, or any substring. Use
/// [method`Gtk.StringFilter.set_match_mode`] choose a mode.
/// 
/// It is also possible to make case-insensitive comparisons, with
/// [method`Gtk.StringFilter.set_ignore_case`].
open class StringFilter: Filter, StringFilterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStringFilter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStringFilter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStringFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStringFilter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStringFilter`.
    /// i.e., ownership is transferred to the `StringFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStringFilter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StringFilterProtocol`
    /// Will retain `GtkStringFilter`.
    /// - Parameter other: an instance of a related type that implements `StringFilterProtocol`
    @inlinable public init<T: StringFilterProtocol>(stringFilter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new string filter.
    /// 
    /// You will want to set up the filter by providing a string to search for
    /// and by providing a property to look up on the item.
    @inlinable public init<ExpressionT: ExpressionProtocol>( expression: ExpressionT?) {
        let rv = gtk_string_filter_new(expression?.expression_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StringFilterPropertyName: String, PropertyNameProtocol {
    /// The expression to evaluate on item to get a string to compare with.
    case expression = "expression"
    /// If matching is case sensitive.
    case ignoreCase = "ignore-case"
    /// If exact matches are necessary or if substrings are allowed.
    case matchMode = "match-mode"
    /// The search term.
    case search = "search"
}

public extension StringFilterProtocol {
    /// Bind a `StringFilterPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StringFilterPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StringFilter property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StringFilterPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StringFilter property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StringFilterPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum StringFilterSignalName: String, SignalNameProtocol {
    /// Emitted whenever the filter changed.
    /// 
    /// Users of the filter should then check items again via
    /// [method`Gtk.Filter.match`].
    /// 
    /// `GtkFilterListModel` handles this signal automatically.
    /// 
    /// Depending on the `change` parameter, not all items need
    /// to be checked, but only some. Refer to the [enum`Gtk.FilterChange`]
    /// documentation for details.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The expression to evaluate on item to get a string to compare with.
    case notifyExpression = "notify::expression"
    /// If matching is case sensitive.
    case notifyIgnoreCase = "notify::ignore-case"
    /// If exact matches are necessary or if substrings are allowed.
    case notifyMatchMode = "notify::match-mode"
    /// The search term.
    case notifySearch = "notify::search"
}

// MARK: StringFilter has no signals
// MARK: StringFilter Class: StringFilterProtocol extension (methods and fields)
public extension StringFilterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStringFilter` instance.
    @inlinable var string_filter_ptr: UnsafeMutablePointer<GtkStringFilter>! { return ptr?.assumingMemoryBound(to: GtkStringFilter.self) }

    /// Gets the expression that the string filter uses to
    /// obtain strings from items.
    @inlinable func getExpression() -> ExpressionRef! {
        let rv = ExpressionRef(gconstpointer: gconstpointer(gtk_string_filter_get_expression(string_filter_ptr)))
        return rv
    }

    /// Returns whether the filter ignores case differences.
    @inlinable func getIgnoreCase() -> Bool {
        let rv = ((gtk_string_filter_get_ignore_case(string_filter_ptr)) != 0)
        return rv
    }

    /// Returns the match mode that the filter is using.
    @inlinable func getMatchMode() -> GtkStringFilterMatchMode {
        let rv = gtk_string_filter_get_match_mode(string_filter_ptr)
        return rv
    }

    /// Gets the search term.
    @inlinable func getSearch() -> String! {
        let rv = gtk_string_filter_get_search(string_filter_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Sets the expression that the string filter uses to
    /// obtain strings from items.
    /// 
    /// The expression must have a value type of `G_TYPE_STRING`.
    @inlinable func set(expression: ExpressionRef? = nil) {
        gtk_string_filter_set_expression(string_filter_ptr, expression?.expression_ptr)
    
    }
    /// Sets the expression that the string filter uses to
    /// obtain strings from items.
    /// 
    /// The expression must have a value type of `G_TYPE_STRING`.
    @inlinable func set<ExpressionT: ExpressionProtocol>(expression: ExpressionT?) {
        gtk_string_filter_set_expression(string_filter_ptr, expression?.expression_ptr)
    
    }

    /// Sets whether the filter ignores case differences.
    @inlinable func set(ignoreCase: Bool) {
        gtk_string_filter_set_ignore_case(string_filter_ptr, gboolean((ignoreCase) ? 1 : 0))
    
    }

    /// Sets the match mode for the filter.
    @inlinable func setMatch(mode: GtkStringFilterMatchMode) {
        gtk_string_filter_set_match_mode(string_filter_ptr, mode)
    
    }

    /// Sets the string to search for.
    @inlinable func set(search: UnsafePointer<CChar>? = nil) {
        gtk_string_filter_set_search(string_filter_ptr, search)
    
    }
    /// The expression to evaluate on item to get a string to compare with.
    @inlinable var expression: ExpressionRef! {
        /// Gets the expression that the string filter uses to
        /// obtain strings from items.
        get {
            let rv = ExpressionRef(gconstpointer: gconstpointer(gtk_string_filter_get_expression(string_filter_ptr)))
            return rv
        }
        /// Sets the expression that the string filter uses to
        /// obtain strings from items.
        /// 
        /// The expression must have a value type of `G_TYPE_STRING`.
        nonmutating set {
            gtk_string_filter_set_expression(string_filter_ptr, UnsafeMutablePointer<GtkExpression>(newValue?.expression_ptr))
        }
    }

    /// Returns whether the filter ignores case differences.
    @inlinable var ignoreCase: Bool {
        /// Returns whether the filter ignores case differences.
        get {
            let rv = ((gtk_string_filter_get_ignore_case(string_filter_ptr)) != 0)
            return rv
        }
        /// Sets whether the filter ignores case differences.
        nonmutating set {
            gtk_string_filter_set_ignore_case(string_filter_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the match mode that the filter is using.
    @inlinable var matchMode: GtkStringFilterMatchMode {
        /// Returns the match mode that the filter is using.
        get {
            let rv = gtk_string_filter_get_match_mode(string_filter_ptr)
            return rv
        }
        /// Sets the match mode for the filter.
        nonmutating set {
            gtk_string_filter_set_match_mode(string_filter_ptr, newValue)
        }
    }

    /// The search term.
    @inlinable var search: String! {
        /// Gets the search term.
        get {
            let rv = gtk_string_filter_get_search(string_filter_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the string to search for.
        nonmutating set {
            gtk_string_filter_set_search(string_filter_ptr, newValue)
        }
    }


}



// MARK: - StringList Class

/// The `StringListProtocol` protocol exposes the methods and properties of an underlying `GtkStringList` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StringList`.
/// Alternatively, use `StringListRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkStringList` is a list model that wraps an array of strings.
/// 
/// The objects in the model have a "string" property.
/// 
/// `GtkStringList` is well-suited for any place where you would
/// typically use a `char*[]`, but need a list model.
/// 
/// # GtkStringList as GtkBuildable
/// 
/// The `GtkStringList` implementation of the `GtkBuildable` interface
/// supports adding items directly using the &lt;items&gt; element and
/// specifying &lt;item&gt; elements for each item. Each &lt;item&gt; element
/// supports the regular translation attributes “translatable”,
/// “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying a `GtkStringList`
/// 
/// ```xml
/// &lt;object class="GtkStringList"&gt;
///   &lt;items&gt;
///     &lt;item translatable="yes"&gt;Factory&lt;/item&gt;
///     &lt;item translatable="yes"&gt;Home&lt;/item&gt;
///     &lt;item translatable="yes"&gt;Subway&lt;/item&gt;
///   &lt;/items&gt;
/// &lt;/object&gt;
/// ```
public protocol StringListProtocol: GLibObject.ObjectProtocol, GIO.ListModelProtocol, BuildableProtocol {
        /// Untyped pointer to the underlying `GtkStringList` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStringList` instance.
    var string_list_ptr: UnsafeMutablePointer<GtkStringList>! { get }

    /// Required Initialiser for types conforming to `StringListProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `StringListRef` type acts as a lightweight Swift reference to an underlying `GtkStringList` instance.
/// It exposes methods that can operate on this data type through `StringListProtocol` conformance.
/// Use `StringListRef` only as an `unowned` reference to an existing `GtkStringList` instance.
///
/// `GtkStringList` is a list model that wraps an array of strings.
/// 
/// The objects in the model have a "string" property.
/// 
/// `GtkStringList` is well-suited for any place where you would
/// typically use a `char*[]`, but need a list model.
/// 
/// # GtkStringList as GtkBuildable
/// 
/// The `GtkStringList` implementation of the `GtkBuildable` interface
/// supports adding items directly using the &lt;items&gt; element and
/// specifying &lt;item&gt; elements for each item. Each &lt;item&gt; element
/// supports the regular translation attributes “translatable”,
/// “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying a `GtkStringList`
/// 
/// ```xml
/// &lt;object class="GtkStringList"&gt;
///   &lt;items&gt;
///     &lt;item translatable="yes"&gt;Factory&lt;/item&gt;
///     &lt;item translatable="yes"&gt;Home&lt;/item&gt;
///     &lt;item translatable="yes"&gt;Subway&lt;/item&gt;
///   &lt;/items&gt;
/// &lt;/object&gt;
/// ```
public struct StringListRef: StringListProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStringList` instance.
    /// For type-safe access, use the generated, typed pointer `string_list_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StringListRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStringList>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStringList>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStringList>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStringList>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StringListProtocol`
    @inlinable init<T: StringListProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StringListProtocol>(_ other: T) -> StringListRef { StringListRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkStringList` with the given `strings`.
    @inlinable init( strings: UnsafePointer<UnsafePointer<CChar>?>! = nil) {
        let rv = gtk_string_list_new(strings)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `StringList` type acts as a reference-counted owner of an underlying `GtkStringList` instance.
/// It provides the methods that can operate on this data type through `StringListProtocol` conformance.
/// Use `StringList` as a strong reference or owner of a `GtkStringList` instance.
///
/// `GtkStringList` is a list model that wraps an array of strings.
/// 
/// The objects in the model have a "string" property.
/// 
/// `GtkStringList` is well-suited for any place where you would
/// typically use a `char*[]`, but need a list model.
/// 
/// # GtkStringList as GtkBuildable
/// 
/// The `GtkStringList` implementation of the `GtkBuildable` interface
/// supports adding items directly using the &lt;items&gt; element and
/// specifying &lt;item&gt; elements for each item. Each &lt;item&gt; element
/// supports the regular translation attributes “translatable”,
/// “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying a `GtkStringList`
/// 
/// ```xml
/// &lt;object class="GtkStringList"&gt;
///   &lt;items&gt;
///     &lt;item translatable="yes"&gt;Factory&lt;/item&gt;
///     &lt;item translatable="yes"&gt;Home&lt;/item&gt;
///     &lt;item translatable="yes"&gt;Subway&lt;/item&gt;
///   &lt;/items&gt;
/// &lt;/object&gt;
/// ```
open class StringList: GLibObject.Object, StringListProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStringList>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStringList>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStringList>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStringList>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStringList`.
    /// i.e., ownership is transferred to the `StringList` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStringList>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StringListProtocol`
    /// Will retain `GtkStringList`.
    /// - Parameter other: an instance of a related type that implements `StringListProtocol`
    @inlinable public init<T: StringListProtocol>(stringList other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringListProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkStringList` with the given `strings`.
    @inlinable public init( strings: UnsafePointer<UnsafePointer<CChar>?>! = nil) {
        let rv = gtk_string_list_new(strings)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no StringList properties

public enum StringListSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: StringList has no signals
// MARK: StringList Class: StringListProtocol extension (methods and fields)
public extension StringListProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStringList` instance.
    @inlinable var string_list_ptr: UnsafeMutablePointer<GtkStringList>! { return ptr?.assumingMemoryBound(to: GtkStringList.self) }

    /// Appends `string` to `self`.
    /// 
    /// The `string` will be copied. See
    /// [method`Gtk.StringList.take`] for a way to avoid that.
    @inlinable func append(string: UnsafePointer<CChar>!) {
        gtk_string_list_append(string_list_ptr, string)
    
    }

    /// Gets the string that is at `position` in `self`.
    /// 
    /// If `self` does not contain `position` items, `nil` is returned.
    /// 
    /// This function returns the const char *. To get the
    /// object wrapping it, use `g_list_model_get_item()`.
    @inlinable func getString(position: Int) -> String! {
        let rv = gtk_string_list_get_string(string_list_ptr, guint(position)).map({ String(cString: $0) })
        return rv
    }

    /// Removes the string at `position` from `self`.
    /// 
    /// `position` must be smaller than the current
    /// length of the list.
    @inlinable func remove(position: Int) {
        gtk_string_list_remove(string_list_ptr, guint(position))
    
    }

    /// Changes `self` by removing `n_removals` strings and adding `additions`
    /// to it.
    /// 
    /// This function is more efficient than [method`Gtk.StringList.append`]
    /// and [method`Gtk.StringList.remove`], because it only emits the
    /// `items-changed` signal once for the change.
    /// 
    /// This function copies the strings in `additions`.
    /// 
    /// The parameters `position` and `n_removals` must be correct (ie:
    /// `position` + `n_removals` must be less than or equal to the length
    /// of the list at the time this function is called).
    @inlinable func splice(position: Int, nRemovals: Int, additions: UnsafePointer<UnsafePointer<CChar>?>! = nil) {
        gtk_string_list_splice(string_list_ptr, guint(position), guint(nRemovals), additions)
    
    }

    /// Adds `string` to self at the end, and takes
    /// ownership of it.
    /// 
    /// This variant of [method`Gtk.StringList.append`]
    /// is convenient for formatting strings:
    /// 
    /// ```c
    /// gtk_string_list_take (self, g_strdup_print ("`d` dollars", lots));
    /// ```
    @inlinable func take(string: UnsafeMutablePointer<CChar>!) {
        gtk_string_list_take(string_list_ptr, string)
    
    }


}



// MARK: - StringObject Class

/// The `StringObjectProtocol` protocol exposes the methods and properties of an underlying `GtkStringObject` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StringObject`.
/// Alternatively, use `StringObjectRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkStringObject` is the type of items in a `GtkStringList`.
/// 
/// A `GtkStringObject` is a wrapper around a `const char*`; it has
/// a [property`Gtk.StringObject:string`] property.
public protocol StringObjectProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkStringObject` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStringObject` instance.
    var string_object_ptr: UnsafeMutablePointer<GtkStringObject>! { get }

    /// Required Initialiser for types conforming to `StringObjectProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `StringObjectRef` type acts as a lightweight Swift reference to an underlying `GtkStringObject` instance.
/// It exposes methods that can operate on this data type through `StringObjectProtocol` conformance.
/// Use `StringObjectRef` only as an `unowned` reference to an existing `GtkStringObject` instance.
///
/// `GtkStringObject` is the type of items in a `GtkStringList`.
/// 
/// A `GtkStringObject` is a wrapper around a `const char*`; it has
/// a [property`Gtk.StringObject:string`] property.
public struct StringObjectRef: StringObjectProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStringObject` instance.
    /// For type-safe access, use the generated, typed pointer `string_object_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StringObjectRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStringObject>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStringObject>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStringObject>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStringObject>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StringObjectProtocol`
    @inlinable init<T: StringObjectProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StringObjectProtocol>(_ other: T) -> StringObjectRef { StringObjectRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Wraps a string in an object for use with `GListModel`.
    @inlinable init( string: UnsafePointer<CChar>!) {
        let rv = gtk_string_object_new(string)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `StringObject` type acts as a reference-counted owner of an underlying `GtkStringObject` instance.
/// It provides the methods that can operate on this data type through `StringObjectProtocol` conformance.
/// Use `StringObject` as a strong reference or owner of a `GtkStringObject` instance.
///
/// `GtkStringObject` is the type of items in a `GtkStringList`.
/// 
/// A `GtkStringObject` is a wrapper around a `const char*`; it has
/// a [property`Gtk.StringObject:string`] property.
open class StringObject: GLibObject.Object, StringObjectProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStringObject>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStringObject>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStringObject>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStringObject>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStringObject`.
    /// i.e., ownership is transferred to the `StringObject` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStringObject>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StringObjectProtocol`
    /// Will retain `GtkStringObject`.
    /// - Parameter other: an instance of a related type that implements `StringObjectProtocol`
    @inlinable public init<T: StringObjectProtocol>(stringObject other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringObjectProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Wraps a string in an object for use with `GListModel`.
    @inlinable public init( string: UnsafePointer<CChar>!) {
        let rv = gtk_string_object_new(string)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StringObjectPropertyName: String, PropertyNameProtocol {
    /// The string.
    case string = "string"
}

public extension StringObjectProtocol {
    /// Bind a `StringObjectPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StringObjectPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StringObject property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StringObjectPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StringObject property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StringObjectPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum StringObjectSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The string.
    case notifyString = "notify::string"
}

// MARK: StringObject has no signals
// MARK: StringObject Class: StringObjectProtocol extension (methods and fields)
public extension StringObjectProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStringObject` instance.
    @inlinable var string_object_ptr: UnsafeMutablePointer<GtkStringObject>! { return ptr?.assumingMemoryBound(to: GtkStringObject.self) }

    /// Returns the string contained in a `GtkStringObject`.
    @inlinable func getString() -> String! {
        let rv = gtk_string_object_get_string(string_object_ptr).map({ String(cString: $0) })
        return rv
    }
    /// The string.
    @inlinable var string: String! {
        /// Returns the string contained in a `GtkStringObject`.
        get {
            let rv = gtk_string_object_get_string(string_object_ptr).map({ String(cString: $0) })
            return rv
        }
    }


}



// MARK: - StringSorter Class

/// The `StringSorterProtocol` protocol exposes the methods and properties of an underlying `GtkStringSorter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StringSorter`.
/// Alternatively, use `StringSorterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkStringSorter` is a `GtkSorter` that compares strings.
/// 
/// It does the comparison in a linguistically correct way using the
/// current locale by normalizing Unicode strings and possibly case-folding
/// them before performing the comparison.
/// 
/// To obtain the strings to compare, this sorter evaluates a
/// [class`Gtk.Expression`].
public protocol StringSorterProtocol: SorterProtocol {
        /// Untyped pointer to the underlying `GtkStringSorter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStringSorter` instance.
    var string_sorter_ptr: UnsafeMutablePointer<GtkStringSorter>! { get }

    /// Required Initialiser for types conforming to `StringSorterProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `StringSorterRef` type acts as a lightweight Swift reference to an underlying `GtkStringSorter` instance.
/// It exposes methods that can operate on this data type through `StringSorterProtocol` conformance.
/// Use `StringSorterRef` only as an `unowned` reference to an existing `GtkStringSorter` instance.
///
/// `GtkStringSorter` is a `GtkSorter` that compares strings.
/// 
/// It does the comparison in a linguistically correct way using the
/// current locale by normalizing Unicode strings and possibly case-folding
/// them before performing the comparison.
/// 
/// To obtain the strings to compare, this sorter evaluates a
/// [class`Gtk.Expression`].
public struct StringSorterRef: StringSorterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStringSorter` instance.
    /// For type-safe access, use the generated, typed pointer `string_sorter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StringSorterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStringSorter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStringSorter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStringSorter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStringSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StringSorterProtocol`
    @inlinable init<T: StringSorterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StringSorterProtocol>(_ other: T) -> StringSorterRef { StringSorterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new string sorter that compares items using the given
    /// `expression`.
    /// 
    /// Unless an expression is set on it, this sorter will always
    /// compare items as invalid.
    @inlinable init<ExpressionT: ExpressionProtocol>( expression: ExpressionT?) {
        let rv = gtk_string_sorter_new(expression?.expression_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `StringSorter` type acts as a reference-counted owner of an underlying `GtkStringSorter` instance.
/// It provides the methods that can operate on this data type through `StringSorterProtocol` conformance.
/// Use `StringSorter` as a strong reference or owner of a `GtkStringSorter` instance.
///
/// `GtkStringSorter` is a `GtkSorter` that compares strings.
/// 
/// It does the comparison in a linguistically correct way using the
/// current locale by normalizing Unicode strings and possibly case-folding
/// them before performing the comparison.
/// 
/// To obtain the strings to compare, this sorter evaluates a
/// [class`Gtk.Expression`].
open class StringSorter: Sorter, StringSorterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStringSorter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStringSorter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStringSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStringSorter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStringSorter`.
    /// i.e., ownership is transferred to the `StringSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStringSorter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StringSorterProtocol`
    /// Will retain `GtkStringSorter`.
    /// - Parameter other: an instance of a related type that implements `StringSorterProtocol`
    @inlinable public init<T: StringSorterProtocol>(stringSorter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StringSorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new string sorter that compares items using the given
    /// `expression`.
    /// 
    /// Unless an expression is set on it, this sorter will always
    /// compare items as invalid.
    @inlinable public init<ExpressionT: ExpressionProtocol>( expression: ExpressionT?) {
        let rv = gtk_string_sorter_new(expression?.expression_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum StringSorterPropertyName: String, PropertyNameProtocol {
    /// The expression to evaluate on item to get a string to compare with.
    case expression = "expression"
    /// If matching is case sensitive.
    case ignoreCase = "ignore-case"
}

public extension StringSorterProtocol {
    /// Bind a `StringSorterPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StringSorterPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StringSorter property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StringSorterPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StringSorter property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StringSorterPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum StringSorterSignalName: String, SignalNameProtocol {
    /// Emitted whenever the sorter changed.
    /// 
    /// Users of the sorter should then update the sort order
    /// again via `gtk_sorter_compare()`.
    /// 
    /// [class`Gtk.SortListModel`] handles this signal automatically.
    /// 
    /// Depending on the `change` parameter, it may be possible to update
    /// the sort order without a full resorting. Refer to the
    /// [enum`Gtk.SorterChange`] documentation for details.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The expression to evaluate on item to get a string to compare with.
    case notifyExpression = "notify::expression"
    /// If matching is case sensitive.
    case notifyIgnoreCase = "notify::ignore-case"
}

// MARK: StringSorter has no signals
// MARK: StringSorter Class: StringSorterProtocol extension (methods and fields)
public extension StringSorterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStringSorter` instance.
    @inlinable var string_sorter_ptr: UnsafeMutablePointer<GtkStringSorter>! { return ptr?.assumingMemoryBound(to: GtkStringSorter.self) }

    /// Gets the expression that is evaluated to obtain strings from items.
    @inlinable func getExpression() -> ExpressionRef! {
        let rv = ExpressionRef(gconstpointer: gconstpointer(gtk_string_sorter_get_expression(string_sorter_ptr)))
        return rv
    }

    /// Gets whether the sorter ignores case differences.
    @inlinable func getIgnoreCase() -> Bool {
        let rv = ((gtk_string_sorter_get_ignore_case(string_sorter_ptr)) != 0)
        return rv
    }

    /// Sets the expression that is evaluated to obtain strings from items.
    /// 
    /// The expression must have the type `G_TYPE_STRING`.
    @inlinable func set(expression: ExpressionRef? = nil) {
        gtk_string_sorter_set_expression(string_sorter_ptr, expression?.expression_ptr)
    
    }
    /// Sets the expression that is evaluated to obtain strings from items.
    /// 
    /// The expression must have the type `G_TYPE_STRING`.
    @inlinable func set<ExpressionT: ExpressionProtocol>(expression: ExpressionT?) {
        gtk_string_sorter_set_expression(string_sorter_ptr, expression?.expression_ptr)
    
    }

    /// Sets whether the sorter will ignore case differences.
    @inlinable func set(ignoreCase: Bool) {
        gtk_string_sorter_set_ignore_case(string_sorter_ptr, gboolean((ignoreCase) ? 1 : 0))
    
    }
    /// The expression to evaluate on item to get a string to compare with.
    @inlinable var expression: ExpressionRef! {
        /// Gets the expression that is evaluated to obtain strings from items.
        get {
            let rv = ExpressionRef(gconstpointer: gconstpointer(gtk_string_sorter_get_expression(string_sorter_ptr)))
            return rv
        }
        /// Sets the expression that is evaluated to obtain strings from items.
        /// 
        /// The expression must have the type `G_TYPE_STRING`.
        nonmutating set {
            gtk_string_sorter_set_expression(string_sorter_ptr, UnsafeMutablePointer<GtkExpression>(newValue?.expression_ptr))
        }
    }

    /// Gets whether the sorter ignores case differences.
    @inlinable var ignoreCase: Bool {
        /// Gets whether the sorter ignores case differences.
        get {
            let rv = ((gtk_string_sorter_get_ignore_case(string_sorter_ptr)) != 0)
            return rv
        }
        /// Sets whether the sorter will ignore case differences.
        nonmutating set {
            gtk_string_sorter_set_ignore_case(string_sorter_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - StyleContext Class

/// The `StyleContextProtocol` protocol exposes the methods and properties of an underlying `GtkStyleContext` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `StyleContext`.
/// Alternatively, use `StyleContextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkStyleContext` stores styling information affecting a widget.
/// 
/// In order to construct the final style information, `GtkStyleContext`
/// queries information from all attached `GtkStyleProviders`. Style
/// providers can be either attached explicitly to the context through
/// [method`Gtk.StyleContext.add_provider`], or to the display through
/// [func`Gtk.StyleContext.add_provider_for_display`]. The resulting
/// style is a combination of all providers’ information in priority order.
/// 
/// For GTK widgets, any `GtkStyleContext` returned by
/// [method`Gtk.Widget.get_style_context`] will already have a `GdkDisplay`
/// and RTL/LTR information set. The style context will also be updated
/// automatically if any of these settings change on the widget.
/// 
/// # Style Classes
/// 
/// Widgets can add style classes to their context, which can be used to associate
/// different styles by class. The documentation for individual widgets lists
/// which style classes it uses itself, and which style classes may be added by
/// applications to affect their appearance.
/// 
/// # Custom styling in UI libraries and applications
/// 
/// If you are developing a library with custom widgets that render differently
/// than standard components, you may need to add a `GtkStyleProvider` yourself
/// with the `GTK_STYLE_PROVIDER_PRIORITY_FALLBACK` priority, either a
/// `GtkCssProvider` or a custom object implementing the `GtkStyleProvider`
/// interface. This way themes may still attempt to style your UI elements in
/// a different way if needed so.
/// 
/// If you are using custom styling on an applications, you probably want then
/// to make your style information prevail to the theme’s, so you must use
/// a `GtkStyleProvider` with the `GTK_STYLE_PROVIDER_PRIORITY_APPLICATION`
/// priority, keep in mind that the user settings in
/// `XDG_CONFIG_HOME/gtk-4.0/gtk.css` will
/// still take precedence over your changes, as it uses the
/// `GTK_STYLE_PROVIDER_PRIORITY_USER` priority.
public protocol StyleContextProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkStyleContext` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkStyleContext` instance.
    var style_context_ptr: UnsafeMutablePointer<GtkStyleContext>! { get }

    /// Required Initialiser for types conforming to `StyleContextProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `StyleContextRef` type acts as a lightweight Swift reference to an underlying `GtkStyleContext` instance.
/// It exposes methods that can operate on this data type through `StyleContextProtocol` conformance.
/// Use `StyleContextRef` only as an `unowned` reference to an existing `GtkStyleContext` instance.
///
/// `GtkStyleContext` stores styling information affecting a widget.
/// 
/// In order to construct the final style information, `GtkStyleContext`
/// queries information from all attached `GtkStyleProviders`. Style
/// providers can be either attached explicitly to the context through
/// [method`Gtk.StyleContext.add_provider`], or to the display through
/// [func`Gtk.StyleContext.add_provider_for_display`]. The resulting
/// style is a combination of all providers’ information in priority order.
/// 
/// For GTK widgets, any `GtkStyleContext` returned by
/// [method`Gtk.Widget.get_style_context`] will already have a `GdkDisplay`
/// and RTL/LTR information set. The style context will also be updated
/// automatically if any of these settings change on the widget.
/// 
/// # Style Classes
/// 
/// Widgets can add style classes to their context, which can be used to associate
/// different styles by class. The documentation for individual widgets lists
/// which style classes it uses itself, and which style classes may be added by
/// applications to affect their appearance.
/// 
/// # Custom styling in UI libraries and applications
/// 
/// If you are developing a library with custom widgets that render differently
/// than standard components, you may need to add a `GtkStyleProvider` yourself
/// with the `GTK_STYLE_PROVIDER_PRIORITY_FALLBACK` priority, either a
/// `GtkCssProvider` or a custom object implementing the `GtkStyleProvider`
/// interface. This way themes may still attempt to style your UI elements in
/// a different way if needed so.
/// 
/// If you are using custom styling on an applications, you probably want then
/// to make your style information prevail to the theme’s, so you must use
/// a `GtkStyleProvider` with the `GTK_STYLE_PROVIDER_PRIORITY_APPLICATION`
/// priority, keep in mind that the user settings in
/// `XDG_CONFIG_HOME/gtk-4.0/gtk.css` will
/// still take precedence over your changes, as it uses the
/// `GTK_STYLE_PROVIDER_PRIORITY_USER` priority.
public struct StyleContextRef: StyleContextProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkStyleContext` instance.
    /// For type-safe access, use the generated, typed pointer `style_context_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension StyleContextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkStyleContext>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkStyleContext>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkStyleContext>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkStyleContext>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `StyleContextProtocol`
    @inlinable init<T: StyleContextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: StyleContextProtocol>(_ other: T) -> StyleContextRef { StyleContextRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `StyleContext` type acts as a reference-counted owner of an underlying `GtkStyleContext` instance.
/// It provides the methods that can operate on this data type through `StyleContextProtocol` conformance.
/// Use `StyleContext` as a strong reference or owner of a `GtkStyleContext` instance.
///
/// `GtkStyleContext` stores styling information affecting a widget.
/// 
/// In order to construct the final style information, `GtkStyleContext`
/// queries information from all attached `GtkStyleProviders`. Style
/// providers can be either attached explicitly to the context through
/// [method`Gtk.StyleContext.add_provider`], or to the display through
/// [func`Gtk.StyleContext.add_provider_for_display`]. The resulting
/// style is a combination of all providers’ information in priority order.
/// 
/// For GTK widgets, any `GtkStyleContext` returned by
/// [method`Gtk.Widget.get_style_context`] will already have a `GdkDisplay`
/// and RTL/LTR information set. The style context will also be updated
/// automatically if any of these settings change on the widget.
/// 
/// # Style Classes
/// 
/// Widgets can add style classes to their context, which can be used to associate
/// different styles by class. The documentation for individual widgets lists
/// which style classes it uses itself, and which style classes may be added by
/// applications to affect their appearance.
/// 
/// # Custom styling in UI libraries and applications
/// 
/// If you are developing a library with custom widgets that render differently
/// than standard components, you may need to add a `GtkStyleProvider` yourself
/// with the `GTK_STYLE_PROVIDER_PRIORITY_FALLBACK` priority, either a
/// `GtkCssProvider` or a custom object implementing the `GtkStyleProvider`
/// interface. This way themes may still attempt to style your UI elements in
/// a different way if needed so.
/// 
/// If you are using custom styling on an applications, you probably want then
/// to make your style information prevail to the theme’s, so you must use
/// a `GtkStyleProvider` with the `GTK_STYLE_PROVIDER_PRIORITY_APPLICATION`
/// priority, keep in mind that the user settings in
/// `XDG_CONFIG_HOME/gtk-4.0/gtk.css` will
/// still take precedence over your changes, as it uses the
/// `GTK_STYLE_PROVIDER_PRIORITY_USER` priority.
open class StyleContext: GLibObject.Object, StyleContextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkStyleContext>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkStyleContext>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkStyleContext>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkStyleContext>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkStyleContext`.
    /// i.e., ownership is transferred to the `StyleContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkStyleContext>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `StyleContextProtocol`
    /// Will retain `GtkStyleContext`.
    /// - Parameter other: an instance of a related type that implements `StyleContextProtocol`
    @inlinable public init<T: StyleContextProtocol>(styleContext other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `StyleContextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum StyleContextPropertyName: String, PropertyNameProtocol {
    case display = "display"
}

public extension StyleContextProtocol {
    /// Bind a `StyleContextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: StyleContextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a StyleContext property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: StyleContextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a StyleContext property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: StyleContextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum StyleContextSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyDisplay = "notify::display"
}

// MARK: StyleContext has no signals
// MARK: StyleContext Class: StyleContextProtocol extension (methods and fields)
public extension StyleContextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkStyleContext` instance.
    @inlinable var style_context_ptr: UnsafeMutablePointer<GtkStyleContext>! { return ptr?.assumingMemoryBound(to: GtkStyleContext.self) }

    /// Adds a style class to `context`, so later uses of the
    /// style context will make use of this new class for styling.
    /// 
    /// In the CSS file format, a `GtkEntry` defining a “search”
    /// class, would be matched by:
    /// 
    /// ```css
    /// entry.search { ... }
    /// ```
    /// 
    /// While any widget defining a “search” class would be
    /// matched by:
    /// ```css
    /// .search { ... }
    /// ```
    @inlinable func addClass(className: UnsafePointer<CChar>!) {
        gtk_style_context_add_class(style_context_ptr, className)
    
    }

    /// Adds a style provider to `context`, to be used in style construction.
    /// 
    /// Note that a style provider added by this function only affects
    /// the style of the widget to which `context` belongs. If you want
    /// to affect the style of all widgets, use
    /// [func`Gtk.StyleContext.add_provider_for_display`].
    /// 
    /// Note: If both priorities are the same, a `GtkStyleProvider`
    /// added through this function takes precedence over another added
    /// through [func`Gtk.StyleContext.add_provider_for_display`].
    @inlinable func add<StyleProviderT: StyleProviderProtocol>(provider: StyleProviderT, priority: Int) {
        gtk_style_context_add_provider(style_context_ptr, provider.style_provider_ptr, guint(priority))
    
    }

    /// Gets the border for a given state as a `GtkBorder`.
    @inlinable func get<BorderT: BorderProtocol>(border: BorderT) {
        gtk_style_context_get_border(style_context_ptr, border.border_ptr)
    
    }

    /// Gets the foreground color for a given state.
    @inlinable func get<RGBAT: Gdk.RGBAProtocol>(color: RGBAT) {
        gtk_style_context_get_color(style_context_ptr, color.rgba_ptr)
    
    }

    /// Returns the `GdkDisplay` to which `context` is attached.
    @inlinable func getDisplay() -> Gdk.DisplayRef! {
        let rv = Gdk.DisplayRef(gtk_style_context_get_display(style_context_ptr))
        return rv
    }

    /// Gets the margin for a given state as a `GtkBorder`.
    @inlinable func get<BorderT: BorderProtocol>(margin: BorderT) {
        gtk_style_context_get_margin(style_context_ptr, margin.border_ptr)
    
    }

    /// Gets the padding for a given state as a `GtkBorder`.
    @inlinable func get<BorderT: BorderProtocol>(padding: BorderT) {
        gtk_style_context_get_padding(style_context_ptr, padding.border_ptr)
    
    }

    /// Returns the scale used for assets.
    @inlinable func getScale() -> Int {
        let rv = Int(gtk_style_context_get_scale(style_context_ptr))
        return rv
    }

    /// Returns the state used for style matching.
    /// 
    /// This method should only be used to retrieve the `GtkStateFlags`
    /// to pass to `GtkStyleContext` methods, like
    /// [method`Gtk.StyleContext.get_padding`].
    /// If you need to retrieve the current state of a `GtkWidget`, use
    /// [method`Gtk.Widget.get_state_flags`].
    @inlinable func getState() -> StateFlags {
        let rv = StateFlags(gtk_style_context_get_state(style_context_ptr))
        return rv
    }

    /// Returns `true` if `context` currently has defined the
    /// given class name.
    @inlinable func hasClass(className: UnsafePointer<CChar>!) -> Bool {
        let rv = ((gtk_style_context_has_class(style_context_ptr, className)) != 0)
        return rv
    }

    /// Looks up and resolves a color name in the `context` color map.
    @inlinable func lookupColor<RGBAT: Gdk.RGBAProtocol>(colorName: UnsafePointer<CChar>!, color: RGBAT) -> Bool {
        let rv = ((gtk_style_context_lookup_color(style_context_ptr, colorName, color.rgba_ptr)) != 0)
        return rv
    }

    /// Removes `class_name` from `context`.
    @inlinable func removeClass(className: UnsafePointer<CChar>!) {
        gtk_style_context_remove_class(style_context_ptr, className)
    
    }

    /// Removes `provider` from the style providers list in `context`.
    @inlinable func remove<StyleProviderT: StyleProviderProtocol>(provider: StyleProviderT) {
        gtk_style_context_remove_provider(style_context_ptr, provider.style_provider_ptr)
    
    }

    /// Restores `context` state to a previous stage.
    /// 
    /// See [method`Gtk.StyleContext.save`].
    @inlinable func restore() {
        gtk_style_context_restore(style_context_ptr)
    
    }

    /// Saves the `context` state.
    /// 
    /// This allows temporary modifications done through
    /// [method`Gtk.StyleContext.add_class`],
    /// [method`Gtk.StyleContext.remove_class`],
    /// [method`Gtk.StyleContext.set_state`] to be quickly
    /// reverted in one go through [method`Gtk.StyleContext.restore`].
    /// 
    /// The matching call to [method`Gtk.StyleContext.restore`]
    /// must be done before GTK returns to the main loop.
    @inlinable func save() {
        gtk_style_context_save(style_context_ptr)
    
    }

    /// Attaches `context` to the given display.
    /// 
    /// The display is used to add style information from “global”
    /// style providers, such as the display's `GtkSettings` instance.
    /// 
    /// If you are using a `GtkStyleContext` returned from
    /// [method`Gtk.Widget.get_style_context`], you do not need to
    /// call this yourself.
    @inlinable func set<DisplayT: Gdk.DisplayProtocol>(display: DisplayT) {
        gtk_style_context_set_display(style_context_ptr, display.display_ptr)
    
    }

    /// Sets the scale to use when getting image assets for the style.
    @inlinable func set(scale: Int) {
        gtk_style_context_set_scale(style_context_ptr, gint(scale))
    
    }

    /// Sets the state to be used for style matching.
    @inlinable func setState(flags: StateFlags) {
        gtk_style_context_set_state(style_context_ptr, flags.value)
    
    }

    /// Converts the style context into a string representation.
    /// 
    /// The string representation always includes information about
    /// the name, state, id, visibility and style classes of the CSS
    /// node that is backing `context`. Depending on the flags, more
    /// information may be included.
    /// 
    /// This function is intended for testing and debugging of the
    /// CSS implementation in GTK. There are no guarantees about
    /// the format of the returned string, it may change.
    @inlinable func toString(flags: StyleContextPrintFlags) -> String! {
        let rv = gtk_style_context_to_string(style_context_ptr, flags.value).map({ String(cString: $0) })
        return rv
    }

    /// Renders an activity indicator (such as in `GtkSpinner`).
    /// The state `GTK_STATE_FLAG_CHECKED` determines whether there is
    /// activity going on.
    @inlinable func renderActivity<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_activity(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders an arrow pointing to `angle`.
    /// 
    /// Typical arrow rendering at 0, 1⁄2 π;, π; and 3⁄2 π:
    /// 
    /// ![](arrows.png)
    @inlinable func renderArrow<ContextT: Cairo.ContextProtocol>(cr: ContextT, angle: CDouble, x: CDouble, y: CDouble, size: CDouble) {
        gtk_render_arrow(style_context_ptr, cr._ptr, angle, x, y, size)
    
    }

    /// Renders the background of an element.
    /// 
    /// Typical background rendering, showing the effect of
    /// `background-image`, `border-width` and `border-radius`:
    /// 
    /// ![](background.png)
    @inlinable func renderBackground<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_background(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders a checkmark (as in a `GtkCheckButton`).
    /// 
    /// The `GTK_STATE_FLAG_CHECKED` state determines whether the check is
    /// on or off, and `GTK_STATE_FLAG_INCONSISTENT` determines whether it
    /// should be marked as undefined.
    /// 
    /// Typical checkmark rendering:
    /// 
    /// ![](checks.png)
    @inlinable func renderCheck<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_check(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders an expander (as used in `GtkTreeView` and `GtkExpander`) in the area
    /// defined by `x`, `y`, `width`, `height`. The state `GTK_STATE_FLAG_CHECKED`
    /// determines whether the expander is collapsed or expanded.
    /// 
    /// Typical expander rendering:
    /// 
    /// ![](expanders.png)
    @inlinable func renderExpander<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_expander(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders a focus indicator on the rectangle determined by `x`, `y`, `width`, `height`.
    /// 
    /// Typical focus rendering:
    /// 
    /// ![](focus.png)
    @inlinable func renderFocus<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_focus(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders a frame around the rectangle defined by `x`, `y`, `width`, `height`.
    /// 
    /// Examples of frame rendering, showing the effect of `border-image`,
    /// `border-color`, `border-width`, `border-radius` and junctions:
    /// 
    /// ![](frames.png)
    @inlinable func renderFrame<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_frame(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders a handle (as in `GtkPaned` and
    /// `GtkWindow`’s resize grip), in the rectangle
    /// determined by `x`, `y`, `width`, `height`.
    /// 
    /// Handles rendered for the paned and grip classes:
    /// 
    /// ![](handles.png)
    @inlinable func renderHandle<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_handle(style_context_ptr, cr._ptr, x, y, width, height)
    
    }

    /// Renders the icon in `texture` at the specified `x` and `y` coordinates.
    /// 
    /// This function will render the icon in `texture` at exactly its size,
    /// regardless of scaling factors, which may not be appropriate when
    /// drawing on displays with high pixel densities.
    @inlinable func renderIcon<ContextT: Cairo.ContextProtocol, TextureT: Gdk.TextureProtocol>(cr: ContextT, texture: TextureT, x: CDouble, y: CDouble) {
        gtk_render_icon(style_context_ptr, cr._ptr, texture.texture_ptr, x, y)
    
    }

    /// Renders `layout` on the coordinates `x`, `y`
    @inlinable func renderLayout<ContextT: Cairo.ContextProtocol, LayoutT: Pango.LayoutProtocol>(cr: ContextT, x: CDouble, y: CDouble, layout: LayoutT) {
        gtk_render_layout(style_context_ptr, cr._ptr, x, y, layout.layout_ptr)
    
    }

    /// Renders a line from (x0, y0) to (x1, y1).
    @inlinable func renderLine<ContextT: Cairo.ContextProtocol>(cr: ContextT, x0: CDouble, y0: CDouble, x1: CDouble, y1: CDouble) {
        gtk_render_line(style_context_ptr, cr._ptr, x0, y0, x1, y1)
    
    }

    /// Renders an option mark (as in a radio button), the `GTK_STATE_FLAG_CHECKED`
    /// state will determine whether the option is on or off, and
    /// `GTK_STATE_FLAG_INCONSISTENT` whether it should be marked as undefined.
    /// 
    /// Typical option mark rendering:
    /// 
    /// ![](options.png)
    @inlinable func renderOption<ContextT: Cairo.ContextProtocol>(cr: ContextT, x: CDouble, y: CDouble, width: CDouble, height: CDouble) {
        gtk_render_option(style_context_ptr, cr._ptr, x, y, width, height)
    
    }
    @inlinable var display: Gdk.DisplayRef! {
        /// Returns the `GdkDisplay` to which `context` is attached.
        get {
            let rv = Gdk.DisplayRef(gtk_style_context_get_display(style_context_ptr))
            return rv
        }
        /// Attaches `context` to the given display.
        /// 
        /// The display is used to add style information from “global”
        /// style providers, such as the display's `GtkSettings` instance.
        /// 
        /// If you are using a `GtkStyleContext` returned from
        /// [method`Gtk.Widget.get_style_context`], you do not need to
        /// call this yourself.
        nonmutating set {
            gtk_style_context_set_display(style_context_ptr, UnsafeMutablePointer<GdkDisplay>(newValue?.display_ptr))
        }
    }

    /// Returns the scale used for assets.
    @inlinable var scale: Int {
        /// Returns the scale used for assets.
        get {
            let rv = Int(gtk_style_context_get_scale(style_context_ptr))
            return rv
        }
        /// Sets the scale to use when getting image assets for the style.
        nonmutating set {
            gtk_style_context_set_scale(style_context_ptr, gint(newValue))
        }
    }

    /// Returns the state used for style matching.
    /// 
    /// This method should only be used to retrieve the `GtkStateFlags`
    /// to pass to `GtkStyleContext` methods, like
    /// [method`Gtk.StyleContext.get_padding`].
    /// If you need to retrieve the current state of a `GtkWidget`, use
    /// [method`Gtk.Widget.get_state_flags`].
    @inlinable var state: StateFlags {
        /// Returns the state used for style matching.
        /// 
        /// This method should only be used to retrieve the `GtkStateFlags`
        /// to pass to `GtkStyleContext` methods, like
        /// [method`Gtk.StyleContext.get_padding`].
        /// If you need to retrieve the current state of a `GtkWidget`, use
        /// [method`Gtk.Widget.get_state_flags`].
        get {
            let rv = StateFlags(gtk_style_context_get_state(style_context_ptr))
            return rv
        }
        /// Sets the state to be used for style matching.
        nonmutating set {
            gtk_style_context_set_state(style_context_ptr, newValue.value)
        }
    }

    @inlinable var parentObject: GObject {
        get {
            let rv = style_context_ptr.pointee.parent_object
            return rv
        }
    }

}



// MARK: - Switch Class

/// The `SwitchProtocol` protocol exposes the methods and properties of an underlying `GtkSwitch` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Switch`.
/// Alternatively, use `SwitchRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// `GtkSwitch` is a "light switch" that has two states: on or off.
/// 
/// ![An example GtkSwitch](switch.png)
/// 
/// The user can control which state should be active by clicking the
/// empty area, or by dragging the handle.
/// 
/// `GtkSwitch` can also handle situations where the underlying state
/// changes with a delay. See [signal`GtkSwitch::state-set`] for details.
/// 
/// # CSS nodes
/// 
/// ```
/// switch
/// ├── label
/// ├── label
/// ╰── slider
/// ```
/// 
/// `GtkSwitch` has four css nodes, the main node with the name switch and
/// subnodes for the slider and the on and off labels. Neither of them is
/// using any style classes.
/// 
/// # Accessibility
/// 
/// `GtkSwitch` uses the `GTK_ACCESSIBLE_ROLE_SWITCH` role.
public protocol SwitchProtocol: WidgetProtocol, ActionableProtocol {
        /// Untyped pointer to the underlying `GtkSwitch` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkSwitch` instance.
    var switch_ptr: UnsafeMutablePointer<GtkSwitch>! { get }

    /// Required Initialiser for types conforming to `SwitchProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `SwitchRef` type acts as a lightweight Swift reference to an underlying `GtkSwitch` instance.
/// It exposes methods that can operate on this data type through `SwitchProtocol` conformance.
/// Use `SwitchRef` only as an `unowned` reference to an existing `GtkSwitch` instance.
///
/// `GtkSwitch` is a "light switch" that has two states: on or off.
/// 
/// ![An example GtkSwitch](switch.png)
/// 
/// The user can control which state should be active by clicking the
/// empty area, or by dragging the handle.
/// 
/// `GtkSwitch` can also handle situations where the underlying state
/// changes with a delay. See [signal`GtkSwitch::state-set`] for details.
/// 
/// # CSS nodes
/// 
/// ```
/// switch
/// ├── label
/// ├── label
/// ╰── slider
/// ```
/// 
/// `GtkSwitch` has four css nodes, the main node with the name switch and
/// subnodes for the slider and the on and off labels. Neither of them is
/// using any style classes.
/// 
/// # Accessibility
/// 
/// `GtkSwitch` uses the `GTK_ACCESSIBLE_ROLE_SWITCH` role.
public struct SwitchRef: SwitchProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkSwitch` instance.
    /// For type-safe access, use the generated, typed pointer `switch_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension SwitchRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkSwitch>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkSwitch>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkSwitch>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkSwitch>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `SwitchProtocol`
    @inlinable init<T: SwitchProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: SwitchProtocol>(_ other: T) -> SwitchRef { SwitchRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSwitch` widget.
    @inlinable init() {
        let rv = gtk_switch_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `Switch` type acts as a reference-counted owner of an underlying `GtkSwitch` instance.
/// It provides the methods that can operate on this data type through `SwitchProtocol` conformance.
/// Use `Switch` as a strong reference or owner of a `GtkSwitch` instance.
///
/// `GtkSwitch` is a "light switch" that has two states: on or off.
/// 
/// ![An example GtkSwitch](switch.png)
/// 
/// The user can control which state should be active by clicking the
/// empty area, or by dragging the handle.
/// 
/// `GtkSwitch` can also handle situations where the underlying state
/// changes with a delay. See [signal`GtkSwitch::state-set`] for details.
/// 
/// # CSS nodes
/// 
/// ```
/// switch
/// ├── label
/// ├── label
/// ╰── slider
/// ```
/// 
/// `GtkSwitch` has four css nodes, the main node with the name switch and
/// subnodes for the slider and the on and off labels. Neither of them is
/// using any style classes.
/// 
/// # Accessibility
/// 
/// `GtkSwitch` uses the `GTK_ACCESSIBLE_ROLE_SWITCH` role.
open class Switch: Widget, SwitchProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkSwitch>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkSwitch>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkSwitch>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkSwitch>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkSwitch`.
    /// i.e., ownership is transferred to the `Switch` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkSwitch>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `SwitchProtocol`
    /// Will retain `GtkSwitch`.
    /// - Parameter other: an instance of a related type that implements `SwitchProtocol`
    @inlinable public init<T: SwitchProtocol>(switch other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `SwitchProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSwitch` widget.
    @inlinable public init() {
        let rv = gtk_switch_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum SwitchPropertyName: String, PropertyNameProtocol {
    /// Whether the `GtkSwitch` widget is in its on or off state.
    case active = "active"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// The backend state that is controlled by the switch.
    /// 
    /// See [signal`GtkSwitch::state-set`] for details.
    case state = "state"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension SwitchProtocol {
    /// Bind a `SwitchPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: SwitchPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Switch property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: SwitchPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Switch property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: SwitchPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum SwitchSignalName: String, SignalNameProtocol {
    /// Emitted to animate the switch.
    /// 
    /// Applications should never connect to this signal,
    /// but use the [property`Gtk.Switch:active`] property.
    case activate = "activate"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted to change the underlying state.
    /// 
    /// The `state-set` signal is emitted when the user changes the switch
    /// position. The default handler keeps the state in sync with the
    /// [property`Gtk.Switch:active`] property.
    /// 
    /// To implement delayed state change, applications can connect to this
    /// signal, initiate the change of the underlying state, and call
    /// [method`Gtk.Switch.set_state`] when the underlying state change is
    /// complete. The signal handler should return `true` to prevent the
    /// default handler from running.
    /// 
    /// Visually, the underlying state is represented by the trough color of
    /// the switch, while the [property`Gtk.Switch``:active] property is
    /// represented by the position of the switch.
    case stateSet = "state-set"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the `GtkSwitch` widget is in its on or off state.
    case notifyActive = "notify::active"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// The backend state that is controlled by the switch.
    /// 
    /// See [signal`GtkSwitch::state-set`] for details.
    case notifyState = "notify::state"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: Switch signals
public extension SwitchProtocol {
    /// Connect a Swift signal handler to the given, typed `SwitchSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: SwitchSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `SwitchSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: SwitchSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted to animate the switch.
    /// 
    /// Applications should never connect to this signal,
    /// but use the [property`Gtk.Switch:active`] property.
    /// - Note: This represents the underlying `activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `activate` signal is emitted
    @discardableResult @inlinable func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SwitchRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<SwitchRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SwitchRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .activate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `activate` signal for using the `connect(signal:)` methods
    static var activateSignal: SwitchSignalName { .activate }
    
    /// Emitted to change the underlying state.
    /// 
    /// The `state-set` signal is emitted when the user changes the switch
    /// position. The default handler keeps the state in sync with the
    /// [property`Gtk.Switch:active`] property.
    /// 
    /// To implement delayed state change, applications can connect to this
    /// signal, initiate the change of the underlying state, and call
    /// [method`Gtk.Switch.set_state`] when the underlying state change is
    /// complete. The signal handler should return `true` to prevent the
    /// default handler from running.
    /// 
    /// Visually, the underlying state is represented by the trough color of
    /// the switch, while the [property`Gtk.Switch``:active] property is
    /// represented by the position of the switch.
    /// - Note: This represents the underlying `state-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter state: the new state of the switch
    /// - Parameter handler: `true` to stop the signal emission
    /// Run the given callback whenever the `stateSet` signal is emitted
    @discardableResult @inlinable func onStateSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SwitchRef, _ state: Bool) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SwitchRef, Bool, Bool>
        let cCallback: @convention(c) (gpointer, gboolean, gpointer) -> gboolean = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(SwitchRef(raw: unownedSelf), ((arg1) != 0))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .stateSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `state-set` signal for using the `connect(signal:)` methods
    static var stateSetSignal: SwitchSignalName { .stateSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActive` signal is emitted
    @discardableResult @inlinable func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SwitchRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SwitchRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SwitchRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active` signal for using the `connect(signal:)` methods
    static var notifyActiveSignal: SwitchSignalName { .notifyActive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::state` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyState` signal is emitted
    @discardableResult @inlinable func onNotifyState(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: SwitchRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<SwitchRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(SwitchRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyState,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::state` signal for using the `connect(signal:)` methods
    static var notifyStateSignal: SwitchSignalName { .notifyState }
    
}

// MARK: Switch Class: SwitchProtocol extension (methods and fields)
public extension SwitchProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkSwitch` instance.
    @inlinable var switch_ptr: UnsafeMutablePointer<GtkSwitch>! { return ptr?.assumingMemoryBound(to: GtkSwitch.self) }

    /// Gets whether the `GtkSwitch` is in its “on” or “off” state.
    @inlinable func getActive() -> Bool {
        let rv = ((gtk_switch_get_active(switch_ptr)) != 0)
        return rv
    }

    /// Gets the underlying state of the `GtkSwitch`.
    @inlinable func getState() -> Bool {
        let rv = ((gtk_switch_get_state(switch_ptr)) != 0)
        return rv
    }

    /// Changes the state of `self` to the desired one.
    @inlinable func setActive(isActive: Bool) {
        gtk_switch_set_active(switch_ptr, gboolean((isActive) ? 1 : 0))
    
    }

    /// Sets the underlying state of the `GtkSwitch`.
    /// 
    /// Normally, this is the same as [property`Gtk.Switch:active`], unless
    /// the switch is set up for delayed state changes. This function is
    /// typically called from a [signal`Gtk.Switch```state-set`] signal handler.
    /// 
    /// See [signal`Gtk.Switch::state-set`] for details.
    @inlinable func set(state: Bool) {
        gtk_switch_set_state(switch_ptr, gboolean((state) ? 1 : 0))
    
    }
    /// Whether the `GtkSwitch` widget is in its on or off state.
    @inlinable var active: Bool {
        /// Gets whether the `GtkSwitch` is in its “on” or “off” state.
        get {
            let rv = ((gtk_switch_get_active(switch_ptr)) != 0)
            return rv
        }
        /// Changes the state of `self` to the desired one.
        nonmutating set {
            gtk_switch_set_active(switch_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The backend state that is controlled by the switch.
    /// 
    /// See [signal`GtkSwitch::state-set`] for details.
    @inlinable var state: Bool {
        /// Gets the underlying state of the `GtkSwitch`.
        get {
            let rv = ((gtk_switch_get_state(switch_ptr)) != 0)
            return rv
        }
        /// Sets the underlying state of the `GtkSwitch`.
        /// 
        /// Normally, this is the same as [property`Gtk.Switch:active`], unless
        /// the switch is set up for delayed state changes. This function is
        /// typically called from a [signal`Gtk.Switch```state-set`] signal handler.
        /// 
        /// See [signal`Gtk.Switch::state-set`] for details.
        nonmutating set {
            gtk_switch_set_state(switch_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - Text Class

/// The `TextProtocol` protocol exposes the methods and properties of an underlying `GtkText` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Text`.
/// Alternatively, use `TextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
/// The `GtkText` widget is a single-line text entry widget.
/// 
/// `GtkText` is the common implementation of single-line text editing
/// that is shared between `GtkEntry`, `GtkPasswordEntry, `GtkSpinButton`
/// and other widgets. In all of these, `GtkText` is used as the delegate
/// for the [iface`Gtk.Editable`] implementation.
/// 
/// A fairly large set of key bindings are supported by default. If the
/// entered text is longer than the allocation of the widget, the widget
/// will scroll so that the cursor position is visible.
/// 
/// When using an entry for passwords and other sensitive information,
/// it can be put into “password mode” using [method`Gtk.Text.set_visibility`].
/// In this mode, entered text is displayed using a “invisible” character.
/// By default, GTK picks the best invisible character that is available
/// in the current font, but it can be changed with
/// [method`Gtk.Text.set_invisible_char`].
/// 
/// If you are looking to add icons or progress display in an entry, look
/// at `GtkEntry`. There other alternatives for more specialized use cases,
/// such as `GtkSearchEntry`.
/// 
/// If you need multi-line editable text, look at `GtkTextView`.
/// 
/// # CSS nodes
/// 
/// ```
/// text[.read-only]
/// ├── placeholder
/// ├── undershoot.left
/// ├── undershoot.right
/// ├── [selection]
/// ├── [block-cursor]
/// ╰── [window.popup]
/// ```
/// 
/// `GtkText` has a main node with the name text. Depending on the properties
/// of the widget, the .read-only style class may appear.
/// 
/// When the entry has a selection, it adds a subnode with the name selection.
/// 
/// When the entry is in overwrite mode, it adds a subnode with the name
/// block-cursor that determines how the block cursor is drawn.
/// 
/// The CSS node for a context menu is added as a subnode below text as well.
/// 
/// The undershoot nodes are used to draw the underflow indication when content
/// is scrolled out of view. These nodes get the .left and .right style classes
/// added depending on where the indication is drawn.
/// 
/// When touch is used and touch selection handles are shown, they are using
/// CSS nodes with name cursor-handle. They get the .top or .bottom style class
/// depending on where they are shown in relation to the selection. If there is
/// just a single handle for the text cursor, it gets the style class
/// .insertion-cursor.
/// 
/// # Accessibility
/// 
/// `GtkText` uses the `GTK_ACCESSIBLE_ROLE_NONE` role, which causes it to be
/// skipped for accessibility. This is because `GtkText` is expected to be used
/// as a delegate for a `GtkEditable` implementation that will be represented
/// to accessibility.
public protocol TextProtocol: WidgetProtocol, EditableProtocol {
        /// Untyped pointer to the underlying `GtkText` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkText` instance.
    var text_ptr: UnsafeMutablePointer<GtkText>! { get }

    /// Required Initialiser for types conforming to `TextProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `TextRef` type acts as a lightweight Swift reference to an underlying `GtkText` instance.
/// It exposes methods that can operate on this data type through `TextProtocol` conformance.
/// Use `TextRef` only as an `unowned` reference to an existing `GtkText` instance.
///
/// The `GtkText` widget is a single-line text entry widget.
/// 
/// `GtkText` is the common implementation of single-line text editing
/// that is shared between `GtkEntry`, `GtkPasswordEntry, `GtkSpinButton`
/// and other widgets. In all of these, `GtkText` is used as the delegate
/// for the [iface`Gtk.Editable`] implementation.
/// 
/// A fairly large set of key bindings are supported by default. If the
/// entered text is longer than the allocation of the widget, the widget
/// will scroll so that the cursor position is visible.
/// 
/// When using an entry for passwords and other sensitive information,
/// it can be put into “password mode” using [method`Gtk.Text.set_visibility`].
/// In this mode, entered text is displayed using a “invisible” character.
/// By default, GTK picks the best invisible character that is available
/// in the current font, but it can be changed with
/// [method`Gtk.Text.set_invisible_char`].
/// 
/// If you are looking to add icons or progress display in an entry, look
/// at `GtkEntry`. There other alternatives for more specialized use cases,
/// such as `GtkSearchEntry`.
/// 
/// If you need multi-line editable text, look at `GtkTextView`.
/// 
/// # CSS nodes
/// 
/// ```
/// text[.read-only]
/// ├── placeholder
/// ├── undershoot.left
/// ├── undershoot.right
/// ├── [selection]
/// ├── [block-cursor]
/// ╰── [window.popup]
/// ```
/// 
/// `GtkText` has a main node with the name text. Depending on the properties
/// of the widget, the .read-only style class may appear.
/// 
/// When the entry has a selection, it adds a subnode with the name selection.
/// 
/// When the entry is in overwrite mode, it adds a subnode with the name
/// block-cursor that determines how the block cursor is drawn.
/// 
/// The CSS node for a context menu is added as a subnode below text as well.
/// 
/// The undershoot nodes are used to draw the underflow indication when content
/// is scrolled out of view. These nodes get the .left and .right style classes
/// added depending on where the indication is drawn.
/// 
/// When touch is used and touch selection handles are shown, they are using
/// CSS nodes with name cursor-handle. They get the .top or .bottom style class
/// depending on where they are shown in relation to the selection. If there is
/// just a single handle for the text cursor, it gets the style class
/// .insertion-cursor.
/// 
/// # Accessibility
/// 
/// `GtkText` uses the `GTK_ACCESSIBLE_ROLE_NONE` role, which causes it to be
/// skipped for accessibility. This is because `GtkText` is expected to be used
/// as a delegate for a `GtkEditable` implementation that will be represented
/// to accessibility.
public struct TextRef: TextProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkText` instance.
    /// For type-safe access, use the generated, typed pointer `text_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkText>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkText>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkText>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkText>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextProtocol`
    @inlinable init<T: TextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextProtocol>(_ other: T) -> TextRef { TextRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkText`.
    @inlinable init() {
        let rv = gtk_text_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkText` with the specified text buffer.
    @inlinable init<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) {
        let rv = gtk_text_new_with_buffer(buffer.entry_buffer_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkText` with the specified text buffer.
    @inlinable static func newWith<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_text_new_with_buffer(buffer.entry_buffer_ptr))) else { return nil }
        return rv
    }
}

/// The `Text` type acts as a reference-counted owner of an underlying `GtkText` instance.
/// It provides the methods that can operate on this data type through `TextProtocol` conformance.
/// Use `Text` as a strong reference or owner of a `GtkText` instance.
///
/// The `GtkText` widget is a single-line text entry widget.
/// 
/// `GtkText` is the common implementation of single-line text editing
/// that is shared between `GtkEntry`, `GtkPasswordEntry, `GtkSpinButton`
/// and other widgets. In all of these, `GtkText` is used as the delegate
/// for the [iface`Gtk.Editable`] implementation.
/// 
/// A fairly large set of key bindings are supported by default. If the
/// entered text is longer than the allocation of the widget, the widget
/// will scroll so that the cursor position is visible.
/// 
/// When using an entry for passwords and other sensitive information,
/// it can be put into “password mode” using [method`Gtk.Text.set_visibility`].
/// In this mode, entered text is displayed using a “invisible” character.
/// By default, GTK picks the best invisible character that is available
/// in the current font, but it can be changed with
/// [method`Gtk.Text.set_invisible_char`].
/// 
/// If you are looking to add icons or progress display in an entry, look
/// at `GtkEntry`. There other alternatives for more specialized use cases,
/// such as `GtkSearchEntry`.
/// 
/// If you need multi-line editable text, look at `GtkTextView`.
/// 
/// # CSS nodes
/// 
/// ```
/// text[.read-only]
/// ├── placeholder
/// ├── undershoot.left
/// ├── undershoot.right
/// ├── [selection]
/// ├── [block-cursor]
/// ╰── [window.popup]
/// ```
/// 
/// `GtkText` has a main node with the name text. Depending on the properties
/// of the widget, the .read-only style class may appear.
/// 
/// When the entry has a selection, it adds a subnode with the name selection.
/// 
/// When the entry is in overwrite mode, it adds a subnode with the name
/// block-cursor that determines how the block cursor is drawn.
/// 
/// The CSS node for a context menu is added as a subnode below text as well.
/// 
/// The undershoot nodes are used to draw the underflow indication when content
/// is scrolled out of view. These nodes get the .left and .right style classes
/// added depending on where the indication is drawn.
/// 
/// When touch is used and touch selection handles are shown, they are using
/// CSS nodes with name cursor-handle. They get the .top or .bottom style class
/// depending on where they are shown in relation to the selection. If there is
/// just a single handle for the text cursor, it gets the style class
/// .insertion-cursor.
/// 
/// # Accessibility
/// 
/// `GtkText` uses the `GTK_ACCESSIBLE_ROLE_NONE` role, which causes it to be
/// skipped for accessibility. This is because `GtkText` is expected to be used
/// as a delegate for a `GtkEditable` implementation that will be represented
/// to accessibility.
open class Text: Widget, TextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkText>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkText>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkText>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkText>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkText`.
    /// i.e., ownership is transferred to the `Text` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkText>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextProtocol`
    /// Will retain `GtkText`.
    /// - Parameter other: an instance of a related type that implements `TextProtocol`
    @inlinable public init<T: TextProtocol>(text other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkText`.
    @inlinable public init() {
        let rv = gtk_text_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkText` with the specified text buffer.
    @inlinable public init<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) {
        let rv = gtk_text_new_with_buffer(buffer.entry_buffer_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkText` with the specified text buffer.
    @inlinable public static func newWith<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_text_new_with_buffer(buffer.entry_buffer_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum TextPropertyName: String, PropertyNameProtocol {
    /// Whether to activate the default widget when Enter is pressed.
    case activatesDefault = "activates-default"
    /// A list of Pango attributes to apply to the text of the `GtkText`.
    /// 
    /// This is mainly useful to change the size or weight of the text.
    /// 
    /// The `PangoAttribute`'s `start_index` and `end_index` must refer to the
    /// `GtkEntryBuffer` text, i.e. without the preedit string.
    case attributes = "attributes"
    /// The `GtkEntryBuffer` object which stores the text.
    case buffer = "buffer"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether to suggest Emoji replacements.
    case enableEmojiCompletion = "enable-emoji-completion"
    /// A menu model whose contents will be appended to
    /// the context menu.
    case extraMenu = "extra-menu"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// Which IM (input method) module should be used for this self.
    /// 
    /// See [class`Gtk.IMContext`].
    /// 
    /// Setting this to a non-`nil` value overrides the system-wide
    /// IM module setting. See the [property`Gtk.Settings:gtk-im-module`]
    /// property.
    case imModule = "im-module"
    /// Additional hints that allow input methods to fine-tune
    /// their behaviour.
    case inputHints = "input-hints"
    /// The purpose of this text field.
    /// 
    /// This property can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    /// 
    /// Note that setting the purpose to `GTK_INPUT_PURPOSE_PASSWORD` or
    /// `GTK_INPUT_PURPOSE_PIN` is independent from setting
    /// [property`Gtk.Text:visibility`].
    case inputPurpose = "input-purpose"
    /// The character to used when masking contents (in “password mode”).
    case invisibleChar = "invisible-char"
    /// Whether the invisible char has been set for the `GtkText`.
    case invisibleCharSet = "invisible-char-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// Maximum number of characters that are allowed.
    /// 
    /// Zero indicates no limit.
    case maxLength = "max-length"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// If text is overwritten when typing in the `GtkText`.
    case overwriteMode = "overwrite-mode"
    /// The parent widget of this widget.
    case parent = "parent"
    /// The text that will be displayed in the `GtkText` when it is empty
    /// and unfocused.
    case placeholderText = "placeholder-text"
    /// Whether the widget should grow and shrink with the content.
    case propagateTextWidth = "propagate-text-width"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Number of pixels scrolled of the screen to the left.
    case scrollOffset = "scroll-offset"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// A list of tabstops to apply to the text of the `GtkText`.
    case tabs = "tabs"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// When `true`, pasted multi-line text is truncated to the first line.
    case truncateMultiline = "truncate-multiline"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// If `false`, the text is masked with the “invisible char”.
    case visibility = "visibility"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension TextProtocol {
    /// Bind a `TextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Text property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Text property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TextSignalName: String, SignalNameProtocol {
    /// Emitted when the user hits the Enter key.
    /// 
    /// The default bindings for this signal are all forms
    /// of the &lt;kbd&gt;Enter&lt;/kbd&gt; key.
    case activate = "activate"
    /// Emitted when the user asks for it.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Backspace&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Backspace&lt;/kbd&gt;.
    case backspace = "backspace"
    /// Emitted to copy the selection to the clipboard.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;c&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
    case copyClipboard = "copy-clipboard"
    /// Emitted to cut the selection to the clipboard.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;x&lt;/kbd&gt; and
    /// &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt;.
    case cutClipboard = "cut-clipboard"
    /// Emitted when the user initiates a text deletion.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// If the `type` is `GTK_DELETE_CHARS`, GTK deletes the selection
    /// if there is one, otherwise it deletes the requested number
    /// of characters.
    /// 
    /// The default bindings for this signal are &lt;kbd&gt;Delete&lt;/kbd&gt;
    /// for deleting a character and &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt;
    /// for deleting a word.
    case deleteFromCursor = "delete-from-cursor"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted when the user initiates the insertion of a
    /// fixed string at the cursor.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// This signal has no default bindings.
    case insertAtCursor = "insert-at-cursor"
    /// Emitted to present the Emoji chooser for the `self`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;.&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;;&lt;/kbd&gt;
    case insertEmoji = "insert-emoji"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the user initiates a cursor movement.
    /// 
    /// If the cursor is not visible in `self`, this signal causes
    /// the viewport to be moved instead.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// The default bindings for this signal come in two variants,
    /// the variant with the &lt;kbd&gt;Shift&lt;/kbd&gt; modifier extends the
    /// selection, the variant without it does not.
    /// There are too many key combinations to list them all here.
    /// 
    /// - &lt;kbd&gt;←&lt;/kbd&gt;, &lt;kbd&gt;→&lt;/kbd&gt;, &lt;kbd&gt;↑&lt;/kbd&gt;, &lt;kbd&gt;↓&lt;/kbd&gt;
    ///   move by individual characters/lines
    /// - &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;→&lt;/kbd&gt;, etc. move by words/paragraphs
    /// - &lt;kbd&gt;Home&lt;/kbd&gt;, &lt;kbd&gt;End&lt;/kbd&gt; move to the ends of the buffer
    case moveCursor = "move-cursor"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted to paste the contents of the clipboard.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;v&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
    case pasteClipboard = "paste-clipboard"
    /// Emitted when the preedit text changes.
    /// 
    /// If an input method is used, the typed text will not immediately
    /// be committed to the buffer. So if you are interested in the text,
    /// connect to this signal.
    case preeditChanged = "preedit-changed"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted to toggle the overwrite mode of the `GtkText`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal is &lt;kbd&gt;Insert&lt;/kbd&gt;.
    case toggleOverwrite = "toggle-overwrite"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether to activate the default widget when Enter is pressed.
    case notifyActivatesDefault = "notify::activates-default"
    /// A list of Pango attributes to apply to the text of the `GtkText`.
    /// 
    /// This is mainly useful to change the size or weight of the text.
    /// 
    /// The `PangoAttribute`'s `start_index` and `end_index` must refer to the
    /// `GtkEntryBuffer` text, i.e. without the preedit string.
    case notifyAttributes = "notify::attributes"
    /// The `GtkEntryBuffer` object which stores the text.
    case notifyBuffer = "notify::buffer"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether to suggest Emoji replacements.
    case notifyEnableEmojiCompletion = "notify::enable-emoji-completion"
    /// A menu model whose contents will be appended to
    /// the context menu.
    case notifyExtraMenu = "notify::extra-menu"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Which IM (input method) module should be used for this self.
    /// 
    /// See [class`Gtk.IMContext`].
    /// 
    /// Setting this to a non-`nil` value overrides the system-wide
    /// IM module setting. See the [property`Gtk.Settings:gtk-im-module`]
    /// property.
    case notifyImModule = "notify::im-module"
    /// Additional hints that allow input methods to fine-tune
    /// their behaviour.
    case notifyInputHints = "notify::input-hints"
    /// The purpose of this text field.
    /// 
    /// This property can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    /// 
    /// Note that setting the purpose to `GTK_INPUT_PURPOSE_PASSWORD` or
    /// `GTK_INPUT_PURPOSE_PIN` is independent from setting
    /// [property`Gtk.Text:visibility`].
    case notifyInputPurpose = "notify::input-purpose"
    /// The character to used when masking contents (in “password mode”).
    case notifyInvisibleChar = "notify::invisible-char"
    /// Whether the invisible char has been set for the `GtkText`.
    case notifyInvisibleCharSet = "notify::invisible-char-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// Maximum number of characters that are allowed.
    /// 
    /// Zero indicates no limit.
    case notifyMaxLength = "notify::max-length"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// If text is overwritten when typing in the `GtkText`.
    case notifyOverwriteMode = "notify::overwrite-mode"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// The text that will be displayed in the `GtkText` when it is empty
    /// and unfocused.
    case notifyPlaceholderText = "notify::placeholder-text"
    /// Whether the widget should grow and shrink with the content.
    case notifyPropagateTextWidth = "notify::propagate-text-width"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Number of pixels scrolled of the screen to the left.
    case notifyScrollOffset = "notify::scroll-offset"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// A list of tabstops to apply to the text of the `GtkText`.
    case notifyTabs = "notify::tabs"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// When `true`, pasted multi-line text is truncated to the first line.
    case notifyTruncateMultiline = "notify::truncate-multiline"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// If `false`, the text is masked with the “invisible char”.
    case notifyVisibility = "notify::visibility"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: Text signals
public extension TextProtocol {
    /// Connect a Swift signal handler to the given, typed `TextSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TextSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when the user hits the Enter key.
    /// 
    /// The default bindings for this signal are all forms
    /// of the &lt;kbd&gt;Enter&lt;/kbd&gt; key.
    /// - Note: This represents the underlying `activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `activate` signal is emitted
    @discardableResult @inlinable func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .activate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `activate` signal for using the `connect(signal:)` methods
    static var activateSignal: TextSignalName { .activate }
    
    /// Emitted when the user asks for it.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Backspace&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Backspace&lt;/kbd&gt;.
    /// - Note: This represents the underlying `backspace` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `backspace` signal is emitted
    @discardableResult @inlinable func onBackspace(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .backspace,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `backspace` signal for using the `connect(signal:)` methods
    static var backspaceSignal: TextSignalName { .backspace }
    
    /// Emitted to copy the selection to the clipboard.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;c&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
    /// - Note: This represents the underlying `copy-clipboard` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `copyClipboard` signal is emitted
    @discardableResult @inlinable func onCopyClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .copyClipboard,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `copy-clipboard` signal for using the `connect(signal:)` methods
    static var copyClipboardSignal: TextSignalName { .copyClipboard }
    
    /// Emitted to cut the selection to the clipboard.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;x&lt;/kbd&gt; and
    /// &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt;.
    /// - Note: This represents the underlying `cut-clipboard` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `cutClipboard` signal is emitted
    @discardableResult @inlinable func onCutClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .cutClipboard,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `cut-clipboard` signal for using the `connect(signal:)` methods
    static var cutClipboardSignal: TextSignalName { .cutClipboard }
    
    /// Emitted when the user initiates a text deletion.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// If the `type` is `GTK_DELETE_CHARS`, GTK deletes the selection
    /// if there is one, otherwise it deletes the requested number
    /// of characters.
    /// 
    /// The default bindings for this signal are &lt;kbd&gt;Delete&lt;/kbd&gt;
    /// for deleting a character and &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;Delete&lt;/kbd&gt;
    /// for deleting a word.
    /// - Note: This represents the underlying `delete-from-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter type: the granularity of the deletion, as a `GtkDeleteType`
    /// - Parameter count: the number of `type` units to delete
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `deleteFromCursor` signal is emitted
    @discardableResult @inlinable func onDeleteFromCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ type: DeleteType, _ count: Int) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TextRef, DeleteType, Int, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), DeleteType(arg1), Int(arg2))
            return output
        }
        return connect(
            signal: .deleteFromCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `delete-from-cursor` signal for using the `connect(signal:)` methods
    static var deleteFromCursorSignal: TextSignalName { .deleteFromCursor }
    
    /// Emitted when the user initiates the insertion of a
    /// fixed string at the cursor.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// This signal has no default bindings.
    /// - Note: This represents the underlying `insert-at-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter string: the string to insert
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertAtCursor` signal is emitted
    @discardableResult @inlinable func onInsertAtCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ string: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, String, Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!)
            return output
        }
        return connect(
            signal: .insertAtCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-at-cursor` signal for using the `connect(signal:)` methods
    static var insertAtCursorSignal: TextSignalName { .insertAtCursor }
    
    /// Emitted to present the Emoji chooser for the `self`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;.&lt;/kbd&gt; and
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;;&lt;/kbd&gt;
    /// - Note: This represents the underlying `insert-emoji` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertEmoji` signal is emitted
    @discardableResult @inlinable func onInsertEmoji(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .insertEmoji,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-emoji` signal for using the `connect(signal:)` methods
    static var insertEmojiSignal: TextSignalName { .insertEmoji }
    
    /// Emitted when the user initiates a cursor movement.
    /// 
    /// If the cursor is not visible in `self`, this signal causes
    /// the viewport to be moved instead.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// The default bindings for this signal come in two variants,
    /// the variant with the &lt;kbd&gt;Shift&lt;/kbd&gt; modifier extends the
    /// selection, the variant without it does not.
    /// There are too many key combinations to list them all here.
    /// 
    /// - &lt;kbd&gt;←&lt;/kbd&gt;, &lt;kbd&gt;→&lt;/kbd&gt;, &lt;kbd&gt;↑&lt;/kbd&gt;, &lt;kbd&gt;↓&lt;/kbd&gt;
    ///   move by individual characters/lines
    /// - &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;→&lt;/kbd&gt;, etc. move by words/paragraphs
    /// - &lt;kbd&gt;Home&lt;/kbd&gt;, &lt;kbd&gt;End&lt;/kbd&gt; move to the ends of the buffer
    /// - Note: This represents the underlying `move-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter step: the granularity of the move, as a `GtkMovementStep`
    /// - Parameter count: the number of `step` units to move
    /// - Parameter extend: `true` if the move should extend the selection
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `moveCursor` signal is emitted
    @discardableResult @inlinable func onMoveCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ step: MovementStep, _ count: Int, _ extend: Bool) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder4<TextRef, MovementStep, Int, Bool, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gboolean, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), MovementStep(arg1), Int(arg2), ((arg3) != 0))
            return output
        }
        return connect(
            signal: .moveCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `move-cursor` signal for using the `connect(signal:)` methods
    static var moveCursorSignal: TextSignalName { .moveCursor }
    
    /// Emitted to paste the contents of the clipboard.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are
    /// &lt;kbd&gt;Ctrl&lt;/kbd&gt;-&lt;kbd&gt;v&lt;/kbd&gt; and &lt;kbd&gt;Shift&lt;/kbd&gt;-&lt;kbd&gt;Insert&lt;/kbd&gt;.
    /// - Note: This represents the underlying `paste-clipboard` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `pasteClipboard` signal is emitted
    @discardableResult @inlinable func onPasteClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .pasteClipboard,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `paste-clipboard` signal for using the `connect(signal:)` methods
    static var pasteClipboardSignal: TextSignalName { .pasteClipboard }
    
    /// Emitted when the preedit text changes.
    /// 
    /// If an input method is used, the typed text will not immediately
    /// be committed to the buffer. So if you are interested in the text,
    /// connect to this signal.
    /// - Note: This represents the underlying `preedit-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter preedit: the current preedit string
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `preeditChanged` signal is emitted
    @discardableResult @inlinable func onPreeditChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ preedit: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, String, Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!)
            return output
        }
        return connect(
            signal: .preeditChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `preedit-changed` signal for using the `connect(signal:)` methods
    static var preeditChangedSignal: TextSignalName { .preeditChanged }
    
    /// Emitted to toggle the overwrite mode of the `GtkText`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal is &lt;kbd&gt;Insert&lt;/kbd&gt;.
    /// - Note: This represents the underlying `toggle-overwrite` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggleOverwrite` signal is emitted
    @discardableResult @inlinable func onToggleOverwrite(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .toggleOverwrite,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggle-overwrite` signal for using the `connect(signal:)` methods
    static var toggleOverwriteSignal: TextSignalName { .toggleOverwrite }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::activates-default` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActivatesDefault` signal is emitted
    @discardableResult @inlinable func onNotifyActivatesDefault(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyActivatesDefault,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::activates-default` signal for using the `connect(signal:)` methods
    static var notifyActivatesDefaultSignal: TextSignalName { .notifyActivatesDefault }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::attributes` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAttributes` signal is emitted
    @discardableResult @inlinable func onNotifyAttributes(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAttributes,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::attributes` signal for using the `connect(signal:)` methods
    static var notifyAttributesSignal: TextSignalName { .notifyAttributes }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::buffer` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBuffer` signal is emitted
    @discardableResult @inlinable func onNotifyBuffer(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyBuffer,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::buffer` signal for using the `connect(signal:)` methods
    static var notifyBufferSignal: TextSignalName { .notifyBuffer }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::enable-emoji-completion` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEnableEmojiCompletion` signal is emitted
    @discardableResult @inlinable func onNotifyEnableEmojiCompletion(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEnableEmojiCompletion,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::enable-emoji-completion` signal for using the `connect(signal:)` methods
    static var notifyEnableEmojiCompletionSignal: TextSignalName { .notifyEnableEmojiCompletion }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::extra-menu` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyExtraMenu` signal is emitted
    @discardableResult @inlinable func onNotifyExtraMenu(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyExtraMenu,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::extra-menu` signal for using the `connect(signal:)` methods
    static var notifyExtraMenuSignal: TextSignalName { .notifyExtraMenu }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::im-module` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyImModule` signal is emitted
    @discardableResult @inlinable func onNotifyImModule(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyImModule,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::im-module` signal for using the `connect(signal:)` methods
    static var notifyImModuleSignal: TextSignalName { .notifyImModule }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::input-hints` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInputHints` signal is emitted
    @discardableResult @inlinable func onNotifyInputHints(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyInputHints,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::input-hints` signal for using the `connect(signal:)` methods
    static var notifyInputHintsSignal: TextSignalName { .notifyInputHints }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::input-purpose` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInputPurpose` signal is emitted
    @discardableResult @inlinable func onNotifyInputPurpose(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyInputPurpose,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::input-purpose` signal for using the `connect(signal:)` methods
    static var notifyInputPurposeSignal: TextSignalName { .notifyInputPurpose }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::invisible-char` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInvisibleChar` signal is emitted
    @discardableResult @inlinable func onNotifyInvisibleChar(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyInvisibleChar,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::invisible-char` signal for using the `connect(signal:)` methods
    static var notifyInvisibleCharSignal: TextSignalName { .notifyInvisibleChar }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::invisible-char-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInvisibleCharSet` signal is emitted
    @discardableResult @inlinable func onNotifyInvisibleCharSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyInvisibleCharSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::invisible-char-set` signal for using the `connect(signal:)` methods
    static var notifyInvisibleCharSetSignal: TextSignalName { .notifyInvisibleCharSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::max-length` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMaxLength` signal is emitted
    @discardableResult @inlinable func onNotifyMaxLength(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMaxLength,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::max-length` signal for using the `connect(signal:)` methods
    static var notifyMaxLengthSignal: TextSignalName { .notifyMaxLength }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::overwrite-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyOverwriteMode` signal is emitted
    @discardableResult @inlinable func onNotifyOverwriteMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyOverwriteMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::overwrite-mode` signal for using the `connect(signal:)` methods
    static var notifyOverwriteModeSignal: TextSignalName { .notifyOverwriteMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::placeholder-text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPlaceholderText` signal is emitted
    @discardableResult @inlinable func onNotifyPlaceholderText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPlaceholderText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::placeholder-text` signal for using the `connect(signal:)` methods
    static var notifyPlaceholderTextSignal: TextSignalName { .notifyPlaceholderText }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::propagate-text-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPropagateTextWidth` signal is emitted
    @discardableResult @inlinable func onNotifyPropagateTextWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPropagateTextWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::propagate-text-width` signal for using the `connect(signal:)` methods
    static var notifyPropagateTextWidthSignal: TextSignalName { .notifyPropagateTextWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::scroll-offset` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyScrollOffset` signal is emitted
    @discardableResult @inlinable func onNotifyScrollOffset(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyScrollOffset,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::scroll-offset` signal for using the `connect(signal:)` methods
    static var notifyScrollOffsetSignal: TextSignalName { .notifyScrollOffset }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::tabs` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTabs` signal is emitted
    @discardableResult @inlinable func onNotifyTabs(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyTabs,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::tabs` signal for using the `connect(signal:)` methods
    static var notifyTabsSignal: TextSignalName { .notifyTabs }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::truncate-multiline` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTruncateMultiline` signal is emitted
    @discardableResult @inlinable func onNotifyTruncateMultiline(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyTruncateMultiline,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::truncate-multiline` signal for using the `connect(signal:)` methods
    static var notifyTruncateMultilineSignal: TextSignalName { .notifyTruncateMultiline }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::visibility` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVisibility` signal is emitted
    @discardableResult @inlinable func onNotifyVisibility(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyVisibility,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::visibility` signal for using the `connect(signal:)` methods
    static var notifyVisibilitySignal: TextSignalName { .notifyVisibility }
    
}

// MARK: Text Class: TextProtocol extension (methods and fields)
public extension TextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkText` instance.
    @inlinable var text_ptr: UnsafeMutablePointer<GtkText>! { return ptr?.assumingMemoryBound(to: GtkText.self) }

    /// Retrieves the value set by `gtk_text_set_activates_default()`.
    @inlinable func getActivatesDefault() -> Bool {
        let rv = ((gtk_text_get_activates_default(text_ptr)) != 0)
        return rv
    }

    /// Gets the attribute list that was set on the `GtkText`
    /// using `gtk_text_set_attributes()`.
    @inlinable func getAttributes() -> Pango.AttrListRef! {
        let rv = Pango.AttrListRef(gtk_text_get_attributes(text_ptr))
        return rv
    }

    /// Get the `GtkEntryBuffer` object which holds the text for
    /// this self.
    @inlinable func getBuffer() -> EntryBufferRef! {
        let rv = EntryBufferRef(gconstpointer: gconstpointer(gtk_text_get_buffer(text_ptr)))
        return rv
    }

    /// Returns whether Emoji completion is enabled for this
    /// `GtkText` widget.
    @inlinable func getEnableEmojiCompletion() -> Bool {
        let rv = ((gtk_text_get_enable_emoji_completion(text_ptr)) != 0)
        return rv
    }

    /// Gets the menu model set with `gtk_text_set_extra_menu()`.
    @inlinable func getExtraMenu() -> GIO.MenuModelRef! {
        let rv = GIO.MenuModelRef(gtk_text_get_extra_menu(text_ptr))
        return rv
    }

    /// Gets the input hints of the `GtkText`.
    @inlinable func getInputHints() -> InputHints {
        let rv = InputHints(gtk_text_get_input_hints(text_ptr))
        return rv
    }

    /// Gets the input purpose of the `GtkText`.
    @inlinable func getInputPurpose() -> GtkInputPurpose {
        let rv = gtk_text_get_input_purpose(text_ptr)
        return rv
    }

    /// Retrieves the character displayed in place of the real characters
    /// for entries with visibility set to false.
    /// 
    /// Note that GTK does not compute this value unless it needs it,
    /// so the value returned by this function is not very useful unless
    /// it has been explicitly set with [method`Gtk.Text.set_invisible_char`].
    @inlinable func getInvisibleChar() -> gunichar {
        let rv = gtk_text_get_invisible_char(text_ptr)
        return rv
    }

    /// Retrieves the maximum allowed length of the text in `self`.
    /// 
    /// See [method`Gtk.Text.set_max_length`].
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
    /// calling [method`Gtk.EntryBuffer.get_max_length`] on it.
    @inlinable func getMaxLength() -> Int {
        let rv = Int(gtk_text_get_max_length(text_ptr))
        return rv
    }

    /// Gets the value set by `gtk_text_set_overwrite_mode()`.
    @inlinable func getOverwriteMode() -> Bool {
        let rv = ((gtk_text_get_overwrite_mode(text_ptr)) != 0)
        return rv
    }

    /// Retrieves the text that will be displayed when
    /// `self` is empty and unfocused
    @inlinable func getPlaceholderText() -> String! {
        let rv = gtk_text_get_placeholder_text(text_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns whether the `GtkText` will grow and shrink
    /// with the content.
    @inlinable func getPropagateTextWidth() -> Bool {
        let rv = ((gtk_text_get_propagate_text_width(text_ptr)) != 0)
        return rv
    }

    /// Gets the tabstops that were set on the `GtkText`
    /// using `gtk_text_set_tabs()`.
    @inlinable func getTabs() -> Pango.TabArrayRef! {
        let rv = Pango.TabArrayRef(gtk_text_get_tabs(text_ptr))
        return rv
    }

    /// Retrieves the current length of the text in `self`.
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer`
    /// and calling [method`Gtk.EntryBuffer.get_length`] on it.
    @inlinable func getTextLength() -> guint16 {
        let rv = gtk_text_get_text_length(text_ptr)
        return rv
    }

    /// Returns whether the `GtkText` will truncate multi-line text
    /// that is pasted into the widget
    @inlinable func getTruncateMultiline() -> Bool {
        let rv = ((gtk_text_get_truncate_multiline(text_ptr)) != 0)
        return rv
    }

    /// Retrieves whether the text in `self` is visible.
    @inlinable func getVisibility() -> Bool {
        let rv = ((gtk_text_get_visibility(text_ptr)) != 0)
        return rv
    }

    /// Causes `self` to have keyboard focus.
    /// 
    /// It behaves like [method`Gtk.Widget.grab_focus`],
    /// except that it doesn't select the contents of `self`.
    /// You only want to call this on some special entries
    /// which the user usually doesn't want to replace all text in,
    /// such as search-as-you-type entries.
    @inlinable func grabFocusWithoutSelecting() -> Bool {
        let rv = ((gtk_text_grab_focus_without_selecting(text_ptr)) != 0)
        return rv
    }

    /// If `activates` is `true`, pressing Enter in the `self` will
    /// activate the default widget for the window containing `self`.
    /// 
    /// This usually means that the dialog containing the `GtkText`
    /// will be closed, since the default widget is usually one of
    /// the dialog buttons.
    @inlinable func setActivatesDefault(activates: Bool) {
        gtk_text_set_activates_default(text_ptr, gboolean((activates) ? 1 : 0))
    
    }

    /// Sets attributes that are applied to the text.
    @inlinable func setAttributes(attrs: Pango.AttrListRef? = nil) {
        gtk_text_set_attributes(text_ptr, attrs?.attr_list_ptr)
    
    }
    /// Sets attributes that are applied to the text.
    @inlinable func setAttributes<AttrListT: Pango.AttrListProtocol>(attrs: AttrListT?) {
        gtk_text_set_attributes(text_ptr, attrs?.attr_list_ptr)
    
    }

    /// Set the `GtkEntryBuffer` object which holds the text for
    /// this widget.
    @inlinable func set<EntryBufferT: EntryBufferProtocol>(buffer: EntryBufferT) {
        gtk_text_set_buffer(text_ptr, buffer.entry_buffer_ptr)
    
    }

    /// Sets whether Emoji completion is enabled.
    /// 
    /// If it is, typing ':', followed by a recognized keyword,
    /// will pop up a window with suggested Emojis matching the
    /// keyword.
    @inlinable func set(enableEmojiCompletion: Bool) {
        gtk_text_set_enable_emoji_completion(text_ptr, gboolean((enableEmojiCompletion) ? 1 : 0))
    
    }

    /// Sets a menu model to add when constructing
    /// the context menu for `self`.
    @inlinable func setExtraMenu(model: GIO.MenuModelRef? = nil) {
        gtk_text_set_extra_menu(text_ptr, model?.menu_model_ptr)
    
    }
    /// Sets a menu model to add when constructing
    /// the context menu for `self`.
    @inlinable func setExtraMenu<MenuModelT: GIO.MenuModelProtocol>(model: MenuModelT?) {
        gtk_text_set_extra_menu(text_ptr, model?.menu_model_ptr)
    
    }

    /// Sets input hints that allow input methods
    /// to fine-tune their behaviour.
    @inlinable func setInput(hints: InputHints) {
        gtk_text_set_input_hints(text_ptr, hints.value)
    
    }

    /// Sets the input purpose of the `GtkText`.
    /// 
    /// This can be used by on-screen keyboards and other
    /// input methods to adjust their behaviour.
    @inlinable func setInput(purpose: GtkInputPurpose) {
        gtk_text_set_input_purpose(text_ptr, purpose)
    
    }

    /// Sets the character to use in place of the actual text when
    /// in “password mode”.
    /// 
    /// By default, GTK picks the best invisible char available in the
    /// current font. If you set the invisible char to 0, then the user
    /// will get no feedback at all; there will be no text on the screen
    /// as they type.
    @inlinable func setInvisibleChar(ch: gunichar) {
        gtk_text_set_invisible_char(text_ptr, ch)
    
    }

    /// Sets the maximum allowed length of the contents of the widget.
    /// 
    /// If the current contents are longer than the given length, then
    /// they will be truncated to fit.
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
    /// calling [method`Gtk.EntryBuffer.set_max_length`] on it.
    @inlinable func setMax(length: Int) {
        gtk_text_set_max_length(text_ptr, gint(length))
    
    }

    /// Sets whether the text is overwritten when typing
    /// in the `GtkText`.
    @inlinable func setOverwriteMode(overwrite: Bool) {
        gtk_text_set_overwrite_mode(text_ptr, gboolean((overwrite) ? 1 : 0))
    
    }

    /// Sets text to be displayed in `self` when it is empty.
    /// 
    /// This can be used to give a visual hint of the expected
    /// contents of the `GtkText`.
    @inlinable func setPlaceholder(text: UnsafePointer<CChar>? = nil) {
        gtk_text_set_placeholder_text(text_ptr, text)
    
    }

    /// Sets whether the `GtkText` should grow and shrink with the content.
    @inlinable func set(propagateTextWidth: Bool) {
        gtk_text_set_propagate_text_width(text_ptr, gboolean((propagateTextWidth) ? 1 : 0))
    
    }

    /// Sets tabstops that are applied to the text.
    @inlinable func set(tabs: Pango.TabArrayRef? = nil) {
        gtk_text_set_tabs(text_ptr, tabs?.tab_array_ptr)
    
    }
    /// Sets tabstops that are applied to the text.
    @inlinable func set<TabArrayT: Pango.TabArrayProtocol>(tabs: TabArrayT?) {
        gtk_text_set_tabs(text_ptr, tabs?.tab_array_ptr)
    
    }

    /// Sets whether the `GtkText` should truncate multi-line text
    /// that is pasted into the widget.
    @inlinable func set(truncateMultiline: Bool) {
        gtk_text_set_truncate_multiline(text_ptr, gboolean((truncateMultiline) ? 1 : 0))
    
    }

    /// Sets whether the contents of the `GtkText` are visible or not.
    /// 
    /// When visibility is set to `false`, characters are displayed
    /// as the invisible char, and will also appear that way when
    /// the text in the widget is copied to the clipboard.
    /// 
    /// By default, GTK picks the best invisible character available
    /// in the current font, but it can be changed with
    /// [method`Gtk.Text.set_invisible_char`].
    /// 
    /// Note that you probably want to set [property`Gtk.Text:input-purpose`]
    /// to `GTK_INPUT_PURPOSE_PASSWORD` or `GTK_INPUT_PURPOSE_PIN` to
    /// inform input methods about the purpose of this self,
    /// in addition to setting visibility to `false`.
    @inlinable func setVisibility(visible: Bool) {
        gtk_text_set_visibility(text_ptr, gboolean((visible) ? 1 : 0))
    
    }

    /// Unsets the invisible char.
    /// 
    /// After calling this, the default invisible
    /// char is used again.
    @inlinable func unsetInvisibleChar() {
        gtk_text_unset_invisible_char(text_ptr)
    
    }
    /// Retrieves the value set by `gtk_text_set_activates_default()`.
    @inlinable var activatesDefault: Bool {
        /// Retrieves the value set by `gtk_text_set_activates_default()`.
        get {
            let rv = ((gtk_text_get_activates_default(text_ptr)) != 0)
            return rv
        }
        /// If `activates` is `true`, pressing Enter in the `self` will
        /// activate the default widget for the window containing `self`.
        /// 
        /// This usually means that the dialog containing the `GtkText`
        /// will be closed, since the default widget is usually one of
        /// the dialog buttons.
        nonmutating set {
            gtk_text_set_activates_default(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// A list of Pango attributes to apply to the text of the `GtkText`.
    /// 
    /// This is mainly useful to change the size or weight of the text.
    /// 
    /// The `PangoAttribute`'s `start_index` and `end_index` must refer to the
    /// `GtkEntryBuffer` text, i.e. without the preedit string.
    @inlinable var attributes: Pango.AttrListRef! {
        /// Gets the attribute list that was set on the `GtkText`
        /// using `gtk_text_set_attributes()`.
        get {
            let rv = Pango.AttrListRef(gtk_text_get_attributes(text_ptr))
            return rv
        }
        /// Sets attributes that are applied to the text.
        nonmutating set {
            gtk_text_set_attributes(text_ptr, UnsafeMutablePointer<PangoAttrList>(newValue?.attr_list_ptr))
        }
    }

    /// The `GtkEntryBuffer` object which stores the text.
    @inlinable var buffer: EntryBufferRef! {
        /// Get the `GtkEntryBuffer` object which holds the text for
        /// this self.
        get {
            let rv = EntryBufferRef(gconstpointer: gconstpointer(gtk_text_get_buffer(text_ptr)))
            return rv
        }
        /// Set the `GtkEntryBuffer` object which holds the text for
        /// this widget.
        nonmutating set {
            gtk_text_set_buffer(text_ptr, UnsafeMutablePointer<GtkEntryBuffer>(newValue?.entry_buffer_ptr))
        }
    }

    /// Returns whether Emoji completion is enabled for this
    /// `GtkText` widget.
    @inlinable var enableEmojiCompletion: Bool {
        /// Returns whether Emoji completion is enabled for this
        /// `GtkText` widget.
        get {
            let rv = ((gtk_text_get_enable_emoji_completion(text_ptr)) != 0)
            return rv
        }
        /// Sets whether Emoji completion is enabled.
        /// 
        /// If it is, typing ':', followed by a recognized keyword,
        /// will pop up a window with suggested Emojis matching the
        /// keyword.
        nonmutating set {
            gtk_text_set_enable_emoji_completion(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the menu model set with `gtk_text_set_extra_menu()`.
    @inlinable var extraMenu: GIO.MenuModelRef! {
        /// Gets the menu model set with `gtk_text_set_extra_menu()`.
        get {
            let rv = GIO.MenuModelRef(gtk_text_get_extra_menu(text_ptr))
            return rv
        }
        /// Sets a menu model to add when constructing
        /// the context menu for `self`.
        nonmutating set {
            gtk_text_set_extra_menu(text_ptr, UnsafeMutablePointer<GMenuModel>(newValue?.menu_model_ptr))
        }
    }

    /// Gets the input hints of the `GtkText`.
    @inlinable var inputHints: InputHints {
        /// Gets the input hints of the `GtkText`.
        get {
            let rv = InputHints(gtk_text_get_input_hints(text_ptr))
            return rv
        }
        /// Sets input hints that allow input methods
        /// to fine-tune their behaviour.
        nonmutating set {
            gtk_text_set_input_hints(text_ptr, newValue.value)
        }
    }

    /// Gets the input purpose of the `GtkText`.
    @inlinable var inputPurpose: GtkInputPurpose {
        /// Gets the input purpose of the `GtkText`.
        get {
            let rv = gtk_text_get_input_purpose(text_ptr)
            return rv
        }
        /// Sets the input purpose of the `GtkText`.
        /// 
        /// This can be used by on-screen keyboards and other
        /// input methods to adjust their behaviour.
        nonmutating set {
            gtk_text_set_input_purpose(text_ptr, newValue)
        }
    }

    /// Retrieves the character displayed in place of the real characters
    /// for entries with visibility set to false.
    /// 
    /// Note that GTK does not compute this value unless it needs it,
    /// so the value returned by this function is not very useful unless
    /// it has been explicitly set with [method`Gtk.Text.set_invisible_char`].
    @inlinable var invisibleChar: gunichar {
        /// Retrieves the character displayed in place of the real characters
        /// for entries with visibility set to false.
        /// 
        /// Note that GTK does not compute this value unless it needs it,
        /// so the value returned by this function is not very useful unless
        /// it has been explicitly set with [method`Gtk.Text.set_invisible_char`].
        get {
            let rv = gtk_text_get_invisible_char(text_ptr)
            return rv
        }
        /// Sets the character to use in place of the actual text when
        /// in “password mode”.
        /// 
        /// By default, GTK picks the best invisible char available in the
        /// current font. If you set the invisible char to 0, then the user
        /// will get no feedback at all; there will be no text on the screen
        /// as they type.
        nonmutating set {
            gtk_text_set_invisible_char(text_ptr, newValue)
        }
    }

    /// Retrieves the maximum allowed length of the text in `self`.
    /// 
    /// See [method`Gtk.Text.set_max_length`].
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
    /// calling [method`Gtk.EntryBuffer.get_max_length`] on it.
    @inlinable var maxLength: Int {
        /// Retrieves the maximum allowed length of the text in `self`.
        /// 
        /// See [method`Gtk.Text.set_max_length`].
        /// 
        /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
        /// calling [method`Gtk.EntryBuffer.get_max_length`] on it.
        get {
            let rv = Int(gtk_text_get_max_length(text_ptr))
            return rv
        }
        /// Sets the maximum allowed length of the contents of the widget.
        /// 
        /// If the current contents are longer than the given length, then
        /// they will be truncated to fit.
        /// 
        /// This is equivalent to getting `self`'s `GtkEntryBuffer` and
        /// calling [method`Gtk.EntryBuffer.set_max_length`] on it.
        nonmutating set {
            gtk_text_set_max_length(text_ptr, gint(newValue))
        }
    }

    /// Gets the value set by `gtk_text_set_overwrite_mode()`.
    @inlinable var overwriteMode: Bool {
        /// Gets the value set by `gtk_text_set_overwrite_mode()`.
        get {
            let rv = ((gtk_text_get_overwrite_mode(text_ptr)) != 0)
            return rv
        }
        /// Sets whether the text is overwritten when typing
        /// in the `GtkText`.
        nonmutating set {
            gtk_text_set_overwrite_mode(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Retrieves the text that will be displayed when
    /// `self` is empty and unfocused
    @inlinable var placeholderText: String! {
        /// Retrieves the text that will be displayed when
        /// `self` is empty and unfocused
        get {
            let rv = gtk_text_get_placeholder_text(text_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets text to be displayed in `self` when it is empty.
        /// 
        /// This can be used to give a visual hint of the expected
        /// contents of the `GtkText`.
        nonmutating set {
            gtk_text_set_placeholder_text(text_ptr, newValue)
        }
    }

    /// Returns whether the `GtkText` will grow and shrink
    /// with the content.
    @inlinable var propagateTextWidth: Bool {
        /// Returns whether the `GtkText` will grow and shrink
        /// with the content.
        get {
            let rv = ((gtk_text_get_propagate_text_width(text_ptr)) != 0)
            return rv
        }
        /// Sets whether the `GtkText` should grow and shrink with the content.
        nonmutating set {
            gtk_text_set_propagate_text_width(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// A list of tabstops to apply to the text of the `GtkText`.
    @inlinable var tabs: Pango.TabArrayRef! {
        /// Gets the tabstops that were set on the `GtkText`
        /// using `gtk_text_set_tabs()`.
        get {
            let rv = Pango.TabArrayRef(gtk_text_get_tabs(text_ptr))
            return rv
        }
        /// Sets tabstops that are applied to the text.
        nonmutating set {
            gtk_text_set_tabs(text_ptr, UnsafeMutablePointer<PangoTabArray>(newValue?.tab_array_ptr))
        }
    }

    /// Retrieves the current length of the text in `self`.
    /// 
    /// This is equivalent to getting `self`'s `GtkEntryBuffer`
    /// and calling [method`Gtk.EntryBuffer.get_length`] on it.
    @inlinable var textLength: guint16 {
        /// Retrieves the current length of the text in `self`.
        /// 
        /// This is equivalent to getting `self`'s `GtkEntryBuffer`
        /// and calling [method`Gtk.EntryBuffer.get_length`] on it.
        get {
            let rv = gtk_text_get_text_length(text_ptr)
            return rv
        }
    }

    /// Returns whether the `GtkText` will truncate multi-line text
    /// that is pasted into the widget
    @inlinable var truncateMultiline: Bool {
        /// Returns whether the `GtkText` will truncate multi-line text
        /// that is pasted into the widget
        get {
            let rv = ((gtk_text_get_truncate_multiline(text_ptr)) != 0)
            return rv
        }
        /// Sets whether the `GtkText` should truncate multi-line text
        /// that is pasted into the widget.
        nonmutating set {
            gtk_text_set_truncate_multiline(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// If `false`, the text is masked with the “invisible char”.
    @inlinable var visibility: Bool {
        /// Retrieves whether the text in `self` is visible.
        get {
            let rv = ((gtk_text_get_visibility(text_ptr)) != 0)
            return rv
        }
        /// Sets whether the contents of the `GtkText` are visible or not.
        /// 
        /// When visibility is set to `false`, characters are displayed
        /// as the invisible char, and will also appear that way when
        /// the text in the widget is copied to the clipboard.
        /// 
        /// By default, GTK picks the best invisible character available
        /// in the current font, but it can be changed with
        /// [method`Gtk.Text.set_invisible_char`].
        /// 
        /// Note that you probably want to set [property`Gtk.Text:input-purpose`]
        /// to `GTK_INPUT_PURPOSE_PASSWORD` or `GTK_INPUT_PURPOSE_PIN` to
        /// inform input methods about the purpose of this self,
        /// in addition to setting visibility to `false`.
        nonmutating set {
            gtk_text_set_visibility(text_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    // var parentInstance is unavailable because parent_instance is private

}



