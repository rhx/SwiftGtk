import CGLib
import CCairo
import CPango
import CGdkPixbuf
import CGdk
import CAtk
import CGtk
import GLib
import GLibObject
import GIO
import Pango
import Cairo
import PangoCairo
import GdkPixbuf
import Gdk
import Atk

// MARK: - TearoffMenuItem Class

/// A `GtkTearoffMenuItem` is a special `GtkMenuItem` which is used to
/// tear off and reattach its menu.
/// 
/// When its menu is shown normally, the `GtkTearoffMenuItem` is drawn as a
/// dotted line indicating that the menu can be torn off.  Activating it
/// causes its menu to be torn off and displayed in its own window
/// as a tearoff menu.
/// 
/// When its menu is shown as a tearoff menu, the `GtkTearoffMenuItem` is drawn
/// as a dotted line which has a left pointing arrow graphic indicating that
/// the tearoff menu can be reattached.  Activating it will erase the tearoff
/// menu window.
/// 
/// &gt; `GtkTearoffMenuItem` is deprecated and should not be used in newly
/// &gt; written code. Menus are not meant to be torn around.
///
/// The `TearoffMenuItemProtocol` protocol exposes the methods and properties of an underlying `GtkTearoffMenuItem` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TearoffMenuItem`.
/// Alternatively, use `TearoffMenuItemRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TearoffMenuItemProtocol: MenuItemProtocol {
        /// Untyped pointer to the underlying `GtkTearoffMenuItem` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTearoffMenuItem` instance.
    var tearoff_menu_item_ptr: UnsafeMutablePointer<GtkTearoffMenuItem>! { get }

    /// Required Initialiser for types conforming to `TearoffMenuItemProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkTearoffMenuItem` is a special `GtkMenuItem` which is used to
/// tear off and reattach its menu.
/// 
/// When its menu is shown normally, the `GtkTearoffMenuItem` is drawn as a
/// dotted line indicating that the menu can be torn off.  Activating it
/// causes its menu to be torn off and displayed in its own window
/// as a tearoff menu.
/// 
/// When its menu is shown as a tearoff menu, the `GtkTearoffMenuItem` is drawn
/// as a dotted line which has a left pointing arrow graphic indicating that
/// the tearoff menu can be reattached.  Activating it will erase the tearoff
/// menu window.
/// 
/// &gt; `GtkTearoffMenuItem` is deprecated and should not be used in newly
/// &gt; written code. Menus are not meant to be torn around.
///
/// The `TearoffMenuItemRef` type acts as a lightweight Swift reference to an underlying `GtkTearoffMenuItem` instance.
/// It exposes methods that can operate on this data type through `TearoffMenuItemProtocol` conformance.
/// Use `TearoffMenuItemRef` only as an `unowned` reference to an existing `GtkTearoffMenuItem` instance.
///
public struct TearoffMenuItemRef: TearoffMenuItemProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTearoffMenuItem` instance.
    /// For type-safe access, use the generated, typed pointer `tearoff_menu_item_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TearoffMenuItemRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTearoffMenuItem>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTearoffMenuItem>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTearoffMenuItem>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTearoffMenuItem>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TearoffMenuItemProtocol`
    @inlinable init<T: TearoffMenuItemProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TearoffMenuItemProtocol>(_ other: T) -> TearoffMenuItemRef { TearoffMenuItemRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTearoffMenuItem`.
    ///
    /// **new is deprecated:**
    /// #GtkTearoffMenuItem is deprecated and should not be
    ///     used in newly written code.
    @available(*, deprecated)
    @inlinable init() {
        let rv = gtk_tearoff_menu_item_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A `GtkTearoffMenuItem` is a special `GtkMenuItem` which is used to
/// tear off and reattach its menu.
/// 
/// When its menu is shown normally, the `GtkTearoffMenuItem` is drawn as a
/// dotted line indicating that the menu can be torn off.  Activating it
/// causes its menu to be torn off and displayed in its own window
/// as a tearoff menu.
/// 
/// When its menu is shown as a tearoff menu, the `GtkTearoffMenuItem` is drawn
/// as a dotted line which has a left pointing arrow graphic indicating that
/// the tearoff menu can be reattached.  Activating it will erase the tearoff
/// menu window.
/// 
/// &gt; `GtkTearoffMenuItem` is deprecated and should not be used in newly
/// &gt; written code. Menus are not meant to be torn around.
///
/// The `TearoffMenuItem` type acts as a reference-counted owner of an underlying `GtkTearoffMenuItem` instance.
/// It provides the methods that can operate on this data type through `TearoffMenuItemProtocol` conformance.
/// Use `TearoffMenuItem` as a strong reference or owner of a `GtkTearoffMenuItem` instance.
///
open class TearoffMenuItem: MenuItem, TearoffMenuItemProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TearoffMenuItem` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTearoffMenuItem>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TearoffMenuItem` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTearoffMenuItem>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TearoffMenuItem` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TearoffMenuItem` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TearoffMenuItem` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTearoffMenuItem>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TearoffMenuItem` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTearoffMenuItem>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTearoffMenuItem`.
    /// i.e., ownership is transferred to the `TearoffMenuItem` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTearoffMenuItem>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TearoffMenuItemProtocol`
    /// Will retain `GtkTearoffMenuItem`.
    /// - Parameter other: an instance of a related type that implements `TearoffMenuItemProtocol`
    @inlinable public init<T: TearoffMenuItemProtocol>(tearoffMenuItem other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TearoffMenuItemProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkTearoffMenuItem`.
    ///
    /// **new is deprecated:**
    /// #GtkTearoffMenuItem is deprecated and should not be
    ///     used in newly written code.
    @available(*, deprecated)
    @inlinable override public init() {
        let rv = gtk_tearoff_menu_item_new()
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum TearoffMenuItemPropertyName: String, PropertyNameProtocol {
    /// Sets the accelerator path of the menu item, through which runtime
    /// changes of the menu item's accelerator caused by the user can be
    /// identified and saved to persistant storage.
    case accelPath = "accel-path"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case isFocus = "is-focus"
    /// The text for the child label.
    case label = "label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// Sets whether the menu item appears justified
    /// at the right side of a menu bar.
    case rightJustified = "right-justified"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// The submenu attached to the menu item, or `nil` if it has none.
    case submenu = "submenu"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// `true` if underlines in the text indicate mnemonics.
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension TearoffMenuItemProtocol {
    /// Bind a `TearoffMenuItemPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TearoffMenuItemPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TearoffMenuItem property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TearoffMenuItemPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TearoffMenuItem property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TearoffMenuItemPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TearoffMenuItemSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// Emitted when the item is activated.
    case activate = "activate"
    /// Emitted when the item is activated, but also if the menu item has a
    /// submenu. For normal applications, the relevant signal is
    /// `GtkMenuItem::activate`.
    case activateItem = "activate-item"
    case add = "add"
    /// The `button-press-event` signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button-release-event` signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child-notify` signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The `composited-changed` signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure-event` signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete-event` signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    case deselect = "deselect"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy-event` signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction-changed` signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag-begin` signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag-data-delete` signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag-data-get` signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag-data-received` signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag-drop` signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag-drop` signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag-data-received` handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag-end` signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag-begin`.
    case dragEnd = "drag-end"
    /// The `drag-failed` signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag-leave` signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag-motion`, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag-leave` signal is also emitted before the
    /// `drag-drop` signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag-motion` signal handler.
    case dragLeave = "drag-leave"
    /// The `drag-motion` signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag-data-received`
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag-leave` and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter-notify-event` will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key-press-event`) and finally a generic
    /// `GtkWidget::event-after` signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event-after` will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The `focus-in-event` signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus-out-event` signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab-notify` signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy-changed` signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key-press-event` signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key-release-event` signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave-notify-event` will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map-event` will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map-event` signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion-notify-event` signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent-set` signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The `property-notify-event` signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has-tooltip` is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen-changed` signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll-event` signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    case select = "select"
    /// The `selection-clear-event` signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection-request-event` signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The `state-changed` signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state-flags-changed` signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style-set` signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style-updated` signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style-updated` signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case toggleSizeAllocate = "toggle-size-allocate"
    case toggleSizeRequest = "toggle-size-request"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap-event` signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility-notify-event` will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The `window-state-event` will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    /// Sets the accelerator path of the menu item, through which runtime
    /// changes of the menu item's accelerator caused by the user can be
    /// identified and saved to persistant storage.
    case notifyAccelPath = "notify::accel-path"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyIsFocus = "notify::is-focus"
    /// The text for the child label.
    case notifyLabel = "notify::label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// Sets whether the menu item appears justified
    /// at the right side of a menu bar.
    case notifyRightJustified = "notify::right-justified"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// The submenu attached to the menu item, or `nil` if it has none.
    case notifySubmenu = "notify::submenu"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// `true` if underlines in the text indicate mnemonics.
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

// MARK: TearoffMenuItem has no signals
// MARK: TearoffMenuItem Class: TearoffMenuItemProtocol extension (methods and fields)
public extension TearoffMenuItemProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTearoffMenuItem` instance.
    @inlinable var tearoff_menu_item_ptr: UnsafeMutablePointer<GtkTearoffMenuItem>! { return ptr?.assumingMemoryBound(to: GtkTearoffMenuItem.self) }


    @inlinable var menuItem: GtkMenuItem {
        get {
            let rv = tearoff_menu_item_ptr.pointee.menu_item
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TextBuffer Class

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
///
/// The `TextBufferProtocol` protocol exposes the methods and properties of an underlying `GtkTextBuffer` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextBuffer`.
/// Alternatively, use `TextBufferRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextBufferProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTextBuffer` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextBuffer` instance.
    var text_buffer_ptr: UnsafeMutablePointer<GtkTextBuffer>! { get }

    /// Required Initialiser for types conforming to `TextBufferProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
///
/// The `TextBufferRef` type acts as a lightweight Swift reference to an underlying `GtkTextBuffer` instance.
/// It exposes methods that can operate on this data type through `TextBufferProtocol` conformance.
/// Use `TextBufferRef` only as an `unowned` reference to an existing `GtkTextBuffer` instance.
///
public struct TextBufferRef: TextBufferProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextBuffer` instance.
    /// For type-safe access, use the generated, typed pointer `text_buffer_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextBufferRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextBuffer>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextBuffer>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextBuffer>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextBuffer>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextBufferProtocol`
    @inlinable init<T: TextBufferProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextBufferProtocol>(_ other: T) -> TextBufferRef { TextBufferRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new text buffer.
    @inlinable init<TextTagTableT: TextTagTableProtocol>( table: TextTagTableT?) {
        let rv = gtk_text_buffer_new(table?.text_tag_table_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
///
/// The `TextBuffer` type acts as a reference-counted owner of an underlying `GtkTextBuffer` instance.
/// It provides the methods that can operate on this data type through `TextBufferProtocol` conformance.
/// Use `TextBuffer` as a strong reference or owner of a `GtkTextBuffer` instance.
///
open class TextBuffer: GLibObject.Object, TextBufferProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextBuffer>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextBuffer>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextBuffer>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextBuffer>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextBuffer`.
    /// i.e., ownership is transferred to the `TextBuffer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextBuffer>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextBufferProtocol`
    /// Will retain `GtkTextBuffer`.
    /// - Parameter other: an instance of a related type that implements `TextBufferProtocol`
    @inlinable public init<T: TextBufferProtocol>(textBuffer other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextBufferProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new text buffer.
    @inlinable public init<TextTagTableT: TextTagTableProtocol>( table: TextTagTableT?) {
        let rv = gtk_text_buffer_new(table?.text_tag_table_ptr)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum TextBufferPropertyName: String, PropertyNameProtocol {
    /// The list of targets this buffer supports for clipboard copying
    /// and as DND source.
    case copyTargetList = "copy-target-list"
    /// The position of the insert mark (as offset from the beginning
    /// of the buffer). It is useful for getting notified when the
    /// cursor moves.
    case cursorPosition = "cursor-position"
    /// Whether the buffer has some text currently selected.
    case hasSelection = "has-selection"
    /// The list of targets this buffer supports for clipboard pasting
    /// and as DND destination.
    case pasteTargetList = "paste-target-list"
    case tagTable = "tag-table"
    /// The text content of the buffer. Without child widgets and images,
    /// see `gtk_text_buffer_get_text()` for more information.
    case text = "text"
}

public extension TextBufferProtocol {
    /// Bind a `TextBufferPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextBufferPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TextBuffer property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextBufferPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TextBuffer property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextBufferPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TextBufferSignalName: String, SignalNameProtocol {
    /// The `apply-tag` signal is emitted to apply a tag to a
    /// range of text in a `GtkTextBuffer`.
    /// Applying actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `start` and `end` iters (or has to revalidate them).
    /// 
    /// See also:
    /// `gtk_text_buffer_apply_tag()`,
    /// `gtk_text_buffer_insert_with_tags()`,
    /// `gtk_text_buffer_insert_range()`.
    case applyTag = "apply-tag"
    /// The `begin-user-action` signal is emitted at the beginning of a single
    /// user-visible operation on a `GtkTextBuffer`.
    /// 
    /// See also:
    /// `gtk_text_buffer_begin_user_action()`,
    /// `gtk_text_buffer_insert_interactive()`,
    /// `gtk_text_buffer_insert_range_interactive()`,
    /// `gtk_text_buffer_delete_interactive()`,
    /// `gtk_text_buffer_backspace()`,
    /// `gtk_text_buffer_delete_selection()`.
    case beginUserAction = "begin-user-action"
    /// The `changed` signal is emitted when the content of a `GtkTextBuffer`
    /// has changed.
    case changed = "changed"
    /// The `delete-range` signal is emitted to delete a range
    /// from a `GtkTextBuffer`.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `start` and `end` iters (or has to revalidate them).
    /// The default signal handler revalidates the `start` and `end` iters to
    /// both point to the location where text was deleted. Handlers
    /// which run after the default handler (see `g_signal_connect_after()`)
    /// do not have access to the deleted text.
    /// 
    /// See also: `gtk_text_buffer_delete()`.
    case deleteRange = "delete-range"
    /// The `end-user-action` signal is emitted at the end of a single
    /// user-visible operation on the `GtkTextBuffer`.
    /// 
    /// See also:
    /// `gtk_text_buffer_end_user_action()`,
    /// `gtk_text_buffer_insert_interactive()`,
    /// `gtk_text_buffer_insert_range_interactive()`,
    /// `gtk_text_buffer_delete_interactive()`,
    /// `gtk_text_buffer_backspace()`,
    /// `gtk_text_buffer_delete_selection()`,
    /// `gtk_text_buffer_backspace()`.
    case endUserAction = "end-user-action"
    /// The `insert-child-anchor` signal is emitted to insert a
    /// `GtkTextChildAnchor` in a `GtkTextBuffer`.
    /// Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must
    /// not invalidate the `location` iter (or has to revalidate it).
    /// The default signal handler revalidates it to be placed after the
    /// inserted `anchor`.
    /// 
    /// See also: `gtk_text_buffer_insert_child_anchor()`.
    case insertChildAnchor = "insert-child-anchor"
    /// The `insert-pixbuf` signal is emitted to insert a `GdkPixbuf`
    /// in a `GtkTextBuffer`. Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `location` iter (or has to revalidate it).
    /// The default signal handler revalidates it to be placed after the
    /// inserted `pixbuf`.
    /// 
    /// See also: `gtk_text_buffer_insert_pixbuf()`.
    case insertPixbuf = "insert-pixbuf"
    /// The `insert-text` signal is emitted to insert text in a `GtkTextBuffer`.
    /// Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `location` iter (or has to revalidate it).
    /// The default signal handler revalidates it to point to the end of the
    /// inserted text.
    /// 
    /// See also:
    /// `gtk_text_buffer_insert()`,
    /// `gtk_text_buffer_insert_range()`.
    case insertText = "insert-text"
    /// The `mark-deleted` signal is emitted as notification
    /// after a `GtkTextMark` is deleted.
    /// 
    /// See also:
    /// `gtk_text_buffer_delete_mark()`.
    case markDeleted = "mark-deleted"
    /// The `mark-set` signal is emitted as notification
    /// after a `GtkTextMark` is set.
    /// 
    /// See also:
    /// `gtk_text_buffer_create_mark()`,
    /// `gtk_text_buffer_move_mark()`.
    case markSet = "mark-set"
    /// The `modified-changed` signal is emitted when the modified bit of a
    /// `GtkTextBuffer` flips.
    /// 
    /// See also:
    /// `gtk_text_buffer_set_modified()`.
    case modifiedChanged = "modified-changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The paste-done signal is emitted after paste operation has been completed.
    /// This is useful to properly scroll the view to the end of the pasted text.
    /// See `gtk_text_buffer_paste_clipboard()` for more details.
    case pasteDone = "paste-done"
    /// The `remove-tag` signal is emitted to remove all occurrences of `tag` from
    /// a range of text in a `GtkTextBuffer`.
    /// Removal actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `start` and `end` iters (or has to revalidate them).
    /// 
    /// See also:
    /// `gtk_text_buffer_remove_tag()`.
    case removeTag = "remove-tag"
    /// The list of targets this buffer supports for clipboard copying
    /// and as DND source.
    case notifyCopyTargetList = "notify::copy-target-list"
    /// The position of the insert mark (as offset from the beginning
    /// of the buffer). It is useful for getting notified when the
    /// cursor moves.
    case notifyCursorPosition = "notify::cursor-position"
    /// Whether the buffer has some text currently selected.
    case notifyHasSelection = "notify::has-selection"
    /// The list of targets this buffer supports for clipboard pasting
    /// and as DND destination.
    case notifyPasteTargetList = "notify::paste-target-list"
    case notifyTagTable = "notify::tag-table"
    /// The text content of the buffer. Without child widgets and images,
    /// see `gtk_text_buffer_get_text()` for more information.
    case notifyText = "notify::text"
}

// MARK: TextBuffer signals
public extension TextBufferProtocol {
    /// Connect a Swift signal handler to the given, typed `TextBufferSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextBufferSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TextBufferSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextBufferSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// The `apply-tag` signal is emitted to apply a tag to a
    /// range of text in a `GtkTextBuffer`.
    /// Applying actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `start` and `end` iters (or has to revalidate them).
    /// 
    /// See also:
    /// `gtk_text_buffer_apply_tag()`,
    /// `gtk_text_buffer_insert_with_tags()`,
    /// `gtk_text_buffer_insert_range()`.
    /// - Note: This represents the underlying `apply-tag` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter tag: the applied tag
    /// - Parameter start: the start of the range the tag is applied to
    /// - Parameter end: the end of the range the tag is applied to
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `applyTag` signal is emitted
    @discardableResult @inlinable func onApplyTag(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ tag: TextTagRef, _ start: TextIterRef, _ end: TextIterRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder4<TextBufferRef, TextTagRef, TextIterRef, TextIterRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), TextTagRef(raw: arg1), TextIterRef(raw: arg2), TextIterRef(raw: arg3))
            return output
        }
        return connect(
            signal: .applyTag,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `apply-tag` signal for using the `connect(signal:)` methods
    static var applyTagSignal: TextBufferSignalName { .applyTag }
    
    /// The `begin-user-action` signal is emitted at the beginning of a single
    /// user-visible operation on a `GtkTextBuffer`.
    /// 
    /// See also:
    /// `gtk_text_buffer_begin_user_action()`,
    /// `gtk_text_buffer_insert_interactive()`,
    /// `gtk_text_buffer_insert_range_interactive()`,
    /// `gtk_text_buffer_delete_interactive()`,
    /// `gtk_text_buffer_backspace()`,
    /// `gtk_text_buffer_delete_selection()`.
    /// - Note: This represents the underlying `begin-user-action` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `beginUserAction` signal is emitted
    @discardableResult @inlinable func onBeginUserAction(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextBufferRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .beginUserAction,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `begin-user-action` signal for using the `connect(signal:)` methods
    static var beginUserActionSignal: TextBufferSignalName { .beginUserAction }
    
    /// The `changed` signal is emitted when the content of a `GtkTextBuffer`
    /// has changed.
    /// - Note: This represents the underlying `changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `changed` signal is emitted
    @discardableResult @inlinable func onChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextBufferRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .changed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `changed` signal for using the `connect(signal:)` methods
    static var changedSignal: TextBufferSignalName { .changed }
    
    /// The `delete-range` signal is emitted to delete a range
    /// from a `GtkTextBuffer`.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `start` and `end` iters (or has to revalidate them).
    /// The default signal handler revalidates the `start` and `end` iters to
    /// both point to the location where text was deleted. Handlers
    /// which run after the default handler (see `g_signal_connect_after()`)
    /// do not have access to the deleted text.
    /// 
    /// See also: `gtk_text_buffer_delete()`.
    /// - Note: This represents the underlying `delete-range` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter start: the start of the range to be deleted
    /// - Parameter end: the end of the range to be deleted
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `deleteRange` signal is emitted
    @discardableResult @inlinable func onDeleteRange(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ start: TextIterRef, _ end: TextIterRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TextBufferRef, TextIterRef, TextIterRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), TextIterRef(raw: arg1), TextIterRef(raw: arg2))
            return output
        }
        return connect(
            signal: .deleteRange,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `delete-range` signal for using the `connect(signal:)` methods
    static var deleteRangeSignal: TextBufferSignalName { .deleteRange }
    
    /// The `end-user-action` signal is emitted at the end of a single
    /// user-visible operation on the `GtkTextBuffer`.
    /// 
    /// See also:
    /// `gtk_text_buffer_end_user_action()`,
    /// `gtk_text_buffer_insert_interactive()`,
    /// `gtk_text_buffer_insert_range_interactive()`,
    /// `gtk_text_buffer_delete_interactive()`,
    /// `gtk_text_buffer_backspace()`,
    /// `gtk_text_buffer_delete_selection()`,
    /// `gtk_text_buffer_backspace()`.
    /// - Note: This represents the underlying `end-user-action` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `endUserAction` signal is emitted
    @discardableResult @inlinable func onEndUserAction(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextBufferRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .endUserAction,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `end-user-action` signal for using the `connect(signal:)` methods
    static var endUserActionSignal: TextBufferSignalName { .endUserAction }
    
    /// The `insert-child-anchor` signal is emitted to insert a
    /// `GtkTextChildAnchor` in a `GtkTextBuffer`.
    /// Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must
    /// not invalidate the `location` iter (or has to revalidate it).
    /// The default signal handler revalidates it to be placed after the
    /// inserted `anchor`.
    /// 
    /// See also: `gtk_text_buffer_insert_child_anchor()`.
    /// - Note: This represents the underlying `insert-child-anchor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter location: position to insert `anchor` in `textbuffer`
    /// - Parameter anchor: the `GtkTextChildAnchor` to be inserted
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertChildAnchor` signal is emitted
    @discardableResult @inlinable func onInsertChildAnchor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ location: TextIterRef, _ anchor: TextChildAnchorRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TextBufferRef, TextIterRef, TextChildAnchorRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), TextIterRef(raw: arg1), TextChildAnchorRef(raw: arg2))
            return output
        }
        return connect(
            signal: .insertChildAnchor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-child-anchor` signal for using the `connect(signal:)` methods
    static var insertChildAnchorSignal: TextBufferSignalName { .insertChildAnchor }
    
    /// The `insert-pixbuf` signal is emitted to insert a `GdkPixbuf`
    /// in a `GtkTextBuffer`. Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `location` iter (or has to revalidate it).
    /// The default signal handler revalidates it to be placed after the
    /// inserted `pixbuf`.
    /// 
    /// See also: `gtk_text_buffer_insert_pixbuf()`.
    /// - Note: This represents the underlying `insert-pixbuf` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter location: position to insert `pixbuf` in `textbuffer`
    /// - Parameter pixbuf: the `GdkPixbuf` to be inserted
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertPixbuf` signal is emitted
    @discardableResult @inlinable func onInsertPixbuf(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ location: TextIterRef, _ pixbuf: PixbufRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TextBufferRef, TextIterRef, PixbufRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), TextIterRef(raw: arg1), PixbufRef(raw: arg2))
            return output
        }
        return connect(
            signal: .insertPixbuf,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-pixbuf` signal for using the `connect(signal:)` methods
    static var insertPixbufSignal: TextBufferSignalName { .insertPixbuf }
    
    /// The `insert-text` signal is emitted to insert text in a `GtkTextBuffer`.
    /// Insertion actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `location` iter (or has to revalidate it).
    /// The default signal handler revalidates it to point to the end of the
    /// inserted text.
    /// 
    /// See also:
    /// `gtk_text_buffer_insert()`,
    /// `gtk_text_buffer_insert_range()`.
    /// - Note: This represents the underlying `insert-text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter location: position to insert `text` in `textbuffer`
    /// - Parameter text: the UTF-8 text to be inserted
    /// - Parameter len: length of the inserted text in bytes
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertText` signal is emitted
    @discardableResult @inlinable func onInsertText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ location: TextIterRef, _ text: String, _ len: Int) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder4<TextBufferRef, TextIterRef, String, Int, Void>
        let cCallback: @convention(c) (gpointer, gpointer, UnsafeMutablePointer<gchar>?, gint, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), TextIterRef(raw: arg1), arg2.map({ String(cString: $0) })!, Int(arg3))
            return output
        }
        return connect(
            signal: .insertText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-text` signal for using the `connect(signal:)` methods
    static var insertTextSignal: TextBufferSignalName { .insertText }
    
    /// The `mark-deleted` signal is emitted as notification
    /// after a `GtkTextMark` is deleted.
    /// 
    /// See also:
    /// `gtk_text_buffer_delete_mark()`.
    /// - Note: This represents the underlying `mark-deleted` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter mark: The mark that was deleted
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `markDeleted` signal is emitted
    @discardableResult @inlinable func onMarkDeleted(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ mark: TextMarkRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextBufferRef, TextMarkRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), TextMarkRef(raw: arg1))
            return output
        }
        return connect(
            signal: .markDeleted,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `mark-deleted` signal for using the `connect(signal:)` methods
    static var markDeletedSignal: TextBufferSignalName { .markDeleted }
    
    /// The `mark-set` signal is emitted as notification
    /// after a `GtkTextMark` is set.
    /// 
    /// See also:
    /// `gtk_text_buffer_create_mark()`,
    /// `gtk_text_buffer_move_mark()`.
    /// - Note: This represents the underlying `mark-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter location: The location of `mark` in `textbuffer`
    /// - Parameter mark: The mark that is set
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `markSet` signal is emitted
    @discardableResult @inlinable func onMarkSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ location: TextIterRef, _ mark: TextMarkRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TextBufferRef, TextIterRef, TextMarkRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), TextIterRef(raw: arg1), TextMarkRef(raw: arg2))
            return output
        }
        return connect(
            signal: .markSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `mark-set` signal for using the `connect(signal:)` methods
    static var markSetSignal: TextBufferSignalName { .markSet }
    
    /// The `modified-changed` signal is emitted when the modified bit of a
    /// `GtkTextBuffer` flips.
    /// 
    /// See also:
    /// `gtk_text_buffer_set_modified()`.
    /// - Note: This represents the underlying `modified-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `modifiedChanged` signal is emitted
    @discardableResult @inlinable func onModifiedChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextBufferRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .modifiedChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `modified-changed` signal for using the `connect(signal:)` methods
    static var modifiedChangedSignal: TextBufferSignalName { .modifiedChanged }
    
    /// The paste-done signal is emitted after paste operation has been completed.
    /// This is useful to properly scroll the view to the end of the pasted text.
    /// See `gtk_text_buffer_paste_clipboard()` for more details.
    /// - Note: This represents the underlying `paste-done` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter clipboard: the `GtkClipboard` pasted from
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `pasteDone` signal is emitted
    @discardableResult @inlinable func onPasteDone(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ clipboard: ClipboardRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextBufferRef, ClipboardRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), ClipboardRef(raw: arg1))
            return output
        }
        return connect(
            signal: .pasteDone,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `paste-done` signal for using the `connect(signal:)` methods
    static var pasteDoneSignal: TextBufferSignalName { .pasteDone }
    
    /// The `remove-tag` signal is emitted to remove all occurrences of `tag` from
    /// a range of text in a `GtkTextBuffer`.
    /// Removal actually occurs in the default handler.
    /// 
    /// Note that if your handler runs before the default handler it must not
    /// invalidate the `start` and `end` iters (or has to revalidate them).
    /// 
    /// See also:
    /// `gtk_text_buffer_remove_tag()`.
    /// - Note: This represents the underlying `remove-tag` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter tag: the tag to be removed
    /// - Parameter start: the start of the range the tag is removed from
    /// - Parameter end: the end of the range the tag is removed from
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `removeTag` signal is emitted
    @discardableResult @inlinable func onRemoveTag(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ tag: TextTagRef, _ start: TextIterRef, _ end: TextIterRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder4<TextBufferRef, TextTagRef, TextIterRef, TextIterRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), TextTagRef(raw: arg1), TextIterRef(raw: arg2), TextIterRef(raw: arg3))
            return output
        }
        return connect(
            signal: .removeTag,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `remove-tag` signal for using the `connect(signal:)` methods
    static var removeTagSignal: TextBufferSignalName { .removeTag }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::copy-target-list` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCopyTargetList` signal is emitted
    @discardableResult @inlinable func onNotifyCopyTargetList(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextBufferRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyCopyTargetList,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::copy-target-list` signal for using the `connect(signal:)` methods
    static var notifyCopyTargetListSignal: TextBufferSignalName { .notifyCopyTargetList }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::cursor-position` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCursorPosition` signal is emitted
    @discardableResult @inlinable func onNotifyCursorPosition(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextBufferRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyCursorPosition,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::cursor-position` signal for using the `connect(signal:)` methods
    static var notifyCursorPositionSignal: TextBufferSignalName { .notifyCursorPosition }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::has-selection` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHasSelection` signal is emitted
    @discardableResult @inlinable func onNotifyHasSelection(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextBufferRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyHasSelection,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::has-selection` signal for using the `connect(signal:)` methods
    static var notifyHasSelectionSignal: TextBufferSignalName { .notifyHasSelection }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::paste-target-list` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPasteTargetList` signal is emitted
    @discardableResult @inlinable func onNotifyPasteTargetList(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextBufferRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPasteTargetList,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::paste-target-list` signal for using the `connect(signal:)` methods
    static var notifyPasteTargetListSignal: TextBufferSignalName { .notifyPasteTargetList }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::tag-table` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTagTable` signal is emitted
    @discardableResult @inlinable func onNotifyTagTable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextBufferRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyTagTable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::tag-table` signal for using the `connect(signal:)` methods
    static var notifyTagTableSignal: TextBufferSignalName { .notifyTagTable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyText` signal is emitted
    @discardableResult @inlinable func onNotifyText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextBufferRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextBufferRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextBufferRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::text` signal for using the `connect(signal:)` methods
    static var notifyTextSignal: TextBufferSignalName { .notifyText }
    
}

// MARK: TextBuffer Class: TextBufferProtocol extension (methods and fields)
public extension TextBufferProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextBuffer` instance.
    @inlinable var text_buffer_ptr: UnsafeMutablePointer<GtkTextBuffer>! { return ptr?.assumingMemoryBound(to: GtkTextBuffer.self) }

    /// Adds the mark at position `where`. The mark must not be added to
    /// another buffer, and if its name is not `nil` then there must not
    /// be another mark in the buffer with the same name.
    /// 
    /// Emits the `GtkTextBuffer::mark-set` signal as notification of the mark's
    /// initial placement.
    @inlinable func add<TextIterT: TextIterProtocol, TextMarkT: TextMarkProtocol>(mark: TextMarkT, `where`: TextIterT) {
        gtk_text_buffer_add_mark(text_buffer_ptr, mark.text_mark_ptr, `where`.text_iter_ptr)
    
    }

    /// Adds `clipboard` to the list of clipboards in which the selection
    /// contents of `buffer` are available. In most cases, `clipboard` will be
    /// the `GtkClipboard` of type `GDK_SELECTION_PRIMARY` for a view of `buffer`.
    @inlinable func addSelection<ClipboardT: ClipboardProtocol>(clipboard: ClipboardT) {
        gtk_text_buffer_add_selection_clipboard(text_buffer_ptr, clipboard.clipboard_ptr)
    
    }

    /// Emits the “apply-tag” signal on `buffer`. The default
    /// handler for the signal applies `tag` to the given range.
    /// `start` and `end` do not have to be in order.
    @inlinable func apply<TextIterT: TextIterProtocol, TextTagT: TextTagProtocol>(tag: TextTagT, start: TextIterT, end: TextIterT) {
        gtk_text_buffer_apply_tag(text_buffer_ptr, tag.text_tag_ptr, start.text_iter_ptr, end.text_iter_ptr)
    
    }

    /// Calls `gtk_text_tag_table_lookup()` on the buffer’s tag table to
    /// get a `GtkTextTag`, then calls `gtk_text_buffer_apply_tag()`.
    @inlinable func applyTagBy<TextIterT: TextIterProtocol>(name: UnsafePointer<gchar>!, start: TextIterT, end: TextIterT) {
        gtk_text_buffer_apply_tag_by_name(text_buffer_ptr, name, start.text_iter_ptr, end.text_iter_ptr)
    
    }

    /// Performs the appropriate action as if the user hit the delete
    /// key with the cursor at the position specified by `iter`. In the
    /// normal case a single character will be deleted, but when
    /// combining accents are involved, more than one character can
    /// be deleted, and when precomposed character and accent combinations
    /// are involved, less than one character will be deleted.
    /// 
    /// Because the buffer is modified, all outstanding iterators become
    /// invalid after calling this function; however, the `iter` will be
    /// re-initialized to point to the location where text was deleted.
    @inlinable func backspace<TextIterT: TextIterProtocol>(iter: TextIterT, interactive: Bool, defaultEditable: Bool) -> Bool {
        let rv = ((gtk_text_buffer_backspace(text_buffer_ptr, iter.text_iter_ptr, gboolean((interactive) ? 1 : 0), gboolean((defaultEditable) ? 1 : 0))) != 0)
        return rv
    }

    /// Called to indicate that the buffer operations between here and a
    /// call to `gtk_text_buffer_end_user_action()` are part of a single
    /// user-visible operation. The operations between
    /// `gtk_text_buffer_begin_user_action()` and
    /// `gtk_text_buffer_end_user_action()` can then be grouped when creating
    /// an undo stack. `GtkTextBuffer` maintains a count of calls to
    /// `gtk_text_buffer_begin_user_action()` that have not been closed with
    /// a call to `gtk_text_buffer_end_user_action()`, and emits the
    /// “begin-user-action” and “end-user-action” signals only for the
    /// outermost pair of calls. This allows you to build user actions
    /// from other user actions.
    /// 
    /// The “interactive” buffer mutation functions, such as
    /// `gtk_text_buffer_insert_interactive()`, automatically call begin/end
    /// user action around the buffer operations they perform, so there's
    /// no need to add extra calls if you user action consists solely of a
    /// single call to one of those functions.
    @inlinable func beginUserAction() {
        gtk_text_buffer_begin_user_action(text_buffer_ptr)
    
    }

    /// Copies the currently-selected text to a clipboard.
    @inlinable func copy<ClipboardT: ClipboardProtocol>(clipboard: ClipboardT) {
        gtk_text_buffer_copy_clipboard(text_buffer_ptr, clipboard.clipboard_ptr)
    
    }

    /// This is a convenience function which simply creates a child anchor
    /// with `gtk_text_child_anchor_new()` and inserts it into the buffer
    /// with `gtk_text_buffer_insert_child_anchor()`. The new anchor is
    /// owned by the buffer; no reference count is returned to
    /// the caller of `gtk_text_buffer_create_child_anchor()`.
    @inlinable func createChildAnchor<TextIterT: TextIterProtocol>(iter: TextIterT) -> TextChildAnchorRef! {
        let rv = TextChildAnchorRef(gconstpointer: gconstpointer(gtk_text_buffer_create_child_anchor(text_buffer_ptr, iter.text_iter_ptr)))
        return rv
    }

    /// Creates a mark at position `where`. If `mark_name` is `nil`, the mark
    /// is anonymous; otherwise, the mark can be retrieved by name using
    /// `gtk_text_buffer_get_mark()`. If a mark has left gravity, and text is
    /// inserted at the mark’s current location, the mark will be moved to
    /// the left of the newly-inserted text. If the mark has right gravity
    /// (`left_gravity` = `false`), the mark will end up on the right of
    /// newly-inserted text. The standard left-to-right cursor is a mark
    /// with right gravity (when you type, the cursor stays on the right
    /// side of the text you’re typing).
    /// 
    /// The caller of this function does not own a
    /// reference to the returned `GtkTextMark`, so you can ignore the
    /// return value if you like. Marks are owned by the buffer and go
    /// away when the buffer does.
    /// 
    /// Emits the `GtkTextBuffer::mark-set` signal as notification of the mark's
    /// initial placement.
    @inlinable func createMark<TextIterT: TextIterProtocol>(markName: UnsafePointer<gchar>? = nil, `where`: TextIterT, leftGravity: Bool) -> TextMarkRef! {
        let rv = TextMarkRef(gconstpointer: gconstpointer(gtk_text_buffer_create_mark(text_buffer_ptr, markName, `where`.text_iter_ptr, gboolean((leftGravity) ? 1 : 0))))
        return rv
    }


    // *** createTag() is not available because it has a varargs (...) parameter!


    /// Copies the currently-selected text to a clipboard, then deletes
    /// said text if it’s editable.
    @inlinable func cut<ClipboardT: ClipboardProtocol>(clipboard: ClipboardT, defaultEditable: Bool) {
        gtk_text_buffer_cut_clipboard(text_buffer_ptr, clipboard.clipboard_ptr, gboolean((defaultEditable) ? 1 : 0))
    
    }

    /// Deletes text between `start` and `end`. The order of `start` and `end`
    /// is not actually relevant; `gtk_text_buffer_delete()` will reorder
    /// them. This function actually emits the “delete-range” signal, and
    /// the default handler of that signal deletes the text. Because the
    /// buffer is modified, all outstanding iterators become invalid after
    /// calling this function; however, the `start` and `end` will be
    /// re-initialized to point to the location where text was deleted.
    @inlinable func delete<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT) {
        gtk_text_buffer_delete(text_buffer_ptr, start.text_iter_ptr, end.text_iter_ptr)
    
    }

    /// Deletes all editable text in the given range.
    /// Calls `gtk_text_buffer_delete()` for each editable sub-range of
    /// [`start`,`end`). `start` and `end` are revalidated to point to
    /// the location of the last deleted range, or left untouched if
    /// no text was deleted.
    @inlinable func deleteInteractive<TextIterT: TextIterProtocol>(startIter: TextIterT, endIter: TextIterT, defaultEditable: Bool) -> Bool {
        let rv = ((gtk_text_buffer_delete_interactive(text_buffer_ptr, startIter.text_iter_ptr, endIter.text_iter_ptr, gboolean((defaultEditable) ? 1 : 0))) != 0)
        return rv
    }

    /// Deletes `mark`, so that it’s no longer located anywhere in the
    /// buffer. Removes the reference the buffer holds to the mark, so if
    /// you haven’t called `g_object_ref()` on the mark, it will be freed. Even
    /// if the mark isn’t freed, most operations on `mark` become
    /// invalid, until it gets added to a buffer again with
    /// `gtk_text_buffer_add_mark()`. Use `gtk_text_mark_get_deleted()` to
    /// find out if a mark has been removed from its buffer.
    /// The `GtkTextBuffer::mark-deleted` signal will be emitted as notification after
    /// the mark is deleted.
    @inlinable func delete<TextMarkT: TextMarkProtocol>(mark: TextMarkT) {
        gtk_text_buffer_delete_mark(text_buffer_ptr, mark.text_mark_ptr)
    
    }

    /// Deletes the mark named `name`; the mark must exist. See
    /// `gtk_text_buffer_delete_mark()` for details.
    @inlinable func deleteMarkBy(name: UnsafePointer<gchar>!) {
        gtk_text_buffer_delete_mark_by_name(text_buffer_ptr, name)
    
    }

    /// Deletes the range between the “insert” and “selection_bound” marks,
    /// that is, the currently-selected text. If `interactive` is `true`,
    /// the editability of the selection will be considered (users can’t delete
    /// uneditable text).
    @inlinable func deleteSelection(interactive: Bool, defaultEditable: Bool) -> Bool {
        let rv = ((gtk_text_buffer_delete_selection(text_buffer_ptr, gboolean((interactive) ? 1 : 0), gboolean((defaultEditable) ? 1 : 0))) != 0)
        return rv
    }

    /// This function deserializes rich text in format `format` and inserts
    /// it at `iter`.
    /// 
    /// `formats` to be used must be registered using
    /// `gtk_text_buffer_register_deserialize_format()` or
    /// `gtk_text_buffer_register_deserialize_tagset()` beforehand.
    @inlinable func deserialize<TextBufferT: TextBufferProtocol, TextIterT: TextIterProtocol>(contentBuffer: TextBufferT, format: GdkAtom, iter: TextIterT, data: UnsafePointer<guint8>!, length: Int) throws -> Bool {
        var error: UnsafeMutablePointer<GError>?
        let rv = ((gtk_text_buffer_deserialize(text_buffer_ptr, contentBuffer.text_buffer_ptr, format, iter.text_iter_ptr, data, gsize(length), &error)) != 0)
        if let error = error { throw GLibError(error) }
        return rv
    }

    /// This functions returns the value set with
    /// `gtk_text_buffer_deserialize_set_can_create_tags()`
    @inlinable func deserializeGetCanCreateTags(format: GdkAtom) -> Bool {
        let rv = ((gtk_text_buffer_deserialize_get_can_create_tags(text_buffer_ptr, format)) != 0)
        return rv
    }

    /// Use this function to allow a rich text deserialization function to
    /// create new tags in the receiving buffer. Note that using this
    /// function is almost always a bad idea, because the rich text
    /// functions you register should know how to map the rich text format
    /// they handler to your text buffers set of tags.
    /// 
    /// The ability of creating new (arbitrary!) tags in the receiving buffer
    /// is meant for special rich text formats like the internal one that
    /// is registered using `gtk_text_buffer_register_deserialize_tagset()`,
    /// because that format is essentially a dump of the internal structure
    /// of the source buffer, including its tag names.
    /// 
    /// You should allow creation of tags only if you know what you are
    /// doing, e.g. if you defined a tagset name for your application
    /// suite’s text buffers and you know that it’s fine to receive new
    /// tags from these buffers, because you know that your application can
    /// handle the newly created tags.
    @inlinable func deserializeSetCanCreateTags(format: GdkAtom, canCreateTags: Bool) {
        gtk_text_buffer_deserialize_set_can_create_tags(text_buffer_ptr, format, gboolean((canCreateTags) ? 1 : 0))
    
    }

    /// Should be paired with a call to `gtk_text_buffer_begin_user_action()`.
    /// See that function for a full explanation.
    @inlinable func endUserAction() {
        gtk_text_buffer_end_user_action(text_buffer_ptr)
    
    }

    /// Retrieves the first and last iterators in the buffer, i.e. the
    /// entire buffer lies within the range [`start`,`end`).
    @inlinable func getBounds<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT) {
        gtk_text_buffer_get_bounds(text_buffer_ptr, start.text_iter_ptr, end.text_iter_ptr)
    
    }

    /// Gets the number of characters in the buffer; note that characters
    /// and bytes are not the same, you can’t e.g. expect the contents of
    /// the buffer in string form to be this many bytes long. The character
    /// count is cached, so this function is very fast.
    @inlinable func getCharCount() -> Int {
        let rv = Int(gtk_text_buffer_get_char_count(text_buffer_ptr))
        return rv
    }

    /// This function returns the list of targets this text buffer can
    /// provide for copying and as DND source. The targets in the list are
    /// added with `info` values from the `GtkTextBufferTargetInfo` enum,
    /// using `gtk_target_list_add_rich_text_targets()` and
    /// `gtk_target_list_add_text_targets()`.
    @inlinable func getCopyTargetList() -> TargetListRef! {
        let rv = TargetListRef(gconstpointer: gconstpointer(gtk_text_buffer_get_copy_target_list(text_buffer_ptr)))
        return rv
    }

    /// This function returns the rich text deserialize formats registered
    /// with `buffer` using `gtk_text_buffer_register_deserialize_format()` or
    /// `gtk_text_buffer_register_deserialize_tagset()`
    @inlinable func getDeserializeFormats(nFormats: UnsafeMutablePointer<gint>!) -> UnsafeMutablePointer<GdkAtom?>! {
        let rv = gtk_text_buffer_get_deserialize_formats(text_buffer_ptr, nFormats)
        return rv
    }

    /// Initializes `iter` with the “end iterator,” one past the last valid
    /// character in the text buffer. If dereferenced with
    /// `gtk_text_iter_get_char()`, the end iterator has a character value of 0.
    /// The entire buffer lies in the range from the first position in
    /// the buffer (call `gtk_text_buffer_get_start_iter()` to get
    /// character position 0) to the end iterator.
    @inlinable func getEnd<TextIterT: TextIterProtocol>(iter: TextIterT) {
        gtk_text_buffer_get_end_iter(text_buffer_ptr, iter.text_iter_ptr)
    
    }

    /// Indicates whether the buffer has some text currently selected.
    @inlinable func getHasSelection() -> Bool {
        let rv = ((gtk_text_buffer_get_has_selection(text_buffer_ptr)) != 0)
        return rv
    }

    /// Returns the mark that represents the cursor (insertion point).
    /// Equivalent to calling `gtk_text_buffer_get_mark()` to get the mark
    /// named “insert”, but very slightly more efficient, and involves less
    /// typing.
    @inlinable func getInsert() -> TextMarkRef! {
        let rv = TextMarkRef(gconstpointer: gconstpointer(gtk_text_buffer_get_insert(text_buffer_ptr)))
        return rv
    }

    /// Obtains the location of `anchor` within `buffer`.
    @inlinable func getIterAtChildAnchor<TextChildAnchorT: TextChildAnchorProtocol, TextIterT: TextIterProtocol>(iter: TextIterT, anchor: TextChildAnchorT) {
        gtk_text_buffer_get_iter_at_child_anchor(text_buffer_ptr, iter.text_iter_ptr, anchor.text_child_anchor_ptr)
    
    }

    /// Initializes `iter` to the start of the given line. If `line_number` is greater
    /// than the number of lines in the `buffer`, the end iterator is returned.
    @inlinable func getIterAtLine<TextIterT: TextIterProtocol>(iter: TextIterT, lineNumber: Int) {
        gtk_text_buffer_get_iter_at_line(text_buffer_ptr, iter.text_iter_ptr, gint(lineNumber))
    
    }

    /// Obtains an iterator pointing to `byte_index` within the given line.
    /// `byte_index` must be the start of a UTF-8 character. Note bytes, not
    /// characters; UTF-8 may encode one character as multiple bytes.
    /// 
    /// Before the 3.20 version, it was not allowed to pass an invalid location.
    /// 
    /// Since the 3.20 version, if `line_number` is greater than the number of lines
    /// in the `buffer`, the end iterator is returned. And if `byte_index` is off the
    /// end of the line, the iterator at the end of the line is returned.
    @inlinable func getIterAtLineIndex<TextIterT: TextIterProtocol>(iter: TextIterT, lineNumber: Int, byteIndex: Int) {
        gtk_text_buffer_get_iter_at_line_index(text_buffer_ptr, iter.text_iter_ptr, gint(lineNumber), gint(byteIndex))
    
    }

    /// Obtains an iterator pointing to `char_offset` within the given line. Note
    /// characters, not bytes; UTF-8 may encode one character as multiple bytes.
    /// 
    /// Before the 3.20 version, it was not allowed to pass an invalid location.
    /// 
    /// Since the 3.20 version, if `line_number` is greater than the number of lines
    /// in the `buffer`, the end iterator is returned. And if `char_offset` is off the
    /// end of the line, the iterator at the end of the line is returned.
    @inlinable func getIterAtLineOffset<TextIterT: TextIterProtocol>(iter: TextIterT, lineNumber: Int, charOffset: Int) {
        gtk_text_buffer_get_iter_at_line_offset(text_buffer_ptr, iter.text_iter_ptr, gint(lineNumber), gint(charOffset))
    
    }

    /// Initializes `iter` with the current position of `mark`.
    @inlinable func getIterAtMark<TextIterT: TextIterProtocol, TextMarkT: TextMarkProtocol>(iter: TextIterT, mark: TextMarkT) {
        gtk_text_buffer_get_iter_at_mark(text_buffer_ptr, iter.text_iter_ptr, mark.text_mark_ptr)
    
    }

    /// Initializes `iter` to a position `char_offset` chars from the start
    /// of the entire buffer. If `char_offset` is -1 or greater than the number
    /// of characters in the buffer, `iter` is initialized to the end iterator,
    /// the iterator one past the last valid character in the buffer.
    @inlinable func getIterAtOffset<TextIterT: TextIterProtocol>(iter: TextIterT, charOffset: Int) {
        gtk_text_buffer_get_iter_at_offset(text_buffer_ptr, iter.text_iter_ptr, gint(charOffset))
    
    }

    /// Obtains the number of lines in the buffer. This value is cached, so
    /// the function is very fast.
    @inlinable func getLineCount() -> Int {
        let rv = Int(gtk_text_buffer_get_line_count(text_buffer_ptr))
        return rv
    }

    /// Returns the mark named `name` in buffer `buffer`, or `nil` if no such
    /// mark exists in the buffer.
    @inlinable func getMark(name: UnsafePointer<gchar>!) -> TextMarkRef! {
        let rv = TextMarkRef(gconstpointer: gconstpointer(gtk_text_buffer_get_mark(text_buffer_ptr, name)))
        return rv
    }

    /// Indicates whether the buffer has been modified since the last call
    /// to `gtk_text_buffer_set_modified()` set the modification flag to
    /// `false`. Used for example to enable a “save” function in a text
    /// editor.
    @inlinable func getModified() -> Bool {
        let rv = ((gtk_text_buffer_get_modified(text_buffer_ptr)) != 0)
        return rv
    }

    /// This function returns the list of targets this text buffer supports
    /// for pasting and as DND destination. The targets in the list are
    /// added with `info` values from the `GtkTextBufferTargetInfo` enum,
    /// using `gtk_target_list_add_rich_text_targets()` and
    /// `gtk_target_list_add_text_targets()`.
    @inlinable func getPasteTargetList() -> TargetListRef! {
        let rv = TargetListRef(gconstpointer: gconstpointer(gtk_text_buffer_get_paste_target_list(text_buffer_ptr)))
        return rv
    }

    /// Returns the mark that represents the selection bound.  Equivalent
    /// to calling `gtk_text_buffer_get_mark()` to get the mark named
    /// “selection_bound”, but very slightly more efficient, and involves
    /// less typing.
    /// 
    /// The currently-selected text in `buffer` is the region between the
    /// “selection_bound” and “insert” marks. If “selection_bound” and
    /// “insert” are in the same place, then there is no current selection.
    /// `gtk_text_buffer_get_selection_bounds()` is another convenient function
    /// for handling the selection, if you just want to know whether there’s a
    /// selection and what its bounds are.
    @inlinable func getSelectionBound() -> TextMarkRef! {
        let rv = TextMarkRef(gconstpointer: gconstpointer(gtk_text_buffer_get_selection_bound(text_buffer_ptr)))
        return rv
    }

    /// Returns `true` if some text is selected; places the bounds
    /// of the selection in `start` and `end` (if the selection has length 0,
    /// then `start` and `end` are filled in with the same value).
    /// `start` and `end` will be in ascending order. If `start` and `end` are
    /// NULL, then they are not filled in, but the return value still indicates
    /// whether text is selected.
    @inlinable func getSelectionBounds<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT) -> Bool {
        let rv = ((gtk_text_buffer_get_selection_bounds(text_buffer_ptr, start.text_iter_ptr, end.text_iter_ptr)) != 0)
        return rv
    }

    /// This function returns the rich text serialize formats registered
    /// with `buffer` using `gtk_text_buffer_register_serialize_format()` or
    /// `gtk_text_buffer_register_serialize_tagset()`
    @inlinable func getSerializeFormats(nFormats: UnsafeMutablePointer<gint>!) -> UnsafeMutablePointer<GdkAtom?>! {
        let rv = gtk_text_buffer_get_serialize_formats(text_buffer_ptr, nFormats)
        return rv
    }

    /// Returns the text in the range [`start`,`end`). Excludes undisplayed
    /// text (text marked with tags that set the invisibility attribute) if
    /// `include_hidden_chars` is `false`. The returned string includes a
    /// 0xFFFC character whenever the buffer contains
    /// embedded images, so byte and character indexes into
    /// the returned string do correspond to byte
    /// and character indexes into the buffer. Contrast with
    /// `gtk_text_buffer_get_text()`. Note that 0xFFFC can occur in normal
    /// text as well, so it is not a reliable indicator that a pixbuf or
    /// widget is in the buffer.
    @inlinable func getSlice<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT, includeHiddenChars: Bool) -> String! {
        let rv = gtk_text_buffer_get_slice(text_buffer_ptr, start.text_iter_ptr, end.text_iter_ptr, gboolean((includeHiddenChars) ? 1 : 0)).map({ String(cString: $0) })
        return rv
    }

    /// Initialized `iter` with the first position in the text buffer. This
    /// is the same as using `gtk_text_buffer_get_iter_at_offset()` to get
    /// the iter at character offset 0.
    @inlinable func getStart<TextIterT: TextIterProtocol>(iter: TextIterT) {
        gtk_text_buffer_get_start_iter(text_buffer_ptr, iter.text_iter_ptr)
    
    }

    /// Get the `GtkTextTagTable` associated with this buffer.
    @inlinable func getTagTable() -> TextTagTableRef! {
        let rv = TextTagTableRef(gconstpointer: gconstpointer(gtk_text_buffer_get_tag_table(text_buffer_ptr)))
        return rv
    }

    /// Returns the text in the range [`start`,`end`). Excludes undisplayed
    /// text (text marked with tags that set the invisibility attribute) if
    /// `include_hidden_chars` is `false`. Does not include characters
    /// representing embedded images, so byte and character indexes into
    /// the returned string do not correspond to byte
    /// and character indexes into the buffer. Contrast with
    /// `gtk_text_buffer_get_slice()`.
    @inlinable func getText<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT, includeHiddenChars: Bool) -> String! {
        let rv = gtk_text_buffer_get_text(text_buffer_ptr, start.text_iter_ptr, end.text_iter_ptr, gboolean((includeHiddenChars) ? 1 : 0)).map({ String(cString: $0) })
        return rv
    }

    /// Inserts `len` bytes of `text` at position `iter`.  If `len` is -1,
    /// `text` must be nul-terminated and will be inserted in its
    /// entirety. Emits the “insert-text” signal; insertion actually occurs
    /// in the default handler for the signal. `iter` is invalidated when
    /// insertion occurs (because the buffer contents change), but the
    /// default signal handler revalidates it to point to the end of the
    /// inserted text.
    @inlinable func getInsert<TextIterT: TextIterProtocol>(iter: TextIterT, text: UnsafePointer<gchar>!, len: Int) {
        gtk_text_buffer_insert(text_buffer_ptr, iter.text_iter_ptr, text, gint(len))
    
    }

    /// Simply calls `gtk_text_buffer_insert()`, using the current
    /// cursor position as the insertion point.
    @inlinable func insertAtCursor(text: UnsafePointer<gchar>!, len: Int) {
        gtk_text_buffer_insert_at_cursor(text_buffer_ptr, text, gint(len))
    
    }

    /// Inserts a child widget anchor into the text buffer at `iter`. The
    /// anchor will be counted as one character in character counts, and
    /// when obtaining the buffer contents as a string, will be represented
    /// by the Unicode “object replacement character” 0xFFFC. Note that the
    /// “slice” variants for obtaining portions of the buffer as a string
    /// include this character for child anchors, but the “text” variants do
    /// not. E.g. see `gtk_text_buffer_get_slice()` and
    /// `gtk_text_buffer_get_text()`. Consider
    /// `gtk_text_buffer_create_child_anchor()` as a more convenient
    /// alternative to this function. The buffer will add a reference to
    /// the anchor, so you can unref it after insertion.
    @inlinable func insertChildAnchor<TextChildAnchorT: TextChildAnchorProtocol, TextIterT: TextIterProtocol>(iter: TextIterT, anchor: TextChildAnchorT) {
        gtk_text_buffer_insert_child_anchor(text_buffer_ptr, iter.text_iter_ptr, anchor.text_child_anchor_ptr)
    
    }

    /// Like `gtk_text_buffer_insert()`, but the insertion will not occur if
    /// `iter` is at a non-editable location in the buffer. Usually you
    /// want to prevent insertions at ineditable locations if the insertion
    /// results from a user action (is interactive).
    /// 
    /// `default_editable` indicates the editability of text that doesn't
    /// have a tag affecting editability applied to it. Typically the
    /// result of `gtk_text_view_get_editable()` is appropriate here.
    @inlinable func insertInteractive<TextIterT: TextIterProtocol>(iter: TextIterT, text: UnsafePointer<gchar>!, len: Int, defaultEditable: Bool) -> Bool {
        let rv = ((gtk_text_buffer_insert_interactive(text_buffer_ptr, iter.text_iter_ptr, text, gint(len), gboolean((defaultEditable) ? 1 : 0))) != 0)
        return rv
    }

    /// Calls `gtk_text_buffer_insert_interactive()` at the cursor
    /// position.
    /// 
    /// `default_editable` indicates the editability of text that doesn't
    /// have a tag affecting editability applied to it. Typically the
    /// result of `gtk_text_view_get_editable()` is appropriate here.
    @inlinable func insertInteractiveAtCursor(text: UnsafePointer<gchar>!, len: Int, defaultEditable: Bool) -> Bool {
        let rv = ((gtk_text_buffer_insert_interactive_at_cursor(text_buffer_ptr, text, gint(len), gboolean((defaultEditable) ? 1 : 0))) != 0)
        return rv
    }

    /// Inserts the text in `markup` at position `iter`. `markup` will be inserted
    /// in its entirety and must be nul-terminated and valid UTF-8. Emits the
    /// `GtkTextBuffer::insert-text` signal, possibly multiple times; insertion
    /// actually occurs in the default handler for the signal. `iter` will point
    /// to the end of the inserted text on return.
    @inlinable func insertMarkup<TextIterT: TextIterProtocol>(iter: TextIterT, markup: UnsafePointer<gchar>!, len: Int) {
        gtk_text_buffer_insert_markup(text_buffer_ptr, iter.text_iter_ptr, markup, gint(len))
    
    }

    /// Inserts an image into the text buffer at `iter`. The image will be
    /// counted as one character in character counts, and when obtaining
    /// the buffer contents as a string, will be represented by the Unicode
    /// “object replacement character” 0xFFFC. Note that the “slice”
    /// variants for obtaining portions of the buffer as a string include
    /// this character for pixbufs, but the “text” variants do
    /// not. e.g. see `gtk_text_buffer_get_slice()` and
    /// `gtk_text_buffer_get_text()`.
    @inlinable func insertPixbuf<PixbufT: PixbufProtocol, TextIterT: TextIterProtocol>(iter: TextIterT, pixbuf: PixbufT) {
        gtk_text_buffer_insert_pixbuf(text_buffer_ptr, iter.text_iter_ptr, pixbuf.pixbuf_ptr)
    
    }

    /// Copies text, tags, and pixbufs between `start` and `end` (the order
    /// of `start` and `end` doesn’t matter) and inserts the copy at `iter`.
    /// Used instead of simply getting/inserting text because it preserves
    /// images and tags. If `start` and `end` are in a different buffer from
    /// `buffer`, the two buffers must share the same tag table.
    /// 
    /// Implemented via emissions of the insert_text and apply_tag signals,
    /// so expect those.
    @inlinable func insertRange<TextIterT: TextIterProtocol>(iter: TextIterT, start: TextIterT, end: TextIterT) {
        gtk_text_buffer_insert_range(text_buffer_ptr, iter.text_iter_ptr, start.text_iter_ptr, end.text_iter_ptr)
    
    }

    /// Same as `gtk_text_buffer_insert_range()`, but does nothing if the
    /// insertion point isn’t editable. The `default_editable` parameter
    /// indicates whether the text is editable at `iter` if no tags
    /// enclosing `iter` affect editability. Typically the result of
    /// `gtk_text_view_get_editable()` is appropriate here.
    @inlinable func insertRangeInteractive<TextIterT: TextIterProtocol>(iter: TextIterT, start: TextIterT, end: TextIterT, defaultEditable: Bool) -> Bool {
        let rv = ((gtk_text_buffer_insert_range_interactive(text_buffer_ptr, iter.text_iter_ptr, start.text_iter_ptr, end.text_iter_ptr, gboolean((defaultEditable) ? 1 : 0))) != 0)
        return rv
    }


    // *** insertWithTags() is not available because it has a varargs (...) parameter!



    // *** insertWithTagsByName() is not available because it has a varargs (...) parameter!


    /// Moves `mark` to the new location `where`. Emits the `GtkTextBuffer::mark-set`
    /// signal as notification of the move.
    @inlinable func move<TextIterT: TextIterProtocol, TextMarkT: TextMarkProtocol>(mark: TextMarkT, `where`: TextIterT) {
        gtk_text_buffer_move_mark(text_buffer_ptr, mark.text_mark_ptr, `where`.text_iter_ptr)
    
    }

    /// Moves the mark named `name` (which must exist) to location `where`.
    /// See `gtk_text_buffer_move_mark()` for details.
    @inlinable func moveMarkBy<TextIterT: TextIterProtocol>(name: UnsafePointer<gchar>!, `where`: TextIterT) {
        gtk_text_buffer_move_mark_by_name(text_buffer_ptr, name, `where`.text_iter_ptr)
    
    }

    /// Pastes the contents of a clipboard. If `override_location` is `nil`, the
    /// pasted text will be inserted at the cursor position, or the buffer selection
    /// will be replaced if the selection is non-empty.
    /// 
    /// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
    /// return, and at some point later after the main loop runs, the paste data will
    /// be inserted.
    @inlinable func paste<ClipboardT: ClipboardProtocol>(clipboard: ClipboardT, overrideLocation: TextIterRef? = nil, defaultEditable: Bool) {
        gtk_text_buffer_paste_clipboard(text_buffer_ptr, clipboard.clipboard_ptr, overrideLocation?.text_iter_ptr, gboolean((defaultEditable) ? 1 : 0))
    
    }
    /// Pastes the contents of a clipboard. If `override_location` is `nil`, the
    /// pasted text will be inserted at the cursor position, or the buffer selection
    /// will be replaced if the selection is non-empty.
    /// 
    /// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
    /// return, and at some point later after the main loop runs, the paste data will
    /// be inserted.
    @inlinable func paste<ClipboardT: ClipboardProtocol, TextIterT: TextIterProtocol>(clipboard: ClipboardT, overrideLocation: TextIterT?, defaultEditable: Bool) {
        gtk_text_buffer_paste_clipboard(text_buffer_ptr, clipboard.clipboard_ptr, overrideLocation?.text_iter_ptr, gboolean((defaultEditable) ? 1 : 0))
    
    }

    /// This function moves the “insert” and “selection_bound” marks
    /// simultaneously.  If you move them to the same place in two steps
    /// with `gtk_text_buffer_move_mark()`, you will temporarily select a
    /// region in between their old and new locations, which can be pretty
    /// inefficient since the temporarily-selected region will force stuff
    /// to be recalculated. This function moves them as a unit, which can
    /// be optimized.
    @inlinable func placeCursor<TextIterT: TextIterProtocol>(`where`: TextIterT) {
        gtk_text_buffer_place_cursor(text_buffer_ptr, `where`.text_iter_ptr)
    
    }

    /// This function registers a rich text deserialization `function` along with
    /// its `mime_type` with the passed `buffer`.
    @inlinable func registerDeserializeFormat(mimeType: UnsafePointer<gchar>!, function: GtkTextBufferDeserializeFunc?, userData: gpointer! = nil, userDataDestroy: GDestroyNotify?) -> GdkAtom! {
        let rv = gtk_text_buffer_register_deserialize_format(text_buffer_ptr, mimeType, function, userData, userDataDestroy)
        return rv
    }

    /// This function registers GTK+’s internal rich text serialization
    /// format with the passed `buffer`. See
    /// `gtk_text_buffer_register_serialize_tagset()` for details.
    @inlinable func registerDeserializeTagset(tagsetName: UnsafePointer<gchar>? = nil) -> GdkAtom! {
        let rv = gtk_text_buffer_register_deserialize_tagset(text_buffer_ptr, tagsetName)
        return rv
    }

    /// This function registers a rich text serialization `function` along with
    /// its `mime_type` with the passed `buffer`.
    @inlinable func registerSerializeFormat(mimeType: UnsafePointer<gchar>!, function: GtkTextBufferSerializeFunc?, userData: gpointer! = nil, userDataDestroy: GDestroyNotify?) -> GdkAtom! {
        let rv = gtk_text_buffer_register_serialize_format(text_buffer_ptr, mimeType, function, userData, userDataDestroy)
        return rv
    }

    /// This function registers GTK+’s internal rich text serialization
    /// format with the passed `buffer`. The internal format does not comply
    /// to any standard rich text format and only works between `GtkTextBuffer`
    /// instances. It is capable of serializing all of a text buffer’s tags
    /// and embedded pixbufs.
    /// 
    /// This function is just a wrapper around
    /// `gtk_text_buffer_register_serialize_format()`. The mime type used
    /// for registering is “application/x-gtk-text-buffer-rich-text”, or
    /// “application/x-gtk-text-buffer-rich-text;format=`tagset_name`” if a
    /// `tagset_name` was passed.
    /// 
    /// The `tagset_name` can be used to restrict the transfer of rich text
    /// to buffers with compatible sets of tags, in order to avoid unknown
    /// tags from being pasted. It is probably the common case to pass an
    /// identifier != `nil` here, since the `nil` tagset requires the
    /// receiving buffer to deal with with pasting of arbitrary tags.
    @inlinable func registerSerializeTagset(tagsetName: UnsafePointer<gchar>? = nil) -> GdkAtom! {
        let rv = gtk_text_buffer_register_serialize_tagset(text_buffer_ptr, tagsetName)
        return rv
    }

    /// Removes all tags in the range between `start` and `end`.  Be careful
    /// with this function; it could remove tags added in code unrelated to
    /// the code you’re currently writing. That is, using this function is
    /// probably a bad idea if you have two or more unrelated code sections
    /// that add tags.
    @inlinable func removeAllTags<TextIterT: TextIterProtocol>(start: TextIterT, end: TextIterT) {
        gtk_text_buffer_remove_all_tags(text_buffer_ptr, start.text_iter_ptr, end.text_iter_ptr)
    
    }

    /// Removes a `GtkClipboard` added with
    /// `gtk_text_buffer_add_selection_clipboard()`.
    @inlinable func removeSelection<ClipboardT: ClipboardProtocol>(clipboard: ClipboardT) {
        gtk_text_buffer_remove_selection_clipboard(text_buffer_ptr, clipboard.clipboard_ptr)
    
    }

    /// Emits the “remove-tag” signal. The default handler for the signal
    /// removes all occurrences of `tag` from the given range. `start` and
    /// `end` don’t have to be in order.
    @inlinable func remove<TextIterT: TextIterProtocol, TextTagT: TextTagProtocol>(tag: TextTagT, start: TextIterT, end: TextIterT) {
        gtk_text_buffer_remove_tag(text_buffer_ptr, tag.text_tag_ptr, start.text_iter_ptr, end.text_iter_ptr)
    
    }

    /// Calls `gtk_text_tag_table_lookup()` on the buffer’s tag table to
    /// get a `GtkTextTag`, then calls `gtk_text_buffer_remove_tag()`.
    @inlinable func removeTagBy<TextIterT: TextIterProtocol>(name: UnsafePointer<gchar>!, start: TextIterT, end: TextIterT) {
        gtk_text_buffer_remove_tag_by_name(text_buffer_ptr, name, start.text_iter_ptr, end.text_iter_ptr)
    
    }

    /// This function moves the “insert” and “selection_bound” marks
    /// simultaneously.  If you move them in two steps
    /// with `gtk_text_buffer_move_mark()`, you will temporarily select a
    /// region in between their old and new locations, which can be pretty
    /// inefficient since the temporarily-selected region will force stuff
    /// to be recalculated. This function moves them as a unit, which can
    /// be optimized.
    @inlinable func selectRange<TextIterT: TextIterProtocol>(ins: TextIterT, bound: TextIterT) {
        gtk_text_buffer_select_range(text_buffer_ptr, ins.text_iter_ptr, bound.text_iter_ptr)
    
    }

    /// This function serializes the portion of text between `start`
    /// and `end` in the rich text format represented by `format`.
    /// 
    /// `formats` to be used must be registered using
    /// `gtk_text_buffer_register_serialize_format()` or
    /// `gtk_text_buffer_register_serialize_tagset()` beforehand.
    @inlinable func serialize<TextBufferT: TextBufferProtocol, TextIterT: TextIterProtocol>(contentBuffer: TextBufferT, format: GdkAtom, start: TextIterT, end: TextIterT, length: UnsafeMutablePointer<gsize>!) -> UnsafeMutablePointer<guint8>! {
        let rv = gtk_text_buffer_serialize(text_buffer_ptr, contentBuffer.text_buffer_ptr, format, start.text_iter_ptr, end.text_iter_ptr, length)
        return rv
    }

    /// Used to keep track of whether the buffer has been modified since the
    /// last time it was saved. Whenever the buffer is saved to disk, call
    /// gtk_text_buffer_set_modified (`buffer`, FALSE). When the buffer is modified,
    /// it will automatically toggled on the modified bit again. When the modified
    /// bit flips, the buffer emits the `GtkTextBuffer::modified-changed` signal.
    @inlinable func setModified(setting: Bool) {
        gtk_text_buffer_set_modified(text_buffer_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Deletes current contents of `buffer`, and inserts `text` instead. If
    /// `len` is -1, `text` must be nul-terminated. `text` must be valid UTF-8.
    @inlinable func set(text: UnsafePointer<gchar>!, len: Int) {
        gtk_text_buffer_set_text(text_buffer_ptr, text, gint(len))
    
    }

    /// This function unregisters a rich text format that was previously
    /// registered using `gtk_text_buffer_register_deserialize_format()` or
    /// `gtk_text_buffer_register_deserialize_tagset()`.
    @inlinable func unregisterDeserialize(format: GdkAtom) {
        gtk_text_buffer_unregister_deserialize_format(text_buffer_ptr, format)
    
    }

    /// This function unregisters a rich text format that was previously
    /// registered using `gtk_text_buffer_register_serialize_format()` or
    /// `gtk_text_buffer_register_serialize_tagset()`
    @inlinable func unregisterSerialize(format: GdkAtom) {
        gtk_text_buffer_unregister_serialize_format(text_buffer_ptr, format)
    
    }

    /// Determines if any of the targets in `targets` can be used to
    /// provide rich text.
    @inlinable func targetsIncludeRichText(targets: UnsafeMutablePointer<GdkAtom?>!, nTargets: Int) -> Bool {
        let rv = ((gtk_targets_include_rich_text(targets, gint(nTargets), text_buffer_ptr)) != 0)
        return rv
    }
    /// Gets the number of characters in the buffer; note that characters
    /// and bytes are not the same, you can’t e.g. expect the contents of
    /// the buffer in string form to be this many bytes long. The character
    /// count is cached, so this function is very fast.
    @inlinable var charCount: Int {
        /// Gets the number of characters in the buffer; note that characters
        /// and bytes are not the same, you can’t e.g. expect the contents of
        /// the buffer in string form to be this many bytes long. The character
        /// count is cached, so this function is very fast.
        get {
            let rv = Int(gtk_text_buffer_get_char_count(text_buffer_ptr))
            return rv
        }
    }

    /// This function returns the list of targets this text buffer can
    /// provide for copying and as DND source. The targets in the list are
    /// added with `info` values from the `GtkTextBufferTargetInfo` enum,
    /// using `gtk_target_list_add_rich_text_targets()` and
    /// `gtk_target_list_add_text_targets()`.
    @inlinable var copyTargetList: TargetListRef! {
        /// This function returns the list of targets this text buffer can
        /// provide for copying and as DND source. The targets in the list are
        /// added with `info` values from the `GtkTextBufferTargetInfo` enum,
        /// using `gtk_target_list_add_rich_text_targets()` and
        /// `gtk_target_list_add_text_targets()`.
        get {
            let rv = TargetListRef(gconstpointer: gconstpointer(gtk_text_buffer_get_copy_target_list(text_buffer_ptr)))
            return rv
        }
    }

    /// Indicates whether the buffer has some text currently selected.
    @inlinable var hasSelection: Bool {
        /// Indicates whether the buffer has some text currently selected.
        get {
            let rv = ((gtk_text_buffer_get_has_selection(text_buffer_ptr)) != 0)
            return rv
        }
    }

    /// Returns the mark that represents the cursor (insertion point).
    /// Equivalent to calling `gtk_text_buffer_get_mark()` to get the mark
    /// named “insert”, but very slightly more efficient, and involves less
    /// typing.
    @inlinable var insert: TextMarkRef! {
        /// Returns the mark that represents the cursor (insertion point).
        /// Equivalent to calling `gtk_text_buffer_get_mark()` to get the mark
        /// named “insert”, but very slightly more efficient, and involves less
        /// typing.
        get {
            let rv = TextMarkRef(gconstpointer: gconstpointer(gtk_text_buffer_get_insert(text_buffer_ptr)))
            return rv
        }
    }

    /// Obtains the number of lines in the buffer. This value is cached, so
    /// the function is very fast.
    @inlinable var lineCount: Int {
        /// Obtains the number of lines in the buffer. This value is cached, so
        /// the function is very fast.
        get {
            let rv = Int(gtk_text_buffer_get_line_count(text_buffer_ptr))
            return rv
        }
    }

    /// Indicates whether the buffer has been modified since the last call
    /// to `gtk_text_buffer_set_modified()` set the modification flag to
    /// `false`. Used for example to enable a “save” function in a text
    /// editor.
    @inlinable var modified: Bool {
        /// Indicates whether the buffer has been modified since the last call
        /// to `gtk_text_buffer_set_modified()` set the modification flag to
        /// `false`. Used for example to enable a “save” function in a text
        /// editor.
        get {
            let rv = ((gtk_text_buffer_get_modified(text_buffer_ptr)) != 0)
            return rv
        }
        /// Used to keep track of whether the buffer has been modified since the
        /// last time it was saved. Whenever the buffer is saved to disk, call
        /// gtk_text_buffer_set_modified (`buffer`, FALSE). When the buffer is modified,
        /// it will automatically toggled on the modified bit again. When the modified
        /// bit flips, the buffer emits the `GtkTextBuffer::modified-changed` signal.
        nonmutating set {
            gtk_text_buffer_set_modified(text_buffer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// This function returns the list of targets this text buffer supports
    /// for pasting and as DND destination. The targets in the list are
    /// added with `info` values from the `GtkTextBufferTargetInfo` enum,
    /// using `gtk_target_list_add_rich_text_targets()` and
    /// `gtk_target_list_add_text_targets()`.
    @inlinable var pasteTargetList: TargetListRef! {
        /// This function returns the list of targets this text buffer supports
        /// for pasting and as DND destination. The targets in the list are
        /// added with `info` values from the `GtkTextBufferTargetInfo` enum,
        /// using `gtk_target_list_add_rich_text_targets()` and
        /// `gtk_target_list_add_text_targets()`.
        get {
            let rv = TargetListRef(gconstpointer: gconstpointer(gtk_text_buffer_get_paste_target_list(text_buffer_ptr)))
            return rv
        }
    }

    /// Returns the mark that represents the selection bound.  Equivalent
    /// to calling `gtk_text_buffer_get_mark()` to get the mark named
    /// “selection_bound”, but very slightly more efficient, and involves
    /// less typing.
    /// 
    /// The currently-selected text in `buffer` is the region between the
    /// “selection_bound” and “insert” marks. If “selection_bound” and
    /// “insert” are in the same place, then there is no current selection.
    /// `gtk_text_buffer_get_selection_bounds()` is another convenient function
    /// for handling the selection, if you just want to know whether there’s a
    /// selection and what its bounds are.
    @inlinable var selectionBound: TextMarkRef! {
        /// Returns the mark that represents the selection bound.  Equivalent
        /// to calling `gtk_text_buffer_get_mark()` to get the mark named
        /// “selection_bound”, but very slightly more efficient, and involves
        /// less typing.
        /// 
        /// The currently-selected text in `buffer` is the region between the
        /// “selection_bound” and “insert” marks. If “selection_bound” and
        /// “insert” are in the same place, then there is no current selection.
        /// `gtk_text_buffer_get_selection_bounds()` is another convenient function
        /// for handling the selection, if you just want to know whether there’s a
        /// selection and what its bounds are.
        get {
            let rv = TextMarkRef(gconstpointer: gconstpointer(gtk_text_buffer_get_selection_bound(text_buffer_ptr)))
            return rv
        }
    }

    /// Get the `GtkTextTagTable` associated with this buffer.
    @inlinable var tagTable: TextTagTableRef! {
        /// Get the `GtkTextTagTable` associated with this buffer.
        get {
            let rv = TextTagTableRef(gconstpointer: gconstpointer(gtk_text_buffer_get_tag_table(text_buffer_ptr)))
            return rv
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = text_buffer_ptr.pointee.parent_instance
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TextCellAccessible Class


///
/// The `TextCellAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkTextCellAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextCellAccessible`.
/// Alternatively, use `TextCellAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextCellAccessibleProtocol: RendererCellAccessibleProtocol, Atk.TextProtocol {
        /// Untyped pointer to the underlying `GtkTextCellAccessible` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextCellAccessible` instance.
    var text_cell_accessible_ptr: UnsafeMutablePointer<GtkTextCellAccessible>! { get }

    /// Required Initialiser for types conforming to `TextCellAccessibleProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TextCellAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkTextCellAccessible` instance.
/// It exposes methods that can operate on this data type through `TextCellAccessibleProtocol` conformance.
/// Use `TextCellAccessibleRef` only as an `unowned` reference to an existing `GtkTextCellAccessible` instance.
///
public struct TextCellAccessibleRef: TextCellAccessibleProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextCellAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `text_cell_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextCellAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextCellAccessible>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextCellAccessible>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextCellAccessible>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextCellAccessible>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextCellAccessibleProtocol`
    @inlinable init<T: TextCellAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextCellAccessibleProtocol>(_ other: T) -> TextCellAccessibleRef { TextCellAccessibleRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }


///
/// The `TextCellAccessible` type acts as a reference-counted owner of an underlying `GtkTextCellAccessible` instance.
/// It provides the methods that can operate on this data type through `TextCellAccessibleProtocol` conformance.
/// Use `TextCellAccessible` as a strong reference or owner of a `GtkTextCellAccessible` instance.
///
open class TextCellAccessible: RendererCellAccessible, TextCellAccessibleProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextCellAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextCellAccessible>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextCellAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextCellAccessible>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextCellAccessible` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextCellAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextCellAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextCellAccessible>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextCellAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextCellAccessible>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextCellAccessible`.
    /// i.e., ownership is transferred to the `TextCellAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextCellAccessible>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextCellAccessibleProtocol`
    /// Will retain `GtkTextCellAccessible`.
    /// - Parameter other: an instance of a related type that implements `TextCellAccessibleProtocol`
    @inlinable public init<T: TextCellAccessibleProtocol>(textCellAccessible other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextCellAccessibleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum TextCellAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case renderer = "renderer"
    case widget = "widget"
}

public extension TextCellAccessibleProtocol {
    /// Bind a `TextCellAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextCellAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TextCellAccessible property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextCellAccessiblePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TextCellAccessible property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextCellAccessiblePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TextCellAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property-changed` is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyRenderer = "notify::renderer"
    case notifyWidget = "notify::widget"
}

// MARK: TextCellAccessible has no signals
// MARK: TextCellAccessible Class: TextCellAccessibleProtocol extension (methods and fields)
public extension TextCellAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextCellAccessible` instance.
    @inlinable var text_cell_accessible_ptr: UnsafeMutablePointer<GtkTextCellAccessible>! { return ptr?.assumingMemoryBound(to: GtkTextCellAccessible.self) }


    @inlinable var parent: GtkRendererCellAccessible {
        get {
            let rv = text_cell_accessible_ptr.pointee.parent
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TextChildAnchor Class

/// A `GtkTextChildAnchor` is a spot in the buffer where child widgets can
/// be “anchored” (inserted inline, as if they were characters). The anchor
/// can have multiple widgets anchored, to allow for multiple views.
///
/// The `TextChildAnchorProtocol` protocol exposes the methods and properties of an underlying `GtkTextChildAnchor` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextChildAnchor`.
/// Alternatively, use `TextChildAnchorRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextChildAnchorProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTextChildAnchor` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextChildAnchor` instance.
    var text_child_anchor_ptr: UnsafeMutablePointer<GtkTextChildAnchor>! { get }

    /// Required Initialiser for types conforming to `TextChildAnchorProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkTextChildAnchor` is a spot in the buffer where child widgets can
/// be “anchored” (inserted inline, as if they were characters). The anchor
/// can have multiple widgets anchored, to allow for multiple views.
///
/// The `TextChildAnchorRef` type acts as a lightweight Swift reference to an underlying `GtkTextChildAnchor` instance.
/// It exposes methods that can operate on this data type through `TextChildAnchorProtocol` conformance.
/// Use `TextChildAnchorRef` only as an `unowned` reference to an existing `GtkTextChildAnchor` instance.
///
public struct TextChildAnchorRef: TextChildAnchorProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextChildAnchor` instance.
    /// For type-safe access, use the generated, typed pointer `text_child_anchor_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextChildAnchorRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextChildAnchor>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextChildAnchor>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextChildAnchor>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextChildAnchor>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextChildAnchorProtocol`
    @inlinable init<T: TextChildAnchorProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextChildAnchorProtocol>(_ other: T) -> TextChildAnchorRef { TextChildAnchorRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTextChildAnchor`. Usually you would then insert
    /// it into a `GtkTextBuffer` with `gtk_text_buffer_insert_child_anchor()`.
    /// To perform the creation and insertion in one step, use the
    /// convenience function `gtk_text_buffer_create_child_anchor()`.
    @inlinable init() {
        let rv = gtk_text_child_anchor_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A `GtkTextChildAnchor` is a spot in the buffer where child widgets can
/// be “anchored” (inserted inline, as if they were characters). The anchor
/// can have multiple widgets anchored, to allow for multiple views.
///
/// The `TextChildAnchor` type acts as a reference-counted owner of an underlying `GtkTextChildAnchor` instance.
/// It provides the methods that can operate on this data type through `TextChildAnchorProtocol` conformance.
/// Use `TextChildAnchor` as a strong reference or owner of a `GtkTextChildAnchor` instance.
///
open class TextChildAnchor: GLibObject.Object, TextChildAnchorProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextChildAnchor>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextChildAnchor>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextChildAnchor>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextChildAnchor>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextChildAnchor`.
    /// i.e., ownership is transferred to the `TextChildAnchor` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextChildAnchor>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextChildAnchorProtocol`
    /// Will retain `GtkTextChildAnchor`.
    /// - Parameter other: an instance of a related type that implements `TextChildAnchorProtocol`
    @inlinable public init<T: TextChildAnchorProtocol>(textChildAnchor other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextChildAnchorProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkTextChildAnchor`. Usually you would then insert
    /// it into a `GtkTextBuffer` with `gtk_text_buffer_insert_child_anchor()`.
    /// To perform the creation and insertion in one step, use the
    /// convenience function `gtk_text_buffer_create_child_anchor()`.
    @inlinable public init() {
        let rv = gtk_text_child_anchor_new()
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no TextChildAnchor properties

public enum TextChildAnchorSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: TextChildAnchor has no signals
// MARK: TextChildAnchor Class: TextChildAnchorProtocol extension (methods and fields)
public extension TextChildAnchorProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextChildAnchor` instance.
    @inlinable var text_child_anchor_ptr: UnsafeMutablePointer<GtkTextChildAnchor>! { return ptr?.assumingMemoryBound(to: GtkTextChildAnchor.self) }

    /// Determines whether a child anchor has been deleted from
    /// the buffer. Keep in mind that the child anchor will be
    /// unreferenced when removed from the buffer, so you need to
    /// hold your own reference (with `g_object_ref()`) if you plan
    /// to use this function — otherwise all deleted child anchors
    /// will also be finalized.
    @inlinable func getDeleted() -> Bool {
        let rv = ((gtk_text_child_anchor_get_deleted(text_child_anchor_ptr)) != 0)
        return rv
    }

    /// Gets a list of all widgets anchored at this child anchor.
    /// The returned list should be freed with `g_list_free()`.
    @inlinable func getWidgets() -> GLib.ListRef! {
        let rv = GLib.ListRef(gtk_text_child_anchor_get_widgets(text_child_anchor_ptr))
        return rv
    }
    /// Determines whether a child anchor has been deleted from
    /// the buffer. Keep in mind that the child anchor will be
    /// unreferenced when removed from the buffer, so you need to
    /// hold your own reference (with `g_object_ref()`) if you plan
    /// to use this function — otherwise all deleted child anchors
    /// will also be finalized.
    @inlinable var deleted: Bool {
        /// Determines whether a child anchor has been deleted from
        /// the buffer. Keep in mind that the child anchor will be
        /// unreferenced when removed from the buffer, so you need to
        /// hold your own reference (with `g_object_ref()`) if you plan
        /// to use this function — otherwise all deleted child anchors
        /// will also be finalized.
        get {
            let rv = ((gtk_text_child_anchor_get_deleted(text_child_anchor_ptr)) != 0)
            return rv
        }
    }

    /// Gets a list of all widgets anchored at this child anchor.
    /// The returned list should be freed with `g_list_free()`.
    @inlinable var widgets: GLib.ListRef! {
        /// Gets a list of all widgets anchored at this child anchor.
        /// The returned list should be freed with `g_list_free()`.
        get {
            let rv = GLib.ListRef(gtk_text_child_anchor_get_widgets(text_child_anchor_ptr))
            return rv
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = text_child_anchor_ptr.pointee.parent_instance
            return rv
        }
    }

    // var segment is unavailable because segment is private

}



// MARK: - TextMark Class

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
/// 
/// A `GtkTextMark` is like a bookmark in a text buffer; it preserves a position in
/// the text. You can convert the mark to an iterator using
/// `gtk_text_buffer_get_iter_at_mark()`. Unlike iterators, marks remain valid across
/// buffer mutations, because their behavior is defined when text is inserted or
/// deleted. When text containing a mark is deleted, the mark remains in the
/// position originally occupied by the deleted text. When text is inserted at a
/// mark, a mark with “left gravity” will be moved to the
/// beginning of the newly-inserted text, and a mark with “right
/// gravity” will be moved to the end.
/// 
/// Note that “left” and “right” here refer to logical direction (left
/// is the toward the start of the buffer); in some languages such as
/// Hebrew the logically-leftmost text is not actually on the left when
/// displayed.
/// 
/// Marks are reference counted, but the reference count only controls the validity
/// of the memory; marks can be deleted from the buffer at any time with
/// `gtk_text_buffer_delete_mark()`. Once deleted from the buffer, a mark is
/// essentially useless.
/// 
/// Marks optionally have names; these can be convenient to avoid passing the
/// `GtkTextMark` object around.
/// 
/// Marks are typically created using the `gtk_text_buffer_create_mark()` function.
///
/// The `TextMarkProtocol` protocol exposes the methods and properties of an underlying `GtkTextMark` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextMark`.
/// Alternatively, use `TextMarkRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextMarkProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTextMark` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextMark` instance.
    var text_mark_ptr: UnsafeMutablePointer<GtkTextMark>! { get }

    /// Required Initialiser for types conforming to `TextMarkProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
/// 
/// A `GtkTextMark` is like a bookmark in a text buffer; it preserves a position in
/// the text. You can convert the mark to an iterator using
/// `gtk_text_buffer_get_iter_at_mark()`. Unlike iterators, marks remain valid across
/// buffer mutations, because their behavior is defined when text is inserted or
/// deleted. When text containing a mark is deleted, the mark remains in the
/// position originally occupied by the deleted text. When text is inserted at a
/// mark, a mark with “left gravity” will be moved to the
/// beginning of the newly-inserted text, and a mark with “right
/// gravity” will be moved to the end.
/// 
/// Note that “left” and “right” here refer to logical direction (left
/// is the toward the start of the buffer); in some languages such as
/// Hebrew the logically-leftmost text is not actually on the left when
/// displayed.
/// 
/// Marks are reference counted, but the reference count only controls the validity
/// of the memory; marks can be deleted from the buffer at any time with
/// `gtk_text_buffer_delete_mark()`. Once deleted from the buffer, a mark is
/// essentially useless.
/// 
/// Marks optionally have names; these can be convenient to avoid passing the
/// `GtkTextMark` object around.
/// 
/// Marks are typically created using the `gtk_text_buffer_create_mark()` function.
///
/// The `TextMarkRef` type acts as a lightweight Swift reference to an underlying `GtkTextMark` instance.
/// It exposes methods that can operate on this data type through `TextMarkProtocol` conformance.
/// Use `TextMarkRef` only as an `unowned` reference to an existing `GtkTextMark` instance.
///
public struct TextMarkRef: TextMarkProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextMark` instance.
    /// For type-safe access, use the generated, typed pointer `text_mark_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextMarkRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextMark>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextMark>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextMark>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextMark>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextMarkProtocol`
    @inlinable init<T: TextMarkProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextMarkProtocol>(_ other: T) -> TextMarkRef { TextMarkRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a text mark. Add it to a buffer using `gtk_text_buffer_add_mark()`.
    /// If `name` is `nil`, the mark is anonymous; otherwise, the mark can be
    /// retrieved by name using `gtk_text_buffer_get_mark()`. If a mark has left
    /// gravity, and text is inserted at the mark’s current location, the mark
    /// will be moved to the left of the newly-inserted text. If the mark has
    /// right gravity (`left_gravity` = `false`), the mark will end up on the
    /// right of newly-inserted text. The standard left-to-right cursor is a
    /// mark with right gravity (when you type, the cursor stays on the right
    /// side of the text you’re typing).
    @inlinable init( name: UnsafePointer<gchar>? = nil, leftGravity: Bool) {
        let rv = gtk_text_mark_new(name, gboolean((leftGravity) ? 1 : 0))
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
/// 
/// A `GtkTextMark` is like a bookmark in a text buffer; it preserves a position in
/// the text. You can convert the mark to an iterator using
/// `gtk_text_buffer_get_iter_at_mark()`. Unlike iterators, marks remain valid across
/// buffer mutations, because their behavior is defined when text is inserted or
/// deleted. When text containing a mark is deleted, the mark remains in the
/// position originally occupied by the deleted text. When text is inserted at a
/// mark, a mark with “left gravity” will be moved to the
/// beginning of the newly-inserted text, and a mark with “right
/// gravity” will be moved to the end.
/// 
/// Note that “left” and “right” here refer to logical direction (left
/// is the toward the start of the buffer); in some languages such as
/// Hebrew the logically-leftmost text is not actually on the left when
/// displayed.
/// 
/// Marks are reference counted, but the reference count only controls the validity
/// of the memory; marks can be deleted from the buffer at any time with
/// `gtk_text_buffer_delete_mark()`. Once deleted from the buffer, a mark is
/// essentially useless.
/// 
/// Marks optionally have names; these can be convenient to avoid passing the
/// `GtkTextMark` object around.
/// 
/// Marks are typically created using the `gtk_text_buffer_create_mark()` function.
///
/// The `TextMark` type acts as a reference-counted owner of an underlying `GtkTextMark` instance.
/// It provides the methods that can operate on this data type through `TextMarkProtocol` conformance.
/// Use `TextMark` as a strong reference or owner of a `GtkTextMark` instance.
///
open class TextMark: GLibObject.Object, TextMarkProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextMark>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextMark>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextMark>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextMark>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextMark`.
    /// i.e., ownership is transferred to the `TextMark` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextMark>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextMarkProtocol`
    /// Will retain `GtkTextMark`.
    /// - Parameter other: an instance of a related type that implements `TextMarkProtocol`
    @inlinable public init<T: TextMarkProtocol>(textMark other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextMarkProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a text mark. Add it to a buffer using `gtk_text_buffer_add_mark()`.
    /// If `name` is `nil`, the mark is anonymous; otherwise, the mark can be
    /// retrieved by name using `gtk_text_buffer_get_mark()`. If a mark has left
    /// gravity, and text is inserted at the mark’s current location, the mark
    /// will be moved to the left of the newly-inserted text. If the mark has
    /// right gravity (`left_gravity` = `false`), the mark will end up on the
    /// right of newly-inserted text. The standard left-to-right cursor is a
    /// mark with right gravity (when you type, the cursor stays on the right
    /// side of the text you’re typing).
    @inlinable public init( name: UnsafePointer<gchar>? = nil, leftGravity: Bool) {
        let rv = gtk_text_mark_new(name, gboolean((leftGravity) ? 1 : 0))
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum TextMarkPropertyName: String, PropertyNameProtocol {
    /// Whether the mark has left gravity. When text is inserted at the mark’s
    /// current location, if the mark has left gravity it will be moved
    /// to the left of the newly-inserted text, otherwise to the right.
    case leftGravity = "left-gravity"
    /// The name of the mark or `nil` if the mark is anonymous.
    case name = "name"
}

public extension TextMarkProtocol {
    /// Bind a `TextMarkPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextMarkPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TextMark property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextMarkPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TextMark property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextMarkPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TextMarkSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Whether the mark has left gravity. When text is inserted at the mark’s
    /// current location, if the mark has left gravity it will be moved
    /// to the left of the newly-inserted text, otherwise to the right.
    case notifyLeftGravity = "notify::left-gravity"
    /// The name of the mark or `nil` if the mark is anonymous.
    case notifyName = "notify::name"
}

// MARK: TextMark has no signals
// MARK: TextMark Class: TextMarkProtocol extension (methods and fields)
public extension TextMarkProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextMark` instance.
    @inlinable var text_mark_ptr: UnsafeMutablePointer<GtkTextMark>! { return ptr?.assumingMemoryBound(to: GtkTextMark.self) }

    /// Gets the buffer this mark is located inside,
    /// or `nil` if the mark is deleted.
    @inlinable func getBuffer() -> TextBufferRef! {
        let rv = TextBufferRef(gconstpointer: gconstpointer(gtk_text_mark_get_buffer(text_mark_ptr)))
        return rv
    }

    /// Returns `true` if the mark has been removed from its buffer
    /// with `gtk_text_buffer_delete_mark()`. See `gtk_text_buffer_add_mark()`
    /// for a way to add it to a buffer again.
    @inlinable func getDeleted() -> Bool {
        let rv = ((gtk_text_mark_get_deleted(text_mark_ptr)) != 0)
        return rv
    }

    /// Determines whether the mark has left gravity.
    @inlinable func getLeftGravity() -> Bool {
        let rv = ((gtk_text_mark_get_left_gravity(text_mark_ptr)) != 0)
        return rv
    }

    /// Returns the mark name; returns NULL for anonymous marks.
    @inlinable func getName() -> String! {
        let rv = gtk_text_mark_get_name(text_mark_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns `true` if the mark is visible (i.e. a cursor is displayed
    /// for it).
    @inlinable func getVisible() -> Bool {
        let rv = ((gtk_text_mark_get_visible(text_mark_ptr)) != 0)
        return rv
    }

    /// Sets the visibility of `mark`; the insertion point is normally
    /// visible, i.e. you can see it as a vertical bar. Also, the text
    /// widget uses a visible mark to indicate where a drop will occur when
    /// dragging-and-dropping text. Most other marks are not visible.
    /// Marks are not visible by default.
    @inlinable func setVisible(setting: Bool) {
        gtk_text_mark_set_visible(text_mark_ptr, gboolean((setting) ? 1 : 0))
    
    }
    /// Gets the buffer this mark is located inside,
    /// or `nil` if the mark is deleted.
    @inlinable var buffer: TextBufferRef! {
        /// Gets the buffer this mark is located inside,
        /// or `nil` if the mark is deleted.
        get {
            let rv = TextBufferRef(gconstpointer: gconstpointer(gtk_text_mark_get_buffer(text_mark_ptr)))
            return rv
        }
    }

    /// Returns `true` if the mark has been removed from its buffer
    /// with `gtk_text_buffer_delete_mark()`. See `gtk_text_buffer_add_mark()`
    /// for a way to add it to a buffer again.
    @inlinable var deleted: Bool {
        /// Returns `true` if the mark has been removed from its buffer
        /// with `gtk_text_buffer_delete_mark()`. See `gtk_text_buffer_add_mark()`
        /// for a way to add it to a buffer again.
        get {
            let rv = ((gtk_text_mark_get_deleted(text_mark_ptr)) != 0)
            return rv
        }
    }

    /// Determines whether the mark has left gravity.
    @inlinable var leftGravity: Bool {
        /// Determines whether the mark has left gravity.
        get {
            let rv = ((gtk_text_mark_get_left_gravity(text_mark_ptr)) != 0)
            return rv
        }
    }

    /// The name of the mark or `nil` if the mark is anonymous.
    @inlinable var name: String! {
        /// Returns the mark name; returns NULL for anonymous marks.
        get {
            let rv = gtk_text_mark_get_name(text_mark_ptr).map({ String(cString: $0) })
            return rv
        }
    }

    /// Returns `true` if the mark is visible (i.e. a cursor is displayed
    /// for it).
    @inlinable var visible: Bool {
        /// Returns `true` if the mark is visible (i.e. a cursor is displayed
        /// for it).
        get {
            let rv = ((gtk_text_mark_get_visible(text_mark_ptr)) != 0)
            return rv
        }
        /// Sets the visibility of `mark`; the insertion point is normally
        /// visible, i.e. you can see it as a vertical bar. Also, the text
        /// widget uses a visible mark to indicate where a drop will occur when
        /// dragging-and-dropping text. Most other marks are not visible.
        /// Marks are not visible by default.
        nonmutating set {
            gtk_text_mark_set_visible(text_mark_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = text_mark_ptr.pointee.parent_instance
            return rv
        }
    }

    // var segment is unavailable because segment is private

}



// MARK: - TextTag Class

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
/// 
/// Tags should be in the `GtkTextTagTable` for a given `GtkTextBuffer`
/// before using them with that buffer.
/// 
/// `gtk_text_buffer_create_tag()` is the best way to create tags.
/// See “gtk3-demo” for numerous examples.
/// 
/// For each property of `GtkTextTag`, there is a “set” property, e.g.
/// “font-set” corresponds to “font”. These “set” properties reflect
/// whether a property has been set or not.
/// They are maintained by GTK+ and you should not set them independently.
///
/// The `TextTagProtocol` protocol exposes the methods and properties of an underlying `GtkTextTag` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextTag`.
/// Alternatively, use `TextTagRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextTagProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTextTag` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextTag` instance.
    var text_tag_ptr: UnsafeMutablePointer<GtkTextTag>! { get }

    /// Required Initialiser for types conforming to `TextTagProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
/// 
/// Tags should be in the `GtkTextTagTable` for a given `GtkTextBuffer`
/// before using them with that buffer.
/// 
/// `gtk_text_buffer_create_tag()` is the best way to create tags.
/// See “gtk3-demo” for numerous examples.
/// 
/// For each property of `GtkTextTag`, there is a “set” property, e.g.
/// “font-set” corresponds to “font”. These “set” properties reflect
/// whether a property has been set or not.
/// They are maintained by GTK+ and you should not set them independently.
///
/// The `TextTagRef` type acts as a lightweight Swift reference to an underlying `GtkTextTag` instance.
/// It exposes methods that can operate on this data type through `TextTagProtocol` conformance.
/// Use `TextTagRef` only as an `unowned` reference to an existing `GtkTextTag` instance.
///
public struct TextTagRef: TextTagProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextTag` instance.
    /// For type-safe access, use the generated, typed pointer `text_tag_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextTagRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextTag>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextTag>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextTag>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextTag>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextTagProtocol`
    @inlinable init<T: TextTagProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextTagProtocol>(_ other: T) -> TextTagRef { TextTagRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a `GtkTextTag`. Configure the tag using object arguments,
    /// i.e. using `g_object_set()`.
    @inlinable init( name: UnsafePointer<gchar>? = nil) {
        let rv = gtk_text_tag_new(name)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
/// 
/// Tags should be in the `GtkTextTagTable` for a given `GtkTextBuffer`
/// before using them with that buffer.
/// 
/// `gtk_text_buffer_create_tag()` is the best way to create tags.
/// See “gtk3-demo” for numerous examples.
/// 
/// For each property of `GtkTextTag`, there is a “set” property, e.g.
/// “font-set” corresponds to “font”. These “set” properties reflect
/// whether a property has been set or not.
/// They are maintained by GTK+ and you should not set them independently.
///
/// The `TextTag` type acts as a reference-counted owner of an underlying `GtkTextTag` instance.
/// It provides the methods that can operate on this data type through `TextTagProtocol` conformance.
/// Use `TextTag` as a strong reference or owner of a `GtkTextTag` instance.
///
open class TextTag: GLibObject.Object, TextTagProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextTag>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextTag>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextTag>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextTag>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextTag`.
    /// i.e., ownership is transferred to the `TextTag` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextTag>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextTagProtocol`
    /// Will retain `GtkTextTag`.
    /// - Parameter other: an instance of a related type that implements `TextTagProtocol`
    @inlinable public init<T: TextTagProtocol>(textTag other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a `GtkTextTag`. Configure the tag using object arguments,
    /// i.e. using `g_object_set()`.
    @inlinable public init( name: UnsafePointer<gchar>? = nil) {
        let rv = gtk_text_tag_new(name)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum TextTagPropertyName: String, PropertyNameProtocol {
    /// Whether the margins accumulate or override each other.
    /// 
    /// When set to `true` the margins of this tag are added to the margins
    /// of any other non-accumulative margins present. When set to `false`
    /// the margins override one another (the default).
    case accumulativeMargin = "accumulative-margin"
    case background = "background"
    case backgroundFullHeight = "background-full-height"
    case backgroundFullHeightSet = "background-full-height-set"
    /// Background color as a `GdkColor`.
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkTextTag:background-rgba instead.
    case backgroundGdk = "background-gdk"
    /// Background color as a `GdkRGBA`.
    case backgroundRGBA = "background-rgba"
    case backgroundSet = "background-set"
    case direction = "direction"
    case editable = "editable"
    case editableSet = "editable-set"
    /// Whether font fallback is enabled.
    /// 
    /// When set to `true`, other fonts will be substituted
    /// where the current font is missing glyphs.
    case fallback = "fallback"
    case fallbackSet = "fallback-set"
    case family = "family"
    case familySet = "family-set"
    /// Font description as string, e.g. \"Sans Italic 12\".
    /// 
    /// Note that the initial value of this property depends on
    /// the internals of `PangoFontDescription`.
    case font = "font"
    case fontDesc = "font-desc"
    /// OpenType font features, as a string.
    case fontFeatures = "font-features"
    case fontFeaturesSet = "font-features-set"
    case foreground = "foreground"
    /// Foreground color as a `GdkColor`.
    ///
    /// **foreground-gdk is deprecated:**
    /// Use #GtkTextTag:foreground-rgba instead.
    case foregroundGdk = "foreground-gdk"
    /// Foreground color as a `GdkRGBA`.
    case foregroundRGBA = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case indent = "indent"
    case indentSet = "indent-set"
    /// Whether this text is hidden.
    /// 
    /// Note that there may still be problems with the support for invisible
    /// text, in particular when navigating programmatically inside a buffer
    /// containing invisible segments.
    case invisible = "invisible"
    case invisibleSet = "invisible-set"
    case justification = "justification"
    case justificationSet = "justification-set"
    /// The language this text is in, as an ISO code. Pango can use this as a
    /// hint when rendering the text. If not set, an appropriate default will be
    /// used.
    /// 
    /// Note that the initial value of this property depends on the current
    /// locale, see also `gtk_get_default_language()`.
    case language = "language"
    case languageSet = "language-set"
    case leftMargin = "left-margin"
    case leftMarginSet = "left-margin-set"
    /// Extra spacing between graphemes, in Pango units.
    case letterSpacing = "letter-spacing"
    case letterSpacingSet = "letter-spacing-set"
    case name = "name"
    /// The paragraph background color as a string.
    case paragraphBackground = "paragraph-background"
    /// The paragraph background color as a `GdkColor`.
    ///
    /// **paragraph-background-gdk is deprecated:**
    /// Use #GtkTextTag:paragraph-background-rgba instead.
    case paragraphBackgroundGdk = "paragraph-background-gdk"
    /// The paragraph background color as a `GdkRGBA`.
    case paragraphBackgroundRGBA = "paragraph-background-rgba"
    case paragraphBackgroundSet = "paragraph-background-set"
    case pixelsAboveLines = "pixels-above-lines"
    case pixelsAboveLinesSet = "pixels-above-lines-set"
    case pixelsBelowLines = "pixels-below-lines"
    case pixelsBelowLinesSet = "pixels-below-lines-set"
    case pixelsInsideWrap = "pixels-inside-wrap"
    case pixelsInsideWrapSet = "pixels-inside-wrap-set"
    case rightMargin = "right-margin"
    case rightMarginSet = "right-margin-set"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    /// This property modifies the color of strikeouts. If not set, strikeouts
    /// will use the forground color.
    case strikethroughRGBA = "strikethrough-rgba"
    /// If the `GtkTextTag:strikethrough-rgba` property has been set.
    case strikethroughRGBASet = "strikethrough-rgba-set"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case tabs = "tabs"
    case tabsSet = "tabs-set"
    case underline = "underline"
    /// This property modifies the color of underlines. If not set, underlines
    /// will use the forground color.
    /// 
    /// If `GtkTextTag:underline` is set to `PANGO_UNDERLINE_ERROR`, an alternate
    /// color may be applied instead of the foreground. Setting this property
    /// will always override those defaults.
    case underlineRGBA = "underline-rgba"
    /// If the `GtkTextTag:underline-rgba` property has been set.
    case underlineRGBASet = "underline-rgba-set"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case weight = "weight"
    case weightSet = "weight-set"
    case wrapMode = "wrap-mode"
    case wrapModeSet = "wrap-mode-set"
}

public extension TextTagProtocol {
    /// Bind a `TextTagPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextTagPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TextTag property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextTagPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TextTag property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextTagPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TextTagSignalName: String, SignalNameProtocol {
    /// The `event` signal is emitted when an event occurs on a region of the
    /// buffer marked with this tag.
    case event = "event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Whether the margins accumulate or override each other.
    /// 
    /// When set to `true` the margins of this tag are added to the margins
    /// of any other non-accumulative margins present. When set to `false`
    /// the margins override one another (the default).
    case notifyAccumulativeMargin = "notify::accumulative-margin"
    case notifyBackground = "notify::background"
    case notifyBackgroundFullHeight = "notify::background-full-height"
    case notifyBackgroundFullHeightSet = "notify::background-full-height-set"
    /// Background color as a `GdkColor`.
    ///
    /// **background-gdk is deprecated:**
    /// Use #GtkTextTag:background-rgba instead.
    case notifyBackgroundGdk = "notify::background-gdk"
    /// Background color as a `GdkRGBA`.
    case notifyBackgroundRGBA = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyDirection = "notify::direction"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    /// Whether font fallback is enabled.
    /// 
    /// When set to `true`, other fonts will be substituted
    /// where the current font is missing glyphs.
    case notifyFallback = "notify::fallback"
    case notifyFallbackSet = "notify::fallback-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    /// Font description as string, e.g. \"Sans Italic 12\".
    /// 
    /// Note that the initial value of this property depends on
    /// the internals of `PangoFontDescription`.
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    /// OpenType font features, as a string.
    case notifyFontFeatures = "notify::font-features"
    case notifyFontFeaturesSet = "notify::font-features-set"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkColor`.
    ///
    /// **foreground-gdk is deprecated:**
    /// Use #GtkTextTag:foreground-rgba instead.
    case notifyForegroundGdk = "notify::foreground-gdk"
    /// Foreground color as a `GdkRGBA`.
    case notifyForegroundRGBA = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyIndent = "notify::indent"
    case notifyIndentSet = "notify::indent-set"
    /// Whether this text is hidden.
    /// 
    /// Note that there may still be problems with the support for invisible
    /// text, in particular when navigating programmatically inside a buffer
    /// containing invisible segments.
    case notifyInvisible = "notify::invisible"
    case notifyInvisibleSet = "notify::invisible-set"
    case notifyJustification = "notify::justification"
    case notifyJustificationSet = "notify::justification-set"
    /// The language this text is in, as an ISO code. Pango can use this as a
    /// hint when rendering the text. If not set, an appropriate default will be
    /// used.
    /// 
    /// Note that the initial value of this property depends on the current
    /// locale, see also `gtk_get_default_language()`.
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyLeftMargin = "notify::left-margin"
    case notifyLeftMarginSet = "notify::left-margin-set"
    /// Extra spacing between graphemes, in Pango units.
    case notifyLetterSpacing = "notify::letter-spacing"
    case notifyLetterSpacingSet = "notify::letter-spacing-set"
    case notifyName = "notify::name"
    /// The paragraph background color as a string.
    case notifyParagraphBackground = "notify::paragraph-background"
    /// The paragraph background color as a `GdkColor`.
    ///
    /// **paragraph-background-gdk is deprecated:**
    /// Use #GtkTextTag:paragraph-background-rgba instead.
    case notifyParagraphBackgroundGdk = "notify::paragraph-background-gdk"
    /// The paragraph background color as a `GdkRGBA`.
    case notifyParagraphBackgroundRGBA = "notify::paragraph-background-rgba"
    case notifyParagraphBackgroundSet = "notify::paragraph-background-set"
    case notifyPixelsAboveLines = "notify::pixels-above-lines"
    case notifyPixelsAboveLinesSet = "notify::pixels-above-lines-set"
    case notifyPixelsBelowLines = "notify::pixels-below-lines"
    case notifyPixelsBelowLinesSet = "notify::pixels-below-lines-set"
    case notifyPixelsInsideWrap = "notify::pixels-inside-wrap"
    case notifyPixelsInsideWrapSet = "notify::pixels-inside-wrap-set"
    case notifyRightMargin = "notify::right-margin"
    case notifyRightMarginSet = "notify::right-margin-set"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    /// This property modifies the color of strikeouts. If not set, strikeouts
    /// will use the forground color.
    case notifyStrikethroughRGBA = "notify::strikethrough-rgba"
    /// If the `GtkTextTag:strikethrough-rgba` property has been set.
    case notifyStrikethroughRGBASet = "notify::strikethrough-rgba-set"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyTabs = "notify::tabs"
    case notifyTabsSet = "notify::tabs-set"
    case notifyUnderline = "notify::underline"
    /// This property modifies the color of underlines. If not set, underlines
    /// will use the forground color.
    /// 
    /// If `GtkTextTag:underline` is set to `PANGO_UNDERLINE_ERROR`, an alternate
    /// color may be applied instead of the foreground. Setting this property
    /// will always override those defaults.
    case notifyUnderlineRGBA = "notify::underline-rgba"
    /// If the `GtkTextTag:underline-rgba` property has been set.
    case notifyUnderlineRGBASet = "notify::underline-rgba-set"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWrapMode = "notify::wrap-mode"
    case notifyWrapModeSet = "notify::wrap-mode-set"
}

// MARK: TextTag signals
public extension TextTagProtocol {
    /// Connect a Swift signal handler to the given, typed `TextTagSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextTagSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TextTagSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextTagSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// The `event` signal is emitted when an event occurs on a region of the
    /// buffer marked with this tag.
    /// - Note: This represents the underlying `event` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter object: the object the event was fired from (typically a `GtkTextView`)
    /// - Parameter event: the event which triggered the signal
    /// - Parameter iter: a `GtkTextIter` pointing at the location the event occurred
    /// - Parameter handler: `true` to stop other handlers from being invoked for the event. `false` to propagate the event further.
    /// Run the given callback whenever the `event` signal is emitted
    @discardableResult @inlinable func onEvent(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ object: GLibObject.ObjectRef, _ event: Gdk.EventRef, _ iter: TextIterRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder4<TextTagRef, GLibObject.ObjectRef, Gdk.EventRef, TextIterRef, Bool>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer, gpointer) -> gboolean = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(TextTagRef(raw: unownedSelf), GLibObject.ObjectRef(raw: arg1), Gdk.EventRef(raw: arg2), TextIterRef(raw: arg3))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .event,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `event` signal for using the `connect(signal:)` methods
    static var eventSignal: TextTagSignalName { .event }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::accumulative-margin` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAccumulativeMargin` signal is emitted
    @discardableResult @inlinable func onNotifyAccumulativeMargin(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAccumulativeMargin,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::accumulative-margin` signal for using the `connect(signal:)` methods
    static var notifyAccumulativeMarginSignal: TextTagSignalName { .notifyAccumulativeMargin }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::background` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBackground` signal is emitted
    @discardableResult @inlinable func onNotifyBackground(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyBackground,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::background` signal for using the `connect(signal:)` methods
    static var notifyBackgroundSignal: TextTagSignalName { .notifyBackground }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::background-full-height` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBackgroundFullHeight` signal is emitted
    @discardableResult @inlinable func onNotifyBackgroundFullHeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyBackgroundFullHeight,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::background-full-height` signal for using the `connect(signal:)` methods
    static var notifyBackgroundFullHeightSignal: TextTagSignalName { .notifyBackgroundFullHeight }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::background-full-height-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBackgroundFullHeightSet` signal is emitted
    @discardableResult @inlinable func onNotifyBackgroundFullHeightSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyBackgroundFullHeightSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::background-full-height-set` signal for using the `connect(signal:)` methods
    static var notifyBackgroundFullHeightSetSignal: TextTagSignalName { .notifyBackgroundFullHeightSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::background-gdk` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBackgroundGdk` signal is emitted
    @discardableResult @inlinable func onNotifyBackgroundGdk(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyBackgroundGdk,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::background-gdk` signal for using the `connect(signal:)` methods
    static var notifyBackgroundGdkSignal: TextTagSignalName { .notifyBackgroundGdk }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::background-rgba` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBackgroundRGBA` signal is emitted
    @discardableResult @inlinable func onNotifyBackgroundRGBA(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyBackgroundRGBA,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::background-rgba` signal for using the `connect(signal:)` methods
    static var notifyBackgroundRGBASignal: TextTagSignalName { .notifyBackgroundRGBA }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::background-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBackgroundSet` signal is emitted
    @discardableResult @inlinable func onNotifyBackgroundSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyBackgroundSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::background-set` signal for using the `connect(signal:)` methods
    static var notifyBackgroundSetSignal: TextTagSignalName { .notifyBackgroundSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::direction` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyDirection` signal is emitted
    @discardableResult @inlinable func onNotifyDirection(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyDirection,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::direction` signal for using the `connect(signal:)` methods
    static var notifyDirectionSignal: TextTagSignalName { .notifyDirection }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::editable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditable` signal is emitted
    @discardableResult @inlinable func onNotifyEditable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEditable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::editable` signal for using the `connect(signal:)` methods
    static var notifyEditableSignal: TextTagSignalName { .notifyEditable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::editable-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditableSet` signal is emitted
    @discardableResult @inlinable func onNotifyEditableSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEditableSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::editable-set` signal for using the `connect(signal:)` methods
    static var notifyEditableSetSignal: TextTagSignalName { .notifyEditableSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::fallback` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFallback` signal is emitted
    @discardableResult @inlinable func onNotifyFallback(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFallback,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::fallback` signal for using the `connect(signal:)` methods
    static var notifyFallbackSignal: TextTagSignalName { .notifyFallback }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::fallback-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFallbackSet` signal is emitted
    @discardableResult @inlinable func onNotifyFallbackSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFallbackSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::fallback-set` signal for using the `connect(signal:)` methods
    static var notifyFallbackSetSignal: TextTagSignalName { .notifyFallbackSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::family` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFamily` signal is emitted
    @discardableResult @inlinable func onNotifyFamily(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFamily,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::family` signal for using the `connect(signal:)` methods
    static var notifyFamilySignal: TextTagSignalName { .notifyFamily }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::family-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFamilySet` signal is emitted
    @discardableResult @inlinable func onNotifyFamilySet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFamilySet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::family-set` signal for using the `connect(signal:)` methods
    static var notifyFamilySetSignal: TextTagSignalName { .notifyFamilySet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::font` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFont` signal is emitted
    @discardableResult @inlinable func onNotifyFont(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFont,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::font` signal for using the `connect(signal:)` methods
    static var notifyFontSignal: TextTagSignalName { .notifyFont }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::font-desc` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFontDesc` signal is emitted
    @discardableResult @inlinable func onNotifyFontDesc(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFontDesc,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::font-desc` signal for using the `connect(signal:)` methods
    static var notifyFontDescSignal: TextTagSignalName { .notifyFontDesc }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::font-features` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFontFeatures` signal is emitted
    @discardableResult @inlinable func onNotifyFontFeatures(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFontFeatures,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::font-features` signal for using the `connect(signal:)` methods
    static var notifyFontFeaturesSignal: TextTagSignalName { .notifyFontFeatures }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::font-features-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFontFeaturesSet` signal is emitted
    @discardableResult @inlinable func onNotifyFontFeaturesSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFontFeaturesSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::font-features-set` signal for using the `connect(signal:)` methods
    static var notifyFontFeaturesSetSignal: TextTagSignalName { .notifyFontFeaturesSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::foreground` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyForeground` signal is emitted
    @discardableResult @inlinable func onNotifyForeground(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyForeground,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::foreground` signal for using the `connect(signal:)` methods
    static var notifyForegroundSignal: TextTagSignalName { .notifyForeground }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::foreground-gdk` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyForegroundGdk` signal is emitted
    @discardableResult @inlinable func onNotifyForegroundGdk(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyForegroundGdk,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::foreground-gdk` signal for using the `connect(signal:)` methods
    static var notifyForegroundGdkSignal: TextTagSignalName { .notifyForegroundGdk }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::foreground-rgba` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyForegroundRGBA` signal is emitted
    @discardableResult @inlinable func onNotifyForegroundRGBA(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyForegroundRGBA,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::foreground-rgba` signal for using the `connect(signal:)` methods
    static var notifyForegroundRGBASignal: TextTagSignalName { .notifyForegroundRGBA }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::foreground-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyForegroundSet` signal is emitted
    @discardableResult @inlinable func onNotifyForegroundSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyForegroundSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::foreground-set` signal for using the `connect(signal:)` methods
    static var notifyForegroundSetSignal: TextTagSignalName { .notifyForegroundSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::indent` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIndent` signal is emitted
    @discardableResult @inlinable func onNotifyIndent(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyIndent,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::indent` signal for using the `connect(signal:)` methods
    static var notifyIndentSignal: TextTagSignalName { .notifyIndent }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::indent-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIndentSet` signal is emitted
    @discardableResult @inlinable func onNotifyIndentSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyIndentSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::indent-set` signal for using the `connect(signal:)` methods
    static var notifyIndentSetSignal: TextTagSignalName { .notifyIndentSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::invisible` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInvisible` signal is emitted
    @discardableResult @inlinable func onNotifyInvisible(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyInvisible,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::invisible` signal for using the `connect(signal:)` methods
    static var notifyInvisibleSignal: TextTagSignalName { .notifyInvisible }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::invisible-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInvisibleSet` signal is emitted
    @discardableResult @inlinable func onNotifyInvisibleSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyInvisibleSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::invisible-set` signal for using the `connect(signal:)` methods
    static var notifyInvisibleSetSignal: TextTagSignalName { .notifyInvisibleSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::justification` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyJustification` signal is emitted
    @discardableResult @inlinable func onNotifyJustification(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyJustification,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::justification` signal for using the `connect(signal:)` methods
    static var notifyJustificationSignal: TextTagSignalName { .notifyJustification }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::justification-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyJustificationSet` signal is emitted
    @discardableResult @inlinable func onNotifyJustificationSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyJustificationSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::justification-set` signal for using the `connect(signal:)` methods
    static var notifyJustificationSetSignal: TextTagSignalName { .notifyJustificationSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::language` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLanguage` signal is emitted
    @discardableResult @inlinable func onNotifyLanguage(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLanguage,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::language` signal for using the `connect(signal:)` methods
    static var notifyLanguageSignal: TextTagSignalName { .notifyLanguage }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::language-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLanguageSet` signal is emitted
    @discardableResult @inlinable func onNotifyLanguageSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLanguageSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::language-set` signal for using the `connect(signal:)` methods
    static var notifyLanguageSetSignal: TextTagSignalName { .notifyLanguageSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::left-margin` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLeftMargin` signal is emitted
    @discardableResult @inlinable func onNotifyLeftMargin(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLeftMargin,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::left-margin` signal for using the `connect(signal:)` methods
    static var notifyLeftMarginSignal: TextTagSignalName { .notifyLeftMargin }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::left-margin-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLeftMarginSet` signal is emitted
    @discardableResult @inlinable func onNotifyLeftMarginSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLeftMarginSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::left-margin-set` signal for using the `connect(signal:)` methods
    static var notifyLeftMarginSetSignal: TextTagSignalName { .notifyLeftMarginSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::letter-spacing` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLetterSpacing` signal is emitted
    @discardableResult @inlinable func onNotifyLetterSpacing(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLetterSpacing,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::letter-spacing` signal for using the `connect(signal:)` methods
    static var notifyLetterSpacingSignal: TextTagSignalName { .notifyLetterSpacing }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::letter-spacing-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLetterSpacingSet` signal is emitted
    @discardableResult @inlinable func onNotifyLetterSpacingSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLetterSpacingSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::letter-spacing-set` signal for using the `connect(signal:)` methods
    static var notifyLetterSpacingSetSignal: TextTagSignalName { .notifyLetterSpacingSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::name` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyName` signal is emitted
    @discardableResult @inlinable func onNotifyName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyName,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::name` signal for using the `connect(signal:)` methods
    static var notifyNameSignal: TextTagSignalName { .notifyName }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::paragraph-background` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyParagraphBackground` signal is emitted
    @discardableResult @inlinable func onNotifyParagraphBackground(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyParagraphBackground,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::paragraph-background` signal for using the `connect(signal:)` methods
    static var notifyParagraphBackgroundSignal: TextTagSignalName { .notifyParagraphBackground }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::paragraph-background-gdk` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyParagraphBackgroundGdk` signal is emitted
    @discardableResult @inlinable func onNotifyParagraphBackgroundGdk(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyParagraphBackgroundGdk,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::paragraph-background-gdk` signal for using the `connect(signal:)` methods
    static var notifyParagraphBackgroundGdkSignal: TextTagSignalName { .notifyParagraphBackgroundGdk }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::paragraph-background-rgba` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyParagraphBackgroundRGBA` signal is emitted
    @discardableResult @inlinable func onNotifyParagraphBackgroundRGBA(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyParagraphBackgroundRGBA,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::paragraph-background-rgba` signal for using the `connect(signal:)` methods
    static var notifyParagraphBackgroundRGBASignal: TextTagSignalName { .notifyParagraphBackgroundRGBA }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::paragraph-background-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyParagraphBackgroundSet` signal is emitted
    @discardableResult @inlinable func onNotifyParagraphBackgroundSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyParagraphBackgroundSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::paragraph-background-set` signal for using the `connect(signal:)` methods
    static var notifyParagraphBackgroundSetSignal: TextTagSignalName { .notifyParagraphBackgroundSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::pixels-above-lines` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPixelsAboveLines` signal is emitted
    @discardableResult @inlinable func onNotifyPixelsAboveLines(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPixelsAboveLines,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::pixels-above-lines` signal for using the `connect(signal:)` methods
    static var notifyPixelsAboveLinesSignal: TextTagSignalName { .notifyPixelsAboveLines }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::pixels-above-lines-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPixelsAboveLinesSet` signal is emitted
    @discardableResult @inlinable func onNotifyPixelsAboveLinesSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPixelsAboveLinesSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::pixels-above-lines-set` signal for using the `connect(signal:)` methods
    static var notifyPixelsAboveLinesSetSignal: TextTagSignalName { .notifyPixelsAboveLinesSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::pixels-below-lines` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPixelsBelowLines` signal is emitted
    @discardableResult @inlinable func onNotifyPixelsBelowLines(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPixelsBelowLines,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::pixels-below-lines` signal for using the `connect(signal:)` methods
    static var notifyPixelsBelowLinesSignal: TextTagSignalName { .notifyPixelsBelowLines }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::pixels-below-lines-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPixelsBelowLinesSet` signal is emitted
    @discardableResult @inlinable func onNotifyPixelsBelowLinesSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPixelsBelowLinesSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::pixels-below-lines-set` signal for using the `connect(signal:)` methods
    static var notifyPixelsBelowLinesSetSignal: TextTagSignalName { .notifyPixelsBelowLinesSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::pixels-inside-wrap` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPixelsInsideWrap` signal is emitted
    @discardableResult @inlinable func onNotifyPixelsInsideWrap(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPixelsInsideWrap,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::pixels-inside-wrap` signal for using the `connect(signal:)` methods
    static var notifyPixelsInsideWrapSignal: TextTagSignalName { .notifyPixelsInsideWrap }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::pixels-inside-wrap-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPixelsInsideWrapSet` signal is emitted
    @discardableResult @inlinable func onNotifyPixelsInsideWrapSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPixelsInsideWrapSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::pixels-inside-wrap-set` signal for using the `connect(signal:)` methods
    static var notifyPixelsInsideWrapSetSignal: TextTagSignalName { .notifyPixelsInsideWrapSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::right-margin` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRightMargin` signal is emitted
    @discardableResult @inlinable func onNotifyRightMargin(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyRightMargin,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::right-margin` signal for using the `connect(signal:)` methods
    static var notifyRightMarginSignal: TextTagSignalName { .notifyRightMargin }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::right-margin-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRightMarginSet` signal is emitted
    @discardableResult @inlinable func onNotifyRightMarginSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyRightMarginSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::right-margin-set` signal for using the `connect(signal:)` methods
    static var notifyRightMarginSetSignal: TextTagSignalName { .notifyRightMarginSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::rise` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRise` signal is emitted
    @discardableResult @inlinable func onNotifyRise(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyRise,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::rise` signal for using the `connect(signal:)` methods
    static var notifyRiseSignal: TextTagSignalName { .notifyRise }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::rise-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRiseSet` signal is emitted
    @discardableResult @inlinable func onNotifyRiseSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyRiseSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::rise-set` signal for using the `connect(signal:)` methods
    static var notifyRiseSetSignal: TextTagSignalName { .notifyRiseSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::scale` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyScale` signal is emitted
    @discardableResult @inlinable func onNotifyScale(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyScale,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::scale` signal for using the `connect(signal:)` methods
    static var notifyScaleSignal: TextTagSignalName { .notifyScale }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::scale-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyScaleSet` signal is emitted
    @discardableResult @inlinable func onNotifyScaleSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyScaleSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::scale-set` signal for using the `connect(signal:)` methods
    static var notifyScaleSetSignal: TextTagSignalName { .notifyScaleSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::size` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySize` signal is emitted
    @discardableResult @inlinable func onNotifySize(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySize,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::size` signal for using the `connect(signal:)` methods
    static var notifySizeSignal: TextTagSignalName { .notifySize }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::size-points` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySizePoints` signal is emitted
    @discardableResult @inlinable func onNotifySizePoints(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySizePoints,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::size-points` signal for using the `connect(signal:)` methods
    static var notifySizePointsSignal: TextTagSignalName { .notifySizePoints }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::size-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySizeSet` signal is emitted
    @discardableResult @inlinable func onNotifySizeSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySizeSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::size-set` signal for using the `connect(signal:)` methods
    static var notifySizeSetSignal: TextTagSignalName { .notifySizeSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::stretch` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStretch` signal is emitted
    @discardableResult @inlinable func onNotifyStretch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStretch,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::stretch` signal for using the `connect(signal:)` methods
    static var notifyStretchSignal: TextTagSignalName { .notifyStretch }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::stretch-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStretchSet` signal is emitted
    @discardableResult @inlinable func onNotifyStretchSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStretchSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::stretch-set` signal for using the `connect(signal:)` methods
    static var notifyStretchSetSignal: TextTagSignalName { .notifyStretchSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::strikethrough` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStrikethrough` signal is emitted
    @discardableResult @inlinable func onNotifyStrikethrough(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStrikethrough,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::strikethrough` signal for using the `connect(signal:)` methods
    static var notifyStrikethroughSignal: TextTagSignalName { .notifyStrikethrough }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::strikethrough-rgba` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStrikethroughRGBA` signal is emitted
    @discardableResult @inlinable func onNotifyStrikethroughRGBA(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStrikethroughRGBA,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::strikethrough-rgba` signal for using the `connect(signal:)` methods
    static var notifyStrikethroughRGBASignal: TextTagSignalName { .notifyStrikethroughRGBA }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::strikethrough-rgba-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStrikethroughRGBASet` signal is emitted
    @discardableResult @inlinable func onNotifyStrikethroughRGBASet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStrikethroughRGBASet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::strikethrough-rgba-set` signal for using the `connect(signal:)` methods
    static var notifyStrikethroughRGBASetSignal: TextTagSignalName { .notifyStrikethroughRGBASet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::strikethrough-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStrikethroughSet` signal is emitted
    @discardableResult @inlinable func onNotifyStrikethroughSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStrikethroughSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::strikethrough-set` signal for using the `connect(signal:)` methods
    static var notifyStrikethroughSetSignal: TextTagSignalName { .notifyStrikethroughSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::style` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStyle` signal is emitted
    @discardableResult @inlinable func onNotifyStyle(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStyle,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::style` signal for using the `connect(signal:)` methods
    static var notifyStyleSignal: TextTagSignalName { .notifyStyle }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::style-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStyleSet` signal is emitted
    @discardableResult @inlinable func onNotifyStyleSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStyleSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::style-set` signal for using the `connect(signal:)` methods
    static var notifyStyleSetSignal: TextTagSignalName { .notifyStyleSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::tabs` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTabs` signal is emitted
    @discardableResult @inlinable func onNotifyTabs(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyTabs,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::tabs` signal for using the `connect(signal:)` methods
    static var notifyTabsSignal: TextTagSignalName { .notifyTabs }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::tabs-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTabsSet` signal is emitted
    @discardableResult @inlinable func onNotifyTabsSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyTabsSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::tabs-set` signal for using the `connect(signal:)` methods
    static var notifyTabsSetSignal: TextTagSignalName { .notifyTabsSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::underline` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUnderline` signal is emitted
    @discardableResult @inlinable func onNotifyUnderline(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyUnderline,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::underline` signal for using the `connect(signal:)` methods
    static var notifyUnderlineSignal: TextTagSignalName { .notifyUnderline }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::underline-rgba` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUnderlineRGBA` signal is emitted
    @discardableResult @inlinable func onNotifyUnderlineRGBA(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyUnderlineRGBA,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::underline-rgba` signal for using the `connect(signal:)` methods
    static var notifyUnderlineRGBASignal: TextTagSignalName { .notifyUnderlineRGBA }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::underline-rgba-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUnderlineRGBASet` signal is emitted
    @discardableResult @inlinable func onNotifyUnderlineRGBASet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyUnderlineRGBASet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::underline-rgba-set` signal for using the `connect(signal:)` methods
    static var notifyUnderlineRGBASetSignal: TextTagSignalName { .notifyUnderlineRGBASet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::underline-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUnderlineSet` signal is emitted
    @discardableResult @inlinable func onNotifyUnderlineSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyUnderlineSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::underline-set` signal for using the `connect(signal:)` methods
    static var notifyUnderlineSetSignal: TextTagSignalName { .notifyUnderlineSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::variant` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVariant` signal is emitted
    @discardableResult @inlinable func onNotifyVariant(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyVariant,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::variant` signal for using the `connect(signal:)` methods
    static var notifyVariantSignal: TextTagSignalName { .notifyVariant }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::variant-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVariantSet` signal is emitted
    @discardableResult @inlinable func onNotifyVariantSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyVariantSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::variant-set` signal for using the `connect(signal:)` methods
    static var notifyVariantSetSignal: TextTagSignalName { .notifyVariantSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::weight` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWeight` signal is emitted
    @discardableResult @inlinable func onNotifyWeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWeight,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::weight` signal for using the `connect(signal:)` methods
    static var notifyWeightSignal: TextTagSignalName { .notifyWeight }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::weight-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWeightSet` signal is emitted
    @discardableResult @inlinable func onNotifyWeightSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWeightSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::weight-set` signal for using the `connect(signal:)` methods
    static var notifyWeightSetSignal: TextTagSignalName { .notifyWeightSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::wrap-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWrapMode` signal is emitted
    @discardableResult @inlinable func onNotifyWrapMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWrapMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::wrap-mode` signal for using the `connect(signal:)` methods
    static var notifyWrapModeSignal: TextTagSignalName { .notifyWrapMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::wrap-mode-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWrapModeSet` signal is emitted
    @discardableResult @inlinable func onNotifyWrapModeSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWrapModeSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::wrap-mode-set` signal for using the `connect(signal:)` methods
    static var notifyWrapModeSetSignal: TextTagSignalName { .notifyWrapModeSet }
    
}

// MARK: TextTag Class: TextTagProtocol extension (methods and fields)
public extension TextTagProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextTag` instance.
    @inlinable var text_tag_ptr: UnsafeMutablePointer<GtkTextTag>! { return ptr?.assumingMemoryBound(to: GtkTextTag.self) }

    /// Emits the `GtkTextTagTable::tag-changed` signal on the `GtkTextTagTable` where
    /// the tag is included.
    /// 
    /// The signal is already emitted when setting a `GtkTextTag` property. This
    /// function is useful for a `GtkTextTag` subclass.
    @inlinable func changed(sizeChanged: Bool) {
        gtk_text_tag_changed(text_tag_ptr, gboolean((sizeChanged) ? 1 : 0))
    
    }

    /// Emits the “event” signal on the `GtkTextTag`.
    @inlinable func event<EventT: Gdk.EventProtocol, ObjectT: GLibObject.ObjectProtocol, TextIterT: TextIterProtocol>(eventObject: ObjectT, event: EventT, iter: TextIterT) -> Bool {
        let rv = ((gtk_text_tag_event(text_tag_ptr, eventObject.object_ptr, event.event_ptr, iter.text_iter_ptr)) != 0)
        return rv
    }

    /// Get the tag priority.
    @inlinable func getPriority() -> Int {
        let rv = Int(gtk_text_tag_get_priority(text_tag_ptr))
        return rv
    }

    /// Sets the priority of a `GtkTextTag`. Valid priorities
    /// start at 0 and go to one less than `gtk_text_tag_table_get_size()`.
    /// Each tag in a table has a unique priority; setting the priority
    /// of one tag shifts the priorities of all the other tags in the
    /// table to maintain a unique priority for each tag. Higher priority
    /// tags “win” if two tags both set the same text attribute. When adding
    /// a tag to a tag table, it will be assigned the highest priority in
    /// the table by default; so normally the precedence of a set of tags
    /// is the order in which they were added to the table, or created with
    /// `gtk_text_buffer_create_tag()`, which adds the tag to the buffer’s table
    /// automatically.
    @inlinable func set(priority: Int) {
        gtk_text_tag_set_priority(text_tag_ptr, gint(priority))
    
    }
    /// Get the tag priority.
    @inlinable var priority: Int {
        /// Get the tag priority.
        get {
            let rv = Int(gtk_text_tag_get_priority(text_tag_ptr))
            return rv
        }
        /// Sets the priority of a `GtkTextTag`. Valid priorities
        /// start at 0 and go to one less than `gtk_text_tag_table_get_size()`.
        /// Each tag in a table has a unique priority; setting the priority
        /// of one tag shifts the priorities of all the other tags in the
        /// table to maintain a unique priority for each tag. Higher priority
        /// tags “win” if two tags both set the same text attribute. When adding
        /// a tag to a tag table, it will be assigned the highest priority in
        /// the table by default; so normally the precedence of a set of tags
        /// is the order in which they were added to the table, or created with
        /// `gtk_text_buffer_create_tag()`, which adds the tag to the buffer’s table
        /// automatically.
        nonmutating set {
            gtk_text_tag_set_priority(text_tag_ptr, gint(newValue))
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = text_tag_ptr.pointee.parent_instance
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TextTagTable Class

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
/// 
/// # GtkTextTagTables as GtkBuildable
/// 
/// The GtkTextTagTable implementation of the GtkBuildable interface
/// supports adding tags by specifying “tag” as the “type” attribute
/// of a &lt;child&gt; element.
/// 
/// An example of a UI definition fragment specifying tags:
/// ```
/// <object class="GtkTextTagTable">
///  <child type="tag">
///    <object class="GtkTextTag"/>
///  </child>
/// </object>
/// ```
/// 
///
/// The `TextTagTableProtocol` protocol exposes the methods and properties of an underlying `GtkTextTagTable` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextTagTable`.
/// Alternatively, use `TextTagTableRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextTagTableProtocol: GLibObject.ObjectProtocol, BuildableProtocol {
        /// Untyped pointer to the underlying `GtkTextTagTable` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextTagTable` instance.
    var text_tag_table_ptr: UnsafeMutablePointer<GtkTextTagTable>! { get }

    /// Required Initialiser for types conforming to `TextTagTableProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
/// 
/// # GtkTextTagTables as GtkBuildable
/// 
/// The GtkTextTagTable implementation of the GtkBuildable interface
/// supports adding tags by specifying “tag” as the “type” attribute
/// of a &lt;child&gt; element.
/// 
/// An example of a UI definition fragment specifying tags:
/// ```
/// <object class="GtkTextTagTable">
///  <child type="tag">
///    <object class="GtkTextTag"/>
///  </child>
/// </object>
/// ```
/// 
///
/// The `TextTagTableRef` type acts as a lightweight Swift reference to an underlying `GtkTextTagTable` instance.
/// It exposes methods that can operate on this data type through `TextTagTableProtocol` conformance.
/// Use `TextTagTableRef` only as an `unowned` reference to an existing `GtkTextTagTable` instance.
///
public struct TextTagTableRef: TextTagTableProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextTagTable` instance.
    /// For type-safe access, use the generated, typed pointer `text_tag_table_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextTagTableRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextTagTable>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextTagTable>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextTagTable>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextTagTable>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextTagTableProtocol`
    @inlinable init<T: TextTagTableProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextTagTableProtocol>(_ other: T) -> TextTagTableRef { TextTagTableRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTextTagTable`. The table contains no tags by
    /// default.
    @inlinable init() {
        let rv = gtk_text_tag_table_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and
/// data types related to the text widget and how they work together.
/// 
/// # GtkTextTagTables as GtkBuildable
/// 
/// The GtkTextTagTable implementation of the GtkBuildable interface
/// supports adding tags by specifying “tag” as the “type” attribute
/// of a &lt;child&gt; element.
/// 
/// An example of a UI definition fragment specifying tags:
/// ```
/// <object class="GtkTextTagTable">
///  <child type="tag">
///    <object class="GtkTextTag"/>
///  </child>
/// </object>
/// ```
/// 
///
/// The `TextTagTable` type acts as a reference-counted owner of an underlying `GtkTextTagTable` instance.
/// It provides the methods that can operate on this data type through `TextTagTableProtocol` conformance.
/// Use `TextTagTable` as a strong reference or owner of a `GtkTextTagTable` instance.
///
open class TextTagTable: GLibObject.Object, TextTagTableProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextTagTable>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextTagTable>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextTagTable>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextTagTable>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextTagTable`.
    /// i.e., ownership is transferred to the `TextTagTable` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextTagTable>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextTagTableProtocol`
    /// Will retain `GtkTextTagTable`.
    /// - Parameter other: an instance of a related type that implements `TextTagTableProtocol`
    @inlinable public init<T: TextTagTableProtocol>(textTagTable other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextTagTableProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkTextTagTable`. The table contains no tags by
    /// default.
    @inlinable public init() {
        let rv = gtk_text_tag_table_new()
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no TextTagTable properties

public enum TextTagTableSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case tagAdded = "tag-added"
    case tagChanged = "tag-changed"
    case tagRemoved = "tag-removed"

}

// MARK: TextTagTable signals
public extension TextTagTableProtocol {
    /// Connect a Swift signal handler to the given, typed `TextTagTableSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextTagTableSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TextTagTableSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextTagTableSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// - Note: This represents the underlying `tag-added` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter tag: the added tag.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `tagAdded` signal is emitted
    @discardableResult @inlinable func onTagAdded(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagTableRef, _ tag: TextTagRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagTableRef, TextTagRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagTableRef(raw: unownedSelf), TextTagRef(raw: arg1))
            return output
        }
        return connect(
            signal: .tagAdded,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `tag-added` signal for using the `connect(signal:)` methods
    static var tagAddedSignal: TextTagTableSignalName { .tagAdded }
    
    /// - Note: This represents the underlying `tag-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter tag: the changed tag.
    /// - Parameter sizeChanged: whether the change affects the `GtkTextView` layout.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `tagChanged` signal is emitted
    @discardableResult @inlinable func onTagChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagTableRef, _ tag: TextTagRef, _ sizeChanged: Bool) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TextTagTableRef, TextTagRef, Bool, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gboolean, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagTableRef(raw: unownedSelf), TextTagRef(raw: arg1), ((arg2) != 0))
            return output
        }
        return connect(
            signal: .tagChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `tag-changed` signal for using the `connect(signal:)` methods
    static var tagChangedSignal: TextTagTableSignalName { .tagChanged }
    
    /// - Note: This represents the underlying `tag-removed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter tag: the removed tag.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `tagRemoved` signal is emitted
    @discardableResult @inlinable func onTagRemoved(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextTagTableRef, _ tag: TextTagRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextTagTableRef, TextTagRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextTagTableRef(raw: unownedSelf), TextTagRef(raw: arg1))
            return output
        }
        return connect(
            signal: .tagRemoved,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `tag-removed` signal for using the `connect(signal:)` methods
    static var tagRemovedSignal: TextTagTableSignalName { .tagRemoved }
    
    
}

// MARK: TextTagTable Class: TextTagTableProtocol extension (methods and fields)
public extension TextTagTableProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextTagTable` instance.
    @inlinable var text_tag_table_ptr: UnsafeMutablePointer<GtkTextTagTable>! { return ptr?.assumingMemoryBound(to: GtkTextTagTable.self) }

    /// Add a tag to the table. The tag is assigned the highest priority
    /// in the table.
    /// 
    /// `tag` must not be in a tag table already, and may not have
    /// the same name as an already-added tag.
    @inlinable func add<TextTagT: TextTagProtocol>(tag: TextTagT) -> Bool {
        let rv = ((gtk_text_tag_table_add(text_tag_table_ptr, tag.text_tag_ptr)) != 0)
        return rv
    }

    /// Calls `func` on each tag in `table`, with user data `data`.
    /// Note that the table may not be modified while iterating
    /// over it (you can’t add/remove tags).
    @inlinable func foreach(`func`: @escaping GtkTextTagTableForeach, data: gpointer! = nil) {
        gtk_text_tag_table_foreach(text_tag_table_ptr, `func`, data)
    
    }

    /// Returns the size of the table (number of tags)
    @inlinable func getSize() -> Int {
        let rv = Int(gtk_text_tag_table_get_size(text_tag_table_ptr))
        return rv
    }

    /// Look up a named tag.
    @inlinable func lookup(name: UnsafePointer<gchar>!) -> TextTagRef! {
        let rv = TextTagRef(gconstpointer: gconstpointer(gtk_text_tag_table_lookup(text_tag_table_ptr, name)))
        return rv
    }

    /// Remove a tag from the table. If a `GtkTextBuffer` has `table` as its tag table,
    /// the tag is removed from the buffer. The table’s reference to the tag is
    /// removed, so the tag will end up destroyed if you don’t have a reference to
    /// it.
    @inlinable func remove<TextTagT: TextTagProtocol>(tag: TextTagT) {
        gtk_text_tag_table_remove(text_tag_table_ptr, tag.text_tag_ptr)
    
    }
    /// Returns the size of the table (number of tags)
    @inlinable var size: Int {
        /// Returns the size of the table (number of tags)
        get {
            let rv = Int(gtk_text_tag_table_get_size(text_tag_table_ptr))
            return rv
        }
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = text_tag_table_ptr.pointee.parent_instance
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TextView Class

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// textview.view
/// ├── border.top
/// ├── border.left
/// ├── text
/// │   ╰── [selection]
/// ├── border.right
/// ├── border.bottom
/// ╰── [window.popup]
/// ```
/// 
/// GtkTextView has a main css node with name textview and style class .view,
/// and subnodes for each of the border windows, and the main text area,
/// with names border and text, respectively. The border nodes each get
/// one of the style classes .left, .right, .top or .bottom.
/// 
/// A node representing the selection will appear below the text node.
/// 
/// If a context menu is opened, the window node will appear as a subnode
/// of the main node.
///
/// The `TextViewProtocol` protocol exposes the methods and properties of an underlying `GtkTextView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextView`.
/// Alternatively, use `TextViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextViewProtocol: ContainerProtocol, ScrollableProtocol {
        /// Untyped pointer to the underlying `GtkTextView` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextView` instance.
    var text_view_ptr: UnsafeMutablePointer<GtkTextView>! { get }

    /// Required Initialiser for types conforming to `TextViewProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// textview.view
/// ├── border.top
/// ├── border.left
/// ├── text
/// │   ╰── [selection]
/// ├── border.right
/// ├── border.bottom
/// ╰── [window.popup]
/// ```
/// 
/// GtkTextView has a main css node with name textview and style class .view,
/// and subnodes for each of the border windows, and the main text area,
/// with names border and text, respectively. The border nodes each get
/// one of the style classes .left, .right, .top or .bottom.
/// 
/// A node representing the selection will appear below the text node.
/// 
/// If a context menu is opened, the window node will appear as a subnode
/// of the main node.
///
/// The `TextViewRef` type acts as a lightweight Swift reference to an underlying `GtkTextView` instance.
/// It exposes methods that can operate on this data type through `TextViewProtocol` conformance.
/// Use `TextViewRef` only as an `unowned` reference to an existing `GtkTextView` instance.
///
public struct TextViewRef: TextViewProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextView` instance.
    /// For type-safe access, use the generated, typed pointer `text_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextViewRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextView>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextView>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextView>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextView>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextViewProtocol`
    @inlinable init<T: TextViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextViewProtocol>(_ other: T) -> TextViewRef { TextViewRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTextView`. If you don’t call `gtk_text_view_set_buffer()`
    /// before using the text view, an empty default buffer will be created
    /// for you. Get the buffer with `gtk_text_view_get_buffer()`. If you want
    /// to specify your own buffer, consider `gtk_text_view_new_with_buffer()`.
    @inlinable init() {
        let rv = gtk_text_view_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkTextView` widget displaying the buffer
    /// `buffer`. One buffer can be shared among many widgets.
    /// `buffer` may be `nil` to create a default buffer, in which case
    /// this function is equivalent to `gtk_text_view_new()`. The
    /// text view adds its own reference count to the buffer; it does not
    /// take over an existing reference.
    @inlinable init<TextBufferT: TextBufferProtocol>(buffer: TextBufferT) {
        let rv = gtk_text_view_new_with_buffer(buffer.text_buffer_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkTextView` widget displaying the buffer
    /// `buffer`. One buffer can be shared among many widgets.
    /// `buffer` may be `nil` to create a default buffer, in which case
    /// this function is equivalent to `gtk_text_view_new()`. The
    /// text view adds its own reference count to the buffer; it does not
    /// take over an existing reference.
    @inlinable static func newWith<TextBufferT: TextBufferProtocol>(buffer: TextBufferT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_text_view_new_with_buffer(buffer.text_buffer_ptr))) else { return nil }
        return rv
    }
}

/// You may wish to begin by reading the
/// [text widget conceptual overview](#TextWidget)
/// which gives an overview of all the objects and data
/// types related to the text widget and how they work together.
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// textview.view
/// ├── border.top
/// ├── border.left
/// ├── text
/// │   ╰── [selection]
/// ├── border.right
/// ├── border.bottom
/// ╰── [window.popup]
/// ```
/// 
/// GtkTextView has a main css node with name textview and style class .view,
/// and subnodes for each of the border windows, and the main text area,
/// with names border and text, respectively. The border nodes each get
/// one of the style classes .left, .right, .top or .bottom.
/// 
/// A node representing the selection will appear below the text node.
/// 
/// If a context menu is opened, the window node will appear as a subnode
/// of the main node.
///
/// The `TextView` type acts as a reference-counted owner of an underlying `GtkTextView` instance.
/// It provides the methods that can operate on this data type through `TextViewProtocol` conformance.
/// Use `TextView` as a strong reference or owner of a `GtkTextView` instance.
///
open class TextView: Container, TextViewProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextView>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextView>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextView>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextView>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextView`.
    /// i.e., ownership is transferred to the `TextView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextView>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextViewProtocol`
    /// Will retain `GtkTextView`.
    /// - Parameter other: an instance of a related type that implements `TextViewProtocol`
    @inlinable public init<T: TextViewProtocol>(textView other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkTextView`. If you don’t call `gtk_text_view_set_buffer()`
    /// before using the text view, an empty default buffer will be created
    /// for you. Get the buffer with `gtk_text_view_get_buffer()`. If you want
    /// to specify your own buffer, consider `gtk_text_view_new_with_buffer()`.
    @inlinable public init() {
        let rv = gtk_text_view_new()
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkTextView` widget displaying the buffer
    /// `buffer`. One buffer can be shared among many widgets.
    /// `buffer` may be `nil` to create a default buffer, in which case
    /// this function is equivalent to `gtk_text_view_new()`. The
    /// text view adds its own reference count to the buffer; it does not
    /// take over an existing reference.
    @inlinable public init<TextBufferT: TextBufferProtocol>(buffer: TextBufferT) {
        let rv = gtk_text_view_new_with_buffer(buffer.text_buffer_ptr)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkTextView` widget displaying the buffer
    /// `buffer`. One buffer can be shared among many widgets.
    /// `buffer` may be `nil` to create a default buffer, in which case
    /// this function is equivalent to `gtk_text_view_new()`. The
    /// text view adds its own reference count to the buffer; it does not
    /// take over an existing reference.
    @inlinable public static func newWith<TextBufferT: TextBufferProtocol>(buffer: TextBufferT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_text_view_new_with_buffer(buffer.text_buffer_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum TextViewPropertyName: String, PropertyNameProtocol {
    case acceptsTab = "accepts-tab"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    /// The bottom margin for text in the text view.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin-bottom`.
    case bottomMargin = "bottom-margin"
    case buffer = "buffer"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    case cursorVisible = "cursor-visible"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case editable = "editable"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// Which IM (input method) module should be used for this text_view.
    /// See `GtkIMContext`.
    /// 
    /// Setting this to a non-`nil` value overrides the
    /// system-wide IM module setting. See the GtkSettings
    /// `GtkSettings:gtk-im-module` property.
    case imModule = "im-module"
    case indent = "indent"
    /// Additional hints (beyond `GtkTextView:input-purpose`) that
    /// allow input methods to fine-tune their behaviour.
    case inputHints = "input-hints"
    /// The purpose of this text field.
    /// 
    /// This property can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    case inputPurpose = "input-purpose"
    case isFocus = "is-focus"
    case justification = "justification"
    /// The default left margin for text in the text view.
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin-left`.
    case leftMargin = "left-margin"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case monospace = "monospace"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case overwrite = "overwrite"
    case parent = "parent"
    case pixelsAboveLines = "pixels-above-lines"
    case pixelsBelowLines = "pixels-below-lines"
    case pixelsInsideWrap = "pixels-inside-wrap"
    /// If :populate-all is `true`, the `GtkTextView::populate-popup`
    /// signal is also emitted for touch popups.
    case populateAll = "populate-all"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The default right margin for text in the text view.
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin-right`.
    case rightMargin = "right-margin"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    case tabs = "tabs"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The top margin for text in the text view.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin-top`.
    case topMargin = "top-margin"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
    case wrapMode = "wrap-mode"
}

public extension TextViewProtocol {
    /// Bind a `TextViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TextView property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextViewPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TextView property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextViewPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TextViewSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    case add = "add"
    /// The `backspace` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user asks for it.
    /// 
    /// The default bindings for this signal are
    /// Backspace and Shift-Backspace.
    case backspace = "backspace"
    /// The `button-press-event` signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button-release-event` signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child-notify` signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The `composited-changed` signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure-event` signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// The `copy-clipboard` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to copy the selection to the clipboard.
    /// 
    /// The default bindings for this signal are
    /// Ctrl-c and Ctrl-Insert.
    case copyClipboard = "copy-clipboard"
    /// The `cut-clipboard` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to cut the selection to the clipboard.
    /// 
    /// The default bindings for this signal are
    /// Ctrl-x and Shift-Delete.
    case cutClipboard = "cut-clipboard"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete-event` signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// The `delete-from-cursor` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user initiates a text deletion.
    /// 
    /// If the `type` is `GTK_DELETE_CHARS`, GTK+ deletes the selection
    /// if there is one, otherwise it deletes the requested number
    /// of characters.
    /// 
    /// The default bindings for this signal are
    /// Delete for deleting a character, Ctrl-Delete for
    /// deleting a word and Ctrl-Backspace for deleting a word
    /// backwords.
    case deleteFromCursor = "delete-from-cursor"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy-event` signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction-changed` signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag-begin` signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag-data-delete` signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag-data-get` signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag-data-received` signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag-drop` signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag-drop` signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag-data-received` handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag-end` signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag-begin`.
    case dragEnd = "drag-end"
    /// The `drag-failed` signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag-leave` signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag-motion`, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag-leave` signal is also emitted before the
    /// `drag-drop` signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag-motion` signal handler.
    case dragLeave = "drag-leave"
    /// The `drag-motion` signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag-data-received`
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag-leave` and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter-notify-event` will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key-press-event`) and finally a generic
    /// `GtkWidget::event-after` signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event-after` will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    /// The `extend-selection` signal is emitted when the selection needs to be
    /// extended at `location`.
    case extendSelection = "extend-selection"
    case focus = "focus"
    /// The `focus-in-event` signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus-out-event` signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab-notify` signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy-changed` signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `insert-at-cursor` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user initiates the insertion of a
    /// fixed string at the cursor.
    /// 
    /// This signal has no default bindings.
    case insertAtCursor = "insert-at-cursor"
    /// The `insert-emoji` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to present the Emoji chooser for the `text_view`.
    /// 
    /// The default bindings for this signal are Ctrl-. and Ctrl-;
    case insertEmoji = "insert-emoji"
    /// The `key-press-event` signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key-release-event` signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave-notify-event` will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map-event` will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map-event` signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion-notify-event` signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    /// The `move-cursor` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user initiates a cursor movement.
    /// If the cursor is not visible in `text_view`, this signal causes
    /// the viewport to be moved instead.
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// The default bindings for this signal come in two variants,
    /// the variant with the Shift modifier extends the selection,
    /// the variant without the Shift modifer does not.
    /// There are too many key combinations to list them all here.
    /// - Arrow keys move by individual characters/lines
    /// - Ctrl-arrow key combinations move by words/paragraphs
    /// - Home/End keys move to the ends of the buffer
    /// - PageUp/PageDown keys move vertically by pages
    /// - Ctrl-PageUp/PageDown keys move horizontally by pages
    case moveCursor = "move-cursor"
    case moveFocus = "move-focus"
    /// The `move-viewport` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which can be bound to key combinations to allow the user
    /// to move the viewport, i.e. change what part of the text view
    /// is visible in a containing scrolled window.
    /// 
    /// There are no default bindings for this signal.
    case moveViewport = "move-viewport"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent-set` signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// The `paste-clipboard` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to paste the contents of the clipboard
    /// into the text view.
    /// 
    /// The default bindings for this signal are
    /// Ctrl-v and Shift-Insert.
    case pasteClipboard = "paste-clipboard"
    /// The `populate-popup` signal gets emitted before showing the
    /// context menu of the text view.
    /// 
    /// If you need to add items to the context menu, connect
    /// to this signal and append your items to the `popup`, which
    /// will be a `GtkMenu` in this case.
    /// 
    /// If `GtkTextView:populate-all` is `true`, this signal will
    /// also be emitted to populate touch popups. In this case,
    /// `popup` will be a different container, e.g. a `GtkToolbar`.
    /// 
    /// The signal handler should not make assumptions about the
    /// type of `widget`, but check whether `popup` is a `GtkMenu`
    /// or `GtkToolbar` or another kind of container.
    case populatePopup = "populate-popup"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// If an input method is used, the typed text will not immediately
    /// be committed to the buffer. So if you are interested in the text,
    /// connect to this signal.
    /// 
    /// This signal is only emitted if the text at the given position
    /// is actually editable.
    case preeditChanged = "preedit-changed"
    /// The `property-notify-event` signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has-tooltip` is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen-changed` signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll-event` signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `select-all` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to select or unselect the complete
    /// contents of the text view.
    /// 
    /// The default bindings for this signal are Ctrl-a and Ctrl-/
    /// for selecting and Shift-Ctrl-a and Ctrl-\ for unselecting.
    case selectAll = "select-all"
    /// The `selection-clear-event` signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection-request-event` signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    /// The `set-anchor` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user initiates setting the "anchor"
    /// mark. The "anchor" mark gets placed at the same position as the
    /// "insert" mark.
    /// 
    /// This signal has no default bindings.
    case setAnchor = "set-anchor"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The `state-changed` signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state-flags-changed` signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style-set` signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style-updated` signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style-updated` signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// The `toggle-cursor-visible` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to toggle the `GtkTextView:cursor-visible`
    /// property.
    /// 
    /// The default binding for this signal is F7.
    case toggleCursorVisible = "toggle-cursor-visible"
    /// The `toggle-overwrite` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to toggle the overwrite mode of the text view.
    /// 
    /// The default bindings for this signal is Insert.
    case toggleOverwrite = "toggle-overwrite"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap-event` signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility-notify-event` will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The `window-state-event` will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAcceptsTab = "notify::accepts-tab"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    /// The bottom margin for text in the text view.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin-bottom`.
    case notifyBottomMargin = "notify::bottom-margin"
    case notifyBuffer = "notify::buffer"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    case notifyCursorVisible = "notify::cursor-visible"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEditable = "notify::editable"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Which IM (input method) module should be used for this text_view.
    /// See `GtkIMContext`.
    /// 
    /// Setting this to a non-`nil` value overrides the
    /// system-wide IM module setting. See the GtkSettings
    /// `GtkSettings:gtk-im-module` property.
    case notifyImModule = "notify::im-module"
    case notifyIndent = "notify::indent"
    /// Additional hints (beyond `GtkTextView:input-purpose`) that
    /// allow input methods to fine-tune their behaviour.
    case notifyInputHints = "notify::input-hints"
    /// The purpose of this text field.
    /// 
    /// This property can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    case notifyInputPurpose = "notify::input-purpose"
    case notifyIsFocus = "notify::is-focus"
    case notifyJustification = "notify::justification"
    /// The default left margin for text in the text view.
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin-left`.
    case notifyLeftMargin = "notify::left-margin"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyMonospace = "notify::monospace"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyOverwrite = "notify::overwrite"
    case notifyParent = "notify::parent"
    case notifyPixelsAboveLines = "notify::pixels-above-lines"
    case notifyPixelsBelowLines = "notify::pixels-below-lines"
    case notifyPixelsInsideWrap = "notify::pixels-inside-wrap"
    /// If :populate-all is `true`, the `GtkTextView::populate-popup`
    /// signal is also emitted for touch popups.
    case notifyPopulateAll = "notify::populate-all"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The default right margin for text in the text view.
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin-right`.
    case notifyRightMargin = "notify::right-margin"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    case notifyTabs = "notify::tabs"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The top margin for text in the text view.
    /// 
    /// Note that this property is confusingly named. In CSS terms,
    /// the value set here is padding, and it is applied in addition
    /// to the padding from the theme.
    /// 
    /// Don't confuse this property with `GtkWidget:margin-top`.
    case notifyTopMargin = "notify::top-margin"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
    case notifyWrapMode = "notify::wrap-mode"
}

// MARK: TextView signals
public extension TextViewProtocol {
    /// Connect a Swift signal handler to the given, typed `TextViewSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextViewSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TextViewSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TextViewSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// The `backspace` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user asks for it.
    /// 
    /// The default bindings for this signal are
    /// Backspace and Shift-Backspace.
    /// - Note: This represents the underlying `backspace` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `backspace` signal is emitted
    @discardableResult @inlinable func onBackspace(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextViewRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .backspace,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `backspace` signal for using the `connect(signal:)` methods
    static var backspaceSignal: TextViewSignalName { .backspace }
    
    /// The `copy-clipboard` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to copy the selection to the clipboard.
    /// 
    /// The default bindings for this signal are
    /// Ctrl-c and Ctrl-Insert.
    /// - Note: This represents the underlying `copy-clipboard` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `copyClipboard` signal is emitted
    @discardableResult @inlinable func onCopyClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextViewRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .copyClipboard,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `copy-clipboard` signal for using the `connect(signal:)` methods
    static var copyClipboardSignal: TextViewSignalName { .copyClipboard }
    
    /// The `cut-clipboard` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to cut the selection to the clipboard.
    /// 
    /// The default bindings for this signal are
    /// Ctrl-x and Shift-Delete.
    /// - Note: This represents the underlying `cut-clipboard` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `cutClipboard` signal is emitted
    @discardableResult @inlinable func onCutClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextViewRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .cutClipboard,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `cut-clipboard` signal for using the `connect(signal:)` methods
    static var cutClipboardSignal: TextViewSignalName { .cutClipboard }
    
    /// The `delete-from-cursor` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user initiates a text deletion.
    /// 
    /// If the `type` is `GTK_DELETE_CHARS`, GTK+ deletes the selection
    /// if there is one, otherwise it deletes the requested number
    /// of characters.
    /// 
    /// The default bindings for this signal are
    /// Delete for deleting a character, Ctrl-Delete for
    /// deleting a word and Ctrl-Backspace for deleting a word
    /// backwords.
    /// - Note: This represents the underlying `delete-from-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter type: the granularity of the deletion, as a `GtkDeleteType`
    /// - Parameter count: the number of `type` units to delete
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `deleteFromCursor` signal is emitted
    @discardableResult @inlinable func onDeleteFromCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ type: DeleteType, _ count: Int) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TextViewRef, DeleteType, Int, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), DeleteType(arg1), Int(arg2))
            return output
        }
        return connect(
            signal: .deleteFromCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `delete-from-cursor` signal for using the `connect(signal:)` methods
    static var deleteFromCursorSignal: TextViewSignalName { .deleteFromCursor }
    
    /// The `extend-selection` signal is emitted when the selection needs to be
    /// extended at `location`.
    /// - Note: This represents the underlying `extend-selection` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter granularity: the granularity type
    /// - Parameter location: the location where to extend the selection
    /// - Parameter start: where the selection should start
    /// - Parameter end: where the selection should end
    /// - Parameter handler: `GDK_EVENT_STOP` to stop other handlers from being invoked for the   event. `GDK_EVENT_PROPAGATE` to propagate the event further.
    /// Run the given callback whenever the `extendSelection` signal is emitted
    @discardableResult @inlinable func onExtendSelection(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ granularity: TextExtendSelection, _ location: TextIterRef, _ start: TextIterRef, _ end: TextIterRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder5<TextViewRef, TextExtendSelection, TextIterRef, TextIterRef, TextIterRef, Bool>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer, gpointer, gpointer, gpointer) -> gboolean = { unownedSelf, arg1, arg2, arg3, arg4, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(TextViewRef(raw: unownedSelf), TextExtendSelection(arg1), TextIterRef(raw: arg2), TextIterRef(raw: arg3), TextIterRef(raw: arg4))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .extendSelection,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `extend-selection` signal for using the `connect(signal:)` methods
    static var extendSelectionSignal: TextViewSignalName { .extendSelection }
    
    /// The `insert-at-cursor` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user initiates the insertion of a
    /// fixed string at the cursor.
    /// 
    /// This signal has no default bindings.
    /// - Note: This represents the underlying `insert-at-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter string: the string to insert
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertAtCursor` signal is emitted
    @discardableResult @inlinable func onInsertAtCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ string: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, String, Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!)
            return output
        }
        return connect(
            signal: .insertAtCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-at-cursor` signal for using the `connect(signal:)` methods
    static var insertAtCursorSignal: TextViewSignalName { .insertAtCursor }
    
    /// The `insert-emoji` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to present the Emoji chooser for the `text_view`.
    /// 
    /// The default bindings for this signal are Ctrl-. and Ctrl-;
    /// - Note: This represents the underlying `insert-emoji` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `insertEmoji` signal is emitted
    @discardableResult @inlinable func onInsertEmoji(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextViewRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .insertEmoji,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `insert-emoji` signal for using the `connect(signal:)` methods
    static var insertEmojiSignal: TextViewSignalName { .insertEmoji }
    
    /// The `move-cursor` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user initiates a cursor movement.
    /// If the cursor is not visible in `text_view`, this signal causes
    /// the viewport to be moved instead.
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically.
    /// 
    /// The default bindings for this signal come in two variants,
    /// the variant with the Shift modifier extends the selection,
    /// the variant without the Shift modifer does not.
    /// There are too many key combinations to list them all here.
    /// - Arrow keys move by individual characters/lines
    /// - Ctrl-arrow key combinations move by words/paragraphs
    /// - Home/End keys move to the ends of the buffer
    /// - PageUp/PageDown keys move vertically by pages
    /// - Ctrl-PageUp/PageDown keys move horizontally by pages
    /// - Note: This represents the underlying `move-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter step: the granularity of the move, as a `GtkMovementStep`
    /// - Parameter count: the number of `step` units to move
    /// - Parameter extendSelection: `true` if the move should extend the selection
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `moveCursor` signal is emitted
    @discardableResult @inlinable func onMoveCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ step: MovementStep, _ count: Int, _ extendSelection: Bool) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder4<TextViewRef, MovementStep, Int, Bool, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gboolean, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), MovementStep(arg1), Int(arg2), ((arg3) != 0))
            return output
        }
        return connect(
            signal: .moveCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `move-cursor` signal for using the `connect(signal:)` methods
    static var moveCursorSignal: TextViewSignalName { .moveCursor }
    
    /// The `move-viewport` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which can be bound to key combinations to allow the user
    /// to move the viewport, i.e. change what part of the text view
    /// is visible in a containing scrolled window.
    /// 
    /// There are no default bindings for this signal.
    /// - Note: This represents the underlying `move-viewport` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter step: the granularity of the movement, as a `GtkScrollStep`
    /// - Parameter count: the number of `step` units to move
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `moveViewport` signal is emitted
    @discardableResult @inlinable func onMoveViewport(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ step: ScrollStep, _ count: Int) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TextViewRef, ScrollStep, Int, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ScrollStep(arg1), Int(arg2))
            return output
        }
        return connect(
            signal: .moveViewport,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `move-viewport` signal for using the `connect(signal:)` methods
    static var moveViewportSignal: TextViewSignalName { .moveViewport }
    
    /// The `paste-clipboard` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to paste the contents of the clipboard
    /// into the text view.
    /// 
    /// The default bindings for this signal are
    /// Ctrl-v and Shift-Insert.
    /// - Note: This represents the underlying `paste-clipboard` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `pasteClipboard` signal is emitted
    @discardableResult @inlinable func onPasteClipboard(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextViewRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .pasteClipboard,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `paste-clipboard` signal for using the `connect(signal:)` methods
    static var pasteClipboardSignal: TextViewSignalName { .pasteClipboard }
    
    /// The `populate-popup` signal gets emitted before showing the
    /// context menu of the text view.
    /// 
    /// If you need to add items to the context menu, connect
    /// to this signal and append your items to the `popup`, which
    /// will be a `GtkMenu` in this case.
    /// 
    /// If `GtkTextView:populate-all` is `true`, this signal will
    /// also be emitted to populate touch popups. In this case,
    /// `popup` will be a different container, e.g. a `GtkToolbar`.
    /// 
    /// The signal handler should not make assumptions about the
    /// type of `widget`, but check whether `popup` is a `GtkMenu`
    /// or `GtkToolbar` or another kind of container.
    /// - Note: This represents the underlying `populate-popup` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter popup: the container that is being populated
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `populatePopup` signal is emitted
    @discardableResult @inlinable func onPopulatePopup(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ popup: WidgetRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, WidgetRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), WidgetRef(raw: arg1))
            return output
        }
        return connect(
            signal: .populatePopup,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `populate-popup` signal for using the `connect(signal:)` methods
    static var populatePopupSignal: TextViewSignalName { .populatePopup }
    
    /// If an input method is used, the typed text will not immediately
    /// be committed to the buffer. So if you are interested in the text,
    /// connect to this signal.
    /// 
    /// This signal is only emitted if the text at the given position
    /// is actually editable.
    /// - Note: This represents the underlying `preedit-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter preedit: the current preedit string
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `preeditChanged` signal is emitted
    @discardableResult @inlinable func onPreeditChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ preedit: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, String, Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!)
            return output
        }
        return connect(
            signal: .preeditChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `preedit-changed` signal for using the `connect(signal:)` methods
    static var preeditChangedSignal: TextViewSignalName { .preeditChanged }
    
    /// The `select-all` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to select or unselect the complete
    /// contents of the text view.
    /// 
    /// The default bindings for this signal are Ctrl-a and Ctrl-/
    /// for selecting and Shift-Ctrl-a and Ctrl-\ for unselecting.
    /// - Note: This represents the underlying `select-all` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter select: `true` to select, `false` to unselect
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `selectAll` signal is emitted
    @discardableResult @inlinable func onSelectAll(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ select: Bool) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, Bool, Void>
        let cCallback: @convention(c) (gpointer, gboolean, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ((arg1) != 0))
            return output
        }
        return connect(
            signal: .selectAll,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `select-all` signal for using the `connect(signal:)` methods
    static var selectAllSignal: TextViewSignalName { .selectAll }
    
    /// The `set-anchor` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted when the user initiates setting the "anchor"
    /// mark. The "anchor" mark gets placed at the same position as the
    /// "insert" mark.
    /// 
    /// This signal has no default bindings.
    /// - Note: This represents the underlying `set-anchor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `setAnchor` signal is emitted
    @discardableResult @inlinable func onSetAnchor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextViewRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .setAnchor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `set-anchor` signal for using the `connect(signal:)` methods
    static var setAnchorSignal: TextViewSignalName { .setAnchor }
    
    /// The `toggle-cursor-visible` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to toggle the `GtkTextView:cursor-visible`
    /// property.
    /// 
    /// The default binding for this signal is F7.
    /// - Note: This represents the underlying `toggle-cursor-visible` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggleCursorVisible` signal is emitted
    @discardableResult @inlinable func onToggleCursorVisible(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextViewRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .toggleCursorVisible,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggle-cursor-visible` signal for using the `connect(signal:)` methods
    static var toggleCursorVisibleSignal: TextViewSignalName { .toggleCursorVisible }
    
    /// The `toggle-overwrite` signal is a
    /// [keybinding signal](#GtkBindingSignal)
    /// which gets emitted to toggle the overwrite mode of the text view.
    /// 
    /// The default bindings for this signal is Insert.
    /// - Note: This represents the underlying `toggle-overwrite` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggleOverwrite` signal is emitted
    @discardableResult @inlinable func onToggleOverwrite(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TextViewRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .toggleOverwrite,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggle-overwrite` signal for using the `connect(signal:)` methods
    static var toggleOverwriteSignal: TextViewSignalName { .toggleOverwrite }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::accepts-tab` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAcceptsTab` signal is emitted
    @discardableResult @inlinable func onNotifyAcceptsTab(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAcceptsTab,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::accepts-tab` signal for using the `connect(signal:)` methods
    static var notifyAcceptsTabSignal: TextViewSignalName { .notifyAcceptsTab }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::bottom-margin` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBottomMargin` signal is emitted
    @discardableResult @inlinable func onNotifyBottomMargin(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyBottomMargin,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::bottom-margin` signal for using the `connect(signal:)` methods
    static var notifyBottomMarginSignal: TextViewSignalName { .notifyBottomMargin }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::buffer` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBuffer` signal is emitted
    @discardableResult @inlinable func onNotifyBuffer(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyBuffer,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::buffer` signal for using the `connect(signal:)` methods
    static var notifyBufferSignal: TextViewSignalName { .notifyBuffer }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::cursor-visible` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCursorVisible` signal is emitted
    @discardableResult @inlinable func onNotifyCursorVisible(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyCursorVisible,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::cursor-visible` signal for using the `connect(signal:)` methods
    static var notifyCursorVisibleSignal: TextViewSignalName { .notifyCursorVisible }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::editable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditable` signal is emitted
    @discardableResult @inlinable func onNotifyEditable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEditable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::editable` signal for using the `connect(signal:)` methods
    static var notifyEditableSignal: TextViewSignalName { .notifyEditable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::im-module` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyImModule` signal is emitted
    @discardableResult @inlinable func onNotifyImModule(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyImModule,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::im-module` signal for using the `connect(signal:)` methods
    static var notifyImModuleSignal: TextViewSignalName { .notifyImModule }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::indent` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIndent` signal is emitted
    @discardableResult @inlinable func onNotifyIndent(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyIndent,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::indent` signal for using the `connect(signal:)` methods
    static var notifyIndentSignal: TextViewSignalName { .notifyIndent }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::input-hints` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInputHints` signal is emitted
    @discardableResult @inlinable func onNotifyInputHints(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyInputHints,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::input-hints` signal for using the `connect(signal:)` methods
    static var notifyInputHintsSignal: TextViewSignalName { .notifyInputHints }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::input-purpose` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInputPurpose` signal is emitted
    @discardableResult @inlinable func onNotifyInputPurpose(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyInputPurpose,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::input-purpose` signal for using the `connect(signal:)` methods
    static var notifyInputPurposeSignal: TextViewSignalName { .notifyInputPurpose }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::justification` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyJustification` signal is emitted
    @discardableResult @inlinable func onNotifyJustification(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyJustification,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::justification` signal for using the `connect(signal:)` methods
    static var notifyJustificationSignal: TextViewSignalName { .notifyJustification }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::left-margin` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLeftMargin` signal is emitted
    @discardableResult @inlinable func onNotifyLeftMargin(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLeftMargin,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::left-margin` signal for using the `connect(signal:)` methods
    static var notifyLeftMarginSignal: TextViewSignalName { .notifyLeftMargin }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::monospace` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMonospace` signal is emitted
    @discardableResult @inlinable func onNotifyMonospace(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMonospace,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::monospace` signal for using the `connect(signal:)` methods
    static var notifyMonospaceSignal: TextViewSignalName { .notifyMonospace }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::overwrite` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyOverwrite` signal is emitted
    @discardableResult @inlinable func onNotifyOverwrite(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyOverwrite,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::overwrite` signal for using the `connect(signal:)` methods
    static var notifyOverwriteSignal: TextViewSignalName { .notifyOverwrite }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::pixels-above-lines` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPixelsAboveLines` signal is emitted
    @discardableResult @inlinable func onNotifyPixelsAboveLines(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPixelsAboveLines,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::pixels-above-lines` signal for using the `connect(signal:)` methods
    static var notifyPixelsAboveLinesSignal: TextViewSignalName { .notifyPixelsAboveLines }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::pixels-below-lines` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPixelsBelowLines` signal is emitted
    @discardableResult @inlinable func onNotifyPixelsBelowLines(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPixelsBelowLines,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::pixels-below-lines` signal for using the `connect(signal:)` methods
    static var notifyPixelsBelowLinesSignal: TextViewSignalName { .notifyPixelsBelowLines }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::pixels-inside-wrap` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPixelsInsideWrap` signal is emitted
    @discardableResult @inlinable func onNotifyPixelsInsideWrap(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPixelsInsideWrap,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::pixels-inside-wrap` signal for using the `connect(signal:)` methods
    static var notifyPixelsInsideWrapSignal: TextViewSignalName { .notifyPixelsInsideWrap }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::populate-all` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPopulateAll` signal is emitted
    @discardableResult @inlinable func onNotifyPopulateAll(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPopulateAll,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::populate-all` signal for using the `connect(signal:)` methods
    static var notifyPopulateAllSignal: TextViewSignalName { .notifyPopulateAll }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::right-margin` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRightMargin` signal is emitted
    @discardableResult @inlinable func onNotifyRightMargin(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyRightMargin,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::right-margin` signal for using the `connect(signal:)` methods
    static var notifyRightMarginSignal: TextViewSignalName { .notifyRightMargin }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::tabs` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTabs` signal is emitted
    @discardableResult @inlinable func onNotifyTabs(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyTabs,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::tabs` signal for using the `connect(signal:)` methods
    static var notifyTabsSignal: TextViewSignalName { .notifyTabs }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::top-margin` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTopMargin` signal is emitted
    @discardableResult @inlinable func onNotifyTopMargin(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyTopMargin,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::top-margin` signal for using the `connect(signal:)` methods
    static var notifyTopMarginSignal: TextViewSignalName { .notifyTopMargin }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::wrap-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWrapMode` signal is emitted
    @discardableResult @inlinable func onNotifyWrapMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TextViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TextViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TextViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWrapMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::wrap-mode` signal for using the `connect(signal:)` methods
    static var notifyWrapModeSignal: TextViewSignalName { .notifyWrapMode }
    
}

// MARK: TextView Class: TextViewProtocol extension (methods and fields)
public extension TextViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextView` instance.
    @inlinable var text_view_ptr: UnsafeMutablePointer<GtkTextView>! { return ptr?.assumingMemoryBound(to: GtkTextView.self) }

    /// Adds a child widget in the text buffer, at the given `anchor`.
    @inlinable func addChildAtAnchor<TextChildAnchorT: TextChildAnchorProtocol, WidgetT: WidgetProtocol>(child: WidgetT, anchor: TextChildAnchorT) {
        gtk_text_view_add_child_at_anchor(text_view_ptr, child.widget_ptr, anchor.text_child_anchor_ptr)
    
    }

    /// Adds a child at fixed coordinates in one of the text widget's
    /// windows.
    /// 
    /// The window must have nonzero size (see
    /// `gtk_text_view_set_border_window_size()`). Note that the child
    /// coordinates are given relative to scrolling. When
    /// placing a child in `GTK_TEXT_WINDOW_WIDGET`, scrolling is
    /// irrelevant, the child floats above all scrollable areas. But when
    /// placing a child in one of the scrollable windows (border windows or
    /// text window) it will move with the scrolling as needed.
    @inlinable func addChildInWindow<WidgetT: WidgetProtocol>(child: WidgetT, whichWindow: GtkTextWindowType, xpos: Int, ypos: Int) {
        gtk_text_view_add_child_in_window(text_view_ptr, child.widget_ptr, whichWindow, gint(xpos), gint(ypos))
    
    }

    /// Moves the given `iter` backward by one display (wrapped) line.
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `GtkTextBuffer`.
    @inlinable func backwardDisplayLine<TextIterT: TextIterProtocol>(iter: TextIterT) -> Bool {
        let rv = ((gtk_text_view_backward_display_line(text_view_ptr, iter.text_iter_ptr)) != 0)
        return rv
    }

    /// Moves the given `iter` backward to the next display line start.
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `GtkTextBuffer`.
    @inlinable func backwardDisplayLineStart<TextIterT: TextIterProtocol>(iter: TextIterT) -> Bool {
        let rv = ((gtk_text_view_backward_display_line_start(text_view_ptr, iter.text_iter_ptr)) != 0)
        return rv
    }

    /// Converts coordinate (`buffer_x`, `buffer_y`) to coordinates for the window
    /// `win`, and stores the result in (`window_x`, `window_y`).
    /// 
    /// Note that you can’t convert coordinates for a nonexisting window (see
    /// `gtk_text_view_set_border_window_size()`).
    @inlinable func bufferToWindowCoords(win: GtkTextWindowType, bufferX: Int, bufferY: Int, windowX: UnsafeMutablePointer<gint>! = nil, windowY: UnsafeMutablePointer<gint>! = nil) {
        gtk_text_view_buffer_to_window_coords(text_view_ptr, win, gint(bufferX), gint(bufferY), windowX, windowY)
    
    }

    /// Moves the given `iter` forward by one display (wrapped) line.
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `GtkTextBuffer`.
    @inlinable func forwardDisplayLine<TextIterT: TextIterProtocol>(iter: TextIterT) -> Bool {
        let rv = ((gtk_text_view_forward_display_line(text_view_ptr, iter.text_iter_ptr)) != 0)
        return rv
    }

    /// Moves the given `iter` forward to the next display line end.
    /// A display line is different from a paragraph. Paragraphs are
    /// separated by newlines or other paragraph separator characters.
    /// Display lines are created by line-wrapping a paragraph. If
    /// wrapping is turned off, display lines and paragraphs will be the
    /// same. Display lines are divided differently for each view, since
    /// they depend on the view’s width; paragraphs are the same in all
    /// views, since they depend on the contents of the `GtkTextBuffer`.
    @inlinable func forwardDisplayLineEnd<TextIterT: TextIterProtocol>(iter: TextIterT) -> Bool {
        let rv = ((gtk_text_view_forward_display_line_end(text_view_ptr, iter.text_iter_ptr)) != 0)
        return rv
    }

    /// Returns whether pressing the Tab key inserts a tab characters.
    /// `gtk_text_view_set_accepts_tab()`.
    @inlinable func getAcceptsTab() -> Bool {
        let rv = ((gtk_text_view_get_accepts_tab(text_view_ptr)) != 0)
        return rv
    }

    /// Gets the width of the specified border window. See
    /// `gtk_text_view_set_border_window_size()`.
    @inlinable func getBorderWindowSize(type: GtkTextWindowType) -> Int {
        let rv = Int(gtk_text_view_get_border_window_size(text_view_ptr, type))
        return rv
    }

    /// Gets the bottom margin for text in the `text_view`.
    @inlinable func getBottomMargin() -> Int {
        let rv = Int(gtk_text_view_get_bottom_margin(text_view_ptr))
        return rv
    }

    /// Returns the `GtkTextBuffer` being displayed by this text view.
    /// The reference count on the buffer is not incremented; the caller
    /// of this function won’t own a new reference.
    @inlinable func getBuffer() -> TextBufferRef! {
        let rv = TextBufferRef(gconstpointer: gconstpointer(gtk_text_view_get_buffer(text_view_ptr)))
        return rv
    }

    /// Given an `iter` within a text layout, determine the positions of the
    /// strong and weak cursors if the insertion point is at that
    /// iterator. The position of each cursor is stored as a zero-width
    /// rectangle. The strong cursor location is the location where
    /// characters of the directionality equal to the base direction of the
    /// paragraph are inserted.  The weak cursor location is the location
    /// where characters of the directionality opposite to the base
    /// direction of the paragraph are inserted.
    /// 
    /// If `iter` is `nil`, the actual cursor position is used.
    /// 
    /// Note that if `iter` happens to be the actual cursor position, and
    /// there is currently an IM preedit sequence being entered, the
    /// returned locations will be adjusted to account for the preedit
    /// cursor’s offset within the preedit sequence.
    /// 
    /// The rectangle position is in buffer coordinates; use
    /// `gtk_text_view_buffer_to_window_coords()` to convert these
    /// coordinates to coordinates for one of the windows in the text view.
    @inlinable func getCursorLocations(iter: TextIterRef? = nil, strong: Gdk.RectangleRef? = nil, `weak`: Gdk.RectangleRef? = nil) {
        gtk_text_view_get_cursor_locations(text_view_ptr, iter?.text_iter_ptr, strong?.rectangle_ptr, `weak`?.rectangle_ptr)
    
    }
    /// Given an `iter` within a text layout, determine the positions of the
    /// strong and weak cursors if the insertion point is at that
    /// iterator. The position of each cursor is stored as a zero-width
    /// rectangle. The strong cursor location is the location where
    /// characters of the directionality equal to the base direction of the
    /// paragraph are inserted.  The weak cursor location is the location
    /// where characters of the directionality opposite to the base
    /// direction of the paragraph are inserted.
    /// 
    /// If `iter` is `nil`, the actual cursor position is used.
    /// 
    /// Note that if `iter` happens to be the actual cursor position, and
    /// there is currently an IM preedit sequence being entered, the
    /// returned locations will be adjusted to account for the preedit
    /// cursor’s offset within the preedit sequence.
    /// 
    /// The rectangle position is in buffer coordinates; use
    /// `gtk_text_view_buffer_to_window_coords()` to convert these
    /// coordinates to coordinates for one of the windows in the text view.
    @inlinable func getCursorLocations<RectangleT: Gdk.RectangleProtocol, TextIterT: TextIterProtocol>(iter: TextIterT?, strong: RectangleT?, `weak`: RectangleT?) {
        gtk_text_view_get_cursor_locations(text_view_ptr, iter?.text_iter_ptr, strong?.rectangle_ptr, `weak`?.rectangle_ptr)
    
    }

    /// Find out whether the cursor should be displayed.
    @inlinable func getCursorVisible() -> Bool {
        let rv = ((gtk_text_view_get_cursor_visible(text_view_ptr)) != 0)
        return rv
    }

    /// Obtains a copy of the default text attributes. These are the
    /// attributes used for text unless a tag overrides them.
    /// You’d typically pass the default attributes in to
    /// `gtk_text_iter_get_attributes()` in order to get the
    /// attributes in effect at a given text position.
    /// 
    /// The return value is a copy owned by the caller of this function,
    /// and should be freed with `gtk_text_attributes_unref()`.
    @inlinable func getDefaultAttributes() -> TextAttributesRef! {
        let rv = TextAttributesRef(gconstpointer: gconstpointer(gtk_text_view_get_default_attributes(text_view_ptr)))
        return rv
    }

    /// Returns the default editability of the `GtkTextView`. Tags in the
    /// buffer may override this setting for some ranges of text.
    @inlinable func getEditable() -> Bool {
        let rv = ((gtk_text_view_get_editable(text_view_ptr)) != 0)
        return rv
    }

    /// Gets the horizontal-scrolling `GtkAdjustment`.
    ///
    /// **get_hadjustment is deprecated:**
    /// Use gtk_scrollable_get_hadjustment()
    @available(*, deprecated)
    @inlinable func getHadjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_text_view_get_hadjustment(text_view_ptr)))
        return rv
    }

    /// Gets the default indentation of paragraphs in `text_view`.
    /// Tags in the view’s buffer may override the default.
    /// The indentation may be negative.
    @inlinable func getIndent() -> Int {
        let rv = Int(gtk_text_view_get_indent(text_view_ptr))
        return rv
    }

    /// Gets the value of the `GtkTextView:input-hints` property.
    @inlinable func getInputHints() -> InputHints {
        let rv = InputHints(gtk_text_view_get_input_hints(text_view_ptr))
        return rv
    }

    /// Gets the value of the `GtkTextView:input-purpose` property.
    @inlinable func getInputPurpose() -> GtkInputPurpose {
        let rv = gtk_text_view_get_input_purpose(text_view_ptr)
        return rv
    }

    /// Retrieves the iterator at buffer coordinates `x` and `y`. Buffer
    /// coordinates are coordinates for the entire buffer, not just the
    /// currently-displayed portion.  If you have coordinates from an
    /// event, you have to convert those to buffer coordinates with
    /// `gtk_text_view_window_to_buffer_coords()`.
    @inlinable func getIterAtLocation<TextIterT: TextIterProtocol>(iter: TextIterT, x: Int, y: Int) -> Bool {
        let rv = ((gtk_text_view_get_iter_at_location(text_view_ptr, iter.text_iter_ptr, gint(x), gint(y))) != 0)
        return rv
    }

    /// Retrieves the iterator pointing to the character at buffer
    /// coordinates `x` and `y`. Buffer coordinates are coordinates for
    /// the entire buffer, not just the currently-displayed portion.
    /// If you have coordinates from an event, you have to convert
    /// those to buffer coordinates with
    /// `gtk_text_view_window_to_buffer_coords()`.
    /// 
    /// Note that this is different from `gtk_text_view_get_iter_at_location()`,
    /// which returns cursor locations, i.e. positions between
    /// characters.
    @inlinable func getIterAtPosition<TextIterT: TextIterProtocol>(iter: TextIterT, trailing: UnsafeMutablePointer<gint>! = nil, x: Int, y: Int) -> Bool {
        let rv = ((gtk_text_view_get_iter_at_position(text_view_ptr, iter.text_iter_ptr, trailing, gint(x), gint(y))) != 0)
        return rv
    }

    /// Gets a rectangle which roughly contains the character at `iter`.
    /// The rectangle position is in buffer coordinates; use
    /// `gtk_text_view_buffer_to_window_coords()` to convert these
    /// coordinates to coordinates for one of the windows in the text view.
    @inlinable func getIterLocation<RectangleT: Gdk.RectangleProtocol, TextIterT: TextIterProtocol>(iter: TextIterT, location: RectangleT) {
        gtk_text_view_get_iter_location(text_view_ptr, iter.text_iter_ptr, location.rectangle_ptr)
    
    }

    /// Gets the default justification of paragraphs in `text_view`.
    /// Tags in the buffer may override the default.
    @inlinable func getJustification() -> GtkJustification {
        let rv = gtk_text_view_get_justification(text_view_ptr)
        return rv
    }

    /// Gets the default left margin size of paragraphs in the `text_view`.
    /// Tags in the buffer may override the default.
    @inlinable func getLeftMargin() -> Int {
        let rv = Int(gtk_text_view_get_left_margin(text_view_ptr))
        return rv
    }

    /// Gets the `GtkTextIter` at the start of the line containing
    /// the coordinate `y`. `y` is in buffer coordinates, convert from
    /// window coordinates with `gtk_text_view_window_to_buffer_coords()`.
    /// If non-`nil`, `line_top` will be filled with the coordinate of the top
    /// edge of the line.
    @inlinable func getLineAtY<TextIterT: TextIterProtocol>(targetIter: TextIterT, y: Int, lineTop: UnsafeMutablePointer<gint>!) {
        gtk_text_view_get_line_at_y(text_view_ptr, targetIter.text_iter_ptr, gint(y), lineTop)
    
    }

    /// Gets the y coordinate of the top of the line containing `iter`,
    /// and the height of the line. The coordinate is a buffer coordinate;
    /// convert to window coordinates with `gtk_text_view_buffer_to_window_coords()`.
    @inlinable func getLineYrange<TextIterT: TextIterProtocol>(iter: TextIterT, y: UnsafeMutablePointer<gint>!, height: UnsafeMutablePointer<gint>!) {
        gtk_text_view_get_line_yrange(text_view_ptr, iter.text_iter_ptr, y, height)
    
    }

    /// Gets the value of the `GtkTextView:monospace` property.
    @inlinable func getMonospace() -> Bool {
        let rv = ((gtk_text_view_get_monospace(text_view_ptr)) != 0)
        return rv
    }

    /// Returns whether the `GtkTextView` is in overwrite mode or not.
    @inlinable func getOverwrite() -> Bool {
        let rv = ((gtk_text_view_get_overwrite(text_view_ptr)) != 0)
        return rv
    }

    /// Gets the default number of pixels to put above paragraphs.
    /// Adding this function with `gtk_text_view_get_pixels_below_lines()`
    /// is equal to the line space between each paragraph.
    @inlinable func getPixelsAboveLines() -> Int {
        let rv = Int(gtk_text_view_get_pixels_above_lines(text_view_ptr))
        return rv
    }

    /// Gets the value set by `gtk_text_view_set_pixels_below_lines()`.
    /// 
    /// The line space is the sum of the value returned by this function and the
    /// value returned by `gtk_text_view_get_pixels_above_lines()`.
    @inlinable func getPixelsBelowLines() -> Int {
        let rv = Int(gtk_text_view_get_pixels_below_lines(text_view_ptr))
        return rv
    }

    /// Gets the value set by `gtk_text_view_set_pixels_inside_wrap()`.
    @inlinable func getPixelsInsideWrap() -> Int {
        let rv = Int(gtk_text_view_get_pixels_inside_wrap(text_view_ptr))
        return rv
    }

    /// Gets the default right margin for text in `text_view`. Tags
    /// in the buffer may override the default.
    @inlinable func getRightMargin() -> Int {
        let rv = Int(gtk_text_view_get_right_margin(text_view_ptr))
        return rv
    }

    /// Gets the default tabs for `text_view`. Tags in the buffer may
    /// override the defaults. The returned array will be `nil` if
    /// “standard” (8-space) tabs are used. Free the return value
    /// with `pango_tab_array_free()`.
    @inlinable func getTabs() -> Pango.TabArrayRef! {
        let rv = Pango.TabArrayRef(gtk_text_view_get_tabs(text_view_ptr))
        return rv
    }

    /// Gets the top margin for text in the `text_view`.
    @inlinable func getTopMargin() -> Int {
        let rv = Int(gtk_text_view_get_top_margin(text_view_ptr))
        return rv
    }

    /// Gets the vertical-scrolling `GtkAdjustment`.
    ///
    /// **get_vadjustment is deprecated:**
    /// Use gtk_scrollable_get_vadjustment()
    @available(*, deprecated)
    @inlinable func getVadjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_text_view_get_vadjustment(text_view_ptr)))
        return rv
    }

    /// Fills `visible_rect` with the currently-visible
    /// region of the buffer, in buffer coordinates. Convert to window coordinates
    /// with `gtk_text_view_buffer_to_window_coords()`.
    @inlinable func get<RectangleT: Gdk.RectangleProtocol>(visibleRect: RectangleT) {
        gtk_text_view_get_visible_rect(text_view_ptr, visibleRect.rectangle_ptr)
    
    }

    /// Retrieves the `GdkWindow` corresponding to an area of the text view;
    /// possible windows include the overall widget window, child windows
    /// on the left, right, top, bottom, and the window that displays the
    /// text buffer. Windows are `nil` and nonexistent if their width or
    /// height is 0, and are nonexistent before the widget has been
    /// realized.
    @inlinable func getWindow(win: GtkTextWindowType) -> Gdk.WindowRef! {
        let rv = Gdk.WindowRef(gtk_text_view_get_window(text_view_ptr, win))
        return rv
    }

    /// Usually used to find out which window an event corresponds to.
    /// 
    /// If you connect to an event signal on `text_view`, this function
    /// should be called on `event-&gt;window` to see which window it was.
    @inlinable func getWindowType<WindowT: Gdk.WindowProtocol>(window: WindowT) -> GtkTextWindowType {
        let rv = gtk_text_view_get_window_type(text_view_ptr, window.window_ptr)
        return rv
    }

    /// Gets the line wrapping for the view.
    @inlinable func getWrapMode() -> GtkWrapMode {
        let rv = gtk_text_view_get_wrap_mode(text_view_ptr)
        return rv
    }

    /// Allow the `GtkTextView` input method to internally handle key press
    /// and release events. If this function returns `true`, then no further
    /// processing should be done for this key event. See
    /// `gtk_im_context_filter_keypress()`.
    /// 
    /// Note that you are expected to call this function from your handler
    /// when overriding key event handling. This is needed in the case when
    /// you need to insert your own key handling between the input method
    /// and the default key event handling of the `GtkTextView`.
    /// 
    /// (C Language Example):
    /// ```C
    /// static gboolean
    /// gtk_foo_bar_key_press_event (GtkWidget   *widget,
    ///                              GdkEventKey *event)
    /// {
    ///   guint keyval;
    /// 
    ///   gdk_event_get_keyval ((GdkEvent*)event, &keyval);
    /// 
    ///   if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
    ///     {
    ///       if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
    ///         return TRUE;
    ///     }
    /// 
    ///   // Do some stuff
    /// 
    ///   return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
    /// }
    /// ```
    /// 
    @inlinable func imContextFilterKeypress<EventKeyT: Gdk.EventKeyProtocol>(event: EventKeyT) -> Bool {
        let rv = ((gtk_text_view_im_context_filter_keypress(text_view_ptr, event._ptr)) != 0)
        return rv
    }

    /// Updates the position of a child, as for `gtk_text_view_add_child_in_window()`.
    @inlinable func move<WidgetT: WidgetProtocol>(child: WidgetT, xpos: Int, ypos: Int) {
        gtk_text_view_move_child(text_view_ptr, child.widget_ptr, gint(xpos), gint(ypos))
    
    }

    /// Moves a mark within the buffer so that it's
    /// located within the currently-visible text area.
    @inlinable func moveMarkOnscreen<TextMarkT: TextMarkProtocol>(mark: TextMarkT) -> Bool {
        let rv = ((gtk_text_view_move_mark_onscreen(text_view_ptr, mark.text_mark_ptr)) != 0)
        return rv
    }

    /// Move the iterator a given number of characters visually, treating
    /// it as the strong cursor position. If `count` is positive, then the
    /// new strong cursor position will be `count` positions to the right of
    /// the old cursor position. If `count` is negative then the new strong
    /// cursor position will be `count` positions to the left of the old
    /// cursor position.
    /// 
    /// In the presence of bi-directional text, the correspondence
    /// between logical and visual order will depend on the direction
    /// of the current run, and there may be jumps when the cursor
    /// is moved off of the end of a run.
    @inlinable func moveVisually<TextIterT: TextIterProtocol>(iter: TextIterT, count: Int) -> Bool {
        let rv = ((gtk_text_view_move_visually(text_view_ptr, iter.text_iter_ptr, gint(count))) != 0)
        return rv
    }

    /// Moves the cursor to the currently visible region of the
    /// buffer, it it isn’t there already.
    @inlinable func placeCursorOnscreen() -> Bool {
        let rv = ((gtk_text_view_place_cursor_onscreen(text_view_ptr)) != 0)
        return rv
    }

    /// Ensures that the cursor is shown (i.e. not in an 'off' blink
    /// interval) and resets the time that it will stay blinking (or
    /// visible, in case blinking is disabled).
    /// 
    /// This function should be called in response to user input
    /// (e.g. from derived classes that override the textview's
    /// `GtkWidget::key-press-event` handler).
    @inlinable func resetCursorBlink() {
        gtk_text_view_reset_cursor_blink(text_view_ptr)
    
    }

    /// Reset the input method context of the text view if needed.
    /// 
    /// This can be necessary in the case where modifying the buffer
    /// would confuse on-going input method behavior.
    @inlinable func resetImContext() {
        gtk_text_view_reset_im_context(text_view_ptr)
    
    }

    /// Scrolls `text_view` the minimum distance such that `mark` is contained
    /// within the visible area of the widget.
    @inlinable func scrollMarkOnscreen<TextMarkT: TextMarkProtocol>(mark: TextMarkT) {
        gtk_text_view_scroll_mark_onscreen(text_view_ptr, mark.text_mark_ptr)
    
    }

    /// Scrolls `text_view` so that `iter` is on the screen in the position
    /// indicated by `xalign` and `yalign`. An alignment of 0.0 indicates
    /// left or top, 1.0 indicates right or bottom, 0.5 means center.
    /// If `use_align` is `false`, the text scrolls the minimal distance to
    /// get the mark onscreen, possibly not scrolling at all. The effective
    /// screen for purposes of this function is reduced by a margin of size
    /// `within_margin`.
    /// 
    /// Note that this function uses the currently-computed height of the
    /// lines in the text buffer. Line heights are computed in an idle
    /// handler; so this function may not have the desired effect if it’s
    /// called before the height computations. To avoid oddness, consider
    /// using `gtk_text_view_scroll_to_mark()` which saves a point to be
    /// scrolled to after line validation.
    @inlinable func scrollTo<TextIterT: TextIterProtocol>(iter: TextIterT, within margin: Double, useAlign: Bool, xalign: Double, yalign: Double) -> Bool {
        let rv = ((gtk_text_view_scroll_to_iter(text_view_ptr, iter.text_iter_ptr, gdouble(margin), gboolean((useAlign) ? 1 : 0), gdouble(xalign), gdouble(yalign))) != 0)
        return rv
    }

    /// Scrolls `text_view` so that `mark` is on the screen in the position
    /// indicated by `xalign` and `yalign`. An alignment of 0.0 indicates
    /// left or top, 1.0 indicates right or bottom, 0.5 means center.
    /// If `use_align` is `false`, the text scrolls the minimal distance to
    /// get the mark onscreen, possibly not scrolling at all. The effective
    /// screen for purposes of this function is reduced by a margin of size
    /// `within_margin`.
    @inlinable func scrollTo<TextMarkT: TextMarkProtocol>(mark: TextMarkT, within margin: Double, useAlign: Bool, xalign: Double, yalign: Double) {
        gtk_text_view_scroll_to_mark(text_view_ptr, mark.text_mark_ptr, gdouble(margin), gboolean((useAlign) ? 1 : 0), gdouble(xalign), gdouble(yalign))
    
    }

    /// Sets the behavior of the text widget when the Tab key is pressed.
    /// If `accepts_tab` is `true`, a tab character is inserted. If `accepts_tab`
    /// is `false` the keyboard focus is moved to the next widget in the focus
    /// chain.
    @inlinable func set(acceptsTab: Bool) {
        gtk_text_view_set_accepts_tab(text_view_ptr, gboolean((acceptsTab) ? 1 : 0))
    
    }

    /// Sets the width of `GTK_TEXT_WINDOW_LEFT` or `GTK_TEXT_WINDOW_RIGHT`,
    /// or the height of `GTK_TEXT_WINDOW_TOP` or `GTK_TEXT_WINDOW_BOTTOM`.
    /// Automatically destroys the corresponding window if the size is set
    /// to 0, and creates the window if the size is set to non-zero.  This
    /// function can only be used for the “border windows”, and it won’t
    /// work with `GTK_TEXT_WINDOW_WIDGET`, `GTK_TEXT_WINDOW_TEXT`, or
    /// `GTK_TEXT_WINDOW_PRIVATE`.
    @inlinable func setBorderWindowSize(type: GtkTextWindowType, size: Int) {
        gtk_text_view_set_border_window_size(text_view_ptr, type, gint(size))
    
    }

    /// Sets the bottom margin for text in `text_view`.
    /// 
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    @inlinable func set(bottomMargin: Int) {
        gtk_text_view_set_bottom_margin(text_view_ptr, gint(bottomMargin))
    
    }

    /// Sets `buffer` as the buffer being displayed by `text_view`. The previous
    /// buffer displayed by the text view is unreferenced, and a reference is
    /// added to `buffer`. If you owned a reference to `buffer` before passing it
    /// to this function, you must remove that reference yourself; `GtkTextView`
    /// will not “adopt” it.
    @inlinable func set(buffer: TextBufferRef? = nil) {
        gtk_text_view_set_buffer(text_view_ptr, buffer?.text_buffer_ptr)
    
    }
    /// Sets `buffer` as the buffer being displayed by `text_view`. The previous
    /// buffer displayed by the text view is unreferenced, and a reference is
    /// added to `buffer`. If you owned a reference to `buffer` before passing it
    /// to this function, you must remove that reference yourself; `GtkTextView`
    /// will not “adopt” it.
    @inlinable func set<TextBufferT: TextBufferProtocol>(buffer: TextBufferT?) {
        gtk_text_view_set_buffer(text_view_ptr, buffer?.text_buffer_ptr)
    
    }

    /// Toggles whether the insertion point should be displayed. A buffer with
    /// no editable text probably shouldn’t have a visible cursor, so you may
    /// want to turn the cursor off.
    /// 
    /// Note that this property may be overridden by the
    /// `GtkSettings:gtk-keynave-use-caret` settings.
    @inlinable func setCursorVisible(setting: Bool) {
        gtk_text_view_set_cursor_visible(text_view_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Sets the default editability of the `GtkTextView`. You can override
    /// this default setting with tags in the buffer, using the “editable”
    /// attribute of tags.
    @inlinable func setEditable(setting: Bool) {
        gtk_text_view_set_editable(text_view_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Sets the default indentation for paragraphs in `text_view`.
    /// Tags in the buffer may override the default.
    @inlinable func set(indent: Int) {
        gtk_text_view_set_indent(text_view_ptr, gint(indent))
    
    }

    /// Sets the `GtkTextView:input-hints` property, which
    /// allows input methods to fine-tune their behaviour.
    @inlinable func setInput(hints: InputHints) {
        gtk_text_view_set_input_hints(text_view_ptr, hints.value)
    
    }

    /// Sets the `GtkTextView:input-purpose` property which
    /// can be used by on-screen keyboards and other input
    /// methods to adjust their behaviour.
    @inlinable func setInput(purpose: GtkInputPurpose) {
        gtk_text_view_set_input_purpose(text_view_ptr, purpose)
    
    }

    /// Sets the default justification of text in `text_view`.
    /// Tags in the view’s buffer may override the default.
    @inlinable func set(justification: GtkJustification) {
        gtk_text_view_set_justification(text_view_ptr, justification)
    
    }

    /// Sets the default left margin for text in `text_view`.
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    @inlinable func set(leftMargin: Int) {
        gtk_text_view_set_left_margin(text_view_ptr, gint(leftMargin))
    
    }

    /// Sets the `GtkTextView:monospace` property, which
    /// indicates that the text view should use monospace
    /// fonts.
    @inlinable func set(monospace: Bool) {
        gtk_text_view_set_monospace(text_view_ptr, gboolean((monospace) ? 1 : 0))
    
    }

    /// Changes the `GtkTextView` overwrite mode.
    @inlinable func set(overwrite: Bool) {
        gtk_text_view_set_overwrite(text_view_ptr, gboolean((overwrite) ? 1 : 0))
    
    }

    /// Sets the default number of blank pixels above paragraphs in `text_view`.
    /// Tags in the buffer for `text_view` may override the defaults.
    @inlinable func set(pixelsAboveLines: Int) {
        gtk_text_view_set_pixels_above_lines(text_view_ptr, gint(pixelsAboveLines))
    
    }

    /// Sets the default number of pixels of blank space
    /// to put below paragraphs in `text_view`. May be overridden
    /// by tags applied to `text_view`’s buffer.
    @inlinable func set(pixelsBelowLines: Int) {
        gtk_text_view_set_pixels_below_lines(text_view_ptr, gint(pixelsBelowLines))
    
    }

    /// Sets the default number of pixels of blank space to leave between
    /// display/wrapped lines within a paragraph. May be overridden by
    /// tags in `text_view`’s buffer.
    @inlinable func set(pixelsInsideWrap: Int) {
        gtk_text_view_set_pixels_inside_wrap(text_view_ptr, gint(pixelsInsideWrap))
    
    }

    /// Sets the default right margin for text in the text view.
    /// Tags in the buffer may override the default.
    /// 
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    @inlinable func set(rightMargin: Int) {
        gtk_text_view_set_right_margin(text_view_ptr, gint(rightMargin))
    
    }

    /// Sets the default tab stops for paragraphs in `text_view`.
    /// Tags in the buffer may override the default.
    @inlinable func set<TabArrayT: Pango.TabArrayProtocol>(tabs: TabArrayT) {
        gtk_text_view_set_tabs(text_view_ptr, tabs.tab_array_ptr)
    
    }

    /// Sets the top margin for text in `text_view`.
    /// 
    /// Note that this function is confusingly named.
    /// In CSS terms, the value set here is padding.
    @inlinable func set(topMargin: Int) {
        gtk_text_view_set_top_margin(text_view_ptr, gint(topMargin))
    
    }

    /// Sets the line wrapping for the view.
    @inlinable func set(wrapMode: GtkWrapMode) {
        gtk_text_view_set_wrap_mode(text_view_ptr, wrapMode)
    
    }

    /// Determines whether `iter` is at the start of a display line.
    /// See `gtk_text_view_forward_display_line()` for an explanation of
    /// display lines vs. paragraphs.
    @inlinable func startsDisplayLine<TextIterT: TextIterProtocol>(iter: TextIterT) -> Bool {
        let rv = ((gtk_text_view_starts_display_line(text_view_ptr, iter.text_iter_ptr)) != 0)
        return rv
    }

    /// Converts coordinates on the window identified by `win` to buffer
    /// coordinates, storing the result in (`buffer_x`,`buffer_y`).
    /// 
    /// Note that you can’t convert coordinates for a nonexisting window (see
    /// `gtk_text_view_set_border_window_size()`).
    @inlinable func windowToBufferCoords(win: GtkTextWindowType, windowX: Int, windowY: Int, bufferX: UnsafeMutablePointer<gint>! = nil, bufferY: UnsafeMutablePointer<gint>! = nil) {
        gtk_text_view_window_to_buffer_coords(text_view_ptr, win, gint(windowX), gint(windowY), bufferX, bufferY)
    
    }
    /// Returns whether pressing the Tab key inserts a tab characters.
    /// `gtk_text_view_set_accepts_tab()`.
    @inlinable var acceptsTab: Bool {
        /// Returns whether pressing the Tab key inserts a tab characters.
        /// `gtk_text_view_set_accepts_tab()`.
        get {
            let rv = ((gtk_text_view_get_accepts_tab(text_view_ptr)) != 0)
            return rv
        }
        /// Sets the behavior of the text widget when the Tab key is pressed.
        /// If `accepts_tab` is `true`, a tab character is inserted. If `accepts_tab`
        /// is `false` the keyboard focus is moved to the next widget in the focus
        /// chain.
        nonmutating set {
            gtk_text_view_set_accepts_tab(text_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the bottom margin for text in the `text_view`.
    @inlinable var bottomMargin: Int {
        /// Gets the bottom margin for text in the `text_view`.
        get {
            let rv = Int(gtk_text_view_get_bottom_margin(text_view_ptr))
            return rv
        }
        /// Sets the bottom margin for text in `text_view`.
        /// 
        /// Note that this function is confusingly named.
        /// In CSS terms, the value set here is padding.
        nonmutating set {
            gtk_text_view_set_bottom_margin(text_view_ptr, gint(newValue))
        }
    }

    @inlinable var buffer: TextBufferRef! {
        /// Returns the `GtkTextBuffer` being displayed by this text view.
        /// The reference count on the buffer is not incremented; the caller
        /// of this function won’t own a new reference.
        get {
            let rv = TextBufferRef(gconstpointer: gconstpointer(gtk_text_view_get_buffer(text_view_ptr)))
            return rv
        }
        /// Sets `buffer` as the buffer being displayed by `text_view`. The previous
        /// buffer displayed by the text view is unreferenced, and a reference is
        /// added to `buffer`. If you owned a reference to `buffer` before passing it
        /// to this function, you must remove that reference yourself; `GtkTextView`
        /// will not “adopt” it.
        nonmutating set {
            gtk_text_view_set_buffer(text_view_ptr, UnsafeMutablePointer<GtkTextBuffer>(newValue?.text_buffer_ptr))
        }
    }

    /// Find out whether the cursor should be displayed.
    @inlinable var cursorVisible: Bool {
        /// Find out whether the cursor should be displayed.
        get {
            let rv = ((gtk_text_view_get_cursor_visible(text_view_ptr)) != 0)
            return rv
        }
        /// Toggles whether the insertion point should be displayed. A buffer with
        /// no editable text probably shouldn’t have a visible cursor, so you may
        /// want to turn the cursor off.
        /// 
        /// Note that this property may be overridden by the
        /// `GtkSettings:gtk-keynave-use-caret` settings.
        nonmutating set {
            gtk_text_view_set_cursor_visible(text_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Obtains a copy of the default text attributes. These are the
    /// attributes used for text unless a tag overrides them.
    /// You’d typically pass the default attributes in to
    /// `gtk_text_iter_get_attributes()` in order to get the
    /// attributes in effect at a given text position.
    /// 
    /// The return value is a copy owned by the caller of this function,
    /// and should be freed with `gtk_text_attributes_unref()`.
    @inlinable var defaultAttributes: TextAttributesRef! {
        /// Obtains a copy of the default text attributes. These are the
        /// attributes used for text unless a tag overrides them.
        /// You’d typically pass the default attributes in to
        /// `gtk_text_iter_get_attributes()` in order to get the
        /// attributes in effect at a given text position.
        /// 
        /// The return value is a copy owned by the caller of this function,
        /// and should be freed with `gtk_text_attributes_unref()`.
        get {
            let rv = TextAttributesRef(gconstpointer: gconstpointer(gtk_text_view_get_default_attributes(text_view_ptr)))
            return rv
        }
    }

    @inlinable var editable: Bool {
        /// Returns the default editability of the `GtkTextView`. Tags in the
        /// buffer may override this setting for some ranges of text.
        get {
            let rv = ((gtk_text_view_get_editable(text_view_ptr)) != 0)
            return rv
        }
        /// Sets the default editability of the `GtkTextView`. You can override
        /// this default setting with tags in the buffer, using the “editable”
        /// attribute of tags.
        nonmutating set {
            gtk_text_view_set_editable(text_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the horizontal-scrolling `GtkAdjustment`.
    ///
    /// **get_hadjustment is deprecated:**
    /// Use gtk_scrollable_get_hadjustment()
    @inlinable var hadjustment: AdjustmentRef! {
        /// Gets the horizontal-scrolling `GtkAdjustment`.
        ///
        /// **get_hadjustment is deprecated:**
        /// Use gtk_scrollable_get_hadjustment()
        @available(*, deprecated)
    get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_text_view_get_hadjustment(text_view_ptr)))
            return rv
        }
    }

    @inlinable var indent: Int {
        /// Gets the default indentation of paragraphs in `text_view`.
        /// Tags in the view’s buffer may override the default.
        /// The indentation may be negative.
        get {
            let rv = Int(gtk_text_view_get_indent(text_view_ptr))
            return rv
        }
        /// Sets the default indentation for paragraphs in `text_view`.
        /// Tags in the buffer may override the default.
        nonmutating set {
            gtk_text_view_set_indent(text_view_ptr, gint(newValue))
        }
    }

    /// Gets the value of the `GtkTextView:input-hints` property.
    @inlinable var inputHints: InputHints {
        /// Gets the value of the `GtkTextView:input-hints` property.
        get {
            let rv = InputHints(gtk_text_view_get_input_hints(text_view_ptr))
            return rv
        }
        /// Sets the `GtkTextView:input-hints` property, which
        /// allows input methods to fine-tune their behaviour.
        nonmutating set {
            gtk_text_view_set_input_hints(text_view_ptr, newValue.value)
        }
    }

    /// Gets the value of the `GtkTextView:input-purpose` property.
    @inlinable var inputPurpose: GtkInputPurpose {
        /// Gets the value of the `GtkTextView:input-purpose` property.
        get {
            let rv = gtk_text_view_get_input_purpose(text_view_ptr)
            return rv
        }
        /// Sets the `GtkTextView:input-purpose` property which
        /// can be used by on-screen keyboards and other input
        /// methods to adjust their behaviour.
        nonmutating set {
            gtk_text_view_set_input_purpose(text_view_ptr, newValue)
        }
    }

    @inlinable var justification: GtkJustification {
        /// Gets the default justification of paragraphs in `text_view`.
        /// Tags in the buffer may override the default.
        get {
            let rv = gtk_text_view_get_justification(text_view_ptr)
            return rv
        }
        /// Sets the default justification of text in `text_view`.
        /// Tags in the view’s buffer may override the default.
        nonmutating set {
            gtk_text_view_set_justification(text_view_ptr, newValue)
        }
    }

    /// Gets the default left margin size of paragraphs in the `text_view`.
    /// Tags in the buffer may override the default.
    @inlinable var leftMargin: Int {
        /// Gets the default left margin size of paragraphs in the `text_view`.
        /// Tags in the buffer may override the default.
        get {
            let rv = Int(gtk_text_view_get_left_margin(text_view_ptr))
            return rv
        }
        /// Sets the default left margin for text in `text_view`.
        /// Tags in the buffer may override the default.
        /// 
        /// Note that this function is confusingly named.
        /// In CSS terms, the value set here is padding.
        nonmutating set {
            gtk_text_view_set_left_margin(text_view_ptr, gint(newValue))
        }
    }

    @inlinable var monospace: Bool {
        /// Gets the value of the `GtkTextView:monospace` property.
        get {
            let rv = ((gtk_text_view_get_monospace(text_view_ptr)) != 0)
            return rv
        }
        /// Sets the `GtkTextView:monospace` property, which
        /// indicates that the text view should use monospace
        /// fonts.
        nonmutating set {
            gtk_text_view_set_monospace(text_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var overwrite: Bool {
        /// Returns whether the `GtkTextView` is in overwrite mode or not.
        get {
            let rv = ((gtk_text_view_get_overwrite(text_view_ptr)) != 0)
            return rv
        }
        /// Changes the `GtkTextView` overwrite mode.
        nonmutating set {
            gtk_text_view_set_overwrite(text_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the default number of pixels to put above paragraphs.
    /// Adding this function with `gtk_text_view_get_pixels_below_lines()`
    /// is equal to the line space between each paragraph.
    @inlinable var pixelsAboveLines: Int {
        /// Gets the default number of pixels to put above paragraphs.
        /// Adding this function with `gtk_text_view_get_pixels_below_lines()`
        /// is equal to the line space between each paragraph.
        get {
            let rv = Int(gtk_text_view_get_pixels_above_lines(text_view_ptr))
            return rv
        }
        /// Sets the default number of blank pixels above paragraphs in `text_view`.
        /// Tags in the buffer for `text_view` may override the defaults.
        nonmutating set {
            gtk_text_view_set_pixels_above_lines(text_view_ptr, gint(newValue))
        }
    }

    /// Gets the value set by `gtk_text_view_set_pixels_below_lines()`.
    /// 
    /// The line space is the sum of the value returned by this function and the
    /// value returned by `gtk_text_view_get_pixels_above_lines()`.
    @inlinable var pixelsBelowLines: Int {
        /// Gets the value set by `gtk_text_view_set_pixels_below_lines()`.
        /// 
        /// The line space is the sum of the value returned by this function and the
        /// value returned by `gtk_text_view_get_pixels_above_lines()`.
        get {
            let rv = Int(gtk_text_view_get_pixels_below_lines(text_view_ptr))
            return rv
        }
        /// Sets the default number of pixels of blank space
        /// to put below paragraphs in `text_view`. May be overridden
        /// by tags applied to `text_view`’s buffer.
        nonmutating set {
            gtk_text_view_set_pixels_below_lines(text_view_ptr, gint(newValue))
        }
    }

    /// Gets the value set by `gtk_text_view_set_pixels_inside_wrap()`.
    @inlinable var pixelsInsideWrap: Int {
        /// Gets the value set by `gtk_text_view_set_pixels_inside_wrap()`.
        get {
            let rv = Int(gtk_text_view_get_pixels_inside_wrap(text_view_ptr))
            return rv
        }
        /// Sets the default number of pixels of blank space to leave between
        /// display/wrapped lines within a paragraph. May be overridden by
        /// tags in `text_view`’s buffer.
        nonmutating set {
            gtk_text_view_set_pixels_inside_wrap(text_view_ptr, gint(newValue))
        }
    }

    /// Gets the default right margin for text in `text_view`. Tags
    /// in the buffer may override the default.
    @inlinable var rightMargin: Int {
        /// Gets the default right margin for text in `text_view`. Tags
        /// in the buffer may override the default.
        get {
            let rv = Int(gtk_text_view_get_right_margin(text_view_ptr))
            return rv
        }
        /// Sets the default right margin for text in the text view.
        /// Tags in the buffer may override the default.
        /// 
        /// Note that this function is confusingly named.
        /// In CSS terms, the value set here is padding.
        nonmutating set {
            gtk_text_view_set_right_margin(text_view_ptr, gint(newValue))
        }
    }

    @inlinable var tabs: Pango.TabArrayRef! {
        /// Gets the default tabs for `text_view`. Tags in the buffer may
        /// override the defaults. The returned array will be `nil` if
        /// “standard” (8-space) tabs are used. Free the return value
        /// with `pango_tab_array_free()`.
        get {
            let rv = Pango.TabArrayRef(gtk_text_view_get_tabs(text_view_ptr))
            return rv
        }
        /// Sets the default tab stops for paragraphs in `text_view`.
        /// Tags in the buffer may override the default.
        nonmutating set {
            gtk_text_view_set_tabs(text_view_ptr, UnsafeMutablePointer<PangoTabArray>(newValue?.tab_array_ptr))
        }
    }

    /// Gets the top margin for text in the `text_view`.
    @inlinable var topMargin: Int {
        /// Gets the top margin for text in the `text_view`.
        get {
            let rv = Int(gtk_text_view_get_top_margin(text_view_ptr))
            return rv
        }
        /// Sets the top margin for text in `text_view`.
        /// 
        /// Note that this function is confusingly named.
        /// In CSS terms, the value set here is padding.
        nonmutating set {
            gtk_text_view_set_top_margin(text_view_ptr, gint(newValue))
        }
    }

    /// Gets the vertical-scrolling `GtkAdjustment`.
    ///
    /// **get_vadjustment is deprecated:**
    /// Use gtk_scrollable_get_vadjustment()
    @inlinable var vadjustment: AdjustmentRef! {
        /// Gets the vertical-scrolling `GtkAdjustment`.
        ///
        /// **get_vadjustment is deprecated:**
        /// Use gtk_scrollable_get_vadjustment()
        @available(*, deprecated)
    get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_text_view_get_vadjustment(text_view_ptr)))
            return rv
        }
    }

    /// Gets the line wrapping for the view.
    @inlinable var wrapMode: GtkWrapMode {
        /// Gets the line wrapping for the view.
        get {
            let rv = gtk_text_view_get_wrap_mode(text_view_ptr)
            return rv
        }
        /// Sets the line wrapping for the view.
        nonmutating set {
            gtk_text_view_set_wrap_mode(text_view_ptr, newValue)
        }
    }

    @inlinable var parentInstance: GtkContainer {
        get {
            let rv = text_view_ptr.pointee.parent_instance
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TextViewAccessible Class


///
/// The `TextViewAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkTextViewAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TextViewAccessible`.
/// Alternatively, use `TextViewAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TextViewAccessibleProtocol: ContainerAccessibleProtocol, Atk.EditableTextProtocol, Atk.StreamableContentProtocol, Atk.TextProtocol {
        /// Untyped pointer to the underlying `GtkTextViewAccessible` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTextViewAccessible` instance.
    var text_view_accessible_ptr: UnsafeMutablePointer<GtkTextViewAccessible>! { get }

    /// Required Initialiser for types conforming to `TextViewAccessibleProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TextViewAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkTextViewAccessible` instance.
/// It exposes methods that can operate on this data type through `TextViewAccessibleProtocol` conformance.
/// Use `TextViewAccessibleRef` only as an `unowned` reference to an existing `GtkTextViewAccessible` instance.
///
public struct TextViewAccessibleRef: TextViewAccessibleProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTextViewAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `text_view_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TextViewAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTextViewAccessible>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTextViewAccessible>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTextViewAccessible>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTextViewAccessible>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TextViewAccessibleProtocol`
    @inlinable init<T: TextViewAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TextViewAccessibleProtocol>(_ other: T) -> TextViewAccessibleRef { TextViewAccessibleRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }


///
/// The `TextViewAccessible` type acts as a reference-counted owner of an underlying `GtkTextViewAccessible` instance.
/// It provides the methods that can operate on this data type through `TextViewAccessibleProtocol` conformance.
/// Use `TextViewAccessible` as a strong reference or owner of a `GtkTextViewAccessible` instance.
///
open class TextViewAccessible: ContainerAccessible, TextViewAccessibleProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextViewAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTextViewAccessible>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextViewAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTextViewAccessible>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextViewAccessible` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextViewAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextViewAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTextViewAccessible>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TextViewAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTextViewAccessible>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTextViewAccessible`.
    /// i.e., ownership is transferred to the `TextViewAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTextViewAccessible>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TextViewAccessibleProtocol`
    /// Will retain `GtkTextViewAccessible`.
    /// - Parameter other: an instance of a related type that implements `TextViewAccessibleProtocol`
    @inlinable public init<T: TextViewAccessibleProtocol>(textViewAccessible other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TextViewAccessibleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum TextViewAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case widget = "widget"
}

public extension TextViewAccessibleProtocol {
    /// Bind a `TextViewAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TextViewAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TextViewAccessible property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TextViewAccessiblePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TextViewAccessible property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TextViewAccessiblePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TextViewAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property-changed` is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyWidget = "notify::widget"
}

// MARK: TextViewAccessible has no signals
// MARK: TextViewAccessible Class: TextViewAccessibleProtocol extension (methods and fields)
public extension TextViewAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTextViewAccessible` instance.
    @inlinable var text_view_accessible_ptr: UnsafeMutablePointer<GtkTextViewAccessible>! { return ptr?.assumingMemoryBound(to: GtkTextViewAccessible.self) }


    @inlinable var parent: GtkContainerAccessible {
        get {
            let rv = text_view_accessible_ptr.pointee.parent
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - ThemingEngine Class

/// `GtkThemingEngine` was the object used for rendering themed content
/// in GTK+ widgets. It used to allow overriding GTK+'s default
/// implementation of rendering functions by allowing engines to be
/// loaded as modules.
/// 
/// `GtkThemingEngine` has been deprecated in GTK+ 3.14 and will be
/// ignored for rendering. The advancements in CSS theming are good
/// enough to allow themers to achieve their goals without the need
/// to modify source code.
///
/// The `ThemingEngineProtocol` protocol exposes the methods and properties of an underlying `GtkThemingEngine` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ThemingEngine`.
/// Alternatively, use `ThemingEngineRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ThemingEngineProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkThemingEngine` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkThemingEngine` instance.
    var theming_engine_ptr: UnsafeMutablePointer<GtkThemingEngine>! { get }

    /// Required Initialiser for types conforming to `ThemingEngineProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkThemingEngine` was the object used for rendering themed content
/// in GTK+ widgets. It used to allow overriding GTK+'s default
/// implementation of rendering functions by allowing engines to be
/// loaded as modules.
/// 
/// `GtkThemingEngine` has been deprecated in GTK+ 3.14 and will be
/// ignored for rendering. The advancements in CSS theming are good
/// enough to allow themers to achieve their goals without the need
/// to modify source code.
///
/// The `ThemingEngineRef` type acts as a lightweight Swift reference to an underlying `GtkThemingEngine` instance.
/// It exposes methods that can operate on this data type through `ThemingEngineProtocol` conformance.
/// Use `ThemingEngineRef` only as an `unowned` reference to an existing `GtkThemingEngine` instance.
///
public struct ThemingEngineRef: ThemingEngineProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkThemingEngine` instance.
    /// For type-safe access, use the generated, typed pointer `theming_engine_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ThemingEngineRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkThemingEngine>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkThemingEngine>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkThemingEngine>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkThemingEngine>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ThemingEngineProtocol`
    @inlinable init<T: ThemingEngineProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ThemingEngineProtocol>(_ other: T) -> ThemingEngineRef { ThemingEngineRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Loads and initializes a theming engine module from the
    /// standard directories.
    ///
    /// **load is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable static func load(name: UnsafePointer<gchar>!) -> ThemingEngineRef! {
        guard let rv = ThemingEngineRef(gconstpointer: gconstpointer(gtk_theming_engine_load(name))) else { return nil }
        return rv
    }
}

/// `GtkThemingEngine` was the object used for rendering themed content
/// in GTK+ widgets. It used to allow overriding GTK+'s default
/// implementation of rendering functions by allowing engines to be
/// loaded as modules.
/// 
/// `GtkThemingEngine` has been deprecated in GTK+ 3.14 and will be
/// ignored for rendering. The advancements in CSS theming are good
/// enough to allow themers to achieve their goals without the need
/// to modify source code.
///
/// The `ThemingEngine` type acts as a reference-counted owner of an underlying `GtkThemingEngine` instance.
/// It provides the methods that can operate on this data type through `ThemingEngineProtocol` conformance.
/// Use `ThemingEngine` as a strong reference or owner of a `GtkThemingEngine` instance.
///
open class ThemingEngine: GLibObject.Object, ThemingEngineProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ThemingEngine` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkThemingEngine>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ThemingEngine` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkThemingEngine>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ThemingEngine` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ThemingEngine` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ThemingEngine` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkThemingEngine>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ThemingEngine` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkThemingEngine>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkThemingEngine`.
    /// i.e., ownership is transferred to the `ThemingEngine` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkThemingEngine>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ThemingEngineProtocol`
    /// Will retain `GtkThemingEngine`.
    /// - Parameter other: an instance of a related type that implements `ThemingEngineProtocol`
    @inlinable public init<T: ThemingEngineProtocol>(themingEngine other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ThemingEngineProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }


    /// Loads and initializes a theming engine module from the
    /// standard directories.
    ///
    /// **load is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable public static func load(name: UnsafePointer<gchar>!) -> ThemingEngine! {
        guard let rv = ThemingEngine(gconstpointer: gconstpointer(gtk_theming_engine_load(name))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum ThemingEnginePropertyName: String, PropertyNameProtocol {
    /// The theming engine name, this name will be used when registering
    /// custom properties, for a theming engine named "Clearlooks" registering
    /// a "glossy" custom property, it could be referenced in the CSS file as
    /// 
    /// ```
    /// -Clearlooks-glossy: true;
    /// ```
    /// 
    case name = "name"
}

public extension ThemingEngineProtocol {
    /// Bind a `ThemingEnginePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ThemingEnginePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ThemingEngine property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ThemingEnginePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ThemingEngine property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ThemingEnginePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ThemingEngineSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The theming engine name, this name will be used when registering
    /// custom properties, for a theming engine named "Clearlooks" registering
    /// a "glossy" custom property, it could be referenced in the CSS file as
    /// 
    /// ```
    /// -Clearlooks-glossy: true;
    /// ```
    /// 
    case notifyName = "notify::name"
}

// MARK: ThemingEngine has no signals
// MARK: ThemingEngine Class: ThemingEngineProtocol extension (methods and fields)
public extension ThemingEngineProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkThemingEngine` instance.
    @inlinable var theming_engine_ptr: UnsafeMutablePointer<GtkThemingEngine>! { return ptr?.assumingMemoryBound(to: GtkThemingEngine.self) }


    // *** get() is not available because it has a varargs (...) parameter!


    /// Gets the background color for a given state.
    ///
    /// **get_background_color is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getBackgroundColor<RGBAT: Gdk.RGBAProtocol>(state: StateFlags, color: RGBAT) {
        gtk_theming_engine_get_background_color(theming_engine_ptr, state.value, color.rgba_ptr)
    
    }

    /// Gets the border for a given state as a `GtkBorder`.
    ///
    /// **get_border is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getBorder<BorderT: BorderProtocol>(state: StateFlags, border: BorderT) {
        gtk_theming_engine_get_border(theming_engine_ptr, state.value, border.border_ptr)
    
    }

    /// Gets the border color for a given state.
    ///
    /// **get_border_color is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getBorderColor<RGBAT: Gdk.RGBAProtocol>(state: StateFlags, color: RGBAT) {
        gtk_theming_engine_get_border_color(theming_engine_ptr, state.value, color.rgba_ptr)
    
    }

    /// Gets the foreground color for a given state.
    ///
    /// **get_color is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getColor<RGBAT: Gdk.RGBAProtocol>(state: StateFlags, color: RGBAT) {
        gtk_theming_engine_get_color(theming_engine_ptr, state.value, color.rgba_ptr)
    
    }

    /// Returns the widget direction used for rendering.
    ///
    /// **get_direction is deprecated:**
    /// Use gtk_theming_engine_get_state() and
    ///   check for #GTK_STATE_FLAG_DIR_LTR and
    ///   #GTK_STATE_FLAG_DIR_RTL instead.
    @available(*, deprecated)
    @inlinable func getDirection() -> GtkTextDirection {
        let rv = gtk_theming_engine_get_direction(theming_engine_ptr)
        return rv
    }

    /// Returns the font description for a given state.
    ///
    /// **get_font is deprecated:**
    /// Use gtk_theming_engine_get()
    @available(*, deprecated)
    @inlinable func getFont(state: StateFlags) -> Pango.FontDescriptionRef! {
        let rv = Pango.FontDescriptionRef(gtk_theming_engine_get_font(theming_engine_ptr, state.value))
        return rv
    }

    /// Returns the widget direction used for rendering.
    ///
    /// **get_junction_sides is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getJunctionSides() -> JunctionSides {
        let rv = JunctionSides(gtk_theming_engine_get_junction_sides(theming_engine_ptr))
        return rv
    }

    /// Gets the margin for a given state as a `GtkBorder`.
    ///
    /// **get_margin is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getMargin<BorderT: BorderProtocol>(state: StateFlags, margin: BorderT) {
        gtk_theming_engine_get_margin(theming_engine_ptr, state.value, margin.border_ptr)
    
    }

    /// Gets the padding for a given state as a `GtkBorder`.
    ///
    /// **get_padding is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getPadding<BorderT: BorderProtocol>(state: StateFlags, padding: BorderT) {
        gtk_theming_engine_get_padding(theming_engine_ptr, state.value, padding.border_ptr)
    
    }

    /// Returns the widget path used for style matching.
    ///
    /// **get_path is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getPath() -> WidgetPathRef! {
        let rv = WidgetPathRef(gconstpointer: gconstpointer(gtk_theming_engine_get_path(theming_engine_ptr)))
        return rv
    }

    /// Gets a property value as retrieved from the style settings that apply
    /// to the currently rendered element.
    ///
    /// **get_property is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func get<ValueT: GLibObject.ValueProtocol>(property: UnsafePointer<gchar>!, state: StateFlags, value: ValueT) {
        gtk_theming_engine_get_property(theming_engine_ptr, property, state.value, value.value_ptr)
    
    }

    /// Returns the `GdkScreen` to which `engine` currently rendering to.
    ///
    /// **get_screen is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getScreen() -> Gdk.ScreenRef! {
        let rv = Gdk.ScreenRef(gtk_theming_engine_get_screen(theming_engine_ptr))
        return rv
    }

    /// returns the state used when rendering.
    ///
    /// **get_state is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getState() -> StateFlags {
        let rv = StateFlags(gtk_theming_engine_get_state(theming_engine_ptr))
        return rv
    }


    // *** getStyle() is not available because it has a varargs (...) parameter!


    /// Gets the value for a widget style property.
    ///
    /// **get_style_property is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getStyleProperty<ValueT: GLibObject.ValueProtocol>(propertyName: UnsafePointer<gchar>!, value: ValueT) {
        gtk_theming_engine_get_style_property(theming_engine_ptr, propertyName, value.value_ptr)
    
    }

    /// Retrieves several widget style properties from `engine` according to the
    /// currently rendered content’s style.
    ///
    /// **get_style_valist is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getStyleValist(args: CVaListPointer) {
        gtk_theming_engine_get_style_valist(theming_engine_ptr, args)
    
    }

    /// Retrieves several style property values that apply to the currently
    /// rendered element.
    ///
    /// **get_valist is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getValist(state: StateFlags, args: CVaListPointer) {
        gtk_theming_engine_get_valist(theming_engine_ptr, state.value, args)
    
    }

    /// Returns `true` if the currently rendered contents have
    /// defined the given class name.
    ///
    /// **has_class is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func hasClass(styleClass: UnsafePointer<gchar>!) -> Bool {
        let rv = ((gtk_theming_engine_has_class(theming_engine_ptr, styleClass)) != 0)
        return rv
    }

    /// Returns `true` if the currently rendered contents have the
    /// region defined. If `flags_return` is not `nil`, it is set
    /// to the flags affecting the region.
    ///
    /// **has_region is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func hasRegion(styleRegion: UnsafePointer<gchar>!, flags: UnsafeMutablePointer<GtkRegionFlags>! = nil) -> Bool {
        let rv = ((gtk_theming_engine_has_region(theming_engine_ptr, styleRegion, flags)) != 0)
        return rv
    }

    /// Looks up and resolves a color name in the current style’s color map.
    ///
    /// **lookup_color is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func lookupColor<RGBAT: Gdk.RGBAProtocol>(colorName: UnsafePointer<gchar>!, color: RGBAT) -> Bool {
        let rv = ((gtk_theming_engine_lookup_color(theming_engine_ptr, colorName, color.rgba_ptr)) != 0)
        return rv
    }

    /// Returns `true` if there is a transition animation running for the
    /// current region (see `gtk_style_context_push_animatable_region()`).
    /// 
    /// If `progress` is not `nil`, the animation progress will be returned
    /// there, 0.0 means the state is closest to being `false`, while 1.0 means
    /// it’s closest to being `true`. This means transition animations will
    /// run from 0 to 1 when `state` is being set to `true` and from 1 to 0 when
    /// it’s being set to `false`.
    ///
    /// **state_is_running is deprecated:**
    /// Always returns %FALSE
    @available(*, deprecated)
    @inlinable func stateIsRunning(state: GtkStateType, progress: UnsafeMutablePointer<gdouble>!) -> Bool {
        let rv = ((gtk_theming_engine_state_is_running(theming_engine_ptr, state, progress)) != 0)
        return rv
    }
    /// Returns the widget direction used for rendering.
    ///
    /// **get_direction is deprecated:**
    /// Use gtk_theming_engine_get_state() and
    ///   check for #GTK_STATE_FLAG_DIR_LTR and
    ///   #GTK_STATE_FLAG_DIR_RTL instead.
    @inlinable var direction: GtkTextDirection {
        /// Returns the widget direction used for rendering.
        ///
        /// **get_direction is deprecated:**
        /// Use gtk_theming_engine_get_state() and
        ///   check for #GTK_STATE_FLAG_DIR_LTR and
        ///   #GTK_STATE_FLAG_DIR_RTL instead.
        @available(*, deprecated)
    get {
            let rv = gtk_theming_engine_get_direction(theming_engine_ptr)
            return rv
        }
    }

    /// Returns the widget direction used for rendering.
    ///
    /// **get_junction_sides is deprecated:**
    /// This method is deprecated.
    @inlinable var junctionSides: JunctionSides {
        /// Returns the widget direction used for rendering.
        ///
        /// **get_junction_sides is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    get {
            let rv = JunctionSides(gtk_theming_engine_get_junction_sides(theming_engine_ptr))
            return rv
        }
    }

    /// Returns the widget path used for style matching.
    ///
    /// **get_path is deprecated:**
    /// This method is deprecated.
    @inlinable var path: WidgetPathRef! {
        /// Returns the widget path used for style matching.
        ///
        /// **get_path is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    get {
            let rv = WidgetPathRef(gconstpointer: gconstpointer(gtk_theming_engine_get_path(theming_engine_ptr)))
            return rv
        }
    }

    /// Returns the `GdkScreen` to which `engine` currently rendering to.
    ///
    /// **get_screen is deprecated:**
    /// This method is deprecated.
    @inlinable var screen: Gdk.ScreenRef! {
        /// Returns the `GdkScreen` to which `engine` currently rendering to.
        ///
        /// **get_screen is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    get {
            let rv = Gdk.ScreenRef(gtk_theming_engine_get_screen(theming_engine_ptr))
            return rv
        }
    }

    /// returns the state used when rendering.
    ///
    /// **get_state is deprecated:**
    /// This method is deprecated.
    @inlinable var state: StateFlags {
        /// returns the state used when rendering.
        ///
        /// **get_state is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    get {
            let rv = StateFlags(gtk_theming_engine_get_state(theming_engine_ptr))
            return rv
        }
    }

    @inlinable var parentObject: GObject {
        get {
            let rv = theming_engine_ptr.pointee.parent_object
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - ToggleAction Class

/// A `GtkToggleAction` corresponds roughly to a `GtkCheckMenuItem`. It has an
/// “active” state specifying whether the action has been checked or not.
///
/// The `ToggleActionProtocol` protocol exposes the methods and properties of an underlying `GtkToggleAction` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToggleAction`.
/// Alternatively, use `ToggleActionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ToggleActionProtocol: ActionProtocol {
        /// Untyped pointer to the underlying `GtkToggleAction` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkToggleAction` instance.
    var toggle_action_ptr: UnsafeMutablePointer<GtkToggleAction>! { get }

    /// Required Initialiser for types conforming to `ToggleActionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkToggleAction` corresponds roughly to a `GtkCheckMenuItem`. It has an
/// “active” state specifying whether the action has been checked or not.
///
/// The `ToggleActionRef` type acts as a lightweight Swift reference to an underlying `GtkToggleAction` instance.
/// It exposes methods that can operate on this data type through `ToggleActionProtocol` conformance.
/// Use `ToggleActionRef` only as an `unowned` reference to an existing `GtkToggleAction` instance.
///
public struct ToggleActionRef: ToggleActionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkToggleAction` instance.
    /// For type-safe access, use the generated, typed pointer `toggle_action_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ToggleActionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkToggleAction>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkToggleAction>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkToggleAction>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkToggleAction>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ToggleActionProtocol`
    @inlinable init<T: ToggleActionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ToggleActionProtocol>(_ other: T) -> ToggleActionRef { ToggleActionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkToggleAction` object. To add the action to
    /// a `GtkActionGroup` and set the accelerator for the action,
    /// call `gtk_action_group_add_action_with_accel()`.
    ///
    /// **new is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable init( name: UnsafePointer<gchar>!, label: UnsafePointer<gchar>? = nil, tooltip: UnsafePointer<gchar>? = nil, stockID: UnsafePointer<gchar>? = nil) {
        let rv = gtk_toggle_action_new(name, label, tooltip, stockID)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A `GtkToggleAction` corresponds roughly to a `GtkCheckMenuItem`. It has an
/// “active” state specifying whether the action has been checked or not.
///
/// The `ToggleAction` type acts as a reference-counted owner of an underlying `GtkToggleAction` instance.
/// It provides the methods that can operate on this data type through `ToggleActionProtocol` conformance.
/// Use `ToggleAction` as a strong reference or owner of a `GtkToggleAction` instance.
///
open class ToggleAction: Action, ToggleActionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkToggleAction>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkToggleAction>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleAction` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkToggleAction>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkToggleAction>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkToggleAction`.
    /// i.e., ownership is transferred to the `ToggleAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkToggleAction>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ToggleActionProtocol`
    /// Will retain `GtkToggleAction`.
    /// - Parameter other: an instance of a related type that implements `ToggleActionProtocol`
    @inlinable public init<T: ToggleActionProtocol>(toggleAction other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkToggleAction` object. To add the action to
    /// a `GtkActionGroup` and set the accelerator for the action,
    /// call `gtk_action_group_add_action_with_accel()`.
    ///
    /// **new is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable override public init( name: UnsafePointer<gchar>!, label: UnsafePointer<gchar>? = nil, tooltip: UnsafePointer<gchar>? = nil, stockID: UnsafePointer<gchar>? = nil) {
        let rv = gtk_toggle_action_new(name, label, tooltip, stockID)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ToggleActionPropertyName: String, PropertyNameProtocol {
    /// The GtkActionGroup this GtkAction is associated with, or NULL
    /// (for internal use).
    ///
    /// **action-group is deprecated:**
    /// Lookup the #GAction using g_action_map_lookup_action()
    /// instead
    case actionGroup = "action-group"
    /// Whether the toggle action should be active.
    ///
    /// **active is deprecated:**
    /// This method is deprecated.
    case active = "active"
    /// If `true`, the action's menu item proxies will ignore the `GtkSettings:gtk-menu-images`
    /// setting and always show their image, if available.
    /// 
    /// Use this property if the menu item would be useless or hard to use
    /// without their image.
    ///
    /// **always-show-image is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case alwaysShowImage = "always-show-image"
    /// Whether the proxies for this action look like radio action proxies.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use-action-appearance` is `true`.
    ///
    /// **draw-as-radio is deprecated:**
    /// This method is deprecated.
    case drawAsRadio = "draw-as-radio"
    /// The `GIcon` displayed in the `GtkAction`.
    /// 
    /// Note that the stock icon is preferred, if the `GtkAction:stock-id`
    /// property holds the id of an existing stock icon.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use-action-appearance` is `true`.
    ///
    /// **gicon is deprecated:**
    /// Use the "icon" attribute on a #GMenuItem instead
    case gicon = "gicon"
    /// When TRUE, empty menu proxies for this action are hidden.
    ///
    /// **hide-if-empty is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case hideIfEmpty = "hide-if-empty"
    /// The name of the icon from the icon theme.
    /// 
    /// Note that the stock icon is preferred, if the `GtkAction:stock-id`
    /// property holds the id of an existing stock icon, and the `GIcon` is
    /// preferred if the `GtkAction:gicon` property is set.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use-action-appearance` is `true`.
    ///
    /// **icon-name is deprecated:**
    /// Use the "icon" attribute on a #GMenuItem instead
    case iconName = "icon-name"
    /// Whether the action is considered important. When TRUE, toolitem
    /// proxies for this action show text in GTK_TOOLBAR_BOTH_HORIZ mode.
    ///
    /// **is-important is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case isImportant = "is-important"
    /// The label used for menu items and buttons that activate
    /// this action. If the label is `nil`, GTK+ uses the stock
    /// label specified via the stock-id property.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use-action-appearance` is `true`.
    ///
    /// **label is deprecated:**
    /// Use the "label" attribute on #GMenuItem instead
    case label = "label"
    /// A unique name for the action.
    ///
    /// **name is deprecated:**
    /// Use #GAction:name instead
    case name = "name"
    /// Whether the action is enabled.
    ///
    /// **sensitive is deprecated:**
    /// Use #GAction:enabled and #GSimpleAction:enabled
    /// instead
    case sensitive = "sensitive"
    /// A shorter label that may be used on toolbar buttons.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use-action-appearance` is `true`.
    ///
    /// **short-label is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case shortLabel = "short-label"
    /// The stock icon displayed in widgets representing this action.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use-action-appearance` is `true`.
    ///
    /// **stock-id is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case stockID = "stock-id"
    /// A tooltip for this action.
    ///
    /// **tooltip is deprecated:**
    /// Use gtk_widget_set_tooltip_text() instead
    case tooltip = "tooltip"
    /// Whether the action is visible.
    ///
    /// **visible is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case visible = "visible"
    /// Whether the toolbar item is visible when the toolbar is in a horizontal orientation.
    ///
    /// **visible-horizontal is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case visibleHorizontal = "visible-horizontal"
    /// When `true`, toolitem proxies for this action are represented in the
    /// toolbar overflow menu.
    ///
    /// **visible-overflown is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case visibleOverflown = "visible-overflown"
    /// Whether the toolbar item is visible when the toolbar is in a vertical orientation.
    ///
    /// **visible-vertical is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case visibleVertical = "visible-vertical"
}

public extension ToggleActionProtocol {
    /// Bind a `ToggleActionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToggleActionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ToggleAction property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ToggleActionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ToggleAction property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ToggleActionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ToggleActionSignalName: String, SignalNameProtocol {
    /// The "activate" signal is emitted when the action is activated.
    ///
    /// **activate is deprecated:**
    /// Use #GSimpleAction::activate instead
    case activate = "activate"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Should be connected if you wish to perform an action
    /// whenever the `GtkToggleAction` state is changed.
    ///
    /// **toggled is deprecated:**
    /// This method is deprecated.
    case toggled = "toggled"
    /// The GtkActionGroup this GtkAction is associated with, or NULL
    /// (for internal use).
    ///
    /// **action-group is deprecated:**
    /// Lookup the #GAction using g_action_map_lookup_action()
    /// instead
    case notifyActionGroup = "notify::action-group"
    /// Whether the toggle action should be active.
    ///
    /// **active is deprecated:**
    /// This method is deprecated.
    case notifyActive = "notify::active"
    /// If `true`, the action's menu item proxies will ignore the `GtkSettings:gtk-menu-images`
    /// setting and always show their image, if available.
    /// 
    /// Use this property if the menu item would be useless or hard to use
    /// without their image.
    ///
    /// **always-show-image is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyAlwaysShowImage = "notify::always-show-image"
    /// Whether the proxies for this action look like radio action proxies.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use-action-appearance` is `true`.
    ///
    /// **draw-as-radio is deprecated:**
    /// This method is deprecated.
    case notifyDrawAsRadio = "notify::draw-as-radio"
    /// The `GIcon` displayed in the `GtkAction`.
    /// 
    /// Note that the stock icon is preferred, if the `GtkAction:stock-id`
    /// property holds the id of an existing stock icon.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use-action-appearance` is `true`.
    ///
    /// **gicon is deprecated:**
    /// Use the "icon" attribute on a #GMenuItem instead
    case notifyIcon = "notify::gicon"
    /// When TRUE, empty menu proxies for this action are hidden.
    ///
    /// **hide-if-empty is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyHideIfEmpty = "notify::hide-if-empty"
    /// The name of the icon from the icon theme.
    /// 
    /// Note that the stock icon is preferred, if the `GtkAction:stock-id`
    /// property holds the id of an existing stock icon, and the `GIcon` is
    /// preferred if the `GtkAction:gicon` property is set.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use-action-appearance` is `true`.
    ///
    /// **icon-name is deprecated:**
    /// Use the "icon" attribute on a #GMenuItem instead
    case notifyIconName = "notify::icon-name"
    /// Whether the action is considered important. When TRUE, toolitem
    /// proxies for this action show text in GTK_TOOLBAR_BOTH_HORIZ mode.
    ///
    /// **is-important is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyIsImportant = "notify::is-important"
    /// The label used for menu items and buttons that activate
    /// this action. If the label is `nil`, GTK+ uses the stock
    /// label specified via the stock-id property.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use-action-appearance` is `true`.
    ///
    /// **label is deprecated:**
    /// Use the "label" attribute on #GMenuItem instead
    case notifyLabel = "notify::label"
    /// A unique name for the action.
    ///
    /// **name is deprecated:**
    /// Use #GAction:name instead
    case notifyName = "notify::name"
    /// Whether the action is enabled.
    ///
    /// **sensitive is deprecated:**
    /// Use #GAction:enabled and #GSimpleAction:enabled
    /// instead
    case notifySensitive = "notify::sensitive"
    /// A shorter label that may be used on toolbar buttons.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use-action-appearance` is `true`.
    ///
    /// **short-label is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyShortLabel = "notify::short-label"
    /// The stock icon displayed in widgets representing this action.
    /// 
    /// This is an appearance property and thus only applies if
    /// `GtkActivatable:use-action-appearance` is `true`.
    ///
    /// **stock-id is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyStockID = "notify::stock-id"
    /// A tooltip for this action.
    ///
    /// **tooltip is deprecated:**
    /// Use gtk_widget_set_tooltip_text() instead
    case notifyTooltip = "notify::tooltip"
    /// Whether the action is visible.
    ///
    /// **visible is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyVisible = "notify::visible"
    /// Whether the toolbar item is visible when the toolbar is in a horizontal orientation.
    ///
    /// **visible-horizontal is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyVisibleHorizontal = "notify::visible-horizontal"
    /// When `true`, toolitem proxies for this action are represented in the
    /// toolbar overflow menu.
    ///
    /// **visible-overflown is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyVisibleOverflown = "notify::visible-overflown"
    /// Whether the toolbar item is visible when the toolbar is in a vertical orientation.
    ///
    /// **visible-vertical is deprecated:**
    /// There is no corresponding replacement when using
    /// #GAction
    case notifyVisibleVertical = "notify::visible-vertical"
}

// MARK: ToggleAction signals
public extension ToggleActionProtocol {
    /// Connect a Swift signal handler to the given, typed `ToggleActionSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToggleActionSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ToggleActionSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToggleActionSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Should be connected if you wish to perform an action
    /// whenever the `GtkToggleAction` state is changed.
    /// - Note: This represents the underlying `toggled` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggled` signal is emitted
    @discardableResult @inlinable func onToggled(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToggleActionRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ToggleActionRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToggleActionRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .toggled,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggled` signal for using the `connect(signal:)` methods
    static var toggledSignal: ToggleActionSignalName { .toggled }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActive` signal is emitted
    @discardableResult @inlinable func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToggleActionRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToggleActionRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToggleActionRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active` signal for using the `connect(signal:)` methods
    static var notifyActiveSignal: ToggleActionSignalName { .notifyActive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::draw-as-radio` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyDrawAsRadio` signal is emitted
    @discardableResult @inlinable func onNotifyDrawAsRadio(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToggleActionRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToggleActionRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToggleActionRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyDrawAsRadio,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::draw-as-radio` signal for using the `connect(signal:)` methods
    static var notifyDrawAsRadioSignal: ToggleActionSignalName { .notifyDrawAsRadio }
    
}

// MARK: ToggleAction Class: ToggleActionProtocol extension (methods and fields)
public extension ToggleActionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToggleAction` instance.
    @inlinable var toggle_action_ptr: UnsafeMutablePointer<GtkToggleAction>! { return ptr?.assumingMemoryBound(to: GtkToggleAction.self) }

    /// Returns the checked state of the toggle action.
    ///
    /// **get_active is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getActive() -> Bool {
        let rv = ((gtk_toggle_action_get_active(toggle_action_ptr)) != 0)
        return rv
    }

    /// Returns whether the action should have proxies like a radio action.
    ///
    /// **get_draw_as_radio is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getDrawAsRadio() -> Bool {
        let rv = ((gtk_toggle_action_get_draw_as_radio(toggle_action_ptr)) != 0)
        return rv
    }

    /// Sets the checked state on the toggle action.
    ///
    /// **set_active is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func setActive(isActive: Bool) {
        gtk_toggle_action_set_active(toggle_action_ptr, gboolean((isActive) ? 1 : 0))
    
    }

    /// Sets whether the action should have proxies like a radio action.
    ///
    /// **set_draw_as_radio is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func set(drawAsRadio: Bool) {
        gtk_toggle_action_set_draw_as_radio(toggle_action_ptr, gboolean((drawAsRadio) ? 1 : 0))
    
    }

    /// Emits the “toggled” signal on the toggle action.
    ///
    /// **toggled is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func toggled() {
        gtk_toggle_action_toggled(toggle_action_ptr)
    
    }
    /// Whether the toggle action should be active.
    ///
    /// **active is deprecated:**
    /// This method is deprecated.
    @inlinable var active: Bool {
        /// Returns the checked state of the toggle action.
        ///
        /// **get_active is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    get {
            let rv = ((gtk_toggle_action_get_active(toggle_action_ptr)) != 0)
            return rv
        }
        /// Sets the checked state on the toggle action.
        ///
        /// **set_active is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    nonmutating set {
            gtk_toggle_action_set_active(toggle_action_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the action should have proxies like a radio action.
    ///
    /// **get_draw_as_radio is deprecated:**
    /// This method is deprecated.
    @inlinable var drawAsRadio: Bool {
        /// Returns whether the action should have proxies like a radio action.
        ///
        /// **get_draw_as_radio is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    get {
            let rv = ((gtk_toggle_action_get_draw_as_radio(toggle_action_ptr)) != 0)
            return rv
        }
        /// Sets whether the action should have proxies like a radio action.
        ///
        /// **set_draw_as_radio is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    nonmutating set {
            gtk_toggle_action_set_draw_as_radio(toggle_action_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var parent: GtkAction {
        get {
            let rv = toggle_action_ptr.pointee.parent
            return rv
        }
    }

    // var privateData is unavailable because private_data is private

}



// MARK: - ToggleButton Class

/// A `GtkToggleButton` is a `GtkButton` which will remain “pressed-in” when
/// clicked. Clicking again will cause the toggle button to return to its
/// normal state.
/// 
/// A toggle button is created by calling either `gtk_toggle_button_new()` or
/// `gtk_toggle_button_new_with_label()`. If using the former, it is advisable to
/// pack a widget, (such as a `GtkLabel` and/or a `GtkImage`), into the toggle
/// button’s container. (See `GtkButton` for more information).
/// 
/// The state of a `GtkToggleButton` can be set specifically using
/// `gtk_toggle_button_set_active()`, and retrieved using
/// `gtk_toggle_button_get_active()`.
/// 
/// To simply switch the state of a toggle button, use `gtk_toggle_button_toggled()`.
/// 
/// # CSS nodes
/// 
/// GtkToggleButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .toggle style class.
/// 
/// ## Creating two `GtkToggleButton` widgets.
/// 
/// (C Language Example):
/// ```C
/// static void output_state (GtkToggleButton *source, gpointer user_data) {
///   printf ("Active: %d\n", gtk_toggle_button_get_active (source));
/// }
/// 
/// void make_toggles (void) {
///   GtkWidget *window, *toggle1, *toggle2;
///   GtkWidget *box;
///   const char *text;
/// 
///   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
///   box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
/// 
///   text = "Hi, I’m a toggle button.";
///   toggle1 = gtk_toggle_button_new_with_label (text);
/// 
///   // Makes this toggle button invisible
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle1),
///                               TRUE);
/// 
///   g_signal_connect (toggle1, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle1);
/// 
///   text = "Hi, I’m a toggle button.";
///   toggle2 = gtk_toggle_button_new_with_label (text);
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle2),
///                               FALSE);
///   g_signal_connect (toggle2, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle2);
/// 
///   gtk_container_add (GTK_CONTAINER (window), box);
///   gtk_widget_show_all (window);
/// }
/// ```
/// 
///
/// The `ToggleButtonProtocol` protocol exposes the methods and properties of an underlying `GtkToggleButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToggleButton`.
/// Alternatively, use `ToggleButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ToggleButtonProtocol: ButtonProtocol {
        /// Untyped pointer to the underlying `GtkToggleButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkToggleButton` instance.
    var toggle_button_ptr: UnsafeMutablePointer<GtkToggleButton>! { get }

    /// Required Initialiser for types conforming to `ToggleButtonProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkToggleButton` is a `GtkButton` which will remain “pressed-in” when
/// clicked. Clicking again will cause the toggle button to return to its
/// normal state.
/// 
/// A toggle button is created by calling either `gtk_toggle_button_new()` or
/// `gtk_toggle_button_new_with_label()`. If using the former, it is advisable to
/// pack a widget, (such as a `GtkLabel` and/or a `GtkImage`), into the toggle
/// button’s container. (See `GtkButton` for more information).
/// 
/// The state of a `GtkToggleButton` can be set specifically using
/// `gtk_toggle_button_set_active()`, and retrieved using
/// `gtk_toggle_button_get_active()`.
/// 
/// To simply switch the state of a toggle button, use `gtk_toggle_button_toggled()`.
/// 
/// # CSS nodes
/// 
/// GtkToggleButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .toggle style class.
/// 
/// ## Creating two `GtkToggleButton` widgets.
/// 
/// (C Language Example):
/// ```C
/// static void output_state (GtkToggleButton *source, gpointer user_data) {
///   printf ("Active: %d\n", gtk_toggle_button_get_active (source));
/// }
/// 
/// void make_toggles (void) {
///   GtkWidget *window, *toggle1, *toggle2;
///   GtkWidget *box;
///   const char *text;
/// 
///   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
///   box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
/// 
///   text = "Hi, I’m a toggle button.";
///   toggle1 = gtk_toggle_button_new_with_label (text);
/// 
///   // Makes this toggle button invisible
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle1),
///                               TRUE);
/// 
///   g_signal_connect (toggle1, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle1);
/// 
///   text = "Hi, I’m a toggle button.";
///   toggle2 = gtk_toggle_button_new_with_label (text);
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle2),
///                               FALSE);
///   g_signal_connect (toggle2, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle2);
/// 
///   gtk_container_add (GTK_CONTAINER (window), box);
///   gtk_widget_show_all (window);
/// }
/// ```
/// 
///
/// The `ToggleButtonRef` type acts as a lightweight Swift reference to an underlying `GtkToggleButton` instance.
/// It exposes methods that can operate on this data type through `ToggleButtonProtocol` conformance.
/// Use `ToggleButtonRef` only as an `unowned` reference to an existing `GtkToggleButton` instance.
///
public struct ToggleButtonRef: ToggleButtonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkToggleButton` instance.
    /// For type-safe access, use the generated, typed pointer `toggle_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ToggleButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkToggleButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkToggleButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkToggleButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkToggleButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ToggleButtonProtocol`
    @inlinable init<T: ToggleButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ToggleButtonProtocol>(_ other: T) -> ToggleButtonRef { ToggleButtonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new toggle button. A widget should be packed into the button, as in `gtk_button_new()`.
    @inlinable init() {
        let rv = gtk_toggle_button_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new toggle button with a text label.
    @inlinable init(label: UnsafePointer<gchar>!) {
        let rv = gtk_toggle_button_new_with_label(label)
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkToggleButton` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the button.
    @inlinable init(mnemonic label: UnsafePointer<gchar>!) {
        let rv = gtk_toggle_button_new_with_mnemonic(label)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new toggle button with a text label.
    @inlinable static func toggleButtonNewWith(label: UnsafePointer<gchar>!) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_toggle_button_new_with_label(label))) else { return nil }
        return rv
    }

    /// Creates a new `GtkToggleButton` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the button.
    @inlinable static func toggleButtonNewWith(mnemonic label: UnsafePointer<gchar>!) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_toggle_button_new_with_mnemonic(label))) else { return nil }
        return rv
    }
}

/// A `GtkToggleButton` is a `GtkButton` which will remain “pressed-in” when
/// clicked. Clicking again will cause the toggle button to return to its
/// normal state.
/// 
/// A toggle button is created by calling either `gtk_toggle_button_new()` or
/// `gtk_toggle_button_new_with_label()`. If using the former, it is advisable to
/// pack a widget, (such as a `GtkLabel` and/or a `GtkImage`), into the toggle
/// button’s container. (See `GtkButton` for more information).
/// 
/// The state of a `GtkToggleButton` can be set specifically using
/// `gtk_toggle_button_set_active()`, and retrieved using
/// `gtk_toggle_button_get_active()`.
/// 
/// To simply switch the state of a toggle button, use `gtk_toggle_button_toggled()`.
/// 
/// # CSS nodes
/// 
/// GtkToggleButton has a single CSS node with name button. To differentiate
/// it from a plain `GtkButton`, it gets the .toggle style class.
/// 
/// ## Creating two `GtkToggleButton` widgets.
/// 
/// (C Language Example):
/// ```C
/// static void output_state (GtkToggleButton *source, gpointer user_data) {
///   printf ("Active: %d\n", gtk_toggle_button_get_active (source));
/// }
/// 
/// void make_toggles (void) {
///   GtkWidget *window, *toggle1, *toggle2;
///   GtkWidget *box;
///   const char *text;
/// 
///   window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
///   box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
/// 
///   text = "Hi, I’m a toggle button.";
///   toggle1 = gtk_toggle_button_new_with_label (text);
/// 
///   // Makes this toggle button invisible
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle1),
///                               TRUE);
/// 
///   g_signal_connect (toggle1, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle1);
/// 
///   text = "Hi, I’m a toggle button.";
///   toggle2 = gtk_toggle_button_new_with_label (text);
///   gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle2),
///                               FALSE);
///   g_signal_connect (toggle2, "toggled",
///                     G_CALLBACK (output_state),
///                     NULL);
///   gtk_container_add (GTK_CONTAINER (box), toggle2);
/// 
///   gtk_container_add (GTK_CONTAINER (window), box);
///   gtk_widget_show_all (window);
/// }
/// ```
/// 
///
/// The `ToggleButton` type acts as a reference-counted owner of an underlying `GtkToggleButton` instance.
/// It provides the methods that can operate on this data type through `ToggleButtonProtocol` conformance.
/// Use `ToggleButton` as a strong reference or owner of a `GtkToggleButton` instance.
///
open class ToggleButton: Button, ToggleButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkToggleButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkToggleButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkToggleButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkToggleButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkToggleButton`.
    /// i.e., ownership is transferred to the `ToggleButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkToggleButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ToggleButtonProtocol`
    /// Will retain `GtkToggleButton`.
    /// - Parameter other: an instance of a related type that implements `ToggleButtonProtocol`
    @inlinable public init<T: ToggleButtonProtocol>(toggleButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new toggle button. A widget should be packed into the button, as in `gtk_button_new()`.
    @inlinable override public init() {
        let rv = gtk_toggle_button_new()
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new toggle button with a text label.
    @inlinable override public init(label: UnsafePointer<gchar>!) {
        let rv = gtk_toggle_button_new_with_label(label)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkToggleButton` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the button.
    @inlinable override public init(mnemonic label: UnsafePointer<gchar>!) {
        let rv = gtk_toggle_button_new_with_mnemonic(label)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new toggle button with a text label.
    @inlinable public static func toggleButtonNewWith(label: UnsafePointer<gchar>!) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_toggle_button_new_with_label(label))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

    /// Creates a new `GtkToggleButton` containing a label. The label
    /// will be created using `gtk_label_new_with_mnemonic()`, so underscores
    /// in `label` indicate the mnemonic for the button.
    @inlinable public static func toggleButtonNewWith(mnemonic label: UnsafePointer<gchar>!) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_toggle_button_new_with_mnemonic(label))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum ToggleButtonPropertyName: String, PropertyNameProtocol {
    case active = "active"
    /// If `true`, the button will ignore the `GtkSettings:gtk-button-images`
    /// setting and always show the image, if available.
    /// 
    /// Use this property if the button would be useless or hard to use
    /// without the image.
    case alwaysShowImage = "always-show-image"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case drawIndicator = "draw-indicator"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The child widget to appear next to the button text.
    case image = "image"
    /// The position of the image relative to the text inside the button.
    case imagePosition = "image-position"
    case inconsistent = "inconsistent"
    case isFocus = "is-focus"
    case label = "label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case relief = "relief"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"

    ///
    /// **use-stock is deprecated:**
    /// This method is deprecated.
    case useStock = "use-stock"
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its horizontal alignment. 0.0 is left aligned,
    /// 1.0 is right aligned.
    ///
    /// **xalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case xalign = "xalign"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its vertical alignment. 0.0 is top aligned,
    /// 1.0 is bottom aligned.
    ///
    /// **yalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case yalign = "yalign"
}

public extension ToggleButtonProtocol {
    /// Bind a `ToggleButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToggleButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ToggleButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ToggleButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ToggleButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ToggleButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ToggleButtonSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    /// The `activate` signal on GtkButton is an action signal and
    /// emitting it causes the button to animate press then release.
    /// Applications should never connect to this signal, but use the
    /// `GtkButton::clicked` signal.
    case activate = "activate"
    case add = "add"
    /// The `button-press-event` signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button-release-event` signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child-notify` signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// Emitted when the button has been activated (pressed and released).
    case clicked = "clicked"
    /// The `composited-changed` signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure-event` signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete-event` signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy-event` signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction-changed` signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag-begin` signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag-data-delete` signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag-data-get` signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag-data-received` signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag-drop` signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag-drop` signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag-data-received` handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag-end` signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag-begin`.
    case dragEnd = "drag-end"
    /// The `drag-failed` signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag-leave` signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag-motion`, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag-leave` signal is also emitted before the
    /// `drag-drop` signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag-motion` signal handler.
    case dragLeave = "drag-leave"
    /// The `drag-motion` signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag-data-received`
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag-leave` and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// Emitted when the pointer enters the button.
    ///
    /// **enter is deprecated:**
    /// Use the #GtkWidget::enter-notify-event signal.
    case enter = "enter"
    /// The `enter-notify-event` will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key-press-event`) and finally a generic
    /// `GtkWidget::event-after` signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event-after` will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The `focus-in-event` signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus-out-event` signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab-notify` signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy-changed` signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key-press-event` signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key-release-event` signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when the pointer leaves the button.
    ///
    /// **leave is deprecated:**
    /// Use the #GtkWidget::leave-notify-event signal.
    case leave = "leave"
    /// The `leave-notify-event` will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map-event` will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map-event` signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion-notify-event` signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent-set` signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// Emitted when the button is pressed.
    ///
    /// **pressed is deprecated:**
    /// Use the #GtkWidget::button-press-event signal.
    case pressed = "pressed"
    /// The `property-notify-event` signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has-tooltip` is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when the button is released.
    ///
    /// **released is deprecated:**
    /// Use the #GtkWidget::button-release-event signal.
    case released = "released"
    case remove = "remove"
    /// The `screen-changed` signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll-event` signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection-clear-event` signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection-request-event` signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The `state-changed` signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state-flags-changed` signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style-set` signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style-updated` signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style-updated` signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// Should be connected if you wish to perform an action whenever the
    /// `GtkToggleButton`'s state is changed.
    case toggled = "toggled"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap-event` signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility-notify-event` will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The `window-state-event` will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyActive = "notify::active"
    /// If `true`, the button will ignore the `GtkSettings:gtk-button-images`
    /// setting and always show the image, if available.
    /// 
    /// Use this property if the button would be useless or hard to use
    /// without the image.
    case notifyAlwaysShowImage = "notify::always-show-image"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyDrawIndicator = "notify::draw-indicator"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The child widget to appear next to the button text.
    case notifyImage = "notify::image"
    /// The position of the image relative to the text inside the button.
    case notifyImagePosition = "notify::image-position"
    case notifyInconsistent = "notify::inconsistent"
    case notifyIsFocus = "notify::is-focus"
    case notifyLabel = "notify::label"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyRelief = "notify::relief"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"

    ///
    /// **use-stock is deprecated:**
    /// This method is deprecated.
    case notifyUseStock = "notify::use-stock"
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its horizontal alignment. 0.0 is left aligned,
    /// 1.0 is right aligned.
    ///
    /// **xalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case notifyXalign = "notify::xalign"
    /// If the child of the button is a `GtkMisc` or `GtkAlignment`, this property
    /// can be used to control its vertical alignment. 0.0 is top aligned,
    /// 1.0 is bottom aligned.
    ///
    /// **yalign is deprecated:**
    /// Access the child widget directly if you need to control
    /// its alignment.
    case notifyYalign = "notify::yalign"
}

// MARK: ToggleButton signals
public extension ToggleButtonProtocol {
    /// Connect a Swift signal handler to the given, typed `ToggleButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToggleButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ToggleButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToggleButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Should be connected if you wish to perform an action whenever the
    /// `GtkToggleButton`'s state is changed.
    /// - Note: This represents the underlying `toggled` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggled` signal is emitted
    @discardableResult @inlinable func onToggled(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToggleButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ToggleButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToggleButtonRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .toggled,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggled` signal for using the `connect(signal:)` methods
    static var toggledSignal: ToggleButtonSignalName { .toggled }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActive` signal is emitted
    @discardableResult @inlinable func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToggleButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToggleButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToggleButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active` signal for using the `connect(signal:)` methods
    static var notifyActiveSignal: ToggleButtonSignalName { .notifyActive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::draw-indicator` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyDrawIndicator` signal is emitted
    @discardableResult @inlinable func onNotifyDrawIndicator(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToggleButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToggleButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToggleButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyDrawIndicator,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::draw-indicator` signal for using the `connect(signal:)` methods
    static var notifyDrawIndicatorSignal: ToggleButtonSignalName { .notifyDrawIndicator }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::inconsistent` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInconsistent` signal is emitted
    @discardableResult @inlinable func onNotifyInconsistent(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToggleButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToggleButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToggleButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyInconsistent,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::inconsistent` signal for using the `connect(signal:)` methods
    static var notifyInconsistentSignal: ToggleButtonSignalName { .notifyInconsistent }
    
}

// MARK: ToggleButton Class: ToggleButtonProtocol extension (methods and fields)
public extension ToggleButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToggleButton` instance.
    @inlinable var toggle_button_ptr: UnsafeMutablePointer<GtkToggleButton>! { return ptr?.assumingMemoryBound(to: GtkToggleButton.self) }

    /// Queries a `GtkToggleButton` and returns its current state. Returns `true` if
    /// the toggle button is pressed in and `false` if it is raised.
    @inlinable func getActive() -> Bool {
        let rv = ((gtk_toggle_button_get_active(toggle_button_ptr)) != 0)
        return rv
    }

    /// Gets the value set by `gtk_toggle_button_set_inconsistent()`.
    @inlinable func getInconsistent() -> Bool {
        let rv = ((gtk_toggle_button_get_inconsistent(toggle_button_ptr)) != 0)
        return rv
    }

    /// Retrieves whether the button is displayed as a separate indicator
    /// and label. See `gtk_toggle_button_set_mode()`.
    @inlinable func getMode() -> Bool {
        let rv = ((gtk_toggle_button_get_mode(toggle_button_ptr)) != 0)
        return rv
    }

    /// Sets the status of the toggle button. Set to `true` if you want the
    /// GtkToggleButton to be “pressed in”, and `false` to raise it.
    /// This action causes the `GtkToggleButton::toggled` signal and the
    /// `GtkButton::clicked` signal to be emitted.
    @inlinable func setActive(isActive: Bool) {
        gtk_toggle_button_set_active(toggle_button_ptr, gboolean((isActive) ? 1 : 0))
    
    }

    /// If the user has selected a range of elements (such as some text or
    /// spreadsheet cells) that are affected by a toggle button, and the
    /// current values in that range are inconsistent, you may want to
    /// display the toggle in an “in between” state. This function turns on
    /// “in between” display.  Normally you would turn off the inconsistent
    /// state again if the user toggles the toggle button. This has to be
    /// done manually, `gtk_toggle_button_set_inconsistent()` only affects
    /// visual appearance, it doesn’t affect the semantics of the button.
    @inlinable func setInconsistent(setting: Bool) {
        gtk_toggle_button_set_inconsistent(toggle_button_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Sets whether the button is displayed as a separate indicator and label.
    /// You can call this function on a checkbutton or a radiobutton with
    /// `draw_indicator` = `false` to make the button look like a normal button.
    /// 
    /// This can be used to create linked strip of buttons that work like
    /// a `GtkStackSwitcher`.
    /// 
    /// This function only affects instances of classes like `GtkCheckButton`
    /// and `GtkRadioButton` that derive from `GtkToggleButton`,
    /// not instances of `GtkToggleButton` itself.
    @inlinable func setMode(drawIndicator: Bool) {
        gtk_toggle_button_set_mode(toggle_button_ptr, gboolean((drawIndicator) ? 1 : 0))
    
    }

    /// Emits the `GtkToggleButton::toggled` signal on the
    /// `GtkToggleButton`. There is no good reason for an
    /// application ever to call this function.
    @inlinable func toggled() {
        gtk_toggle_button_toggled(toggle_button_ptr)
    
    }
    @inlinable var active: Bool {
        /// Queries a `GtkToggleButton` and returns its current state. Returns `true` if
        /// the toggle button is pressed in and `false` if it is raised.
        get {
            let rv = ((gtk_toggle_button_get_active(toggle_button_ptr)) != 0)
            return rv
        }
        /// Sets the status of the toggle button. Set to `true` if you want the
        /// GtkToggleButton to be “pressed in”, and `false` to raise it.
        /// This action causes the `GtkToggleButton::toggled` signal and the
        /// `GtkButton::clicked` signal to be emitted.
        nonmutating set {
            gtk_toggle_button_set_active(toggle_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var inconsistent: Bool {
        /// Gets the value set by `gtk_toggle_button_set_inconsistent()`.
        get {
            let rv = ((gtk_toggle_button_get_inconsistent(toggle_button_ptr)) != 0)
            return rv
        }
        /// If the user has selected a range of elements (such as some text or
        /// spreadsheet cells) that are affected by a toggle button, and the
        /// current values in that range are inconsistent, you may want to
        /// display the toggle in an “in between” state. This function turns on
        /// “in between” display.  Normally you would turn off the inconsistent
        /// state again if the user toggles the toggle button. This has to be
        /// done manually, `gtk_toggle_button_set_inconsistent()` only affects
        /// visual appearance, it doesn’t affect the semantics of the button.
        nonmutating set {
            gtk_toggle_button_set_inconsistent(toggle_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Retrieves whether the button is displayed as a separate indicator
    /// and label. See `gtk_toggle_button_set_mode()`.
    @inlinable var mode: Bool {
        /// Retrieves whether the button is displayed as a separate indicator
        /// and label. See `gtk_toggle_button_set_mode()`.
        get {
            let rv = ((gtk_toggle_button_get_mode(toggle_button_ptr)) != 0)
            return rv
        }
        /// Sets whether the button is displayed as a separate indicator and label.
        /// You can call this function on a checkbutton or a radiobutton with
        /// `draw_indicator` = `false` to make the button look like a normal button.
        /// 
        /// This can be used to create linked strip of buttons that work like
        /// a `GtkStackSwitcher`.
        /// 
        /// This function only affects instances of classes like `GtkCheckButton`
        /// and `GtkRadioButton` that derive from `GtkToggleButton`,
        /// not instances of `GtkToggleButton` itself.
        nonmutating set {
            gtk_toggle_button_set_mode(toggle_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    // var button is unavailable because button is private

    // var priv is unavailable because priv is private

}



// MARK: - ToggleButtonAccessible Class


///
/// The `ToggleButtonAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkToggleButtonAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToggleButtonAccessible`.
/// Alternatively, use `ToggleButtonAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ToggleButtonAccessibleProtocol: ButtonAccessibleProtocol {
        /// Untyped pointer to the underlying `GtkToggleButtonAccessible` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkToggleButtonAccessible` instance.
    var toggle_button_accessible_ptr: UnsafeMutablePointer<GtkToggleButtonAccessible>! { get }

    /// Required Initialiser for types conforming to `ToggleButtonAccessibleProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `ToggleButtonAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkToggleButtonAccessible` instance.
/// It exposes methods that can operate on this data type through `ToggleButtonAccessibleProtocol` conformance.
/// Use `ToggleButtonAccessibleRef` only as an `unowned` reference to an existing `GtkToggleButtonAccessible` instance.
///
public struct ToggleButtonAccessibleRef: ToggleButtonAccessibleProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkToggleButtonAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `toggle_button_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ToggleButtonAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkToggleButtonAccessible>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkToggleButtonAccessible>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkToggleButtonAccessible>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkToggleButtonAccessible>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ToggleButtonAccessibleProtocol`
    @inlinable init<T: ToggleButtonAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ToggleButtonAccessibleProtocol>(_ other: T) -> ToggleButtonAccessibleRef { ToggleButtonAccessibleRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }


///
/// The `ToggleButtonAccessible` type acts as a reference-counted owner of an underlying `GtkToggleButtonAccessible` instance.
/// It provides the methods that can operate on this data type through `ToggleButtonAccessibleProtocol` conformance.
/// Use `ToggleButtonAccessible` as a strong reference or owner of a `GtkToggleButtonAccessible` instance.
///
open class ToggleButtonAccessible: ButtonAccessible, ToggleButtonAccessibleProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButtonAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkToggleButtonAccessible>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButtonAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkToggleButtonAccessible>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButtonAccessible` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButtonAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButtonAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkToggleButtonAccessible>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleButtonAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkToggleButtonAccessible>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkToggleButtonAccessible`.
    /// i.e., ownership is transferred to the `ToggleButtonAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkToggleButtonAccessible>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ToggleButtonAccessibleProtocol`
    /// Will retain `GtkToggleButtonAccessible`.
    /// - Parameter other: an instance of a related type that implements `ToggleButtonAccessibleProtocol`
    @inlinable public init<T: ToggleButtonAccessibleProtocol>(toggleButtonAccessible other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleButtonAccessibleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ToggleButtonAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case widget = "widget"
}

public extension ToggleButtonAccessibleProtocol {
    /// Bind a `ToggleButtonAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToggleButtonAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ToggleButtonAccessible property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ToggleButtonAccessiblePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ToggleButtonAccessible property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ToggleButtonAccessiblePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ToggleButtonAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property-changed` is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyWidget = "notify::widget"
}

// MARK: ToggleButtonAccessible has no signals
// MARK: ToggleButtonAccessible Class: ToggleButtonAccessibleProtocol extension (methods and fields)
public extension ToggleButtonAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToggleButtonAccessible` instance.
    @inlinable var toggle_button_accessible_ptr: UnsafeMutablePointer<GtkToggleButtonAccessible>! { return ptr?.assumingMemoryBound(to: GtkToggleButtonAccessible.self) }


    @inlinable var parent: GtkButtonAccessible {
        get {
            let rv = toggle_button_accessible_ptr.pointee.parent
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - ToggleToolButton Class

/// A `GtkToggleToolButton` is a `GtkToolItem` that contains a toggle
/// button.
/// 
/// Use `gtk_toggle_tool_button_new()` to create a new GtkToggleToolButton.
/// 
/// # CSS nodes
/// 
/// GtkToggleToolButton has a single CSS node with name togglebutton.
///
/// The `ToggleToolButtonProtocol` protocol exposes the methods and properties of an underlying `GtkToggleToolButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToggleToolButton`.
/// Alternatively, use `ToggleToolButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ToggleToolButtonProtocol: ToolButtonProtocol {
        /// Untyped pointer to the underlying `GtkToggleToolButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkToggleToolButton` instance.
    var toggle_tool_button_ptr: UnsafeMutablePointer<GtkToggleToolButton>! { get }

    /// Required Initialiser for types conforming to `ToggleToolButtonProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkToggleToolButton` is a `GtkToolItem` that contains a toggle
/// button.
/// 
/// Use `gtk_toggle_tool_button_new()` to create a new GtkToggleToolButton.
/// 
/// # CSS nodes
/// 
/// GtkToggleToolButton has a single CSS node with name togglebutton.
///
/// The `ToggleToolButtonRef` type acts as a lightweight Swift reference to an underlying `GtkToggleToolButton` instance.
/// It exposes methods that can operate on this data type through `ToggleToolButtonProtocol` conformance.
/// Use `ToggleToolButtonRef` only as an `unowned` reference to an existing `GtkToggleToolButton` instance.
///
public struct ToggleToolButtonRef: ToggleToolButtonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkToggleToolButton` instance.
    /// For type-safe access, use the generated, typed pointer `toggle_tool_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ToggleToolButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkToggleToolButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkToggleToolButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkToggleToolButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkToggleToolButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ToggleToolButtonProtocol`
    @inlinable init<T: ToggleToolButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ToggleToolButtonProtocol>(_ other: T) -> ToggleToolButtonRef { ToggleToolButtonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Returns a new `GtkToggleToolButton`
    @inlinable init() {
        let rv = gtk_toggle_tool_button_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkToggleToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_toggle_tool_button_new() instead.
    @available(*, deprecated)
    @inlinable init(stock stockID: UnsafePointer<gchar>!) {
        let rv = gtk_toggle_tool_button_new_from_stock(stockID)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkToggleToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_toggle_tool_button_new() instead.
    @available(*, deprecated)
    @inlinable static func toggleToolButtonNewFrom(stock stockID: UnsafePointer<gchar>!) -> ToolItemRef! {
        guard let rv = ToolItemRef(gconstpointer: gconstpointer(gtk_toggle_tool_button_new_from_stock(stockID))) else { return nil }
        return rv
    }
}

/// A `GtkToggleToolButton` is a `GtkToolItem` that contains a toggle
/// button.
/// 
/// Use `gtk_toggle_tool_button_new()` to create a new GtkToggleToolButton.
/// 
/// # CSS nodes
/// 
/// GtkToggleToolButton has a single CSS node with name togglebutton.
///
/// The `ToggleToolButton` type acts as a reference-counted owner of an underlying `GtkToggleToolButton` instance.
/// It provides the methods that can operate on this data type through `ToggleToolButtonProtocol` conformance.
/// Use `ToggleToolButton` as a strong reference or owner of a `GtkToggleToolButton` instance.
///
open class ToggleToolButton: ToolButton, ToggleToolButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleToolButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkToggleToolButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleToolButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkToggleToolButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleToolButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleToolButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleToolButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkToggleToolButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToggleToolButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkToggleToolButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkToggleToolButton`.
    /// i.e., ownership is transferred to the `ToggleToolButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkToggleToolButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ToggleToolButtonProtocol`
    /// Will retain `GtkToggleToolButton`.
    /// - Parameter other: an instance of a related type that implements `ToggleToolButtonProtocol`
    @inlinable public init<T: ToggleToolButtonProtocol>(toggleToolButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToggleToolButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Returns a new `GtkToggleToolButton`
    @inlinable public init() {
        let rv = gtk_toggle_tool_button_new()
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkToggleToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_toggle_tool_button_new() instead.
    @available(*, deprecated)
    @inlinable override public init(stock stockID: UnsafePointer<gchar>!) {
        let rv = gtk_toggle_tool_button_new_from_stock(stockID)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkToggleToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_toggle_tool_button_new() instead.
    @available(*, deprecated)
    @inlinable public static func toggleToolButtonNewFrom(stock stockID: UnsafePointer<gchar>!) -> ToolItem! {
        guard let rv = ToolItem(gconstpointer: gconstpointer(gtk_toggle_tool_button_new_from_stock(stockID))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum ToggleToolButtonPropertyName: String, PropertyNameProtocol {
    /// If the toggle tool button should be pressed in.
    case active = "active"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The name of the themed icon displayed on the item.
    /// This property only has an effect if not overridden by
    /// `GtkToolButton:label-widget`, `GtkToolButton:icon-widget` or
    /// `GtkToolButton:stock-id` properties.
    case iconName = "icon-name"
    case iconWidget = "icon-widget"
    case isFocus = "is-focus"
    case isImportant = "is-important"
    case label = "label"
    case labelWidget = "label-widget"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"

    ///
    /// **stock-id is deprecated:**
    /// Use #GtkToolButton:icon-name instead.
    case stockID = "stock-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case visibleHorizontal = "visible-horizontal"
    case visibleVertical = "visible-vertical"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ToggleToolButtonProtocol {
    /// Bind a `ToggleToolButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToggleToolButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ToggleToolButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ToggleToolButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ToggleToolButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ToggleToolButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ToggleToolButtonSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    case add = "add"
    /// The `button-press-event` signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button-release-event` signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child-notify` signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// This signal is emitted when the tool button is clicked with the mouse
    /// or activated with the keyboard.
    case clicked = "clicked"
    /// The `composited-changed` signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure-event` signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// This signal is emitted when the toolbar needs information from `tool_item`
    /// about whether the item should appear in the toolbar overflow menu. In
    /// response the tool item should either
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a `nil`
    ///   pointer and return `true` to indicate that the item should not appear
    ///   in the overflow menu
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a new menu
    ///   item and return `true`, or
    /// 
    /// - return `false` to indicate that the signal was not handled by the item.
    ///   This means that the item will not appear in the overflow menu unless
    ///   a later handler installs a menu item.
    /// 
    /// The toolbar may cache the result of this signal. When the tool item changes
    /// how it will respond to this signal it must call `gtk_tool_item_rebuild_menu()`
    /// to invalidate the cache and ensure that the toolbar rebuilds its overflow
    /// menu.
    case createMenuProxy = "create-menu-proxy"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete-event` signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy-event` signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction-changed` signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag-begin` signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag-data-delete` signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag-data-get` signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag-data-received` signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag-drop` signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag-drop` signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag-data-received` handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag-end` signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag-begin`.
    case dragEnd = "drag-end"
    /// The `drag-failed` signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag-leave` signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag-motion`, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag-leave` signal is also emitted before the
    /// `drag-drop` signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag-motion` signal handler.
    case dragLeave = "drag-leave"
    /// The `drag-motion` signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag-data-received`
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag-leave` and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter-notify-event` will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key-press-event`) and finally a generic
    /// `GtkWidget::event-after` signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event-after` will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The `focus-in-event` signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus-out-event` signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab-notify` signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy-changed` signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key-press-event` signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key-release-event` signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave-notify-event` will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map-event` will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map-event` signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion-notify-event` signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent-set` signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The `property-notify-event` signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has-tooltip` is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen-changed` signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll-event` signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection-clear-event` signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection-request-event` signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The `state-changed` signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state-flags-changed` signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style-set` signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style-updated` signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style-updated` signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// Emitted whenever the toggle tool button changes state.
    case toggled = "toggled"
    /// This signal is emitted when some property of the toolbar that the
    /// item is a child of changes. For custom subclasses of `GtkToolItem`,
    /// the default handler of this signal use the functions
    /// - `gtk_tool_shell_get_orientation()`
    /// - `gtk_tool_shell_get_style()`
    /// - `gtk_tool_shell_get_icon_size()`
    /// - `gtk_tool_shell_get_relief_style()`
    /// to find out what the toolbar should look like and change
    /// themselves accordingly.
    case toolbarReconfigured = "toolbar-reconfigured"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap-event` signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility-notify-event` will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The `window-state-event` will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    /// If the toggle tool button should be pressed in.
    case notifyActive = "notify::active"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The name of the themed icon displayed on the item.
    /// This property only has an effect if not overridden by
    /// `GtkToolButton:label-widget`, `GtkToolButton:icon-widget` or
    /// `GtkToolButton:stock-id` properties.
    case notifyIconName = "notify::icon-name"
    case notifyIconWidget = "notify::icon-widget"
    case notifyIsFocus = "notify::is-focus"
    case notifyIsImportant = "notify::is-important"
    case notifyLabel = "notify::label"
    case notifyLabelWidget = "notify::label-widget"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"

    ///
    /// **stock-id is deprecated:**
    /// Use #GtkToolButton:icon-name instead.
    case notifyStockID = "notify::stock-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyVisibleHorizontal = "notify::visible-horizontal"
    case notifyVisibleVertical = "notify::visible-vertical"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

// MARK: ToggleToolButton signals
public extension ToggleToolButtonProtocol {
    /// Connect a Swift signal handler to the given, typed `ToggleToolButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToggleToolButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ToggleToolButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToggleToolButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted whenever the toggle tool button changes state.
    /// - Note: This represents the underlying `toggled` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggled` signal is emitted
    @discardableResult @inlinable func onToggled(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToggleToolButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ToggleToolButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToggleToolButtonRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .toggled,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggled` signal for using the `connect(signal:)` methods
    static var toggledSignal: ToggleToolButtonSignalName { .toggled }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActive` signal is emitted
    @discardableResult @inlinable func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToggleToolButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToggleToolButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToggleToolButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active` signal for using the `connect(signal:)` methods
    static var notifyActiveSignal: ToggleToolButtonSignalName { .notifyActive }
    
}

// MARK: ToggleToolButton Class: ToggleToolButtonProtocol extension (methods and fields)
public extension ToggleToolButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToggleToolButton` instance.
    @inlinable var toggle_tool_button_ptr: UnsafeMutablePointer<GtkToggleToolButton>! { return ptr?.assumingMemoryBound(to: GtkToggleToolButton.self) }

    /// Queries a `GtkToggleToolButton` and returns its current state.
    /// Returns `true` if the toggle button is pressed in and `false` if it is raised.
    @inlinable func getActive() -> Bool {
        let rv = ((gtk_toggle_tool_button_get_active(toggle_tool_button_ptr)) != 0)
        return rv
    }

    /// Sets the status of the toggle tool button. Set to `true` if you
    /// want the GtkToggleButton to be “pressed in”, and `false` to raise it.
    /// This action causes the toggled signal to be emitted.
    @inlinable func setActive(isActive: Bool) {
        gtk_toggle_tool_button_set_active(toggle_tool_button_ptr, gboolean((isActive) ? 1 : 0))
    
    }
    /// If the toggle tool button should be pressed in.
    @inlinable var active: Bool {
        /// Queries a `GtkToggleToolButton` and returns its current state.
        /// Returns `true` if the toggle button is pressed in and `false` if it is raised.
        get {
            let rv = ((gtk_toggle_tool_button_get_active(toggle_tool_button_ptr)) != 0)
            return rv
        }
        /// Sets the status of the toggle tool button. Set to `true` if you
        /// want the GtkToggleButton to be “pressed in”, and `false` to raise it.
        /// This action causes the toggled signal to be emitted.
        nonmutating set {
            gtk_toggle_tool_button_set_active(toggle_tool_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var parent: GtkToolButton {
        get {
            let rv = toggle_tool_button_ptr.pointee.parent
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - ToolButton Class

/// `GtkToolButtons` are `GtkToolItems` containing buttons.
/// 
/// Use `gtk_tool_button_new()` to create a new `GtkToolButton`.
/// 
/// The label of a `GtkToolButton` is determined by the properties
/// `GtkToolButton:label-widget`, `GtkToolButton:label`, and
/// `GtkToolButton:stock-id`. If `GtkToolButton:label-widget` is
/// non-`nil`, then that widget is used as the label. Otherwise, if
/// `GtkToolButton:label` is non-`nil`, that string is used as the label.
/// Otherwise, if `GtkToolButton:stock-id` is non-`nil`, the label is
/// determined by the stock item. Otherwise, the button does not have a label.
/// 
/// The icon of a `GtkToolButton` is determined by the properties
/// `GtkToolButton:icon-widget` and `GtkToolButton:stock-id`. If
/// `GtkToolButton:icon-widget` is non-`nil`, then
/// that widget is used as the icon. Otherwise, if `GtkToolButton:stock-id` is
/// non-`nil`, the icon is determined by the stock item. Otherwise,
/// the button does not have a icon.
/// 
/// # CSS nodes
/// 
/// GtkToolButton has a single CSS node with name toolbutton.
///
/// The `ToolButtonProtocol` protocol exposes the methods and properties of an underlying `GtkToolButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToolButton`.
/// Alternatively, use `ToolButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ToolButtonProtocol: ToolItemProtocol, ActionableProtocol {
        /// Untyped pointer to the underlying `GtkToolButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkToolButton` instance.
    var tool_button_ptr: UnsafeMutablePointer<GtkToolButton>! { get }

    /// Required Initialiser for types conforming to `ToolButtonProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkToolButtons` are `GtkToolItems` containing buttons.
/// 
/// Use `gtk_tool_button_new()` to create a new `GtkToolButton`.
/// 
/// The label of a `GtkToolButton` is determined by the properties
/// `GtkToolButton:label-widget`, `GtkToolButton:label`, and
/// `GtkToolButton:stock-id`. If `GtkToolButton:label-widget` is
/// non-`nil`, then that widget is used as the label. Otherwise, if
/// `GtkToolButton:label` is non-`nil`, that string is used as the label.
/// Otherwise, if `GtkToolButton:stock-id` is non-`nil`, the label is
/// determined by the stock item. Otherwise, the button does not have a label.
/// 
/// The icon of a `GtkToolButton` is determined by the properties
/// `GtkToolButton:icon-widget` and `GtkToolButton:stock-id`. If
/// `GtkToolButton:icon-widget` is non-`nil`, then
/// that widget is used as the icon. Otherwise, if `GtkToolButton:stock-id` is
/// non-`nil`, the icon is determined by the stock item. Otherwise,
/// the button does not have a icon.
/// 
/// # CSS nodes
/// 
/// GtkToolButton has a single CSS node with name toolbutton.
///
/// The `ToolButtonRef` type acts as a lightweight Swift reference to an underlying `GtkToolButton` instance.
/// It exposes methods that can operate on this data type through `ToolButtonProtocol` conformance.
/// Use `ToolButtonRef` only as an `unowned` reference to an existing `GtkToolButton` instance.
///
public struct ToolButtonRef: ToolButtonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkToolButton` instance.
    /// For type-safe access, use the generated, typed pointer `tool_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ToolButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkToolButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkToolButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkToolButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkToolButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ToolButtonProtocol`
    @inlinable init<T: ToolButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ToolButtonProtocol>(_ other: T) -> ToolButtonRef { ToolButtonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkToolButton` using `icon_widget` as contents and `label` as
    /// label.
    @inlinable init<WidgetT: WidgetProtocol>( iconWidget: WidgetT?, label: UnsafePointer<gchar>? = nil) {
        let rv = gtk_tool_button_new(iconWidget?.widget_ptr, label)
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_tool_button_new() together with
    /// gtk_image_new_from_icon_name() instead.
    @available(*, deprecated)
    @inlinable init(stock stockID: UnsafePointer<gchar>!) {
        let rv = gtk_tool_button_new_from_stock(stockID)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_tool_button_new() together with
    /// gtk_image_new_from_icon_name() instead.
    @available(*, deprecated)
    @inlinable static func newFrom(stock stockID: UnsafePointer<gchar>!) -> ToolItemRef! {
        guard let rv = ToolItemRef(gconstpointer: gconstpointer(gtk_tool_button_new_from_stock(stockID))) else { return nil }
        return rv
    }
}

/// `GtkToolButtons` are `GtkToolItems` containing buttons.
/// 
/// Use `gtk_tool_button_new()` to create a new `GtkToolButton`.
/// 
/// The label of a `GtkToolButton` is determined by the properties
/// `GtkToolButton:label-widget`, `GtkToolButton:label`, and
/// `GtkToolButton:stock-id`. If `GtkToolButton:label-widget` is
/// non-`nil`, then that widget is used as the label. Otherwise, if
/// `GtkToolButton:label` is non-`nil`, that string is used as the label.
/// Otherwise, if `GtkToolButton:stock-id` is non-`nil`, the label is
/// determined by the stock item. Otherwise, the button does not have a label.
/// 
/// The icon of a `GtkToolButton` is determined by the properties
/// `GtkToolButton:icon-widget` and `GtkToolButton:stock-id`. If
/// `GtkToolButton:icon-widget` is non-`nil`, then
/// that widget is used as the icon. Otherwise, if `GtkToolButton:stock-id` is
/// non-`nil`, the icon is determined by the stock item. Otherwise,
/// the button does not have a icon.
/// 
/// # CSS nodes
/// 
/// GtkToolButton has a single CSS node with name toolbutton.
///
/// The `ToolButton` type acts as a reference-counted owner of an underlying `GtkToolButton` instance.
/// It provides the methods that can operate on this data type through `ToolButtonProtocol` conformance.
/// Use `ToolButton` as a strong reference or owner of a `GtkToolButton` instance.
///
open class ToolButton: ToolItem, ToolButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkToolButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkToolButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkToolButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkToolButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkToolButton`.
    /// i.e., ownership is transferred to the `ToolButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkToolButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ToolButtonProtocol`
    /// Will retain `GtkToolButton`.
    /// - Parameter other: an instance of a related type that implements `ToolButtonProtocol`
    @inlinable public init<T: ToolButtonProtocol>(toolButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkToolButton` using `icon_widget` as contents and `label` as
    /// label.
    @inlinable public init<WidgetT: WidgetProtocol>( iconWidget: WidgetT?, label: UnsafePointer<gchar>? = nil) {
        let rv = gtk_tool_button_new(iconWidget?.widget_ptr, label)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_tool_button_new() together with
    /// gtk_image_new_from_icon_name() instead.
    @available(*, deprecated)
    @inlinable public init(stock stockID: UnsafePointer<gchar>!) {
        let rv = gtk_tool_button_new_from_stock(stockID)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkToolButton` containing the image and text from a
    /// stock item. Some stock ids have preprocessor macros like `GTK_STOCK_OK`
    /// and `GTK_STOCK_APPLY`.
    /// 
    /// It is an error if `stock_id` is not a name of a stock item.
    ///
    /// **new_from_stock is deprecated:**
    /// Use gtk_tool_button_new() together with
    /// gtk_image_new_from_icon_name() instead.
    @available(*, deprecated)
    @inlinable public static func newFrom(stock stockID: UnsafePointer<gchar>!) -> ToolItem! {
        guard let rv = ToolItem(gconstpointer: gconstpointer(gtk_tool_button_new_from_stock(stockID))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum ToolButtonPropertyName: String, PropertyNameProtocol {
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The name of the themed icon displayed on the item.
    /// This property only has an effect if not overridden by
    /// `GtkToolButton:label-widget`, `GtkToolButton:icon-widget` or
    /// `GtkToolButton:stock-id` properties.
    case iconName = "icon-name"
    case iconWidget = "icon-widget"
    case isFocus = "is-focus"
    case isImportant = "is-important"
    case label = "label"
    case labelWidget = "label-widget"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"

    ///
    /// **stock-id is deprecated:**
    /// Use #GtkToolButton:icon-name instead.
    case stockID = "stock-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case visibleHorizontal = "visible-horizontal"
    case visibleVertical = "visible-vertical"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ToolButtonProtocol {
    /// Bind a `ToolButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToolButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ToolButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ToolButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ToolButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ToolButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ToolButtonSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    case add = "add"
    /// The `button-press-event` signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button-release-event` signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child-notify` signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// This signal is emitted when the tool button is clicked with the mouse
    /// or activated with the keyboard.
    case clicked = "clicked"
    /// The `composited-changed` signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure-event` signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// This signal is emitted when the toolbar needs information from `tool_item`
    /// about whether the item should appear in the toolbar overflow menu. In
    /// response the tool item should either
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a `nil`
    ///   pointer and return `true` to indicate that the item should not appear
    ///   in the overflow menu
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a new menu
    ///   item and return `true`, or
    /// 
    /// - return `false` to indicate that the signal was not handled by the item.
    ///   This means that the item will not appear in the overflow menu unless
    ///   a later handler installs a menu item.
    /// 
    /// The toolbar may cache the result of this signal. When the tool item changes
    /// how it will respond to this signal it must call `gtk_tool_item_rebuild_menu()`
    /// to invalidate the cache and ensure that the toolbar rebuilds its overflow
    /// menu.
    case createMenuProxy = "create-menu-proxy"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete-event` signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy-event` signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction-changed` signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag-begin` signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag-data-delete` signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag-data-get` signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag-data-received` signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag-drop` signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag-drop` signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag-data-received` handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag-end` signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag-begin`.
    case dragEnd = "drag-end"
    /// The `drag-failed` signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag-leave` signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag-motion`, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag-leave` signal is also emitted before the
    /// `drag-drop` signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag-motion` signal handler.
    case dragLeave = "drag-leave"
    /// The `drag-motion` signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag-data-received`
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag-leave` and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter-notify-event` will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key-press-event`) and finally a generic
    /// `GtkWidget::event-after` signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event-after` will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The `focus-in-event` signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus-out-event` signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab-notify` signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy-changed` signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key-press-event` signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key-release-event` signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave-notify-event` will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map-event` will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map-event` signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion-notify-event` signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent-set` signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The `property-notify-event` signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has-tooltip` is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen-changed` signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll-event` signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection-clear-event` signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection-request-event` signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The `state-changed` signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state-flags-changed` signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style-set` signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style-updated` signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style-updated` signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// This signal is emitted when some property of the toolbar that the
    /// item is a child of changes. For custom subclasses of `GtkToolItem`,
    /// the default handler of this signal use the functions
    /// - `gtk_tool_shell_get_orientation()`
    /// - `gtk_tool_shell_get_style()`
    /// - `gtk_tool_shell_get_icon_size()`
    /// - `gtk_tool_shell_get_relief_style()`
    /// to find out what the toolbar should look like and change
    /// themselves accordingly.
    case toolbarReconfigured = "toolbar-reconfigured"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap-event` signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility-notify-event` will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The `window-state-event` will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The name of the themed icon displayed on the item.
    /// This property only has an effect if not overridden by
    /// `GtkToolButton:label-widget`, `GtkToolButton:icon-widget` or
    /// `GtkToolButton:stock-id` properties.
    case notifyIconName = "notify::icon-name"
    case notifyIconWidget = "notify::icon-widget"
    case notifyIsFocus = "notify::is-focus"
    case notifyIsImportant = "notify::is-important"
    case notifyLabel = "notify::label"
    case notifyLabelWidget = "notify::label-widget"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"

    ///
    /// **stock-id is deprecated:**
    /// Use #GtkToolButton:icon-name instead.
    case notifyStockID = "notify::stock-id"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyVisibleHorizontal = "notify::visible-horizontal"
    case notifyVisibleVertical = "notify::visible-vertical"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

// MARK: ToolButton signals
public extension ToolButtonProtocol {
    /// Connect a Swift signal handler to the given, typed `ToolButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToolButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ToolButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToolButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// This signal is emitted when the tool button is clicked with the mouse
    /// or activated with the keyboard.
    /// - Note: This represents the underlying `clicked` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `clicked` signal is emitted
    @discardableResult @inlinable func onClicked(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ToolButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolButtonRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .clicked,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `clicked` signal for using the `connect(signal:)` methods
    static var clickedSignal: ToolButtonSignalName { .clicked }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::icon-name` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIconName` signal is emitted
    @discardableResult @inlinable func onNotifyIconName(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyIconName,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::icon-name` signal for using the `connect(signal:)` methods
    static var notifyIconNameSignal: ToolButtonSignalName { .notifyIconName }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::icon-widget` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIconWidget` signal is emitted
    @discardableResult @inlinable func onNotifyIconWidget(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyIconWidget,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::icon-widget` signal for using the `connect(signal:)` methods
    static var notifyIconWidgetSignal: ToolButtonSignalName { .notifyIconWidget }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::label` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLabel` signal is emitted
    @discardableResult @inlinable func onNotifyLabel(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLabel,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::label` signal for using the `connect(signal:)` methods
    static var notifyLabelSignal: ToolButtonSignalName { .notifyLabel }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::label-widget` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLabelWidget` signal is emitted
    @discardableResult @inlinable func onNotifyLabelWidget(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLabelWidget,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::label-widget` signal for using the `connect(signal:)` methods
    static var notifyLabelWidgetSignal: ToolButtonSignalName { .notifyLabelWidget }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::stock-id` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStockID` signal is emitted
    @discardableResult @inlinable func onNotifyStockID(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStockID,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::stock-id` signal for using the `connect(signal:)` methods
    static var notifyStockIDSignal: ToolButtonSignalName { .notifyStockID }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::use-underline` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUseUnderline` signal is emitted
    @discardableResult @inlinable func onNotifyUseUnderline(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyUseUnderline,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::use-underline` signal for using the `connect(signal:)` methods
    static var notifyUseUnderlineSignal: ToolButtonSignalName { .notifyUseUnderline }
    
}

// MARK: ToolButton Class: ToolButtonProtocol extension (methods and fields)
public extension ToolButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToolButton` instance.
    @inlinable var tool_button_ptr: UnsafeMutablePointer<GtkToolButton>! { return ptr?.assumingMemoryBound(to: GtkToolButton.self) }

    /// Returns the name of the themed icon for the tool button,
    /// see `gtk_tool_button_set_icon_name()`.
    @inlinable func getIconName() -> String! {
        let rv = gtk_tool_button_get_icon_name(tool_button_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Return the widget used as icon widget on `button`.
    /// See `gtk_tool_button_set_icon_widget()`.
    @inlinable func getIconWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tool_button_get_icon_widget(tool_button_ptr))) else { return nil }
        return rv
    }

    /// Returns the label used by the tool button, or `nil` if the tool button
    /// doesn’t have a label. or uses a the label from a stock item. The returned
    /// string is owned by GTK+, and must not be modified or freed.
    @inlinable func getLabel() -> String! {
        let rv = gtk_tool_button_get_label(tool_button_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns the widget used as label on `button`.
    /// See `gtk_tool_button_set_label_widget()`.
    @inlinable func getLabelWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tool_button_get_label_widget(tool_button_ptr))) else { return nil }
        return rv
    }

    /// Returns the name of the stock item. See `gtk_tool_button_set_stock_id()`.
    /// The returned string is owned by GTK+ and must not be freed or modifed.
    ///
    /// **get_stock_id is deprecated:**
    /// Use gtk_tool_button_get_icon_name() instead.
    @available(*, deprecated)
    @inlinable func getStockID() -> String! {
        let rv = gtk_tool_button_get_stock_id(tool_button_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns whether underscores in the label property are used as mnemonics
    /// on menu items on the overflow menu. See `gtk_tool_button_set_use_underline()`.
    @inlinable func getUseUnderline() -> Bool {
        let rv = ((gtk_tool_button_get_use_underline(tool_button_ptr)) != 0)
        return rv
    }

    /// Sets the icon for the tool button from a named themed icon.
    /// See the docs for `GtkIconTheme` for more details.
    /// The `GtkToolButton:icon-name` property only has an effect if not
    /// overridden by non-`nil` `GtkToolButton:label-widget`,
    /// `GtkToolButton:icon-widget` and `GtkToolButton:stock-id` properties.
    @inlinable func set(iconName: UnsafePointer<gchar>? = nil) {
        gtk_tool_button_set_icon_name(tool_button_ptr, iconName)
    
    }

    /// Sets `icon` as the widget used as icon on `button`. If `icon_widget` is
    /// `nil` the icon is determined by the `GtkToolButton:stock-id` property. If the
    /// `GtkToolButton:stock-id` property is also `nil`, `button` will not have an icon.
    @inlinable func set(iconWidget: WidgetRef? = nil) {
        gtk_tool_button_set_icon_widget(tool_button_ptr, iconWidget?.widget_ptr)
    
    }
    /// Sets `icon` as the widget used as icon on `button`. If `icon_widget` is
    /// `nil` the icon is determined by the `GtkToolButton:stock-id` property. If the
    /// `GtkToolButton:stock-id` property is also `nil`, `button` will not have an icon.
    @inlinable func set<WidgetT: WidgetProtocol>(iconWidget: WidgetT?) {
        gtk_tool_button_set_icon_widget(tool_button_ptr, iconWidget?.widget_ptr)
    
    }

    /// Sets `label` as the label used for the tool button. The `GtkToolButton:label`
    /// property only has an effect if not overridden by a non-`nil`
    /// `GtkToolButton:label-widget` property. If both the `GtkToolButton:label-widget`
    /// and `GtkToolButton:label` properties are `nil`, the label is determined by the
    /// `GtkToolButton:stock-id` property. If the `GtkToolButton:stock-id` property is
    /// also `nil`, `button` will not have a label.
    @inlinable func set(label: UnsafePointer<gchar>? = nil) {
        gtk_tool_button_set_label(tool_button_ptr, label)
    
    }

    /// Sets `label_widget` as the widget that will be used as the label
    /// for `button`. If `label_widget` is `nil` the `GtkToolButton:label` property is used
    /// as label. If `GtkToolButton:label` is also `nil`, the label in the stock item
    /// determined by the `GtkToolButton:stock-id` property is used as label. If
    /// `GtkToolButton:stock-id` is also `nil`, `button` does not have a label.
    @inlinable func set(labelWidget: WidgetRef? = nil) {
        gtk_tool_button_set_label_widget(tool_button_ptr, labelWidget?.widget_ptr)
    
    }
    /// Sets `label_widget` as the widget that will be used as the label
    /// for `button`. If `label_widget` is `nil` the `GtkToolButton:label` property is used
    /// as label. If `GtkToolButton:label` is also `nil`, the label in the stock item
    /// determined by the `GtkToolButton:stock-id` property is used as label. If
    /// `GtkToolButton:stock-id` is also `nil`, `button` does not have a label.
    @inlinable func set<WidgetT: WidgetProtocol>(labelWidget: WidgetT?) {
        gtk_tool_button_set_label_widget(tool_button_ptr, labelWidget?.widget_ptr)
    
    }

    /// Sets the name of the stock item. See `gtk_tool_button_new_from_stock()`.
    /// The stock_id property only has an effect if not overridden by non-`nil`
    /// `GtkToolButton:label-widget` and `GtkToolButton:icon-widget` properties.
    ///
    /// **set_stock_id is deprecated:**
    /// Use gtk_tool_button_set_icon_name() instead.
    @available(*, deprecated)
    @inlinable func set(stockID: UnsafePointer<gchar>? = nil) {
        gtk_tool_button_set_stock_id(tool_button_ptr, stockID)
    
    }

    /// If set, an underline in the label property indicates that the next character
    /// should be used for the mnemonic accelerator key in the overflow menu. For
    /// example, if the label property is “_Open” and `use_underline` is `true`,
    /// the label on the tool button will be “Open” and the item on the overflow
    /// menu will have an underlined “O”.
    /// 
    /// Labels shown on tool buttons never have mnemonics on them; this property
    /// only affects the menu item on the overflow menu.
    @inlinable func set(useUnderline: Bool) {
        gtk_tool_button_set_use_underline(tool_button_ptr, gboolean((useUnderline) ? 1 : 0))
    
    }
    /// Returns the name of the themed icon for the tool button,
    /// see `gtk_tool_button_set_icon_name()`.
    @inlinable var iconName: String! {
        /// Returns the name of the themed icon for the tool button,
        /// see `gtk_tool_button_set_icon_name()`.
        get {
            let rv = gtk_tool_button_get_icon_name(tool_button_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the icon for the tool button from a named themed icon.
        /// See the docs for `GtkIconTheme` for more details.
        /// The `GtkToolButton:icon-name` property only has an effect if not
        /// overridden by non-`nil` `GtkToolButton:label-widget`,
        /// `GtkToolButton:icon-widget` and `GtkToolButton:stock-id` properties.
        nonmutating set {
            gtk_tool_button_set_icon_name(tool_button_ptr, newValue)
        }
    }

    /// Return the widget used as icon widget on `button`.
    /// See `gtk_tool_button_set_icon_widget()`.
    @inlinable var iconWidget: WidgetRef! {
        /// Return the widget used as icon widget on `button`.
        /// See `gtk_tool_button_set_icon_widget()`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tool_button_get_icon_widget(tool_button_ptr))) else { return nil }
            return rv
        }
        /// Sets `icon` as the widget used as icon on `button`. If `icon_widget` is
        /// `nil` the icon is determined by the `GtkToolButton:stock-id` property. If the
        /// `GtkToolButton:stock-id` property is also `nil`, `button` will not have an icon.
        nonmutating set {
            gtk_tool_button_set_icon_widget(tool_button_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    @inlinable var label: String! {
        /// Returns the label used by the tool button, or `nil` if the tool button
        /// doesn’t have a label. or uses a the label from a stock item. The returned
        /// string is owned by GTK+, and must not be modified or freed.
        get {
            let rv = gtk_tool_button_get_label(tool_button_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets `label` as the label used for the tool button. The `GtkToolButton:label`
        /// property only has an effect if not overridden by a non-`nil`
        /// `GtkToolButton:label-widget` property. If both the `GtkToolButton:label-widget`
        /// and `GtkToolButton:label` properties are `nil`, the label is determined by the
        /// `GtkToolButton:stock-id` property. If the `GtkToolButton:stock-id` property is
        /// also `nil`, `button` will not have a label.
        nonmutating set {
            gtk_tool_button_set_label(tool_button_ptr, newValue)
        }
    }

    /// Returns the widget used as label on `button`.
    /// See `gtk_tool_button_set_label_widget()`.
    @inlinable var labelWidget: WidgetRef! {
        /// Returns the widget used as label on `button`.
        /// See `gtk_tool_button_set_label_widget()`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tool_button_get_label_widget(tool_button_ptr))) else { return nil }
            return rv
        }
        /// Sets `label_widget` as the widget that will be used as the label
        /// for `button`. If `label_widget` is `nil` the `GtkToolButton:label` property is used
        /// as label. If `GtkToolButton:label` is also `nil`, the label in the stock item
        /// determined by the `GtkToolButton:stock-id` property is used as label. If
        /// `GtkToolButton:stock-id` is also `nil`, `button` does not have a label.
        nonmutating set {
            gtk_tool_button_set_label_widget(tool_button_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Returns the name of the stock item. See `gtk_tool_button_set_stock_id()`.
    /// The returned string is owned by GTK+ and must not be freed or modifed.
    ///
    /// **get_stock_id is deprecated:**
    /// Use gtk_tool_button_get_icon_name() instead.
    @inlinable var stockID: String! {
        /// Returns the name of the stock item. See `gtk_tool_button_set_stock_id()`.
        /// The returned string is owned by GTK+ and must not be freed or modifed.
        ///
        /// **get_stock_id is deprecated:**
        /// Use gtk_tool_button_get_icon_name() instead.
        @available(*, deprecated)
    get {
            let rv = gtk_tool_button_get_stock_id(tool_button_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the name of the stock item. See `gtk_tool_button_new_from_stock()`.
        /// The stock_id property only has an effect if not overridden by non-`nil`
        /// `GtkToolButton:label-widget` and `GtkToolButton:icon-widget` properties.
        ///
        /// **set_stock_id is deprecated:**
        /// Use gtk_tool_button_set_icon_name() instead.
        @available(*, deprecated)
    nonmutating set {
            gtk_tool_button_set_stock_id(tool_button_ptr, newValue)
        }
    }

    /// Returns whether underscores in the label property are used as mnemonics
    /// on menu items on the overflow menu. See `gtk_tool_button_set_use_underline()`.
    @inlinable var useUnderline: Bool {
        /// Returns whether underscores in the label property are used as mnemonics
        /// on menu items on the overflow menu. See `gtk_tool_button_set_use_underline()`.
        get {
            let rv = ((gtk_tool_button_get_use_underline(tool_button_ptr)) != 0)
            return rv
        }
        /// If set, an underline in the label property indicates that the next character
        /// should be used for the mnemonic accelerator key in the overflow menu. For
        /// example, if the label property is “_Open” and `use_underline` is `true`,
        /// the label on the tool button will be “Open” and the item on the overflow
        /// menu will have an underlined “O”.
        /// 
        /// Labels shown on tool buttons never have mnemonics on them; this property
        /// only affects the menu item on the overflow menu.
        nonmutating set {
            gtk_tool_button_set_use_underline(tool_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var parent: GtkToolItem {
        get {
            let rv = tool_button_ptr.pointee.parent
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - ToolItem Class

/// `GtkToolItems` are widgets that can appear on a toolbar. To
/// create a toolbar item that contain something else than a button, use
/// `gtk_tool_item_new()`. Use `gtk_container_add()` to add a child
/// widget to the tool item.
/// 
/// For toolbar items that contain buttons, see the `GtkToolButton`,
/// `GtkToggleToolButton` and `GtkRadioToolButton` classes.
/// 
/// See the `GtkToolbar` class for a description of the toolbar widget, and
/// `GtkToolShell` for a description of the tool shell interface.
///
/// The `ToolItemProtocol` protocol exposes the methods and properties of an underlying `GtkToolItem` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToolItem`.
/// Alternatively, use `ToolItemRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ToolItemProtocol: BinProtocol, ActivatableProtocol {
        /// Untyped pointer to the underlying `GtkToolItem` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkToolItem` instance.
    var tool_item_ptr: UnsafeMutablePointer<GtkToolItem>! { get }

    /// Required Initialiser for types conforming to `ToolItemProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkToolItems` are widgets that can appear on a toolbar. To
/// create a toolbar item that contain something else than a button, use
/// `gtk_tool_item_new()`. Use `gtk_container_add()` to add a child
/// widget to the tool item.
/// 
/// For toolbar items that contain buttons, see the `GtkToolButton`,
/// `GtkToggleToolButton` and `GtkRadioToolButton` classes.
/// 
/// See the `GtkToolbar` class for a description of the toolbar widget, and
/// `GtkToolShell` for a description of the tool shell interface.
///
/// The `ToolItemRef` type acts as a lightweight Swift reference to an underlying `GtkToolItem` instance.
/// It exposes methods that can operate on this data type through `ToolItemProtocol` conformance.
/// Use `ToolItemRef` only as an `unowned` reference to an existing `GtkToolItem` instance.
///
public struct ToolItemRef: ToolItemProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkToolItem` instance.
    /// For type-safe access, use the generated, typed pointer `tool_item_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ToolItemRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkToolItem>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkToolItem>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkToolItem>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkToolItem>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ToolItemProtocol`
    @inlinable init<T: ToolItemProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ToolItemProtocol>(_ other: T) -> ToolItemRef { ToolItemRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkToolItem`
    @inlinable init() {
        let rv = gtk_tool_item_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkToolItems` are widgets that can appear on a toolbar. To
/// create a toolbar item that contain something else than a button, use
/// `gtk_tool_item_new()`. Use `gtk_container_add()` to add a child
/// widget to the tool item.
/// 
/// For toolbar items that contain buttons, see the `GtkToolButton`,
/// `GtkToggleToolButton` and `GtkRadioToolButton` classes.
/// 
/// See the `GtkToolbar` class for a description of the toolbar widget, and
/// `GtkToolShell` for a description of the tool shell interface.
///
/// The `ToolItem` type acts as a reference-counted owner of an underlying `GtkToolItem` instance.
/// It provides the methods that can operate on this data type through `ToolItemProtocol` conformance.
/// Use `ToolItem` as a strong reference or owner of a `GtkToolItem` instance.
///
open class ToolItem: Bin, ToolItemProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolItem` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkToolItem>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolItem` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkToolItem>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolItem` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolItem` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolItem` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkToolItem>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolItem` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkToolItem>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkToolItem`.
    /// i.e., ownership is transferred to the `ToolItem` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkToolItem>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ToolItemProtocol`
    /// Will retain `GtkToolItem`.
    /// - Parameter other: an instance of a related type that implements `ToolItemProtocol`
    @inlinable public init<T: ToolItemProtocol>(toolItem other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkToolItem`
    @inlinable public init() {
        let rv = gtk_tool_item_new()
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ToolItemPropertyName: String, PropertyNameProtocol {
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case isFocus = "is-focus"
    case isImportant = "is-important"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case visibleHorizontal = "visible-horizontal"
    case visibleVertical = "visible-vertical"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ToolItemProtocol {
    /// Bind a `ToolItemPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToolItemPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ToolItem property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ToolItemPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ToolItem property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ToolItemPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ToolItemSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    case add = "add"
    /// The `button-press-event` signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button-release-event` signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child-notify` signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The `composited-changed` signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure-event` signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// This signal is emitted when the toolbar needs information from `tool_item`
    /// about whether the item should appear in the toolbar overflow menu. In
    /// response the tool item should either
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a `nil`
    ///   pointer and return `true` to indicate that the item should not appear
    ///   in the overflow menu
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a new menu
    ///   item and return `true`, or
    /// 
    /// - return `false` to indicate that the signal was not handled by the item.
    ///   This means that the item will not appear in the overflow menu unless
    ///   a later handler installs a menu item.
    /// 
    /// The toolbar may cache the result of this signal. When the tool item changes
    /// how it will respond to this signal it must call `gtk_tool_item_rebuild_menu()`
    /// to invalidate the cache and ensure that the toolbar rebuilds its overflow
    /// menu.
    case createMenuProxy = "create-menu-proxy"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete-event` signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy-event` signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction-changed` signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag-begin` signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag-data-delete` signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag-data-get` signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag-data-received` signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag-drop` signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag-drop` signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag-data-received` handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag-end` signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag-begin`.
    case dragEnd = "drag-end"
    /// The `drag-failed` signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag-leave` signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag-motion`, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag-leave` signal is also emitted before the
    /// `drag-drop` signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag-motion` signal handler.
    case dragLeave = "drag-leave"
    /// The `drag-motion` signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag-data-received`
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag-leave` and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter-notify-event` will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key-press-event`) and finally a generic
    /// `GtkWidget::event-after` signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event-after` will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The `focus-in-event` signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus-out-event` signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab-notify` signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy-changed` signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key-press-event` signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key-release-event` signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave-notify-event` will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map-event` will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map-event` signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion-notify-event` signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent-set` signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The `property-notify-event` signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has-tooltip` is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen-changed` signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll-event` signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection-clear-event` signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection-request-event` signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The `state-changed` signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state-flags-changed` signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style-set` signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style-updated` signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style-updated` signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// This signal is emitted when some property of the toolbar that the
    /// item is a child of changes. For custom subclasses of `GtkToolItem`,
    /// the default handler of this signal use the functions
    /// - `gtk_tool_shell_get_orientation()`
    /// - `gtk_tool_shell_get_style()`
    /// - `gtk_tool_shell_get_icon_size()`
    /// - `gtk_tool_shell_get_relief_style()`
    /// to find out what the toolbar should look like and change
    /// themselves accordingly.
    case toolbarReconfigured = "toolbar-reconfigured"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap-event` signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility-notify-event` will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The `window-state-event` will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyIsFocus = "notify::is-focus"
    case notifyIsImportant = "notify::is-important"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyVisibleHorizontal = "notify::visible-horizontal"
    case notifyVisibleVertical = "notify::visible-vertical"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

// MARK: ToolItem signals
public extension ToolItemProtocol {
    /// Connect a Swift signal handler to the given, typed `ToolItemSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToolItemSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ToolItemSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToolItemSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// This signal is emitted when the toolbar needs information from `tool_item`
    /// about whether the item should appear in the toolbar overflow menu. In
    /// response the tool item should either
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a `nil`
    ///   pointer and return `true` to indicate that the item should not appear
    ///   in the overflow menu
    /// 
    /// - call `gtk_tool_item_set_proxy_menu_item()` with a new menu
    ///   item and return `true`, or
    /// 
    /// - return `false` to indicate that the signal was not handled by the item.
    ///   This means that the item will not appear in the overflow menu unless
    ///   a later handler installs a menu item.
    /// 
    /// The toolbar may cache the result of this signal. When the tool item changes
    /// how it will respond to this signal it must call `gtk_tool_item_rebuild_menu()`
    /// to invalidate the cache and ensure that the toolbar rebuilds its overflow
    /// menu.
    /// - Note: This represents the underlying `create-menu-proxy` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: `true` if the signal was handled, `false` if not
    /// Run the given callback whenever the `createMenuProxy` signal is emitted
    @discardableResult @inlinable func onCreateMenuProxy(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolItemRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ToolItemRef, Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(ToolItemRef(raw: unownedSelf))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .createMenuProxy,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `create-menu-proxy` signal for using the `connect(signal:)` methods
    static var createMenuProxySignal: ToolItemSignalName { .createMenuProxy }
    
    /// This signal is emitted when some property of the toolbar that the
    /// item is a child of changes. For custom subclasses of `GtkToolItem`,
    /// the default handler of this signal use the functions
    /// - `gtk_tool_shell_get_orientation()`
    /// - `gtk_tool_shell_get_style()`
    /// - `gtk_tool_shell_get_icon_size()`
    /// - `gtk_tool_shell_get_relief_style()`
    /// to find out what the toolbar should look like and change
    /// themselves accordingly.
    /// - Note: This represents the underlying `toolbar-reconfigured` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toolbarReconfigured` signal is emitted
    @discardableResult @inlinable func onToolbarReconfigured(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolItemRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ToolItemRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolItemRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .toolbarReconfigured,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toolbar-reconfigured` signal for using the `connect(signal:)` methods
    static var toolbarReconfiguredSignal: ToolItemSignalName { .toolbarReconfigured }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::is-important` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIsImportant` signal is emitted
    @discardableResult @inlinable func onNotifyIsImportant(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolItemRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolItemRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolItemRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyIsImportant,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::is-important` signal for using the `connect(signal:)` methods
    static var notifyIsImportantSignal: ToolItemSignalName { .notifyIsImportant }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::visible-horizontal` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVisibleHorizontal` signal is emitted
    @discardableResult @inlinable func onNotifyVisibleHorizontal(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolItemRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolItemRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolItemRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyVisibleHorizontal,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::visible-horizontal` signal for using the `connect(signal:)` methods
    static var notifyVisibleHorizontalSignal: ToolItemSignalName { .notifyVisibleHorizontal }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::visible-vertical` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVisibleVertical` signal is emitted
    @discardableResult @inlinable func onNotifyVisibleVertical(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolItemRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolItemRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolItemRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyVisibleVertical,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::visible-vertical` signal for using the `connect(signal:)` methods
    static var notifyVisibleVerticalSignal: ToolItemSignalName { .notifyVisibleVertical }
    
}

// MARK: ToolItem Class: ToolItemProtocol extension (methods and fields)
public extension ToolItemProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToolItem` instance.
    @inlinable var tool_item_ptr: UnsafeMutablePointer<GtkToolItem>! { return ptr?.assumingMemoryBound(to: GtkToolItem.self) }

    /// Returns the ellipsize mode used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out how text should
    /// be ellipsized.
    @inlinable func getEllipsizeMode() -> PangoEllipsizeMode {
        let rv = gtk_tool_item_get_ellipsize_mode(tool_item_ptr)
        return rv
    }

    /// Returns whether `tool_item` is allocated extra space.
    /// See `gtk_tool_item_set_expand()`.
    @inlinable func getExpand() -> Bool {
        let rv = ((gtk_tool_item_get_expand(tool_item_ptr)) != 0)
        return rv
    }

    /// Returns whether `tool_item` is the same size as other homogeneous
    /// items. See `gtk_tool_item_set_homogeneous()`.
    @inlinable func getHomogeneous() -> Bool {
        let rv = ((gtk_tool_item_get_homogeneous(tool_item_ptr)) != 0)
        return rv
    }

    /// Returns the icon size used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out what size icons
    /// they should use.
    @inlinable func getIconSize() -> GtkIconSize {
        let rv = gtk_tool_item_get_icon_size(tool_item_ptr)
        return rv
    }

    /// Returns whether `tool_item` is considered important. See
    /// `gtk_tool_item_set_is_important()`
    @inlinable func getIsImportant() -> Bool {
        let rv = ((gtk_tool_item_get_is_important(tool_item_ptr)) != 0)
        return rv
    }

    /// Returns the orientation used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out what size icons
    /// they should use.
    @inlinable func getOrientation() -> GtkOrientation {
        let rv = gtk_tool_item_get_orientation(tool_item_ptr)
        return rv
    }

    /// If `menu_item_id` matches the string passed to
    /// `gtk_tool_item_set_proxy_menu_item()` return the corresponding `GtkMenuItem`.
    /// 
    /// Custom subclasses of `GtkToolItem` should use this function to
    /// update their menu item when the `GtkToolItem` changes. That the
    /// `menu_item_ids` must match ensures that a `GtkToolItem`
    /// will not inadvertently change a menu item that they did not create.
    @inlinable func getProxyMenuItem(menuItemID: UnsafePointer<gchar>!) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tool_item_get_proxy_menu_item(tool_item_ptr, menuItemID))) else { return nil }
        return rv
    }

    /// Returns the relief style of `tool_item`. See `gtk_button_set_relief()`.
    /// Custom subclasses of `GtkToolItem` should call this function in the handler
    /// of the `GtkToolItem::toolbar_reconfigured` signal to find out the
    /// relief style of buttons.
    @inlinable func getReliefStyle() -> GtkReliefStyle {
        let rv = gtk_tool_item_get_relief_style(tool_item_ptr)
        return rv
    }

    /// Returns the text alignment used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out how text should
    /// be aligned.
    @inlinable func getTextAlignment() -> Double {
        let rv = Double(gtk_tool_item_get_text_alignment(tool_item_ptr))
        return rv
    }

    /// Returns the text orientation used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out how text should
    /// be orientated.
    @inlinable func getTextOrientation() -> GtkOrientation {
        let rv = gtk_tool_item_get_text_orientation(tool_item_ptr)
        return rv
    }

    /// Returns the size group used for labels in `tool_item`.
    /// Custom subclasses of `GtkToolItem` should call this function
    /// and use the size group for labels.
    @inlinable func getTextSizeGroup() -> SizeGroupRef! {
        let rv = SizeGroupRef(gconstpointer: gconstpointer(gtk_tool_item_get_text_size_group(tool_item_ptr)))
        return rv
    }

    /// Returns the toolbar style used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function in the handler of the
    /// GtkToolItem`toolbar_reconfigured` signal to find out in what style
    /// the toolbar is displayed and change themselves accordingly
    /// 
    /// Possibilities are:
    /// - `GTK_TOOLBAR_BOTH`, meaning the tool item should show
    ///   both an icon and a label, stacked vertically
    /// - `GTK_TOOLBAR_ICONS`, meaning the toolbar shows only icons
    /// - `GTK_TOOLBAR_TEXT`, meaning the tool item should only show text
    /// - `GTK_TOOLBAR_BOTH_HORIZ`, meaning the tool item should show
    ///   both an icon and a label, arranged horizontally
    @inlinable func getToolbarStyle() -> GtkToolbarStyle {
        let rv = gtk_tool_item_get_toolbar_style(tool_item_ptr)
        return rv
    }

    /// Returns whether `tool_item` has a drag window. See
    /// `gtk_tool_item_set_use_drag_window()`.
    @inlinable func getUseDragWindow() -> Bool {
        let rv = ((gtk_tool_item_get_use_drag_window(tool_item_ptr)) != 0)
        return rv
    }

    /// Returns whether the `tool_item` is visible on toolbars that are
    /// docked horizontally.
    @inlinable func getVisibleHorizontal() -> Bool {
        let rv = ((gtk_tool_item_get_visible_horizontal(tool_item_ptr)) != 0)
        return rv
    }

    /// Returns whether `tool_item` is visible when the toolbar is docked vertically.
    /// See `gtk_tool_item_set_visible_vertical()`.
    @inlinable func getVisibleVertical() -> Bool {
        let rv = ((gtk_tool_item_get_visible_vertical(tool_item_ptr)) != 0)
        return rv
    }

    /// Calling this function signals to the toolbar that the
    /// overflow menu item for `tool_item` has changed. If the
    /// overflow menu is visible when this function it called,
    /// the menu will be rebuilt.
    /// 
    /// The function must be called when the tool item changes what it
    /// will do in response to the `GtkToolItem::create-menu-proxy` signal.
    @inlinable func rebuildMenu() {
        gtk_tool_item_rebuild_menu(tool_item_ptr)
    
    }

    /// Returns the `GtkMenuItem` that was last set by
    /// `gtk_tool_item_set_proxy_menu_item()`, ie. the `GtkMenuItem`
    /// that is going to appear in the overflow menu.
    @inlinable func retrieveProxyMenuItem() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tool_item_retrieve_proxy_menu_item(tool_item_ptr))) else { return nil }
        return rv
    }

    /// Sets whether `tool_item` is allocated extra space when there
    /// is more room on the toolbar then needed for the items. The
    /// effect is that the item gets bigger when the toolbar gets bigger
    /// and smaller when the toolbar gets smaller.
    @inlinable func set(expand: Bool) {
        gtk_tool_item_set_expand(tool_item_ptr, gboolean((expand) ? 1 : 0))
    
    }

    /// Sets whether `tool_item` is to be allocated the same size as other
    /// homogeneous items. The effect is that all homogeneous items will have
    /// the same width as the widest of the items.
    @inlinable func set(homogeneous: Bool) {
        gtk_tool_item_set_homogeneous(tool_item_ptr, gboolean((homogeneous) ? 1 : 0))
    
    }

    /// Sets whether `tool_item` should be considered important. The `GtkToolButton`
    /// class uses this property to determine whether to show or hide its label
    /// when the toolbar style is `GTK_TOOLBAR_BOTH_HORIZ`. The result is that
    /// only tool buttons with the “is_important” property set have labels, an
    /// effect known as “priority text”
    @inlinable func set(isImportant: Bool) {
        gtk_tool_item_set_is_important(tool_item_ptr, gboolean((isImportant) ? 1 : 0))
    
    }

    /// Sets the `GtkMenuItem` used in the toolbar overflow menu. The
    /// `menu_item_id` is used to identify the caller of this function and
    /// should also be used with `gtk_tool_item_get_proxy_menu_item()`.
    /// 
    /// See also `GtkToolItem::create-menu-proxy`.
    @inlinable func setProxyMenuItem(menuItemID: UnsafePointer<gchar>!, menuItem: WidgetRef? = nil) {
        gtk_tool_item_set_proxy_menu_item(tool_item_ptr, menuItemID, menuItem?.widget_ptr)
    
    }
    /// Sets the `GtkMenuItem` used in the toolbar overflow menu. The
    /// `menu_item_id` is used to identify the caller of this function and
    /// should also be used with `gtk_tool_item_get_proxy_menu_item()`.
    /// 
    /// See also `GtkToolItem::create-menu-proxy`.
    @inlinable func setProxyMenuItem<WidgetT: WidgetProtocol>(menuItemID: UnsafePointer<gchar>!, menuItem: WidgetT?) {
        gtk_tool_item_set_proxy_menu_item(tool_item_ptr, menuItemID, menuItem?.widget_ptr)
    
    }

    /// Sets the markup text to be displayed as tooltip on the item.
    /// See `gtk_widget_set_tooltip_markup()`.
    @inlinable func setTooltip(markup: UnsafePointer<gchar>!) {
        gtk_tool_item_set_tooltip_markup(tool_item_ptr, markup)
    
    }

    /// Sets the text to be displayed as tooltip on the item.
    /// See `gtk_widget_set_tooltip_text()`.
    @inlinable func setTooltip(text: UnsafePointer<gchar>!) {
        gtk_tool_item_set_tooltip_text(tool_item_ptr, text)
    
    }

    /// Sets whether `tool_item` has a drag window. When `true` the
    /// toolitem can be used as a drag source through `gtk_drag_source_set()`.
    /// When `tool_item` has a drag window it will intercept all events,
    /// even those that would otherwise be sent to a child of `tool_item`.
    @inlinable func set(useDragWindow: Bool) {
        gtk_tool_item_set_use_drag_window(tool_item_ptr, gboolean((useDragWindow) ? 1 : 0))
    
    }

    /// Sets whether `tool_item` is visible when the toolbar is docked horizontally.
    @inlinable func set(visibleHorizontal: Bool) {
        gtk_tool_item_set_visible_horizontal(tool_item_ptr, gboolean((visibleHorizontal) ? 1 : 0))
    
    }

    /// Sets whether `tool_item` is visible when the toolbar is docked
    /// vertically. Some tool items, such as text entries, are too wide to be
    /// useful on a vertically docked toolbar. If `visible_vertical` is `false`
    /// `tool_item` will not appear on toolbars that are docked vertically.
    @inlinable func set(visibleVertical: Bool) {
        gtk_tool_item_set_visible_vertical(tool_item_ptr, gboolean((visibleVertical) ? 1 : 0))
    
    }

    /// Emits the signal `GtkToolItem::toolbar_reconfigured` on `tool_item`.
    /// `GtkToolbar` and other `GtkToolShell` implementations use this function
    /// to notify children, when some aspect of their configuration changes.
    @inlinable func toolbarReconfigured() {
        gtk_tool_item_toolbar_reconfigured(tool_item_ptr)
    
    }
    /// Returns the ellipsize mode used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out how text should
    /// be ellipsized.
    @inlinable var ellipsizeMode: PangoEllipsizeMode {
        /// Returns the ellipsize mode used for `tool_item`. Custom subclasses of
        /// `GtkToolItem` should call this function to find out how text should
        /// be ellipsized.
        get {
            let rv = gtk_tool_item_get_ellipsize_mode(tool_item_ptr)
            return rv
        }
    }

    /// Returns whether `tool_item` is allocated extra space.
    /// See `gtk_tool_item_set_expand()`.
    @inlinable var expand: Bool {
        /// Returns whether `tool_item` is allocated extra space.
        /// See `gtk_tool_item_set_expand()`.
        get {
            let rv = ((gtk_tool_item_get_expand(tool_item_ptr)) != 0)
            return rv
        }
        /// Sets whether `tool_item` is allocated extra space when there
        /// is more room on the toolbar then needed for the items. The
        /// effect is that the item gets bigger when the toolbar gets bigger
        /// and smaller when the toolbar gets smaller.
        nonmutating set {
            gtk_tool_item_set_expand(tool_item_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether `tool_item` is the same size as other homogeneous
    /// items. See `gtk_tool_item_set_homogeneous()`.
    @inlinable var homogeneous: Bool {
        /// Returns whether `tool_item` is the same size as other homogeneous
        /// items. See `gtk_tool_item_set_homogeneous()`.
        get {
            let rv = ((gtk_tool_item_get_homogeneous(tool_item_ptr)) != 0)
            return rv
        }
        /// Sets whether `tool_item` is to be allocated the same size as other
        /// homogeneous items. The effect is that all homogeneous items will have
        /// the same width as the widest of the items.
        nonmutating set {
            gtk_tool_item_set_homogeneous(tool_item_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the icon size used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out what size icons
    /// they should use.
    @inlinable var iconSize: GtkIconSize {
        /// Returns the icon size used for `tool_item`. Custom subclasses of
        /// `GtkToolItem` should call this function to find out what size icons
        /// they should use.
        get {
            let rv = gtk_tool_item_get_icon_size(tool_item_ptr)
            return rv
        }
    }

    /// Returns whether `tool_item` is considered important. See
    /// `gtk_tool_item_set_is_important()`
    @inlinable var isImportant: Bool {
        /// Returns whether `tool_item` is considered important. See
        /// `gtk_tool_item_set_is_important()`
        get {
            let rv = ((gtk_tool_item_get_is_important(tool_item_ptr)) != 0)
            return rv
        }
        /// Sets whether `tool_item` should be considered important. The `GtkToolButton`
        /// class uses this property to determine whether to show or hide its label
        /// when the toolbar style is `GTK_TOOLBAR_BOTH_HORIZ`. The result is that
        /// only tool buttons with the “is_important” property set have labels, an
        /// effect known as “priority text”
        nonmutating set {
            gtk_tool_item_set_is_important(tool_item_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the orientation used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out what size icons
    /// they should use.
    @inlinable var orientation: GtkOrientation {
        /// Returns the orientation used for `tool_item`. Custom subclasses of
        /// `GtkToolItem` should call this function to find out what size icons
        /// they should use.
        get {
            let rv = gtk_tool_item_get_orientation(tool_item_ptr)
            return rv
        }
    }

    /// Returns the relief style of `tool_item`. See `gtk_button_set_relief()`.
    /// Custom subclasses of `GtkToolItem` should call this function in the handler
    /// of the `GtkToolItem::toolbar_reconfigured` signal to find out the
    /// relief style of buttons.
    @inlinable var reliefStyle: GtkReliefStyle {
        /// Returns the relief style of `tool_item`. See `gtk_button_set_relief()`.
        /// Custom subclasses of `GtkToolItem` should call this function in the handler
        /// of the `GtkToolItem::toolbar_reconfigured` signal to find out the
        /// relief style of buttons.
        get {
            let rv = gtk_tool_item_get_relief_style(tool_item_ptr)
            return rv
        }
    }

    /// Returns the text alignment used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out how text should
    /// be aligned.
    @inlinable var textAlignment: Double {
        /// Returns the text alignment used for `tool_item`. Custom subclasses of
        /// `GtkToolItem` should call this function to find out how text should
        /// be aligned.
        get {
            let rv = Double(gtk_tool_item_get_text_alignment(tool_item_ptr))
            return rv
        }
    }

    /// Returns the text orientation used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function to find out how text should
    /// be orientated.
    @inlinable var textOrientation: GtkOrientation {
        /// Returns the text orientation used for `tool_item`. Custom subclasses of
        /// `GtkToolItem` should call this function to find out how text should
        /// be orientated.
        get {
            let rv = gtk_tool_item_get_text_orientation(tool_item_ptr)
            return rv
        }
    }

    /// Returns the size group used for labels in `tool_item`.
    /// Custom subclasses of `GtkToolItem` should call this function
    /// and use the size group for labels.
    @inlinable var textSizeGroup: SizeGroupRef! {
        /// Returns the size group used for labels in `tool_item`.
        /// Custom subclasses of `GtkToolItem` should call this function
        /// and use the size group for labels.
        get {
            let rv = SizeGroupRef(gconstpointer: gconstpointer(gtk_tool_item_get_text_size_group(tool_item_ptr)))
            return rv
        }
    }

    /// Returns the toolbar style used for `tool_item`. Custom subclasses of
    /// `GtkToolItem` should call this function in the handler of the
    /// GtkToolItem`toolbar_reconfigured` signal to find out in what style
    /// the toolbar is displayed and change themselves accordingly
    /// 
    /// Possibilities are:
    /// - `GTK_TOOLBAR_BOTH`, meaning the tool item should show
    ///   both an icon and a label, stacked vertically
    /// - `GTK_TOOLBAR_ICONS`, meaning the toolbar shows only icons
    /// - `GTK_TOOLBAR_TEXT`, meaning the tool item should only show text
    /// - `GTK_TOOLBAR_BOTH_HORIZ`, meaning the tool item should show
    ///   both an icon and a label, arranged horizontally
    @inlinable var toolbarStyle: GtkToolbarStyle {
        /// Returns the toolbar style used for `tool_item`. Custom subclasses of
        /// `GtkToolItem` should call this function in the handler of the
        /// GtkToolItem`toolbar_reconfigured` signal to find out in what style
        /// the toolbar is displayed and change themselves accordingly
        /// 
        /// Possibilities are:
        /// - `GTK_TOOLBAR_BOTH`, meaning the tool item should show
        ///   both an icon and a label, stacked vertically
        /// - `GTK_TOOLBAR_ICONS`, meaning the toolbar shows only icons
        /// - `GTK_TOOLBAR_TEXT`, meaning the tool item should only show text
        /// - `GTK_TOOLBAR_BOTH_HORIZ`, meaning the tool item should show
        ///   both an icon and a label, arranged horizontally
        get {
            let rv = gtk_tool_item_get_toolbar_style(tool_item_ptr)
            return rv
        }
    }

    /// Returns whether `tool_item` has a drag window. See
    /// `gtk_tool_item_set_use_drag_window()`.
    @inlinable var useDragWindow: Bool {
        /// Returns whether `tool_item` has a drag window. See
        /// `gtk_tool_item_set_use_drag_window()`.
        get {
            let rv = ((gtk_tool_item_get_use_drag_window(tool_item_ptr)) != 0)
            return rv
        }
        /// Sets whether `tool_item` has a drag window. When `true` the
        /// toolitem can be used as a drag source through `gtk_drag_source_set()`.
        /// When `tool_item` has a drag window it will intercept all events,
        /// even those that would otherwise be sent to a child of `tool_item`.
        nonmutating set {
            gtk_tool_item_set_use_drag_window(tool_item_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the `tool_item` is visible on toolbars that are
    /// docked horizontally.
    @inlinable var visibleHorizontal: Bool {
        /// Returns whether the `tool_item` is visible on toolbars that are
        /// docked horizontally.
        get {
            let rv = ((gtk_tool_item_get_visible_horizontal(tool_item_ptr)) != 0)
            return rv
        }
        /// Sets whether `tool_item` is visible when the toolbar is docked horizontally.
        nonmutating set {
            gtk_tool_item_set_visible_horizontal(tool_item_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether `tool_item` is visible when the toolbar is docked vertically.
    /// See `gtk_tool_item_set_visible_vertical()`.
    @inlinable var visibleVertical: Bool {
        /// Returns whether `tool_item` is visible when the toolbar is docked vertically.
        /// See `gtk_tool_item_set_visible_vertical()`.
        get {
            let rv = ((gtk_tool_item_get_visible_vertical(tool_item_ptr)) != 0)
            return rv
        }
        /// Sets whether `tool_item` is visible when the toolbar is docked
        /// vertically. Some tool items, such as text entries, are too wide to be
        /// useful on a vertically docked toolbar. If `visible_vertical` is `false`
        /// `tool_item` will not appear on toolbars that are docked vertically.
        nonmutating set {
            gtk_tool_item_set_visible_vertical(tool_item_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var parent: GtkBin {
        get {
            let rv = tool_item_ptr.pointee.parent
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - ToolItemGroup Class

/// A `GtkToolItemGroup` is used together with `GtkToolPalette` to add
/// `GtkToolItems` to a palette like container with different
/// categories and drag and drop support.
/// 
/// # CSS nodes
/// 
/// GtkToolItemGroup has a single CSS node named toolitemgroup.
///
/// The `ToolItemGroupProtocol` protocol exposes the methods and properties of an underlying `GtkToolItemGroup` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToolItemGroup`.
/// Alternatively, use `ToolItemGroupRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ToolItemGroupProtocol: ContainerProtocol, ToolShellProtocol {
        /// Untyped pointer to the underlying `GtkToolItemGroup` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkToolItemGroup` instance.
    var tool_item_group_ptr: UnsafeMutablePointer<GtkToolItemGroup>! { get }

    /// Required Initialiser for types conforming to `ToolItemGroupProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkToolItemGroup` is used together with `GtkToolPalette` to add
/// `GtkToolItems` to a palette like container with different
/// categories and drag and drop support.
/// 
/// # CSS nodes
/// 
/// GtkToolItemGroup has a single CSS node named toolitemgroup.
///
/// The `ToolItemGroupRef` type acts as a lightweight Swift reference to an underlying `GtkToolItemGroup` instance.
/// It exposes methods that can operate on this data type through `ToolItemGroupProtocol` conformance.
/// Use `ToolItemGroupRef` only as an `unowned` reference to an existing `GtkToolItemGroup` instance.
///
public struct ToolItemGroupRef: ToolItemGroupProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkToolItemGroup` instance.
    /// For type-safe access, use the generated, typed pointer `tool_item_group_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ToolItemGroupRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkToolItemGroup>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkToolItemGroup>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkToolItemGroup>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkToolItemGroup>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ToolItemGroupProtocol`
    @inlinable init<T: ToolItemGroupProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ToolItemGroupProtocol>(_ other: T) -> ToolItemGroupRef { ToolItemGroupRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new tool item group with label `label`.
    @inlinable init( label: UnsafePointer<gchar>!) {
        let rv = gtk_tool_item_group_new(label)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A `GtkToolItemGroup` is used together with `GtkToolPalette` to add
/// `GtkToolItems` to a palette like container with different
/// categories and drag and drop support.
/// 
/// # CSS nodes
/// 
/// GtkToolItemGroup has a single CSS node named toolitemgroup.
///
/// The `ToolItemGroup` type acts as a reference-counted owner of an underlying `GtkToolItemGroup` instance.
/// It provides the methods that can operate on this data type through `ToolItemGroupProtocol` conformance.
/// Use `ToolItemGroup` as a strong reference or owner of a `GtkToolItemGroup` instance.
///
open class ToolItemGroup: Container, ToolItemGroupProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolItemGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkToolItemGroup>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolItemGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkToolItemGroup>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolItemGroup` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolItemGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolItemGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkToolItemGroup>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolItemGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkToolItemGroup>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkToolItemGroup`.
    /// i.e., ownership is transferred to the `ToolItemGroup` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkToolItemGroup>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ToolItemGroupProtocol`
    /// Will retain `GtkToolItemGroup`.
    /// - Parameter other: an instance of a related type that implements `ToolItemGroupProtocol`
    @inlinable public init<T: ToolItemGroupProtocol>(toolItemGroup other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolItemGroupProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new tool item group with label `label`.
    @inlinable public init( label: UnsafePointer<gchar>!) {
        let rv = gtk_tool_item_group_new(label)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ToolItemGroupPropertyName: String, PropertyNameProtocol {
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case collapsed = "collapsed"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case ellipsize = "ellipsize"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case headerRelief = "header-relief"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    case isFocus = "is-focus"
    case label = "label"
    case labelWidget = "label-widget"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ToolItemGroupProtocol {
    /// Bind a `ToolItemGroupPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToolItemGroupPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ToolItemGroup property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ToolItemGroupPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ToolItemGroup property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ToolItemGroupPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ToolItemGroupSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    case add = "add"
    /// The `button-press-event` signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button-release-event` signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child-notify` signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The `composited-changed` signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure-event` signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete-event` signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy-event` signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction-changed` signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag-begin` signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag-data-delete` signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag-data-get` signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag-data-received` signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag-drop` signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag-drop` signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag-data-received` handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag-end` signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag-begin`.
    case dragEnd = "drag-end"
    /// The `drag-failed` signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag-leave` signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag-motion`, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag-leave` signal is also emitted before the
    /// `drag-drop` signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag-motion` signal handler.
    case dragLeave = "drag-leave"
    /// The `drag-motion` signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag-data-received`
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag-leave` and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter-notify-event` will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key-press-event`) and finally a generic
    /// `GtkWidget::event-after` signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event-after` will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The `focus-in-event` signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus-out-event` signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab-notify` signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy-changed` signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key-press-event` signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key-release-event` signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave-notify-event` will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map-event` will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map-event` signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion-notify-event` signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent-set` signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The `property-notify-event` signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has-tooltip` is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen-changed` signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll-event` signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection-clear-event` signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection-request-event` signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The `state-changed` signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state-flags-changed` signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style-set` signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style-updated` signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style-updated` signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap-event` signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility-notify-event` will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The `window-state-event` will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCollapsed = "notify::collapsed"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEllipsize = "notify::ellipsize"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeaderRelief = "notify::header-relief"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    case notifyIsFocus = "notify::is-focus"
    case notifyLabel = "notify::label"
    case notifyLabelWidget = "notify::label-widget"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

// MARK: ToolItemGroup has no signals
// MARK: ToolItemGroup Class: ToolItemGroupProtocol extension (methods and fields)
public extension ToolItemGroupProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToolItemGroup` instance.
    @inlinable var tool_item_group_ptr: UnsafeMutablePointer<GtkToolItemGroup>! { return ptr?.assumingMemoryBound(to: GtkToolItemGroup.self) }

    /// Gets whether `group` is collapsed or expanded.
    @inlinable func getCollapsed() -> Bool {
        let rv = ((gtk_tool_item_group_get_collapsed(tool_item_group_ptr)) != 0)
        return rv
    }

    /// Gets the tool item at position (x, y).
    @inlinable func getDropItem(x: Int, y: Int) -> ToolItemRef! {
        let rv = ToolItemRef(gconstpointer: gconstpointer(gtk_tool_item_group_get_drop_item(tool_item_group_ptr, gint(x), gint(y))))
        return rv
    }

    /// Gets the ellipsization mode of `group`.
    @inlinable func getEllipsize() -> PangoEllipsizeMode {
        let rv = gtk_tool_item_group_get_ellipsize(tool_item_group_ptr)
        return rv
    }

    /// Gets the relief mode of the header button of `group`.
    @inlinable func getHeaderRelief() -> GtkReliefStyle {
        let rv = gtk_tool_item_group_get_header_relief(tool_item_group_ptr)
        return rv
    }

    /// Gets the position of `item` in `group` as index.
    @inlinable func getItemPosition<ToolItemT: ToolItemProtocol>(item: ToolItemT) -> Int {
        let rv = Int(gtk_tool_item_group_get_item_position(tool_item_group_ptr, item.tool_item_ptr))
        return rv
    }

    /// Gets the label of `group`.
    @inlinable func getLabel() -> String! {
        let rv = gtk_tool_item_group_get_label(tool_item_group_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Gets the label widget of `group`.
    /// See `gtk_tool_item_group_set_label_widget()`.
    @inlinable func getLabelWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tool_item_group_get_label_widget(tool_item_group_ptr))) else { return nil }
        return rv
    }

    /// Gets the number of tool items in `group`.
    @inlinable func getNItems() -> Int {
        let rv = Int(gtk_tool_item_group_get_n_items(tool_item_group_ptr))
        return rv
    }

    /// Gets the tool item at `index` in group.
    @inlinable func getNthItem(index: Int) -> ToolItemRef! {
        let rv = ToolItemRef(gconstpointer: gconstpointer(gtk_tool_item_group_get_nth_item(tool_item_group_ptr, guint(index))))
        return rv
    }

    /// Inserts `item` at `position` in the list of children of `group`.
    @inlinable func insert<ToolItemT: ToolItemProtocol>(item: ToolItemT, position: Int) {
        gtk_tool_item_group_insert(tool_item_group_ptr, item.tool_item_ptr, gint(position))
    
    }

    /// Sets whether the `group` should be collapsed or expanded.
    @inlinable func set(collapsed: Bool) {
        gtk_tool_item_group_set_collapsed(tool_item_group_ptr, gboolean((collapsed) ? 1 : 0))
    
    }

    /// Sets the ellipsization mode which should be used by labels in `group`.
    @inlinable func set(ellipsize: PangoEllipsizeMode) {
        gtk_tool_item_group_set_ellipsize(tool_item_group_ptr, ellipsize)
    
    }

    /// Set the button relief of the group header.
    /// See `gtk_button_set_relief()` for details.
    @inlinable func setHeaderRelief(style: GtkReliefStyle) {
        gtk_tool_item_group_set_header_relief(tool_item_group_ptr, style)
    
    }

    /// Sets the position of `item` in the list of children of `group`.
    @inlinable func setItemPosition<ToolItemT: ToolItemProtocol>(item: ToolItemT, position: Int) {
        gtk_tool_item_group_set_item_position(tool_item_group_ptr, item.tool_item_ptr, gint(position))
    
    }

    /// Sets the label of the tool item group. The label is displayed in the header
    /// of the group.
    @inlinable func set(label: UnsafePointer<gchar>!) {
        gtk_tool_item_group_set_label(tool_item_group_ptr, label)
    
    }

    /// Sets the label of the tool item group.
    /// The label widget is displayed in the header of the group, in place
    /// of the usual label.
    @inlinable func set<WidgetT: WidgetProtocol>(labelWidget: WidgetT) {
        gtk_tool_item_group_set_label_widget(tool_item_group_ptr, labelWidget.widget_ptr)
    
    }
    @inlinable var collapsed: Bool {
        /// Gets whether `group` is collapsed or expanded.
        get {
            let rv = ((gtk_tool_item_group_get_collapsed(tool_item_group_ptr)) != 0)
            return rv
        }
        /// Sets whether the `group` should be collapsed or expanded.
        nonmutating set {
            gtk_tool_item_group_set_collapsed(tool_item_group_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var ellipsize: PangoEllipsizeMode {
        /// Gets the ellipsization mode of `group`.
        get {
            let rv = gtk_tool_item_group_get_ellipsize(tool_item_group_ptr)
            return rv
        }
        /// Sets the ellipsization mode which should be used by labels in `group`.
        nonmutating set {
            gtk_tool_item_group_set_ellipsize(tool_item_group_ptr, newValue)
        }
    }

    /// Gets the relief mode of the header button of `group`.
    @inlinable var headerRelief: GtkReliefStyle {
        /// Gets the relief mode of the header button of `group`.
        get {
            let rv = gtk_tool_item_group_get_header_relief(tool_item_group_ptr)
            return rv
        }
        /// Set the button relief of the group header.
        /// See `gtk_button_set_relief()` for details.
        nonmutating set {
            gtk_tool_item_group_set_header_relief(tool_item_group_ptr, newValue)
        }
    }

    @inlinable var label: String! {
        /// Gets the label of `group`.
        get {
            let rv = gtk_tool_item_group_get_label(tool_item_group_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the label of the tool item group. The label is displayed in the header
        /// of the group.
        nonmutating set {
            gtk_tool_item_group_set_label(tool_item_group_ptr, newValue)
        }
    }

    /// Gets the label widget of `group`.
    /// See `gtk_tool_item_group_set_label_widget()`.
    @inlinable var labelWidget: WidgetRef! {
        /// Gets the label widget of `group`.
        /// See `gtk_tool_item_group_set_label_widget()`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tool_item_group_get_label_widget(tool_item_group_ptr))) else { return nil }
            return rv
        }
        /// Sets the label of the tool item group.
        /// The label widget is displayed in the header of the group, in place
        /// of the usual label.
        nonmutating set {
            gtk_tool_item_group_set_label_widget(tool_item_group_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Gets the number of tool items in `group`.
    @inlinable var nItems: Int {
        /// Gets the number of tool items in `group`.
        get {
            let rv = Int(gtk_tool_item_group_get_n_items(tool_item_group_ptr))
            return rv
        }
    }

    @inlinable var parentInstance: GtkContainer {
        get {
            let rv = tool_item_group_ptr.pointee.parent_instance
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - ToolPalette Class

/// A `GtkToolPalette` allows you to add `GtkToolItems` to a palette-like
/// container with different categories and drag and drop support.
/// 
/// A `GtkToolPalette` is created with a call to `gtk_tool_palette_new()`.
/// 
/// `GtkToolItems` cannot be added directly to a `GtkToolPalette` -
/// instead they are added to a `GtkToolItemGroup` which can than be added
/// to a `GtkToolPalette`. To add a `GtkToolItemGroup` to a `GtkToolPalette`,
/// use `gtk_container_add()`.
/// 
/// (C Language Example):
/// ```C
/// GtkWidget *palette, *group;
/// GtkToolItem *item;
/// 
/// palette = gtk_tool_palette_new ();
/// group = gtk_tool_item_group_new (_("Test Category"));
/// gtk_container_add (GTK_CONTAINER (palette), group);
/// 
/// item = gtk_tool_button_new (NULL, _("_Open"));
/// gtk_tool_button_set_icon_name (GTK_TOOL_BUTTON (item), "document-open");
/// gtk_tool_item_group_insert (GTK_TOOL_ITEM_GROUP (group), item, -1);
/// ```
/// 
/// The easiest way to use drag and drop with `GtkToolPalette` is to call
/// `gtk_tool_palette_add_drag_dest()` with the desired drag source `palette`
/// and the desired drag target `widget`. Then `gtk_tool_palette_get_drag_item()`
/// can be used to get the dragged item in the `GtkWidget::drag-data-received`
/// signal handler of the drag target.
/// 
/// (C Language Example):
/// ```C
/// static void
/// passive_canvas_drag_data_received (GtkWidget        *widget,
///                                    GdkDragContext   *context,
///                                    gint              x,
///                                    gint              y,
///                                    GtkSelectionData *selection,
///                                    guint             info,
///                                    guint             time,
///                                    gpointer          data)
/// {
///   GtkWidget *palette;
///   GtkWidget *item;
/// 
///   // Get the dragged item
///   palette = gtk_widget_get_ancestor (gtk_drag_get_source_widget (context),
///                                      GTK_TYPE_TOOL_PALETTE);
///   if (palette != NULL)
///     item = gtk_tool_palette_get_drag_item (GTK_TOOL_PALETTE (palette),
///                                            selection);
/// 
///   // Do something with item
/// }
/// 
/// GtkWidget *target, palette;
/// 
/// palette = gtk_tool_palette_new ();
/// target = gtk_drawing_area_new ();
/// 
/// g_signal_connect (G_OBJECT (target), "drag-data-received",
///                   G_CALLBACK (passive_canvas_drag_data_received), NULL);
/// gtk_tool_palette_add_drag_dest (GTK_TOOL_PALETTE (palette), target,
///                                 GTK_DEST_DEFAULT_ALL,
///                                 GTK_TOOL_PALETTE_DRAG_ITEMS,
///                                 GDK_ACTION_COPY);
/// ```
/// 
/// # CSS nodes
/// 
/// GtkToolPalette has a single CSS node named toolpalette.
///
/// The `ToolPaletteProtocol` protocol exposes the methods and properties of an underlying `GtkToolPalette` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToolPalette`.
/// Alternatively, use `ToolPaletteRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ToolPaletteProtocol: ContainerProtocol, OrientableProtocol, ScrollableProtocol {
        /// Untyped pointer to the underlying `GtkToolPalette` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkToolPalette` instance.
    var tool_palette_ptr: UnsafeMutablePointer<GtkToolPalette>! { get }

    /// Required Initialiser for types conforming to `ToolPaletteProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkToolPalette` allows you to add `GtkToolItems` to a palette-like
/// container with different categories and drag and drop support.
/// 
/// A `GtkToolPalette` is created with a call to `gtk_tool_palette_new()`.
/// 
/// `GtkToolItems` cannot be added directly to a `GtkToolPalette` -
/// instead they are added to a `GtkToolItemGroup` which can than be added
/// to a `GtkToolPalette`. To add a `GtkToolItemGroup` to a `GtkToolPalette`,
/// use `gtk_container_add()`.
/// 
/// (C Language Example):
/// ```C
/// GtkWidget *palette, *group;
/// GtkToolItem *item;
/// 
/// palette = gtk_tool_palette_new ();
/// group = gtk_tool_item_group_new (_("Test Category"));
/// gtk_container_add (GTK_CONTAINER (palette), group);
/// 
/// item = gtk_tool_button_new (NULL, _("_Open"));
/// gtk_tool_button_set_icon_name (GTK_TOOL_BUTTON (item), "document-open");
/// gtk_tool_item_group_insert (GTK_TOOL_ITEM_GROUP (group), item, -1);
/// ```
/// 
/// The easiest way to use drag and drop with `GtkToolPalette` is to call
/// `gtk_tool_palette_add_drag_dest()` with the desired drag source `palette`
/// and the desired drag target `widget`. Then `gtk_tool_palette_get_drag_item()`
/// can be used to get the dragged item in the `GtkWidget::drag-data-received`
/// signal handler of the drag target.
/// 
/// (C Language Example):
/// ```C
/// static void
/// passive_canvas_drag_data_received (GtkWidget        *widget,
///                                    GdkDragContext   *context,
///                                    gint              x,
///                                    gint              y,
///                                    GtkSelectionData *selection,
///                                    guint             info,
///                                    guint             time,
///                                    gpointer          data)
/// {
///   GtkWidget *palette;
///   GtkWidget *item;
/// 
///   // Get the dragged item
///   palette = gtk_widget_get_ancestor (gtk_drag_get_source_widget (context),
///                                      GTK_TYPE_TOOL_PALETTE);
///   if (palette != NULL)
///     item = gtk_tool_palette_get_drag_item (GTK_TOOL_PALETTE (palette),
///                                            selection);
/// 
///   // Do something with item
/// }
/// 
/// GtkWidget *target, palette;
/// 
/// palette = gtk_tool_palette_new ();
/// target = gtk_drawing_area_new ();
/// 
/// g_signal_connect (G_OBJECT (target), "drag-data-received",
///                   G_CALLBACK (passive_canvas_drag_data_received), NULL);
/// gtk_tool_palette_add_drag_dest (GTK_TOOL_PALETTE (palette), target,
///                                 GTK_DEST_DEFAULT_ALL,
///                                 GTK_TOOL_PALETTE_DRAG_ITEMS,
///                                 GDK_ACTION_COPY);
/// ```
/// 
/// # CSS nodes
/// 
/// GtkToolPalette has a single CSS node named toolpalette.
///
/// The `ToolPaletteRef` type acts as a lightweight Swift reference to an underlying `GtkToolPalette` instance.
/// It exposes methods that can operate on this data type through `ToolPaletteProtocol` conformance.
/// Use `ToolPaletteRef` only as an `unowned` reference to an existing `GtkToolPalette` instance.
///
public struct ToolPaletteRef: ToolPaletteProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkToolPalette` instance.
    /// For type-safe access, use the generated, typed pointer `tool_palette_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ToolPaletteRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkToolPalette>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkToolPalette>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkToolPalette>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkToolPalette>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ToolPaletteProtocol`
    @inlinable init<T: ToolPaletteProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ToolPaletteProtocol>(_ other: T) -> ToolPaletteRef { ToolPaletteRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new tool palette.
    @inlinable init() {
        let rv = gtk_tool_palette_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A `GtkToolPalette` allows you to add `GtkToolItems` to a palette-like
/// container with different categories and drag and drop support.
/// 
/// A `GtkToolPalette` is created with a call to `gtk_tool_palette_new()`.
/// 
/// `GtkToolItems` cannot be added directly to a `GtkToolPalette` -
/// instead they are added to a `GtkToolItemGroup` which can than be added
/// to a `GtkToolPalette`. To add a `GtkToolItemGroup` to a `GtkToolPalette`,
/// use `gtk_container_add()`.
/// 
/// (C Language Example):
/// ```C
/// GtkWidget *palette, *group;
/// GtkToolItem *item;
/// 
/// palette = gtk_tool_palette_new ();
/// group = gtk_tool_item_group_new (_("Test Category"));
/// gtk_container_add (GTK_CONTAINER (palette), group);
/// 
/// item = gtk_tool_button_new (NULL, _("_Open"));
/// gtk_tool_button_set_icon_name (GTK_TOOL_BUTTON (item), "document-open");
/// gtk_tool_item_group_insert (GTK_TOOL_ITEM_GROUP (group), item, -1);
/// ```
/// 
/// The easiest way to use drag and drop with `GtkToolPalette` is to call
/// `gtk_tool_palette_add_drag_dest()` with the desired drag source `palette`
/// and the desired drag target `widget`. Then `gtk_tool_palette_get_drag_item()`
/// can be used to get the dragged item in the `GtkWidget::drag-data-received`
/// signal handler of the drag target.
/// 
/// (C Language Example):
/// ```C
/// static void
/// passive_canvas_drag_data_received (GtkWidget        *widget,
///                                    GdkDragContext   *context,
///                                    gint              x,
///                                    gint              y,
///                                    GtkSelectionData *selection,
///                                    guint             info,
///                                    guint             time,
///                                    gpointer          data)
/// {
///   GtkWidget *palette;
///   GtkWidget *item;
/// 
///   // Get the dragged item
///   palette = gtk_widget_get_ancestor (gtk_drag_get_source_widget (context),
///                                      GTK_TYPE_TOOL_PALETTE);
///   if (palette != NULL)
///     item = gtk_tool_palette_get_drag_item (GTK_TOOL_PALETTE (palette),
///                                            selection);
/// 
///   // Do something with item
/// }
/// 
/// GtkWidget *target, palette;
/// 
/// palette = gtk_tool_palette_new ();
/// target = gtk_drawing_area_new ();
/// 
/// g_signal_connect (G_OBJECT (target), "drag-data-received",
///                   G_CALLBACK (passive_canvas_drag_data_received), NULL);
/// gtk_tool_palette_add_drag_dest (GTK_TOOL_PALETTE (palette), target,
///                                 GTK_DEST_DEFAULT_ALL,
///                                 GTK_TOOL_PALETTE_DRAG_ITEMS,
///                                 GDK_ACTION_COPY);
/// ```
/// 
/// # CSS nodes
/// 
/// GtkToolPalette has a single CSS node named toolpalette.
///
/// The `ToolPalette` type acts as a reference-counted owner of an underlying `GtkToolPalette` instance.
/// It provides the methods that can operate on this data type through `ToolPaletteProtocol` conformance.
/// Use `ToolPalette` as a strong reference or owner of a `GtkToolPalette` instance.
///
open class ToolPalette: Container, ToolPaletteProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolPalette` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkToolPalette>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolPalette` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkToolPalette>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolPalette` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolPalette` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolPalette` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkToolPalette>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToolPalette` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkToolPalette>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkToolPalette`.
    /// i.e., ownership is transferred to the `ToolPalette` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkToolPalette>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ToolPaletteProtocol`
    /// Will retain `GtkToolPalette`.
    /// - Parameter other: an instance of a related type that implements `ToolPaletteProtocol`
    @inlinable public init<T: ToolPaletteProtocol>(toolPalette other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolPaletteProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new tool palette.
    @inlinable public init() {
        let rv = gtk_tool_palette_new()
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ToolPalettePropertyName: String, PropertyNameProtocol {
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The size of the icons in a tool palette. When this property is set,
    /// it overrides the default setting.
    /// 
    /// This should only be used for special-purpose tool palettes, normal
    /// application tool palettes should respect the user preferences for the
    /// size of icons.
    case iconSize = "icon-size"
    /// Is `true` if the `GtkToolPalette:icon-size` property has been set.
    case iconSizeSet = "icon-size-set"
    case isFocus = "is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    /// The style of items in the tool palette.
    case toolbarStyle = "toolbar-style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ToolPaletteProtocol {
    /// Bind a `ToolPalettePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToolPalettePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ToolPalette property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ToolPalettePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ToolPalette property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ToolPalettePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ToolPaletteSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    case add = "add"
    /// The `button-press-event` signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button-release-event` signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child-notify` signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The `composited-changed` signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure-event` signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete-event` signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy-event` signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction-changed` signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag-begin` signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag-data-delete` signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag-data-get` signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag-data-received` signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag-drop` signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag-drop` signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag-data-received` handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag-end` signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag-begin`.
    case dragEnd = "drag-end"
    /// The `drag-failed` signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag-leave` signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag-motion`, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag-leave` signal is also emitted before the
    /// `drag-drop` signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag-motion` signal handler.
    case dragLeave = "drag-leave"
    /// The `drag-motion` signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag-data-received`
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag-leave` and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter-notify-event` will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key-press-event`) and finally a generic
    /// `GtkWidget::event-after` signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event-after` will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// The `focus-in-event` signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus-out-event` signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab-notify` signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy-changed` signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key-press-event` signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key-release-event` signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave-notify-event` will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map-event` will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map-event` signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion-notify-event` signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent-set` signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The `property-notify-event` signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has-tooltip` is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen-changed` signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll-event` signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection-clear-event` signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection-request-event` signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The `state-changed` signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state-flags-changed` signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style-set` signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style-updated` signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style-updated` signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap-event` signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility-notify-event` will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The `window-state-event` will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The size of the icons in a tool palette. When this property is set,
    /// it overrides the default setting.
    /// 
    /// This should only be used for special-purpose tool palettes, normal
    /// application tool palettes should respect the user preferences for the
    /// size of icons.
    case notifyIconSize = "notify::icon-size"
    /// Is `true` if the `GtkToolPalette:icon-size` property has been set.
    case notifyIconSizeSet = "notify::icon-size-set"
    case notifyIsFocus = "notify::is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    /// The style of items in the tool palette.
    case notifyToolbarStyle = "notify::toolbar-style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

// MARK: ToolPalette has no signals
// MARK: ToolPalette Class: ToolPaletteProtocol extension (methods and fields)
public extension ToolPaletteProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToolPalette` instance.
    @inlinable var tool_palette_ptr: UnsafeMutablePointer<GtkToolPalette>! { return ptr?.assumingMemoryBound(to: GtkToolPalette.self) }

    /// Sets `palette` as drag source (see `gtk_tool_palette_set_drag_source()`)
    /// and sets `widget` as a drag destination for drags from `palette`.
    /// See `gtk_drag_dest_set()`.
    @inlinable func addDragDest<WidgetT: WidgetProtocol>(widget: WidgetT, flags: DestDefaults, targets: ToolPaletteDragTargets, actions: Gdk.DragAction) {
        gtk_tool_palette_add_drag_dest(tool_palette_ptr, widget.widget_ptr, flags.value, targets.value, actions.value)
    
    }

    /// Get the dragged item from the selection.
    /// This could be a `GtkToolItem` or a `GtkToolItemGroup`.
    @inlinable func getDragItem<SelectionDataT: SelectionDataProtocol>(selection: SelectionDataT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tool_palette_get_drag_item(tool_palette_ptr, selection.selection_data_ptr))) else { return nil }
        return rv
    }

    /// Gets the group at position (x, y).
    @inlinable func getDropGroup(x: Int, y: Int) -> ToolItemGroupRef! {
        let rv = ToolItemGroupRef(gconstpointer: gconstpointer(gtk_tool_palette_get_drop_group(tool_palette_ptr, gint(x), gint(y))))
        return rv
    }

    /// Gets the item at position (x, y).
    /// See `gtk_tool_palette_get_drop_group()`.
    @inlinable func getDropItem(x: Int, y: Int) -> ToolItemRef! {
        let rv = ToolItemRef(gconstpointer: gconstpointer(gtk_tool_palette_get_drop_item(tool_palette_ptr, gint(x), gint(y))))
        return rv
    }

    /// Gets whether `group` is exclusive or not.
    /// See `gtk_tool_palette_set_exclusive()`.
    @inlinable func getExclusive<ToolItemGroupT: ToolItemGroupProtocol>(group: ToolItemGroupT) -> Bool {
        let rv = ((gtk_tool_palette_get_exclusive(tool_palette_ptr, group.tool_item_group_ptr)) != 0)
        return rv
    }

    /// Gets whether group should be given extra space.
    /// See `gtk_tool_palette_set_expand()`.
    @inlinable func getExpand<ToolItemGroupT: ToolItemGroupProtocol>(group: ToolItemGroupT) -> Bool {
        let rv = ((gtk_tool_palette_get_expand(tool_palette_ptr, group.tool_item_group_ptr)) != 0)
        return rv
    }

    /// Gets the position of `group` in `palette` as index.
    /// See `gtk_tool_palette_set_group_position()`.
    @inlinable func getGroupPosition<ToolItemGroupT: ToolItemGroupProtocol>(group: ToolItemGroupT) -> Int {
        let rv = Int(gtk_tool_palette_get_group_position(tool_palette_ptr, group.tool_item_group_ptr))
        return rv
    }

    /// Gets the horizontal adjustment of the tool palette.
    ///
    /// **get_hadjustment is deprecated:**
    /// Use gtk_scrollable_get_hadjustment()
    @available(*, deprecated)
    @inlinable func getHadjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_tool_palette_get_hadjustment(tool_palette_ptr)))
        return rv
    }

    /// Gets the size of icons in the tool palette.
    /// See `gtk_tool_palette_set_icon_size()`.
    @inlinable func getIconSize() -> GtkIconSize {
        let rv = gtk_tool_palette_get_icon_size(tool_palette_ptr)
        return rv
    }

    /// Gets the style (icons, text or both) of items in the tool palette.
    @inlinable func getStyle() -> GtkToolbarStyle {
        let rv = gtk_tool_palette_get_style(tool_palette_ptr)
        return rv
    }

    /// Gets the vertical adjustment of the tool palette.
    ///
    /// **get_vadjustment is deprecated:**
    /// Use gtk_scrollable_get_vadjustment()
    @available(*, deprecated)
    @inlinable func getVadjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_tool_palette_get_vadjustment(tool_palette_ptr)))
        return rv
    }

    /// Sets the tool palette as a drag source.
    /// Enables all groups and items in the tool palette as drag sources
    /// on button 1 and button 3 press with copy and move actions.
    /// See `gtk_drag_source_set()`.
    @inlinable func setDragSource(targets: ToolPaletteDragTargets) {
        gtk_tool_palette_set_drag_source(tool_palette_ptr, targets.value)
    
    }

    /// Sets whether the group should be exclusive or not.
    /// If an exclusive group is expanded all other groups are collapsed.
    @inlinable func setExclusive<ToolItemGroupT: ToolItemGroupProtocol>(group: ToolItemGroupT, exclusive: Bool) {
        gtk_tool_palette_set_exclusive(tool_palette_ptr, group.tool_item_group_ptr, gboolean((exclusive) ? 1 : 0))
    
    }

    /// Sets whether the group should be given extra space.
    @inlinable func setExpand<ToolItemGroupT: ToolItemGroupProtocol>(group: ToolItemGroupT, expand: Bool) {
        gtk_tool_palette_set_expand(tool_palette_ptr, group.tool_item_group_ptr, gboolean((expand) ? 1 : 0))
    
    }

    /// Sets the position of the group as an index of the tool palette.
    /// If position is 0 the group will become the first child, if position is
    /// -1 it will become the last child.
    @inlinable func setGroupPosition<ToolItemGroupT: ToolItemGroupProtocol>(group: ToolItemGroupT, position: Int) {
        gtk_tool_palette_set_group_position(tool_palette_ptr, group.tool_item_group_ptr, gint(position))
    
    }

    /// Sets the size of icons in the tool palette.
    @inlinable func set(iconSize: GtkIconSize) {
        gtk_tool_palette_set_icon_size(tool_palette_ptr, iconSize)
    
    }

    /// Sets the style (text, icons or both) of items in the tool palette.
    @inlinable func set(style: GtkToolbarStyle) {
        gtk_tool_palette_set_style(tool_palette_ptr, style)
    
    }

    /// Unsets the tool palette icon size set with `gtk_tool_palette_set_icon_size()`,
    /// so that user preferences will be used to determine the icon size.
    @inlinable func unsetIconSize() {
        gtk_tool_palette_unset_icon_size(tool_palette_ptr)
    
    }

    /// Unsets a toolbar style set with `gtk_tool_palette_set_style()`,
    /// so that user preferences will be used to determine the toolbar style.
    @inlinable func unsetStyle() {
        gtk_tool_palette_unset_style(tool_palette_ptr)
    
    }
    /// Gets the horizontal adjustment of the tool palette.
    ///
    /// **get_hadjustment is deprecated:**
    /// Use gtk_scrollable_get_hadjustment()
    @inlinable var hadjustment: AdjustmentRef! {
        /// Gets the horizontal adjustment of the tool palette.
        ///
        /// **get_hadjustment is deprecated:**
        /// Use gtk_scrollable_get_hadjustment()
        @available(*, deprecated)
    get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_tool_palette_get_hadjustment(tool_palette_ptr)))
            return rv
        }
    }

    /// Gets the size of icons in the tool palette.
    /// See `gtk_tool_palette_set_icon_size()`.
    @inlinable var iconSize: GtkIconSize {
        /// Gets the size of icons in the tool palette.
        /// See `gtk_tool_palette_set_icon_size()`.
        get {
            let rv = gtk_tool_palette_get_icon_size(tool_palette_ptr)
            return rv
        }
        /// Sets the size of icons in the tool palette.
        nonmutating set {
            gtk_tool_palette_set_icon_size(tool_palette_ptr, newValue)
        }
    }

    /// Gets the style (icons, text or both) of items in the tool palette.
    @inlinable var style: GtkToolbarStyle {
        /// Gets the style (icons, text or both) of items in the tool palette.
        get {
            let rv = gtk_tool_palette_get_style(tool_palette_ptr)
            return rv
        }
        /// Sets the style (text, icons or both) of items in the tool palette.
        nonmutating set {
            gtk_tool_palette_set_style(tool_palette_ptr, newValue)
        }
    }

    /// Gets the vertical adjustment of the tool palette.
    ///
    /// **get_vadjustment is deprecated:**
    /// Use gtk_scrollable_get_vadjustment()
    @inlinable var vadjustment: AdjustmentRef! {
        /// Gets the vertical adjustment of the tool palette.
        ///
        /// **get_vadjustment is deprecated:**
        /// Use gtk_scrollable_get_vadjustment()
        @available(*, deprecated)
    get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_tool_palette_get_vadjustment(tool_palette_ptr)))
            return rv
        }
    }

    @inlinable var parentInstance: GtkContainer {
        get {
            let rv = tool_palette_ptr.pointee.parent_instance
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - Toolbar Class

/// A toolbar is created with a call to `gtk_toolbar_new()`.
/// 
/// A toolbar can contain instances of a subclass of `GtkToolItem`. To add
/// a `GtkToolItem` to the a toolbar, use `gtk_toolbar_insert()`. To remove
/// an item from the toolbar use `gtk_container_remove()`. To add a button
/// to the toolbar, add an instance of `GtkToolButton`.
/// 
/// Toolbar items can be visually grouped by adding instances of
/// `GtkSeparatorToolItem` to the toolbar. If the GtkToolbar child property
/// “expand” is `TRUE` and the property `GtkSeparatorToolItem:draw` is set to
/// `FALSE`, the effect is to force all following items to the end of the toolbar.
/// 
/// By default, a toolbar can be shrunk, upon which it will add an arrow button
/// to show an overflow menu offering access to any `GtkToolItem` child that has
/// a proxy menu item. To disable this and request enough size for all children,
/// call `gtk_toolbar_set_show_arrow()` to set `GtkToolbar:show-arrow` to `false`.
/// 
/// Creating a context menu for the toolbar can be done by connecting to
/// the `GtkToolbar::popup-context-menu` signal.
/// 
/// # CSS nodes
/// 
/// GtkToolbar has a single CSS node with name toolbar.
///
/// The `ToolbarProtocol` protocol exposes the methods and properties of an underlying `GtkToolbar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Toolbar`.
/// Alternatively, use `ToolbarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ToolbarProtocol: ContainerProtocol, OrientableProtocol, ToolShellProtocol {
        /// Untyped pointer to the underlying `GtkToolbar` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkToolbar` instance.
    var toolbar_ptr: UnsafeMutablePointer<GtkToolbar>! { get }

    /// Required Initialiser for types conforming to `ToolbarProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A toolbar is created with a call to `gtk_toolbar_new()`.
/// 
/// A toolbar can contain instances of a subclass of `GtkToolItem`. To add
/// a `GtkToolItem` to the a toolbar, use `gtk_toolbar_insert()`. To remove
/// an item from the toolbar use `gtk_container_remove()`. To add a button
/// to the toolbar, add an instance of `GtkToolButton`.
/// 
/// Toolbar items can be visually grouped by adding instances of
/// `GtkSeparatorToolItem` to the toolbar. If the GtkToolbar child property
/// “expand” is `TRUE` and the property `GtkSeparatorToolItem:draw` is set to
/// `FALSE`, the effect is to force all following items to the end of the toolbar.
/// 
/// By default, a toolbar can be shrunk, upon which it will add an arrow button
/// to show an overflow menu offering access to any `GtkToolItem` child that has
/// a proxy menu item. To disable this and request enough size for all children,
/// call `gtk_toolbar_set_show_arrow()` to set `GtkToolbar:show-arrow` to `false`.
/// 
/// Creating a context menu for the toolbar can be done by connecting to
/// the `GtkToolbar::popup-context-menu` signal.
/// 
/// # CSS nodes
/// 
/// GtkToolbar has a single CSS node with name toolbar.
///
/// The `ToolbarRef` type acts as a lightweight Swift reference to an underlying `GtkToolbar` instance.
/// It exposes methods that can operate on this data type through `ToolbarProtocol` conformance.
/// Use `ToolbarRef` only as an `unowned` reference to an existing `GtkToolbar` instance.
///
public struct ToolbarRef: ToolbarProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkToolbar` instance.
    /// For type-safe access, use the generated, typed pointer `toolbar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ToolbarRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkToolbar>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkToolbar>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkToolbar>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkToolbar>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ToolbarProtocol`
    @inlinable init<T: ToolbarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ToolbarProtocol>(_ other: T) -> ToolbarRef { ToolbarRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new toolbar.
    @inlinable init() {
        let rv = gtk_toolbar_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A toolbar is created with a call to `gtk_toolbar_new()`.
/// 
/// A toolbar can contain instances of a subclass of `GtkToolItem`. To add
/// a `GtkToolItem` to the a toolbar, use `gtk_toolbar_insert()`. To remove
/// an item from the toolbar use `gtk_container_remove()`. To add a button
/// to the toolbar, add an instance of `GtkToolButton`.
/// 
/// Toolbar items can be visually grouped by adding instances of
/// `GtkSeparatorToolItem` to the toolbar. If the GtkToolbar child property
/// “expand” is `TRUE` and the property `GtkSeparatorToolItem:draw` is set to
/// `FALSE`, the effect is to force all following items to the end of the toolbar.
/// 
/// By default, a toolbar can be shrunk, upon which it will add an arrow button
/// to show an overflow menu offering access to any `GtkToolItem` child that has
/// a proxy menu item. To disable this and request enough size for all children,
/// call `gtk_toolbar_set_show_arrow()` to set `GtkToolbar:show-arrow` to `false`.
/// 
/// Creating a context menu for the toolbar can be done by connecting to
/// the `GtkToolbar::popup-context-menu` signal.
/// 
/// # CSS nodes
/// 
/// GtkToolbar has a single CSS node with name toolbar.
///
/// The `Toolbar` type acts as a reference-counted owner of an underlying `GtkToolbar` instance.
/// It provides the methods that can operate on this data type through `ToolbarProtocol` conformance.
/// Use `Toolbar` as a strong reference or owner of a `GtkToolbar` instance.
///
open class Toolbar: Container, ToolbarProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Toolbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkToolbar>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Toolbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkToolbar>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Toolbar` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Toolbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Toolbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkToolbar>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Toolbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkToolbar>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkToolbar`.
    /// i.e., ownership is transferred to the `Toolbar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkToolbar>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ToolbarProtocol`
    /// Will retain `GtkToolbar`.
    /// - Parameter other: an instance of a related type that implements `ToolbarProtocol`
    @inlinable public init<T: ToolbarProtocol>(toolbar other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToolbarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new toolbar.
    @inlinable public init() {
        let rv = gtk_toolbar_new()
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ToolbarPropertyName: String, PropertyNameProtocol {
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// The size of the icons in a toolbar is normally determined by
    /// the toolbar-icon-size setting. When this property is set, it
    /// overrides the setting.
    /// 
    /// This should only be used for special-purpose toolbars, normal
    /// application toolbars should respect the user preferences for the
    /// size of icons.
    case iconSize = "icon-size"
    /// Is `true` if the icon-size property has been set.
    case iconSizeSet = "icon-size-set"
    case isFocus = "is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case resizeMode = "resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case sensitive = "sensitive"
    case showArrow = "show-arrow"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    case toolbarStyle = "toolbar-style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension ToolbarProtocol {
    /// Bind a `ToolbarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToolbarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Toolbar property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ToolbarPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Toolbar property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ToolbarPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ToolbarSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    case add = "add"
    /// The `button-press-event` signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button-release-event` signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child-notify` signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The `composited-changed` signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure-event` signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete-event` signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy-event` signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction-changed` signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag-begin` signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag-data-delete` signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag-data-get` signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag-data-received` signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag-drop` signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag-drop` signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag-data-received` handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag-end` signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag-begin`.
    case dragEnd = "drag-end"
    /// The `drag-failed` signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag-leave` signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag-motion`, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag-leave` signal is also emitted before the
    /// `drag-drop` signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag-motion` signal handler.
    case dragLeave = "drag-leave"
    /// The `drag-motion` signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag-data-received`
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag-leave` and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter-notify-event` will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key-press-event`) and finally a generic
    /// `GtkWidget::event-after` signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event-after` will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case focus = "focus"
    /// A keybinding signal used internally by GTK+. This signal can't
    /// be used in application code
    case focusHomeOrEnd = "focus-home-or-end"
    /// The `focus-in-event` signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus-out-event` signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab-notify` signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy-changed` signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key-press-event` signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key-release-event` signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave-notify-event` will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map-event` will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map-event` signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion-notify-event` signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the orientation of the toolbar changes.
    case orientationChanged = "orientation-changed"
    /// The `parent-set` signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// Emitted when the user right-clicks the toolbar or uses the
    /// keybinding to display a popup menu.
    /// 
    /// Application developers should handle this signal if they want
    /// to display a context menu on the toolbar. The context-menu should
    /// appear at the coordinates given by `x` and `y`. The mouse button
    /// number is given by the `button` parameter. If the menu was popped
    /// up using the keybaord, `button` is -1.
    case popupContextMenu = "popup-context-menu"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The `property-notify-event` signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has-tooltip` is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The `screen-changed` signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll-event` signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    /// The `selection-clear-event` signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection-request-event` signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    /// The `state-changed` signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state-flags-changed` signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when the style of the toolbar changes.
    case styleChanged = "style-changed"
    /// The `style-set` signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style-updated` signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style-updated` signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap-event` signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    /// The `visibility-notify-event` will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The `window-state-event` will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The size of the icons in a toolbar is normally determined by
    /// the toolbar-icon-size setting. When this property is set, it
    /// overrides the setting.
    /// 
    /// This should only be used for special-purpose toolbars, normal
    /// application toolbars should respect the user preferences for the
    /// size of icons.
    case notifyIconSize = "notify::icon-size"
    /// Is `true` if the icon-size property has been set.
    case notifyIconSizeSet = "notify::icon-size-set"
    case notifyIsFocus = "notify::is-focus"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyResizeMode = "notify::resize-mode"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySensitive = "notify::sensitive"
    case notifyShowArrow = "notify::show-arrow"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    case notifyToolbarStyle = "notify::toolbar-style"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

// MARK: Toolbar signals
public extension ToolbarProtocol {
    /// Connect a Swift signal handler to the given, typed `ToolbarSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToolbarSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ToolbarSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ToolbarSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// A keybinding signal used internally by GTK+. This signal can't
    /// be used in application code
    /// - Note: This represents the underlying `focus-home-or-end` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter focusHome: `true` if the first item should be focused
    /// - Parameter handler: `true` if the signal was handled, `false` if not
    /// Run the given callback whenever the `focusHomeOrEnd` signal is emitted
    @discardableResult @inlinable func onFocusHomeOrEnd(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolbarRef, _ focusHome: Bool) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolbarRef, Bool, Bool>
        let cCallback: @convention(c) (gpointer, gboolean, gpointer) -> gboolean = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(ToolbarRef(raw: unownedSelf), ((arg1) != 0))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .focusHomeOrEnd,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `focus-home-or-end` signal for using the `connect(signal:)` methods
    static var focusHomeOrEndSignal: ToolbarSignalName { .focusHomeOrEnd }
    
    /// Emitted when the orientation of the toolbar changes.
    /// - Note: This represents the underlying `orientation-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter orientation: the new `GtkOrientation` of the toolbar
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `orientationChanged` signal is emitted
    @discardableResult @inlinable func onOrientationChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolbarRef, _ orientation: Orientation) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolbarRef, Orientation, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolbarRef(raw: unownedSelf), Orientation(arg1))
            return output
        }
        return connect(
            signal: .orientationChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `orientation-changed` signal for using the `connect(signal:)` methods
    static var orientationChangedSignal: ToolbarSignalName { .orientationChanged }
    
    /// Emitted when the user right-clicks the toolbar or uses the
    /// keybinding to display a popup menu.
    /// 
    /// Application developers should handle this signal if they want
    /// to display a context menu on the toolbar. The context-menu should
    /// appear at the coordinates given by `x` and `y`. The mouse button
    /// number is given by the `button` parameter. If the menu was popped
    /// up using the keybaord, `button` is -1.
    /// - Note: This represents the underlying `popup-context-menu` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter x: the x coordinate of the point where the menu should appear
    /// - Parameter y: the y coordinate of the point where the menu should appear
    /// - Parameter button: the mouse button the user pressed, or -1
    /// - Parameter handler: return `true` if the signal was handled, `false` if not
    /// Run the given callback whenever the `popupContextMenu` signal is emitted
    @discardableResult @inlinable func onPopupContextMenu(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolbarRef, _ x: Int, _ y: Int, _ button: Int) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder4<ToolbarRef, Int, Int, Int, Bool>
        let cCallback: @convention(c) (gpointer, gint, gint, gint, gpointer) -> gboolean = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(ToolbarRef(raw: unownedSelf), Int(arg1), Int(arg2), Int(arg3))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .popupContextMenu,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `popup-context-menu` signal for using the `connect(signal:)` methods
    static var popupContextMenuSignal: ToolbarSignalName { .popupContextMenu }
    
    /// Emitted when the style of the toolbar changes.
    /// - Note: This represents the underlying `style-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter style: the new `GtkToolbarStyle` of the toolbar
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `styleChanged` signal is emitted
    @discardableResult @inlinable func onStyleChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolbarRef, _ style: ToolbarStyle) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolbarRef, ToolbarStyle, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolbarRef(raw: unownedSelf), ToolbarStyle(arg1))
            return output
        }
        return connect(
            signal: .styleChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `style-changed` signal for using the `connect(signal:)` methods
    static var styleChangedSignal: ToolbarSignalName { .styleChanged }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::icon-size` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIconSize` signal is emitted
    @discardableResult @inlinable func onNotifyIconSize(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolbarRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolbarRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolbarRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyIconSize,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::icon-size` signal for using the `connect(signal:)` methods
    static var notifyIconSizeSignal: ToolbarSignalName { .notifyIconSize }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::icon-size-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIconSizeSet` signal is emitted
    @discardableResult @inlinable func onNotifyIconSizeSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolbarRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolbarRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolbarRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyIconSizeSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::icon-size-set` signal for using the `connect(signal:)` methods
    static var notifyIconSizeSetSignal: ToolbarSignalName { .notifyIconSizeSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-arrow` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowArrow` signal is emitted
    @discardableResult @inlinable func onNotifyShowArrow(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolbarRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolbarRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolbarRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyShowArrow,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-arrow` signal for using the `connect(signal:)` methods
    static var notifyShowArrowSignal: ToolbarSignalName { .notifyShowArrow }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::toolbar-style` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyToolbarStyle` signal is emitted
    @discardableResult @inlinable func onNotifyToolbarStyle(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ToolbarRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ToolbarRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ToolbarRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyToolbarStyle,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::toolbar-style` signal for using the `connect(signal:)` methods
    static var notifyToolbarStyleSignal: ToolbarSignalName { .notifyToolbarStyle }
    
}

// MARK: Toolbar Class: ToolbarProtocol extension (methods and fields)
public extension ToolbarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToolbar` instance.
    @inlinable var toolbar_ptr: UnsafeMutablePointer<GtkToolbar>! { return ptr?.assumingMemoryBound(to: GtkToolbar.self) }

    /// Returns the position corresponding to the indicated point on
    /// `toolbar`. This is useful when dragging items to the toolbar:
    /// this function returns the position a new item should be
    /// inserted.
    /// 
    /// `x` and `y` are in `toolbar` coordinates.
    @inlinable func getDropIndex(x: Int, y: Int) -> Int {
        let rv = Int(gtk_toolbar_get_drop_index(toolbar_ptr, gint(x), gint(y)))
        return rv
    }

    /// Retrieves the icon size for the toolbar. See `gtk_toolbar_set_icon_size()`.
    @inlinable func getIconSize() -> GtkIconSize {
        let rv = gtk_toolbar_get_icon_size(toolbar_ptr)
        return rv
    }

    /// Returns the position of `item` on the toolbar, starting from 0.
    /// It is an error if `item` is not a child of the toolbar.
    @inlinable func getItemIndex<ToolItemT: ToolItemProtocol>(item: ToolItemT) -> Int {
        let rv = Int(gtk_toolbar_get_item_index(toolbar_ptr, item.tool_item_ptr))
        return rv
    }

    /// Returns the number of items on the toolbar.
    @inlinable func getNItems() -> Int {
        let rv = Int(gtk_toolbar_get_n_items(toolbar_ptr))
        return rv
    }

    /// Returns the `n`'th item on `toolbar`, or `nil` if the
    /// toolbar does not contain an `n`'th item.
    @inlinable func getNthItem(n: Int) -> ToolItemRef! {
        let rv = ToolItemRef(gconstpointer: gconstpointer(gtk_toolbar_get_nth_item(toolbar_ptr, gint(n))))
        return rv
    }

    /// Returns the relief style of buttons on `toolbar`. See
    /// `gtk_button_set_relief()`.
    @inlinable func getReliefStyle() -> GtkReliefStyle {
        let rv = gtk_toolbar_get_relief_style(toolbar_ptr)
        return rv
    }

    /// Returns whether the toolbar has an overflow menu.
    /// See `gtk_toolbar_set_show_arrow()`.
    @inlinable func getShowArrow() -> Bool {
        let rv = ((gtk_toolbar_get_show_arrow(toolbar_ptr)) != 0)
        return rv
    }

    /// Retrieves whether the toolbar has text, icons, or both . See
    /// `gtk_toolbar_set_style()`.
    @inlinable func getStyle() -> GtkToolbarStyle {
        let rv = gtk_toolbar_get_style(toolbar_ptr)
        return rv
    }

    /// Insert a `GtkToolItem` into the toolbar at position `pos`. If `pos` is
    /// 0 the item is prepended to the start of the toolbar. If `pos` is
    /// negative, the item is appended to the end of the toolbar.
    @inlinable func insert<ToolItemT: ToolItemProtocol>(item: ToolItemT, pos: Int) {
        gtk_toolbar_insert(toolbar_ptr, item.tool_item_ptr, gint(pos))
    
    }

    /// Highlights `toolbar` to give an idea of what it would look like
    /// if `item` was added to `toolbar` at the position indicated by `index_`.
    /// If `item` is `nil`, highlighting is turned off. In that case `index_`
    /// is ignored.
    /// 
    /// The `tool_item` passed to this function must not be part of any widget
    /// hierarchy. When an item is set as drop highlight item it can not
    /// added to any widget hierarchy or used as highlight item for another
    /// toolbar.
    @inlinable func setDropHighlightItem(toolItem: ToolItemRef? = nil, index: Int) {
        gtk_toolbar_set_drop_highlight_item(toolbar_ptr, toolItem?.tool_item_ptr, gint(index))
    
    }
    /// Highlights `toolbar` to give an idea of what it would look like
    /// if `item` was added to `toolbar` at the position indicated by `index_`.
    /// If `item` is `nil`, highlighting is turned off. In that case `index_`
    /// is ignored.
    /// 
    /// The `tool_item` passed to this function must not be part of any widget
    /// hierarchy. When an item is set as drop highlight item it can not
    /// added to any widget hierarchy or used as highlight item for another
    /// toolbar.
    @inlinable func setDropHighlightItem<ToolItemT: ToolItemProtocol>(toolItem: ToolItemT?, index: Int) {
        gtk_toolbar_set_drop_highlight_item(toolbar_ptr, toolItem?.tool_item_ptr, gint(index))
    
    }

    /// This function sets the size of stock icons in the toolbar. You
    /// can call it both before you add the icons and after they’ve been
    /// added. The size you set will override user preferences for the default
    /// icon size.
    /// 
    /// This should only be used for special-purpose toolbars, normal
    /// application toolbars should respect the user preferences for the
    /// size of icons.
    @inlinable func set(iconSize: GtkIconSize) {
        gtk_toolbar_set_icon_size(toolbar_ptr, iconSize)
    
    }

    /// Sets whether to show an overflow menu when `toolbar` isn’t allocated enough
    /// size to show all of its items. If `true`, items which can’t fit in `toolbar`,
    /// and which have a proxy menu item set by `gtk_tool_item_set_proxy_menu_item()`
    /// or `GtkToolItem::create-menu-proxy`, will be available in an overflow menu,
    /// which can be opened by an added arrow button. If `false`, `toolbar` will
    /// request enough size to fit all of its child items without any overflow.
    @inlinable func set(showArrow: Bool) {
        gtk_toolbar_set_show_arrow(toolbar_ptr, gboolean((showArrow) ? 1 : 0))
    
    }

    /// Alters the view of `toolbar` to display either icons only, text only, or both.
    @inlinable func set(style: GtkToolbarStyle) {
        gtk_toolbar_set_style(toolbar_ptr, style)
    
    }

    /// Unsets toolbar icon size set with `gtk_toolbar_set_icon_size()`, so that
    /// user preferences will be used to determine the icon size.
    @inlinable func unsetIconSize() {
        gtk_toolbar_unset_icon_size(toolbar_ptr)
    
    }

    /// Unsets a toolbar style set with `gtk_toolbar_set_style()`, so that
    /// user preferences will be used to determine the toolbar style.
    @inlinable func unsetStyle() {
        gtk_toolbar_unset_style(toolbar_ptr)
    
    }
    /// Retrieves the icon size for the toolbar. See `gtk_toolbar_set_icon_size()`.
    @inlinable var iconSize: GtkIconSize {
        /// Retrieves the icon size for the toolbar. See `gtk_toolbar_set_icon_size()`.
        get {
            let rv = gtk_toolbar_get_icon_size(toolbar_ptr)
            return rv
        }
        /// This function sets the size of stock icons in the toolbar. You
        /// can call it both before you add the icons and after they’ve been
        /// added. The size you set will override user preferences for the default
        /// icon size.
        /// 
        /// This should only be used for special-purpose toolbars, normal
        /// application toolbars should respect the user preferences for the
        /// size of icons.
        nonmutating set {
            gtk_toolbar_set_icon_size(toolbar_ptr, newValue)
        }
    }

    /// Returns the number of items on the toolbar.
    @inlinable var nItems: Int {
        /// Returns the number of items on the toolbar.
        get {
            let rv = Int(gtk_toolbar_get_n_items(toolbar_ptr))
            return rv
        }
    }

    /// Returns the relief style of buttons on `toolbar`. See
    /// `gtk_button_set_relief()`.
    @inlinable var reliefStyle: GtkReliefStyle {
        /// Returns the relief style of buttons on `toolbar`. See
        /// `gtk_button_set_relief()`.
        get {
            let rv = gtk_toolbar_get_relief_style(toolbar_ptr)
            return rv
        }
    }

    /// Returns whether the toolbar has an overflow menu.
    /// See `gtk_toolbar_set_show_arrow()`.
    @inlinable var showArrow: Bool {
        /// Returns whether the toolbar has an overflow menu.
        /// See `gtk_toolbar_set_show_arrow()`.
        get {
            let rv = ((gtk_toolbar_get_show_arrow(toolbar_ptr)) != 0)
            return rv
        }
        /// Sets whether to show an overflow menu when `toolbar` isn’t allocated enough
        /// size to show all of its items. If `true`, items which can’t fit in `toolbar`,
        /// and which have a proxy menu item set by `gtk_tool_item_set_proxy_menu_item()`
        /// or `GtkToolItem::create-menu-proxy`, will be available in an overflow menu,
        /// which can be opened by an added arrow button. If `false`, `toolbar` will
        /// request enough size to fit all of its child items without any overflow.
        nonmutating set {
            gtk_toolbar_set_show_arrow(toolbar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Retrieves whether the toolbar has text, icons, or both . See
    /// `gtk_toolbar_set_style()`.
    @inlinable var style: GtkToolbarStyle {
        /// Retrieves whether the toolbar has text, icons, or both . See
        /// `gtk_toolbar_set_style()`.
        get {
            let rv = gtk_toolbar_get_style(toolbar_ptr)
            return rv
        }
        /// Alters the view of `toolbar` to display either icons only, text only, or both.
        nonmutating set {
            gtk_toolbar_set_style(toolbar_ptr, newValue)
        }
    }

    @inlinable var container: GtkContainer {
        get {
            let rv = toolbar_ptr.pointee.container
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - Tooltip Class

/// Basic tooltips can be realized simply by using `gtk_widget_set_tooltip_text()`
/// or `gtk_widget_set_tooltip_markup()` without any explicit tooltip object.
/// 
/// When you need a tooltip with a little more fancy contents, like adding an
/// image, or you want the tooltip to have different contents per `GtkTreeView`
/// row or cell, you will have to do a little more work:
/// 
/// - Set the `GtkWidget:has-tooltip` property to `true`, this will make GTK+
///   monitor the widget for motion and related events which are needed to
///   determine when and where to show a tooltip.
/// 
/// - Connect to the `GtkWidget::query-tooltip` signal.  This signal will be
///   emitted when a tooltip is supposed to be shown. One of the arguments passed
///   to the signal handler is a GtkTooltip object. This is the object that we
///   are about to display as a tooltip, and can be manipulated in your callback
///   using functions like `gtk_tooltip_set_icon()`. There are functions for setting
///   the tooltip’s markup, setting an image from a named icon, or even putting in
///   a custom widget.
/// 
///   Return `true` from your query-tooltip handler. This causes the tooltip to be
///   show. If you return `false`, it will not be shown.
/// 
/// In the probably rare case where you want to have even more control over the
/// tooltip that is about to be shown, you can set your own `GtkWindow` which
/// will be used as tooltip window.  This works as follows:
/// 
/// - Set `GtkWidget:has-tooltip` and connect to `GtkWidget::query-tooltip` as before.
///   Use `gtk_widget_set_tooltip_window()` to set a `GtkWindow` created by you as
///   tooltip window.
/// 
/// - In the `GtkWidget::query-tooltip` callback you can access your window using
///   `gtk_widget_get_tooltip_window()` and manipulate as you wish. The semantics of
///   the return value are exactly as before, return `true` to show the window,
///   `false` to not show it.
///
/// The `TooltipProtocol` protocol exposes the methods and properties of an underlying `GtkTooltip` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Tooltip`.
/// Alternatively, use `TooltipRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TooltipProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTooltip` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTooltip` instance.
    var tooltip_ptr: UnsafeMutablePointer<GtkTooltip>! { get }

    /// Required Initialiser for types conforming to `TooltipProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Basic tooltips can be realized simply by using `gtk_widget_set_tooltip_text()`
/// or `gtk_widget_set_tooltip_markup()` without any explicit tooltip object.
/// 
/// When you need a tooltip with a little more fancy contents, like adding an
/// image, or you want the tooltip to have different contents per `GtkTreeView`
/// row or cell, you will have to do a little more work:
/// 
/// - Set the `GtkWidget:has-tooltip` property to `true`, this will make GTK+
///   monitor the widget for motion and related events which are needed to
///   determine when and where to show a tooltip.
/// 
/// - Connect to the `GtkWidget::query-tooltip` signal.  This signal will be
///   emitted when a tooltip is supposed to be shown. One of the arguments passed
///   to the signal handler is a GtkTooltip object. This is the object that we
///   are about to display as a tooltip, and can be manipulated in your callback
///   using functions like `gtk_tooltip_set_icon()`. There are functions for setting
///   the tooltip’s markup, setting an image from a named icon, or even putting in
///   a custom widget.
/// 
///   Return `true` from your query-tooltip handler. This causes the tooltip to be
///   show. If you return `false`, it will not be shown.
/// 
/// In the probably rare case where you want to have even more control over the
/// tooltip that is about to be shown, you can set your own `GtkWindow` which
/// will be used as tooltip window.  This works as follows:
/// 
/// - Set `GtkWidget:has-tooltip` and connect to `GtkWidget::query-tooltip` as before.
///   Use `gtk_widget_set_tooltip_window()` to set a `GtkWindow` created by you as
///   tooltip window.
/// 
/// - In the `GtkWidget::query-tooltip` callback you can access your window using
///   `gtk_widget_get_tooltip_window()` and manipulate as you wish. The semantics of
///   the return value are exactly as before, return `true` to show the window,
///   `false` to not show it.
///
/// The `TooltipRef` type acts as a lightweight Swift reference to an underlying `GtkTooltip` instance.
/// It exposes methods that can operate on this data type through `TooltipProtocol` conformance.
/// Use `TooltipRef` only as an `unowned` reference to an existing `GtkTooltip` instance.
///
public struct TooltipRef: TooltipProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTooltip` instance.
    /// For type-safe access, use the generated, typed pointer `tooltip_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TooltipRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTooltip>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTooltip>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTooltip>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTooltip>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TooltipProtocol`
    @inlinable init<T: TooltipProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TooltipProtocol>(_ other: T) -> TooltipRef { TooltipRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Basic tooltips can be realized simply by using `gtk_widget_set_tooltip_text()`
/// or `gtk_widget_set_tooltip_markup()` without any explicit tooltip object.
/// 
/// When you need a tooltip with a little more fancy contents, like adding an
/// image, or you want the tooltip to have different contents per `GtkTreeView`
/// row or cell, you will have to do a little more work:
/// 
/// - Set the `GtkWidget:has-tooltip` property to `true`, this will make GTK+
///   monitor the widget for motion and related events which are needed to
///   determine when and where to show a tooltip.
/// 
/// - Connect to the `GtkWidget::query-tooltip` signal.  This signal will be
///   emitted when a tooltip is supposed to be shown. One of the arguments passed
///   to the signal handler is a GtkTooltip object. This is the object that we
///   are about to display as a tooltip, and can be manipulated in your callback
///   using functions like `gtk_tooltip_set_icon()`. There are functions for setting
///   the tooltip’s markup, setting an image from a named icon, or even putting in
///   a custom widget.
/// 
///   Return `true` from your query-tooltip handler. This causes the tooltip to be
///   show. If you return `false`, it will not be shown.
/// 
/// In the probably rare case where you want to have even more control over the
/// tooltip that is about to be shown, you can set your own `GtkWindow` which
/// will be used as tooltip window.  This works as follows:
/// 
/// - Set `GtkWidget:has-tooltip` and connect to `GtkWidget::query-tooltip` as before.
///   Use `gtk_widget_set_tooltip_window()` to set a `GtkWindow` created by you as
///   tooltip window.
/// 
/// - In the `GtkWidget::query-tooltip` callback you can access your window using
///   `gtk_widget_get_tooltip_window()` and manipulate as you wish. The semantics of
///   the return value are exactly as before, return `true` to show the window,
///   `false` to not show it.
///
/// The `Tooltip` type acts as a reference-counted owner of an underlying `GtkTooltip` instance.
/// It provides the methods that can operate on this data type through `TooltipProtocol` conformance.
/// Use `Tooltip` as a strong reference or owner of a `GtkTooltip` instance.
///
open class Tooltip: GLibObject.Object, TooltipProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTooltip>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTooltip>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTooltip>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTooltip>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTooltip`.
    /// i.e., ownership is transferred to the `Tooltip` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTooltip>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TooltipProtocol`
    /// Will retain `GtkTooltip`.
    /// - Parameter other: an instance of a related type that implements `TooltipProtocol`
    @inlinable public init<T: TooltipProtocol>(tooltip other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TooltipProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no Tooltip properties

public enum TooltipSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: Tooltip has no signals
// MARK: Tooltip Class: TooltipProtocol extension (methods and fields)
public extension TooltipProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTooltip` instance.
    @inlinable var tooltip_ptr: UnsafeMutablePointer<GtkTooltip>! { return ptr?.assumingMemoryBound(to: GtkTooltip.self) }

    /// Replaces the widget packed into the tooltip with
    /// `custom_widget`. `custom_widget` does not get destroyed when the tooltip goes
    /// away.
    /// By default a box with a `GtkImage` and `GtkLabel` is embedded in
    /// the tooltip, which can be configured using `gtk_tooltip_set_markup()`
    /// and `gtk_tooltip_set_icon()`.
    @inlinable func setCustom(customWidget: WidgetRef? = nil) {
        gtk_tooltip_set_custom(tooltip_ptr, customWidget?.widget_ptr)
    
    }
    /// Replaces the widget packed into the tooltip with
    /// `custom_widget`. `custom_widget` does not get destroyed when the tooltip goes
    /// away.
    /// By default a box with a `GtkImage` and `GtkLabel` is embedded in
    /// the tooltip, which can be configured using `gtk_tooltip_set_markup()`
    /// and `gtk_tooltip_set_icon()`.
    @inlinable func setCustom<WidgetT: WidgetProtocol>(customWidget: WidgetT?) {
        gtk_tooltip_set_custom(tooltip_ptr, customWidget?.widget_ptr)
    
    }

    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// `pixbuf`.  If `pixbuf` is `nil`, the image will be hidden.
    @inlinable func setIcon(pixbuf: PixbufRef? = nil) {
        gtk_tooltip_set_icon(tooltip_ptr, pixbuf?.pixbuf_ptr)
    
    }
    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// `pixbuf`.  If `pixbuf` is `nil`, the image will be hidden.
    @inlinable func setIcon<PixbufT: PixbufProtocol>(pixbuf: PixbufT?) {
        gtk_tooltip_set_icon(tooltip_ptr, pixbuf?.pixbuf_ptr)
    
    }

    /// Sets the icon of the tooltip (which is in front of the text)
    /// to be the icon indicated by `gicon` with the size indicated
    /// by `size`. If `gicon` is `nil`, the image will be hidden.
    @inlinable func setIconFrom(gicon: GIO.IconRef? = nil, size: GtkIconSize) {
        gtk_tooltip_set_icon_from_gicon(tooltip_ptr, gicon?.icon_ptr, size)
    
    }
    /// Sets the icon of the tooltip (which is in front of the text)
    /// to be the icon indicated by `gicon` with the size indicated
    /// by `size`. If `gicon` is `nil`, the image will be hidden.
    @inlinable func setIconFrom<IconT: GIO.IconProtocol>(gicon: IconT?, size: GtkIconSize) {
        gtk_tooltip_set_icon_from_gicon(tooltip_ptr, gicon?.icon_ptr, size)
    
    }

    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// the icon indicated by `icon_name` with the size indicated
    /// by `size`.  If `icon_name` is `nil`, the image will be hidden.
    @inlinable func setIconFrom(iconName: UnsafePointer<gchar>? = nil, size: GtkIconSize) {
        gtk_tooltip_set_icon_from_icon_name(tooltip_ptr, iconName, size)
    
    }

    /// Sets the icon of the tooltip (which is in front of the text) to be
    /// the stock item indicated by `stock_id` with the size indicated
    /// by `size`.  If `stock_id` is `nil`, the image will be hidden.
    ///
    /// **set_icon_from_stock is deprecated:**
    /// Use gtk_tooltip_set_icon_from_icon_name() instead.
    @available(*, deprecated)
    @inlinable func setIconFromStock(stockID: UnsafePointer<gchar>? = nil, size: GtkIconSize) {
        gtk_tooltip_set_icon_from_stock(tooltip_ptr, stockID, size)
    
    }

    /// Sets the text of the tooltip to be `markup`, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// If `markup` is `nil`, the label will be hidden.
    @inlinable func set(markup: UnsafePointer<gchar>? = nil) {
        gtk_tooltip_set_markup(tooltip_ptr, markup)
    
    }

    /// Sets the text of the tooltip to be `text`. If `text` is `nil`, the label
    /// will be hidden. See also `gtk_tooltip_set_markup()`.
    @inlinable func set(text: UnsafePointer<gchar>? = nil) {
        gtk_tooltip_set_text(tooltip_ptr, text)
    
    }

    /// Sets the area of the widget, where the contents of this tooltip apply,
    /// to be `rect` (in widget coordinates).  This is especially useful for
    /// properly setting tooltips on `GtkTreeView` rows and cells, `GtkIconViews`,
    /// etc.
    /// 
    /// For setting tooltips on `GtkTreeView`, please refer to the convenience
    /// functions for this: `gtk_tree_view_set_tooltip_row()` and
    /// `gtk_tree_view_set_tooltip_cell()`.
    @inlinable func setTipArea<RectangleT: Gdk.RectangleProtocol>(rect: RectangleT) {
        gtk_tooltip_set_tip_area(tooltip_ptr, rect.rectangle_ptr)
    
    }


}



// MARK: - ToplevelAccessible Class


///
/// The `ToplevelAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkToplevelAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ToplevelAccessible`.
/// Alternatively, use `ToplevelAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ToplevelAccessibleProtocol: Atk.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkToplevelAccessible` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkToplevelAccessible` instance.
    var toplevel_accessible_ptr: UnsafeMutablePointer<GtkToplevelAccessible>! { get }

    /// Required Initialiser for types conforming to `ToplevelAccessibleProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `ToplevelAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkToplevelAccessible` instance.
/// It exposes methods that can operate on this data type through `ToplevelAccessibleProtocol` conformance.
/// Use `ToplevelAccessibleRef` only as an `unowned` reference to an existing `GtkToplevelAccessible` instance.
///
public struct ToplevelAccessibleRef: ToplevelAccessibleProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkToplevelAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `toplevel_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ToplevelAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkToplevelAccessible>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkToplevelAccessible>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkToplevelAccessible>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkToplevelAccessible>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ToplevelAccessibleProtocol`
    @inlinable init<T: ToplevelAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ToplevelAccessibleProtocol>(_ other: T) -> ToplevelAccessibleRef { ToplevelAccessibleRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }


///
/// The `ToplevelAccessible` type acts as a reference-counted owner of an underlying `GtkToplevelAccessible` instance.
/// It provides the methods that can operate on this data type through `ToplevelAccessibleProtocol` conformance.
/// Use `ToplevelAccessible` as a strong reference or owner of a `GtkToplevelAccessible` instance.
///
open class ToplevelAccessible: Atk.Object, ToplevelAccessibleProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToplevelAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkToplevelAccessible>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToplevelAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkToplevelAccessible>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToplevelAccessible` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToplevelAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToplevelAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkToplevelAccessible>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ToplevelAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkToplevelAccessible>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkToplevelAccessible`.
    /// i.e., ownership is transferred to the `ToplevelAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkToplevelAccessible>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ToplevelAccessibleProtocol`
    /// Will retain `GtkToplevelAccessible`.
    /// - Parameter other: an instance of a related type that implements `ToplevelAccessibleProtocol`
    @inlinable public init<T: ToplevelAccessibleProtocol>(toplevelAccessible other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ToplevelAccessibleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ToplevelAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
}

public extension ToplevelAccessibleProtocol {
    /// Bind a `ToplevelAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ToplevelAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ToplevelAccessible property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ToplevelAccessiblePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ToplevelAccessible property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ToplevelAccessiblePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ToplevelAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property-changed` is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
}

// MARK: ToplevelAccessible has no signals
// MARK: ToplevelAccessible Class: ToplevelAccessibleProtocol extension (methods and fields)
public extension ToplevelAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkToplevelAccessible` instance.
    @inlinable var toplevel_accessible_ptr: UnsafeMutablePointer<GtkToplevelAccessible>! { return ptr?.assumingMemoryBound(to: GtkToplevelAccessible.self) }

    @inlinable func getChildren() -> GLib.ListRef! {
        let rv = GLib.ListRef(gtk_toplevel_accessible_get_children(toplevel_accessible_ptr))
        return rv
    }
    @inlinable var children: GLib.ListRef! {
        get {
            let rv = GLib.ListRef(gtk_toplevel_accessible_get_children(toplevel_accessible_ptr))
            return rv
        }
    }

    @inlinable var parent: AtkObject {
        get {
            let rv = toplevel_accessible_ptr.pointee.parent
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TreeModelFilter Class

/// A `GtkTreeModelFilter` is a tree model which wraps another tree model,
/// and can do the following things:
/// 
/// - Filter specific rows, based on data from a “visible column”, a column
///   storing booleans indicating whether the row should be filtered or not,
///   or based on the return value of a “visible function”, which gets a
///   model, iter and user_data and returns a boolean indicating whether the
///   row should be filtered or not.
/// 
/// - Modify the “appearance” of the model, using a modify function.
///   This is extremely powerful and allows for just changing some
///   values and also for creating a completely different model based
///   on the given child model.
/// 
/// - Set a different root node, also known as a “virtual root”. You can pass
///   in a `GtkTreePath` indicating the root node for the filter at construction
///   time.
/// 
/// The basic API is similar to `GtkTreeModelSort`. For an example on its usage,
/// see the section on `GtkTreeModelSort`.
/// 
/// When using `GtkTreeModelFilter`, it is important to realize that
/// `GtkTreeModelFilter` maintains an internal cache of all nodes which are
/// visible in its clients. The cache is likely to be a subtree of the tree
/// exposed by the child model. `GtkTreeModelFilter` will not cache the entire
/// child model when unnecessary to not compromise the caching mechanism
/// that is exposed by the reference counting scheme. If the child model
/// implements reference counting, unnecessary signals may not be emitted
/// because of reference counting rule 3, see the `GtkTreeModel`
/// documentation. (Note that e.g. `GtkTreeStore` does not implement
/// reference counting and will always emit all signals, even when
/// the receiving node is not visible).
/// 
/// Because of this, limitations for possible visible functions do apply.
/// In general, visible functions should only use data or properties from
/// the node for which the visibility state must be determined, its siblings
/// or its parents. Usually, having a dependency on the state of any child
/// node is not possible, unless references are taken on these explicitly.
/// When no such reference exists, no signals may be received for these child
/// nodes (see reference couting rule number 3 in the `GtkTreeModel` section).
/// 
/// Determining the visibility state of a given node based on the state
/// of its child nodes is a frequently occurring use case. Therefore,
/// `GtkTreeModelFilter` explicitly supports this. For example, when a node
/// does not have any children, you might not want the node to be visible.
/// As soon as the first row is added to the node’s child level (or the
/// last row removed), the node’s visibility should be updated.
/// 
/// This introduces a dependency from the node on its child nodes. In order
/// to accommodate this, `GtkTreeModelFilter` must make sure the necessary
/// signals are received from the child model. This is achieved by building,
/// for all nodes which are exposed as visible nodes to `GtkTreeModelFilter`'s
/// clients, the child level (if any) and take a reference on the first node
/// in this level. Furthermore, for every row-inserted, row-changed or
/// row-deleted signal (also these which were not handled because the node
/// was not cached), `GtkTreeModelFilter` will check if the visibility state
/// of any parent node has changed.
/// 
/// Beware, however, that this explicit support is limited to these two
/// cases. For example, if you want a node to be visible only if two nodes
/// in a child’s child level (2 levels deeper) are visible, you are on your
/// own. In this case, either rely on `GtkTreeStore` to emit all signals
/// because it does not implement reference counting, or for models that
/// do implement reference counting, obtain references on these child levels
/// yourself.
///
/// The `TreeModelFilterProtocol` protocol exposes the methods and properties of an underlying `GtkTreeModelFilter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeModelFilter`.
/// Alternatively, use `TreeModelFilterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeModelFilterProtocol: GLibObject.ObjectProtocol, TreeDragSourceProtocol, TreeModelProtocol {
        /// Untyped pointer to the underlying `GtkTreeModelFilter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeModelFilter` instance.
    var tree_model_filter_ptr: UnsafeMutablePointer<GtkTreeModelFilter>! { get }

    /// Required Initialiser for types conforming to `TreeModelFilterProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkTreeModelFilter` is a tree model which wraps another tree model,
/// and can do the following things:
/// 
/// - Filter specific rows, based on data from a “visible column”, a column
///   storing booleans indicating whether the row should be filtered or not,
///   or based on the return value of a “visible function”, which gets a
///   model, iter and user_data and returns a boolean indicating whether the
///   row should be filtered or not.
/// 
/// - Modify the “appearance” of the model, using a modify function.
///   This is extremely powerful and allows for just changing some
///   values and also for creating a completely different model based
///   on the given child model.
/// 
/// - Set a different root node, also known as a “virtual root”. You can pass
///   in a `GtkTreePath` indicating the root node for the filter at construction
///   time.
/// 
/// The basic API is similar to `GtkTreeModelSort`. For an example on its usage,
/// see the section on `GtkTreeModelSort`.
/// 
/// When using `GtkTreeModelFilter`, it is important to realize that
/// `GtkTreeModelFilter` maintains an internal cache of all nodes which are
/// visible in its clients. The cache is likely to be a subtree of the tree
/// exposed by the child model. `GtkTreeModelFilter` will not cache the entire
/// child model when unnecessary to not compromise the caching mechanism
/// that is exposed by the reference counting scheme. If the child model
/// implements reference counting, unnecessary signals may not be emitted
/// because of reference counting rule 3, see the `GtkTreeModel`
/// documentation. (Note that e.g. `GtkTreeStore` does not implement
/// reference counting and will always emit all signals, even when
/// the receiving node is not visible).
/// 
/// Because of this, limitations for possible visible functions do apply.
/// In general, visible functions should only use data or properties from
/// the node for which the visibility state must be determined, its siblings
/// or its parents. Usually, having a dependency on the state of any child
/// node is not possible, unless references are taken on these explicitly.
/// When no such reference exists, no signals may be received for these child
/// nodes (see reference couting rule number 3 in the `GtkTreeModel` section).
/// 
/// Determining the visibility state of a given node based on the state
/// of its child nodes is a frequently occurring use case. Therefore,
/// `GtkTreeModelFilter` explicitly supports this. For example, when a node
/// does not have any children, you might not want the node to be visible.
/// As soon as the first row is added to the node’s child level (or the
/// last row removed), the node’s visibility should be updated.
/// 
/// This introduces a dependency from the node on its child nodes. In order
/// to accommodate this, `GtkTreeModelFilter` must make sure the necessary
/// signals are received from the child model. This is achieved by building,
/// for all nodes which are exposed as visible nodes to `GtkTreeModelFilter`'s
/// clients, the child level (if any) and take a reference on the first node
/// in this level. Furthermore, for every row-inserted, row-changed or
/// row-deleted signal (also these which were not handled because the node
/// was not cached), `GtkTreeModelFilter` will check if the visibility state
/// of any parent node has changed.
/// 
/// Beware, however, that this explicit support is limited to these two
/// cases. For example, if you want a node to be visible only if two nodes
/// in a child’s child level (2 levels deeper) are visible, you are on your
/// own. In this case, either rely on `GtkTreeStore` to emit all signals
/// because it does not implement reference counting, or for models that
/// do implement reference counting, obtain references on these child levels
/// yourself.
///
/// The `TreeModelFilterRef` type acts as a lightweight Swift reference to an underlying `GtkTreeModelFilter` instance.
/// It exposes methods that can operate on this data type through `TreeModelFilterProtocol` conformance.
/// Use `TreeModelFilterRef` only as an `unowned` reference to an existing `GtkTreeModelFilter` instance.
///
public struct TreeModelFilterRef: TreeModelFilterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeModelFilter` instance.
    /// For type-safe access, use the generated, typed pointer `tree_model_filter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeModelFilterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeModelFilter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeModelFilter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeModelFilter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeModelFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeModelFilterProtocol`
    @inlinable init<T: TreeModelFilterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeModelFilterProtocol>(_ other: T) -> TreeModelFilterRef { TreeModelFilterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// A `GtkTreeModelFilter` is a tree model which wraps another tree model,
/// and can do the following things:
/// 
/// - Filter specific rows, based on data from a “visible column”, a column
///   storing booleans indicating whether the row should be filtered or not,
///   or based on the return value of a “visible function”, which gets a
///   model, iter and user_data and returns a boolean indicating whether the
///   row should be filtered or not.
/// 
/// - Modify the “appearance” of the model, using a modify function.
///   This is extremely powerful and allows for just changing some
///   values and also for creating a completely different model based
///   on the given child model.
/// 
/// - Set a different root node, also known as a “virtual root”. You can pass
///   in a `GtkTreePath` indicating the root node for the filter at construction
///   time.
/// 
/// The basic API is similar to `GtkTreeModelSort`. For an example on its usage,
/// see the section on `GtkTreeModelSort`.
/// 
/// When using `GtkTreeModelFilter`, it is important to realize that
/// `GtkTreeModelFilter` maintains an internal cache of all nodes which are
/// visible in its clients. The cache is likely to be a subtree of the tree
/// exposed by the child model. `GtkTreeModelFilter` will not cache the entire
/// child model when unnecessary to not compromise the caching mechanism
/// that is exposed by the reference counting scheme. If the child model
/// implements reference counting, unnecessary signals may not be emitted
/// because of reference counting rule 3, see the `GtkTreeModel`
/// documentation. (Note that e.g. `GtkTreeStore` does not implement
/// reference counting and will always emit all signals, even when
/// the receiving node is not visible).
/// 
/// Because of this, limitations for possible visible functions do apply.
/// In general, visible functions should only use data or properties from
/// the node for which the visibility state must be determined, its siblings
/// or its parents. Usually, having a dependency on the state of any child
/// node is not possible, unless references are taken on these explicitly.
/// When no such reference exists, no signals may be received for these child
/// nodes (see reference couting rule number 3 in the `GtkTreeModel` section).
/// 
/// Determining the visibility state of a given node based on the state
/// of its child nodes is a frequently occurring use case. Therefore,
/// `GtkTreeModelFilter` explicitly supports this. For example, when a node
/// does not have any children, you might not want the node to be visible.
/// As soon as the first row is added to the node’s child level (or the
/// last row removed), the node’s visibility should be updated.
/// 
/// This introduces a dependency from the node on its child nodes. In order
/// to accommodate this, `GtkTreeModelFilter` must make sure the necessary
/// signals are received from the child model. This is achieved by building,
/// for all nodes which are exposed as visible nodes to `GtkTreeModelFilter`'s
/// clients, the child level (if any) and take a reference on the first node
/// in this level. Furthermore, for every row-inserted, row-changed or
/// row-deleted signal (also these which were not handled because the node
/// was not cached), `GtkTreeModelFilter` will check if the visibility state
/// of any parent node has changed.
/// 
/// Beware, however, that this explicit support is limited to these two
/// cases. For example, if you want a node to be visible only if two nodes
/// in a child’s child level (2 levels deeper) are visible, you are on your
/// own. In this case, either rely on `GtkTreeStore` to emit all signals
/// because it does not implement reference counting, or for models that
/// do implement reference counting, obtain references on these child levels
/// yourself.
///
/// The `TreeModelFilter` type acts as a reference-counted owner of an underlying `GtkTreeModelFilter` instance.
/// It provides the methods that can operate on this data type through `TreeModelFilterProtocol` conformance.
/// Use `TreeModelFilter` as a strong reference or owner of a `GtkTreeModelFilter` instance.
///
open class TreeModelFilter: GLibObject.Object, TreeModelFilterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeModelFilter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeModelFilter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeModelFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeModelFilter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeModelFilter`.
    /// i.e., ownership is transferred to the `TreeModelFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeModelFilter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeModelFilterProtocol`
    /// Will retain `GtkTreeModelFilter`.
    /// - Parameter other: an instance of a related type that implements `TreeModelFilterProtocol`
    @inlinable public init<T: TreeModelFilterProtocol>(treeModelFilter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum TreeModelFilterPropertyName: String, PropertyNameProtocol {
    case childModel = "child-model"
    case virtualRoot = "virtual-root"
}

public extension TreeModelFilterProtocol {
    /// Bind a `TreeModelFilterPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeModelFilterPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeModelFilter property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeModelFilterPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeModelFilter property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeModelFilterPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeModelFilterSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyChildModel = "notify::child-model"
    case notifyVirtualRoot = "notify::virtual-root"
}

// MARK: TreeModelFilter has no signals
// MARK: TreeModelFilter Class: TreeModelFilterProtocol extension (methods and fields)
public extension TreeModelFilterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeModelFilter` instance.
    @inlinable var tree_model_filter_ptr: UnsafeMutablePointer<GtkTreeModelFilter>! { return ptr?.assumingMemoryBound(to: GtkTreeModelFilter.self) }

    /// This function should almost never be called. It clears the `filter`
    /// of any cached iterators that haven’t been reffed with
    /// `gtk_tree_model_ref_node()`. This might be useful if the child model
    /// being filtered is static (and doesn’t change often) and there has been
    /// a lot of unreffed access to nodes. As a side effect of this function,
    /// all unreffed iters will be invalid.
    @inlinable func clearCache() {
        gtk_tree_model_filter_clear_cache(tree_model_filter_ptr)
    
    }

    /// Sets `filter_iter` to point to the row in `filter` that corresponds to the
    /// row pointed at by `child_iter`.  If `filter_iter` was not set, `false` is
    /// returned.
    @inlinable func convertChildIterToIter<TreeIterT: TreeIterProtocol>(filterIter: TreeIterT, childIter: TreeIterT) -> Bool {
        let rv = ((gtk_tree_model_filter_convert_child_iter_to_iter(tree_model_filter_ptr, filterIter.tree_iter_ptr, childIter.tree_iter_ptr)) != 0)
        return rv
    }

    /// Converts `child_path` to a path relative to `filter`. That is, `child_path`
    /// points to a path in the child model. The rerturned path will point to the
    /// same row in the filtered model. If `child_path` isn’t a valid path on the
    /// child model or points to a row which is not visible in `filter`, then `nil`
    /// is returned.
    @inlinable func convertChildPathToPath<TreePathT: TreePathProtocol>(childPath: TreePathT) -> TreePathRef! {
        let rv = TreePathRef(gconstpointer: gconstpointer(gtk_tree_model_filter_convert_child_path_to_path(tree_model_filter_ptr, childPath.tree_path_ptr)))
        return rv
    }

    /// Sets `child_iter` to point to the row pointed to by `filter_iter`.
    @inlinable func convertIterTo<TreeIterT: TreeIterProtocol>(childIter: TreeIterT, filterIter: TreeIterT) {
        gtk_tree_model_filter_convert_iter_to_child_iter(tree_model_filter_ptr, childIter.tree_iter_ptr, filterIter.tree_iter_ptr)
    
    }

    /// Converts `filter_path` to a path on the child model of `filter`. That is,
    /// `filter_path` points to a location in `filter`. The returned path will
    /// point to the same location in the model not being filtered. If `filter_path`
    /// does not point to a location in the child model, `nil` is returned.
    @inlinable func convertPathToChildPath<TreePathT: TreePathProtocol>(filterPath: TreePathT) -> TreePathRef! {
        let rv = TreePathRef(gconstpointer: gconstpointer(gtk_tree_model_filter_convert_path_to_child_path(tree_model_filter_ptr, filterPath.tree_path_ptr)))
        return rv
    }

    /// Returns a pointer to the child model of `filter`.
    @inlinable func getModel() -> TreeModelRef! {
        let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_tree_model_filter_get_model(tree_model_filter_ptr)))
        return rv
    }

    /// Emits `row_changed` for each row in the child model, which causes
    /// the filter to re-evaluate whether a row is visible or not.
    @inlinable func refilter() {
        gtk_tree_model_filter_refilter(tree_model_filter_ptr)
    
    }

    /// With the `n_columns` and `types` parameters, you give an array of column
    /// types for this model (which will be exposed to the parent model/view).
    /// The `func`, `data` and `destroy` parameters are for specifying the modify
    /// function. The modify function will get called for each
    /// data access, the goal of the modify function is to return the data which
    /// should be displayed at the location specified using the parameters of the
    /// modify function.
    /// 
    /// Note that `gtk_tree_model_filter_set_modify_func()`
    /// can only be called once for a given filter model.
    @inlinable func setModifyFunc(nColumns: Int, types: UnsafeMutablePointer<GType>!, `func`: GtkTreeModelFilterModifyFunc?, data: gpointer! = nil, destroy: GDestroyNotify? = nil) {
        gtk_tree_model_filter_set_modify_func(tree_model_filter_ptr, gint(nColumns), types, `func`, data, destroy)
    
    }

    /// Sets `column` of the child_model to be the column where `filter` should
    /// look for visibility information. `columns` should be a column of type
    /// `G_TYPE_BOOLEAN`, where `true` means that a row is visible, and `false`
    /// if not.
    /// 
    /// Note that `gtk_tree_model_filter_set_visible_func()` or
    /// `gtk_tree_model_filter_set_visible_column()` can only be called
    /// once for a given filter model.
    @inlinable func setVisible(column: Int) {
        gtk_tree_model_filter_set_visible_column(tree_model_filter_ptr, gint(column))
    
    }

    /// Sets the visible function used when filtering the `filter` to be `func`.
    /// The function should return `true` if the given row should be visible and
    /// `false` otherwise.
    /// 
    /// If the condition calculated by the function changes over time (e.g.
    /// because it depends on some global parameters), you must call
    /// `gtk_tree_model_filter_refilter()` to keep the visibility information
    /// of the model up-to-date.
    /// 
    /// Note that `func` is called whenever a row is inserted, when it may still
    /// be empty. The visible function should therefore take special care of empty
    /// rows, like in the example below.
    /// 
    /// (C Language Example):
    /// ```C
    /// static gboolean
    /// visible_func (GtkTreeModel *model,
    ///               GtkTreeIter  *iter,
    ///               gpointer      data)
    /// {
    ///   // Visible if row is non-empty and first column is “HI”
    ///   gchar *str;
    ///   gboolean visible = FALSE;
    /// 
    ///   gtk_tree_model_get (model, iter, 0, &str, -1);
    ///   if (str && strcmp (str, "HI") == 0)
    ///     visible = TRUE;
    ///   g_free (str);
    /// 
    ///   return visible;
    /// }
    /// ```
    /// 
    /// Note that `gtk_tree_model_filter_set_visible_func()` or
    /// `gtk_tree_model_filter_set_visible_column()` can only be called
    /// once for a given filter model.
    @inlinable func setVisibleFunc(`func`: GtkTreeModelFilterVisibleFunc?, data: gpointer! = nil, destroy: GDestroyNotify? = nil) {
        gtk_tree_model_filter_set_visible_func(tree_model_filter_ptr, `func`, data, destroy)
    
    }
    /// Returns a pointer to the child model of `filter`.
    @inlinable var model: TreeModelRef! {
        /// Returns a pointer to the child model of `filter`.
        get {
            let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_tree_model_filter_get_model(tree_model_filter_ptr)))
            return rv
        }
    }

    @inlinable var parent: GObject {
        get {
            let rv = tree_model_filter_ptr.pointee.parent
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TreeModelSort Class

/// The `GtkTreeModelSort` is a model which implements the `GtkTreeSortable`
/// interface.  It does not hold any data itself, but rather is created with
/// a child model and proxies its data.  It has identical column types to
/// this child model, and the changes in the child are propagated.  The
/// primary purpose of this model is to provide a way to sort a different
/// model without modifying it. Note that the sort function used by
/// `GtkTreeModelSort` is not guaranteed to be stable.
/// 
/// The use of this is best demonstrated through an example.  In the
/// following sample code we create two `GtkTreeView` widgets each with a
/// view of the same data.  As the model is wrapped here by a
/// `GtkTreeModelSort`, the two `GtkTreeViews` can each sort their
/// view of the data without affecting the other.  By contrast, if we
/// simply put the same model in each widget, then sorting the first would
/// sort the second.
/// 
/// ## Using a `GtkTreeModelSort`
/// 
/// (C Language Example):
/// ```C
/// {
///   GtkTreeView *tree_view1;
///   GtkTreeView *tree_view2;
///   GtkTreeModel *sort_model1;
///   GtkTreeModel *sort_model2;
///   GtkTreeModel *child_model;
/// 
///   // get the child model
///   child_model = get_my_model ();
/// 
///   // Create the first tree
///   sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view1 = gtk_tree_view_new_with_model (sort_model1);
/// 
///   // Create the second tree
///   sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view2 = gtk_tree_view_new_with_model (sort_model2);
/// 
///   // Now we can sort the two models independently
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
///                                         COLUMN_1, GTK_SORT_ASCENDING);
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
///                                         COLUMN_1, GTK_SORT_DESCENDING);
/// }
/// ```
/// 
/// To demonstrate how to access the underlying child model from the sort
/// model, the next example will be a callback for the `GtkTreeSelection`
/// `GtkTreeSelection::changed` signal.  In this callback, we get a string
/// from COLUMN_1 of the model.  We then modify the string, find the same
/// selected row on the child model, and change the row there.
/// 
/// ## Accessing the child model of in a selection changed callback
/// 
/// (C Language Example):
/// ```C
/// void
/// selection_changed (GtkTreeSelection *selection, gpointer data)
/// {
///   GtkTreeModel *sort_model = NULL;
///   GtkTreeModel *child_model;
///   GtkTreeIter sort_iter;
///   GtkTreeIter child_iter;
///   char *some_data = NULL;
///   char *modified_data;
/// 
///   // Get the current selected row and the model.
///   if (! gtk_tree_selection_get_selected (selection,
///                                          &sort_model,
///                                          &sort_iter))
///     return;
/// 
///   // Look up the current value on the selected row and get
///   // a new value to change it to.
///   gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
///                       COLUMN_1, &some_data,
///                       -1);
/// 
///   modified_data = change_the_data (some_data);
///   g_free (some_data);
/// 
///   // Get an iterator on the child model, instead of the sort model.
///   gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
///                                                   &child_iter,
///                                                   &sort_iter);
/// 
///   // Get the child model and change the value of the row. In this
///   // example, the child model is a GtkListStore. It could be any other
///   // type of model, though.
///   child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
///   gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
///                       COLUMN_1, &modified_data,
///                       -1);
///   g_free (modified_data);
/// }
/// ```
/// 
///
/// The `TreeModelSortProtocol` protocol exposes the methods and properties of an underlying `GtkTreeModelSort` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeModelSort`.
/// Alternatively, use `TreeModelSortRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeModelSortProtocol: GLibObject.ObjectProtocol, TreeDragSourceProtocol, TreeModelProtocol, TreeSortableProtocol {
        /// Untyped pointer to the underlying `GtkTreeModelSort` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeModelSort` instance.
    var tree_model_sort_ptr: UnsafeMutablePointer<GtkTreeModelSort>! { get }

    /// Required Initialiser for types conforming to `TreeModelSortProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GtkTreeModelSort` is a model which implements the `GtkTreeSortable`
/// interface.  It does not hold any data itself, but rather is created with
/// a child model and proxies its data.  It has identical column types to
/// this child model, and the changes in the child are propagated.  The
/// primary purpose of this model is to provide a way to sort a different
/// model without modifying it. Note that the sort function used by
/// `GtkTreeModelSort` is not guaranteed to be stable.
/// 
/// The use of this is best demonstrated through an example.  In the
/// following sample code we create two `GtkTreeView` widgets each with a
/// view of the same data.  As the model is wrapped here by a
/// `GtkTreeModelSort`, the two `GtkTreeViews` can each sort their
/// view of the data without affecting the other.  By contrast, if we
/// simply put the same model in each widget, then sorting the first would
/// sort the second.
/// 
/// ## Using a `GtkTreeModelSort`
/// 
/// (C Language Example):
/// ```C
/// {
///   GtkTreeView *tree_view1;
///   GtkTreeView *tree_view2;
///   GtkTreeModel *sort_model1;
///   GtkTreeModel *sort_model2;
///   GtkTreeModel *child_model;
/// 
///   // get the child model
///   child_model = get_my_model ();
/// 
///   // Create the first tree
///   sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view1 = gtk_tree_view_new_with_model (sort_model1);
/// 
///   // Create the second tree
///   sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view2 = gtk_tree_view_new_with_model (sort_model2);
/// 
///   // Now we can sort the two models independently
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
///                                         COLUMN_1, GTK_SORT_ASCENDING);
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
///                                         COLUMN_1, GTK_SORT_DESCENDING);
/// }
/// ```
/// 
/// To demonstrate how to access the underlying child model from the sort
/// model, the next example will be a callback for the `GtkTreeSelection`
/// `GtkTreeSelection::changed` signal.  In this callback, we get a string
/// from COLUMN_1 of the model.  We then modify the string, find the same
/// selected row on the child model, and change the row there.
/// 
/// ## Accessing the child model of in a selection changed callback
/// 
/// (C Language Example):
/// ```C
/// void
/// selection_changed (GtkTreeSelection *selection, gpointer data)
/// {
///   GtkTreeModel *sort_model = NULL;
///   GtkTreeModel *child_model;
///   GtkTreeIter sort_iter;
///   GtkTreeIter child_iter;
///   char *some_data = NULL;
///   char *modified_data;
/// 
///   // Get the current selected row and the model.
///   if (! gtk_tree_selection_get_selected (selection,
///                                          &sort_model,
///                                          &sort_iter))
///     return;
/// 
///   // Look up the current value on the selected row and get
///   // a new value to change it to.
///   gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
///                       COLUMN_1, &some_data,
///                       -1);
/// 
///   modified_data = change_the_data (some_data);
///   g_free (some_data);
/// 
///   // Get an iterator on the child model, instead of the sort model.
///   gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
///                                                   &child_iter,
///                                                   &sort_iter);
/// 
///   // Get the child model and change the value of the row. In this
///   // example, the child model is a GtkListStore. It could be any other
///   // type of model, though.
///   child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
///   gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
///                       COLUMN_1, &modified_data,
///                       -1);
///   g_free (modified_data);
/// }
/// ```
/// 
///
/// The `TreeModelSortRef` type acts as a lightweight Swift reference to an underlying `GtkTreeModelSort` instance.
/// It exposes methods that can operate on this data type through `TreeModelSortProtocol` conformance.
/// Use `TreeModelSortRef` only as an `unowned` reference to an existing `GtkTreeModelSort` instance.
///
public struct TreeModelSortRef: TreeModelSortProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeModelSort` instance.
    /// For type-safe access, use the generated, typed pointer `tree_model_sort_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeModelSortRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeModelSort>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeModelSort>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeModelSort>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeModelSort>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeModelSortProtocol`
    @inlinable init<T: TreeModelSortProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeModelSortProtocol>(_ other: T) -> TreeModelSortRef { TreeModelSortRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `GtkTreeModelSort` is a model which implements the `GtkTreeSortable`
/// interface.  It does not hold any data itself, but rather is created with
/// a child model and proxies its data.  It has identical column types to
/// this child model, and the changes in the child are propagated.  The
/// primary purpose of this model is to provide a way to sort a different
/// model without modifying it. Note that the sort function used by
/// `GtkTreeModelSort` is not guaranteed to be stable.
/// 
/// The use of this is best demonstrated through an example.  In the
/// following sample code we create two `GtkTreeView` widgets each with a
/// view of the same data.  As the model is wrapped here by a
/// `GtkTreeModelSort`, the two `GtkTreeViews` can each sort their
/// view of the data without affecting the other.  By contrast, if we
/// simply put the same model in each widget, then sorting the first would
/// sort the second.
/// 
/// ## Using a `GtkTreeModelSort`
/// 
/// (C Language Example):
/// ```C
/// {
///   GtkTreeView *tree_view1;
///   GtkTreeView *tree_view2;
///   GtkTreeModel *sort_model1;
///   GtkTreeModel *sort_model2;
///   GtkTreeModel *child_model;
/// 
///   // get the child model
///   child_model = get_my_model ();
/// 
///   // Create the first tree
///   sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view1 = gtk_tree_view_new_with_model (sort_model1);
/// 
///   // Create the second tree
///   sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
///   tree_view2 = gtk_tree_view_new_with_model (sort_model2);
/// 
///   // Now we can sort the two models independently
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
///                                         COLUMN_1, GTK_SORT_ASCENDING);
///   gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
///                                         COLUMN_1, GTK_SORT_DESCENDING);
/// }
/// ```
/// 
/// To demonstrate how to access the underlying child model from the sort
/// model, the next example will be a callback for the `GtkTreeSelection`
/// `GtkTreeSelection::changed` signal.  In this callback, we get a string
/// from COLUMN_1 of the model.  We then modify the string, find the same
/// selected row on the child model, and change the row there.
/// 
/// ## Accessing the child model of in a selection changed callback
/// 
/// (C Language Example):
/// ```C
/// void
/// selection_changed (GtkTreeSelection *selection, gpointer data)
/// {
///   GtkTreeModel *sort_model = NULL;
///   GtkTreeModel *child_model;
///   GtkTreeIter sort_iter;
///   GtkTreeIter child_iter;
///   char *some_data = NULL;
///   char *modified_data;
/// 
///   // Get the current selected row and the model.
///   if (! gtk_tree_selection_get_selected (selection,
///                                          &sort_model,
///                                          &sort_iter))
///     return;
/// 
///   // Look up the current value on the selected row and get
///   // a new value to change it to.
///   gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
///                       COLUMN_1, &some_data,
///                       -1);
/// 
///   modified_data = change_the_data (some_data);
///   g_free (some_data);
/// 
///   // Get an iterator on the child model, instead of the sort model.
///   gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
///                                                   &child_iter,
///                                                   &sort_iter);
/// 
///   // Get the child model and change the value of the row. In this
///   // example, the child model is a GtkListStore. It could be any other
///   // type of model, though.
///   child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
///   gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
///                       COLUMN_1, &modified_data,
///                       -1);
///   g_free (modified_data);
/// }
/// ```
/// 
///
/// The `TreeModelSort` type acts as a reference-counted owner of an underlying `GtkTreeModelSort` instance.
/// It provides the methods that can operate on this data type through `TreeModelSortProtocol` conformance.
/// Use `TreeModelSort` as a strong reference or owner of a `GtkTreeModelSort` instance.
///
open class TreeModelSort: GLibObject.Object, TreeModelSortProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeModelSort>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeModelSort>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeModelSort>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeModelSort>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeModelSort`.
    /// i.e., ownership is transferred to the `TreeModelSort` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeModelSort>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeModelSortProtocol`
    /// Will retain `GtkTreeModelSort`.
    /// - Parameter other: an instance of a related type that implements `TreeModelSortProtocol`
    @inlinable public init<T: TreeModelSortProtocol>(treeModelSort other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeModelSortProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum TreeModelSortPropertyName: String, PropertyNameProtocol {
    case model = "model"
}

public extension TreeModelSortProtocol {
    /// Bind a `TreeModelSortPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeModelSortPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeModelSort property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeModelSortPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeModelSort property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeModelSortPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeModelSortSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyModel = "notify::model"
}

// MARK: TreeModelSort has no signals
// MARK: TreeModelSort Class: TreeModelSortProtocol extension (methods and fields)
public extension TreeModelSortProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeModelSort` instance.
    @inlinable var tree_model_sort_ptr: UnsafeMutablePointer<GtkTreeModelSort>! { return ptr?.assumingMemoryBound(to: GtkTreeModelSort.self) }

    /// This function should almost never be called.  It clears the `tree_model_sort`
    /// of any cached iterators that haven’t been reffed with
    /// `gtk_tree_model_ref_node()`.  This might be useful if the child model being
    /// sorted is static (and doesn’t change often) and there has been a lot of
    /// unreffed access to nodes.  As a side effect of this function, all unreffed
    /// iters will be invalid.
    @inlinable func clearCache() {
        gtk_tree_model_sort_clear_cache(tree_model_sort_ptr)
    
    }

    /// Sets `sort_iter` to point to the row in `tree_model_sort` that corresponds to
    /// the row pointed at by `child_iter`.  If `sort_iter` was not set, `false`
    /// is returned.  Note: a boolean is only returned since 2.14.
    @inlinable func convertChildIterToIter<TreeIterT: TreeIterProtocol>(sortIter: TreeIterT, childIter: TreeIterT) -> Bool {
        let rv = ((gtk_tree_model_sort_convert_child_iter_to_iter(tree_model_sort_ptr, sortIter.tree_iter_ptr, childIter.tree_iter_ptr)) != 0)
        return rv
    }

    /// Converts `child_path` to a path relative to `tree_model_sort`.  That is,
    /// `child_path` points to a path in the child model.  The returned path will
    /// point to the same row in the sorted model.  If `child_path` isn’t a valid
    /// path on the child model, then `nil` is returned.
    @inlinable func convertChildPathToPath<TreePathT: TreePathProtocol>(childPath: TreePathT) -> TreePathRef! {
        let rv = TreePathRef(gconstpointer: gconstpointer(gtk_tree_model_sort_convert_child_path_to_path(tree_model_sort_ptr, childPath.tree_path_ptr)))
        return rv
    }

    /// Sets `child_iter` to point to the row pointed to by `sorted_iter`.
    @inlinable func convertIterTo<TreeIterT: TreeIterProtocol>(childIter: TreeIterT, sortedIter: TreeIterT) {
        gtk_tree_model_sort_convert_iter_to_child_iter(tree_model_sort_ptr, childIter.tree_iter_ptr, sortedIter.tree_iter_ptr)
    
    }

    /// Converts `sorted_path` to a path on the child model of `tree_model_sort`.
    /// That is, `sorted_path` points to a location in `tree_model_sort`.  The
    /// returned path will point to the same location in the model not being
    /// sorted.  If `sorted_path` does not point to a location in the child model,
    /// `nil` is returned.
    @inlinable func convertPathToChildPath<TreePathT: TreePathProtocol>(sortedPath: TreePathT) -> TreePathRef! {
        let rv = TreePathRef(gconstpointer: gconstpointer(gtk_tree_model_sort_convert_path_to_child_path(tree_model_sort_ptr, sortedPath.tree_path_ptr)))
        return rv
    }

    /// Returns the model the `GtkTreeModelSort` is sorting.
    @inlinable func getModel() -> TreeModelRef! {
        let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_tree_model_sort_get_model(tree_model_sort_ptr)))
        return rv
    }

    /// >&gt; This function is slow. Only use it for debugging and/or testing
    /// &gt; purposes.
    /// 
    /// Checks if the given iter is a valid iter for this `GtkTreeModelSort`.
    @inlinable func iterIsValid<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let rv = ((gtk_tree_model_sort_iter_is_valid(tree_model_sort_ptr, iter.tree_iter_ptr)) != 0)
        return rv
    }

    /// This resets the default sort function to be in the “unsorted” state.  That
    /// is, it is in the same order as the child model. It will re-sort the model
    /// to be in the same order as the child model only if the `GtkTreeModelSort`
    /// is in “unsorted” state.
    @inlinable func resetDefaultSortFunc() {
        gtk_tree_model_sort_reset_default_sort_func(tree_model_sort_ptr)
    
    }
    @inlinable var model: TreeModelRef! {
        /// Returns the model the `GtkTreeModelSort` is sorting.
        get {
            let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_tree_model_sort_get_model(tree_model_sort_ptr)))
            return rv
        }
    }

    @inlinable var parent: GObject {
        get {
            let rv = tree_model_sort_ptr.pointee.parent
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TreeSelection Class

/// The `GtkTreeSelection` object is a helper object to manage the selection
/// for a `GtkTreeView` widget.  The `GtkTreeSelection` object is
/// automatically created when a new `GtkTreeView` widget is created, and
/// cannot exist independently of this widget.  The primary reason the
/// `GtkTreeSelection` objects exists is for cleanliness of code and API.
/// That is, there is no conceptual reason all these functions could not be
/// methods on the `GtkTreeView` widget instead of a separate function.
/// 
/// The `GtkTreeSelection` object is gotten from a `GtkTreeView` by calling
/// `gtk_tree_view_get_selection()`.  It can be manipulated to check the
/// selection status of the tree, as well as select and deselect individual
/// rows.  Selection is done completely view side.  As a result, multiple
/// views of the same model can have completely different selections.
/// Additionally, you cannot change the selection of a row on the model that
/// is not currently displayed by the view without expanding its parents
/// first.
/// 
/// One of the important things to remember when monitoring the selection of
/// a view is that the `GtkTreeSelection::changed` signal is mostly a hint.
/// That is, it may only emit one signal when a range of rows is selected.
/// Additionally, it may on occasion emit a `GtkTreeSelection::changed` signal
/// when nothing has happened (mostly as a result of programmers calling
/// select_row on an already selected row).
///
/// The `TreeSelectionProtocol` protocol exposes the methods and properties of an underlying `GtkTreeSelection` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeSelection`.
/// Alternatively, use `TreeSelectionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeSelectionProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkTreeSelection` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeSelection` instance.
    var tree_selection_ptr: UnsafeMutablePointer<GtkTreeSelection>! { get }

    /// Required Initialiser for types conforming to `TreeSelectionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GtkTreeSelection` object is a helper object to manage the selection
/// for a `GtkTreeView` widget.  The `GtkTreeSelection` object is
/// automatically created when a new `GtkTreeView` widget is created, and
/// cannot exist independently of this widget.  The primary reason the
/// `GtkTreeSelection` objects exists is for cleanliness of code and API.
/// That is, there is no conceptual reason all these functions could not be
/// methods on the `GtkTreeView` widget instead of a separate function.
/// 
/// The `GtkTreeSelection` object is gotten from a `GtkTreeView` by calling
/// `gtk_tree_view_get_selection()`.  It can be manipulated to check the
/// selection status of the tree, as well as select and deselect individual
/// rows.  Selection is done completely view side.  As a result, multiple
/// views of the same model can have completely different selections.
/// Additionally, you cannot change the selection of a row on the model that
/// is not currently displayed by the view without expanding its parents
/// first.
/// 
/// One of the important things to remember when monitoring the selection of
/// a view is that the `GtkTreeSelection::changed` signal is mostly a hint.
/// That is, it may only emit one signal when a range of rows is selected.
/// Additionally, it may on occasion emit a `GtkTreeSelection::changed` signal
/// when nothing has happened (mostly as a result of programmers calling
/// select_row on an already selected row).
///
/// The `TreeSelectionRef` type acts as a lightweight Swift reference to an underlying `GtkTreeSelection` instance.
/// It exposes methods that can operate on this data type through `TreeSelectionProtocol` conformance.
/// Use `TreeSelectionRef` only as an `unowned` reference to an existing `GtkTreeSelection` instance.
///
public struct TreeSelectionRef: TreeSelectionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeSelection` instance.
    /// For type-safe access, use the generated, typed pointer `tree_selection_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeSelectionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeSelection>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeSelection>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeSelection>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeSelection>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeSelectionProtocol`
    @inlinable init<T: TreeSelectionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeSelectionProtocol>(_ other: T) -> TreeSelectionRef { TreeSelectionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// The `GtkTreeSelection` object is a helper object to manage the selection
/// for a `GtkTreeView` widget.  The `GtkTreeSelection` object is
/// automatically created when a new `GtkTreeView` widget is created, and
/// cannot exist independently of this widget.  The primary reason the
/// `GtkTreeSelection` objects exists is for cleanliness of code and API.
/// That is, there is no conceptual reason all these functions could not be
/// methods on the `GtkTreeView` widget instead of a separate function.
/// 
/// The `GtkTreeSelection` object is gotten from a `GtkTreeView` by calling
/// `gtk_tree_view_get_selection()`.  It can be manipulated to check the
/// selection status of the tree, as well as select and deselect individual
/// rows.  Selection is done completely view side.  As a result, multiple
/// views of the same model can have completely different selections.
/// Additionally, you cannot change the selection of a row on the model that
/// is not currently displayed by the view without expanding its parents
/// first.
/// 
/// One of the important things to remember when monitoring the selection of
/// a view is that the `GtkTreeSelection::changed` signal is mostly a hint.
/// That is, it may only emit one signal when a range of rows is selected.
/// Additionally, it may on occasion emit a `GtkTreeSelection::changed` signal
/// when nothing has happened (mostly as a result of programmers calling
/// select_row on an already selected row).
///
/// The `TreeSelection` type acts as a reference-counted owner of an underlying `GtkTreeSelection` instance.
/// It provides the methods that can operate on this data type through `TreeSelectionProtocol` conformance.
/// Use `TreeSelection` as a strong reference or owner of a `GtkTreeSelection` instance.
///
open class TreeSelection: GLibObject.Object, TreeSelectionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeSelection>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeSelection>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeSelection>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeSelection>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeSelection`.
    /// i.e., ownership is transferred to the `TreeSelection` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeSelection>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeSelectionProtocol`
    /// Will retain `GtkTreeSelection`.
    /// - Parameter other: an instance of a related type that implements `TreeSelectionProtocol`
    @inlinable public init<T: TreeSelectionProtocol>(treeSelection other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeSelectionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum TreeSelectionPropertyName: String, PropertyNameProtocol {
    /// Selection mode.
    /// See `gtk_tree_selection_set_mode()` for more information on this property.
    case mode = "mode"
}

public extension TreeSelectionProtocol {
    /// Bind a `TreeSelectionPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeSelectionPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeSelection property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeSelectionPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeSelection property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeSelectionPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeSelectionSignalName: String, SignalNameProtocol {
    /// Emitted whenever the selection has (possibly) changed. Please note that
    /// this signal is mostly a hint.  It may only be emitted once when a range
    /// of rows are selected, and it may occasionally be emitted when nothing
    /// has happened.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Selection mode.
    /// See `gtk_tree_selection_set_mode()` for more information on this property.
    case notifyMode = "notify::mode"
}

// MARK: TreeSelection signals
public extension TreeSelectionProtocol {
    /// Connect a Swift signal handler to the given, typed `TreeSelectionSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeSelectionSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TreeSelectionSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeSelectionSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted whenever the selection has (possibly) changed. Please note that
    /// this signal is mostly a hint.  It may only be emitted once when a range
    /// of rows are selected, and it may occasionally be emitted when nothing
    /// has happened.
    /// - Note: This represents the underlying `changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `changed` signal is emitted
    @discardableResult @inlinable func onChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeSelectionRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TreeSelectionRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeSelectionRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .changed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `changed` signal for using the `connect(signal:)` methods
    static var changedSignal: TreeSelectionSignalName { .changed }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMode` signal is emitted
    @discardableResult @inlinable func onNotifyMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeSelectionRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeSelectionRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeSelectionRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::mode` signal for using the `connect(signal:)` methods
    static var notifyModeSignal: TreeSelectionSignalName { .notifyMode }
    
}

// MARK: TreeSelection Class: TreeSelectionProtocol extension (methods and fields)
public extension TreeSelectionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeSelection` instance.
    @inlinable var tree_selection_ptr: UnsafeMutablePointer<GtkTreeSelection>! { return ptr?.assumingMemoryBound(to: GtkTreeSelection.self) }

    /// Returns the number of rows that have been selected in `tree`.
    @inlinable func countSelectedRows() -> Int {
        let rv = Int(gtk_tree_selection_count_selected_rows(tree_selection_ptr))
        return rv
    }

    /// Gets the selection mode for `selection`. See
    /// `gtk_tree_selection_set_mode()`.
    @inlinable func getMode() -> GtkSelectionMode {
        let rv = gtk_tree_selection_get_mode(tree_selection_ptr)
        return rv
    }

    /// Returns the current selection function.
    @inlinable func getSelectFunction() -> GtkTreeSelectionFunc! {
        let rv = gtk_tree_selection_get_select_function(tree_selection_ptr)
        return rv
    }

    /// Sets `iter` to the currently selected node if `selection` is set to
    /// `GTK_SELECTION_SINGLE` or `GTK_SELECTION_BROWSE`.  `iter` may be NULL if you
    /// just want to test if `selection` has any selected nodes.  `model` is filled
    /// with the current model as a convenience.  This function will not work if you
    /// use `selection` is `GTK_SELECTION_MULTIPLE`.
    @inlinable func getSelected(model: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeModel>?>! = nil, iter: TreeIterRef? = nil) -> Bool {
        let rv = ((gtk_tree_selection_get_selected(tree_selection_ptr, model, iter?.tree_iter_ptr)) != 0)
        return rv
    }
    /// Sets `iter` to the currently selected node if `selection` is set to
    /// `GTK_SELECTION_SINGLE` or `GTK_SELECTION_BROWSE`.  `iter` may be NULL if you
    /// just want to test if `selection` has any selected nodes.  `model` is filled
    /// with the current model as a convenience.  This function will not work if you
    /// use `selection` is `GTK_SELECTION_MULTIPLE`.
    @inlinable func getSelected<TreeIterT: TreeIterProtocol>(model: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeModel>?>! = nil, iter: TreeIterT?) -> Bool {
        let rv = ((gtk_tree_selection_get_selected(tree_selection_ptr, model, iter?.tree_iter_ptr)) != 0)
        return rv
    }

    /// Creates a list of path of all selected rows. Additionally, if you are
    /// planning on modifying the model after calling this function, you may
    /// want to convert the returned list into a list of `GtkTreeRowReferences`.
    /// To do this, you can use `gtk_tree_row_reference_new()`.
    /// 
    /// To free the return value, use:
    /// (C Language Example):
    /// ```C
    /// g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);
    /// ```
    /// 
    @inlinable func getSelectedRows(model: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeModel>?>! = nil) -> GLib.ListRef! {
        let rv = GLib.ListRef(gtk_tree_selection_get_selected_rows(tree_selection_ptr, model))
        return rv
    }

    /// Returns the tree view associated with `selection`.
    @inlinable func getTreeView() -> TreeViewRef! {
        let rv = TreeViewRef(gconstpointer: gconstpointer(gtk_tree_selection_get_tree_view(tree_selection_ptr)))
        return rv
    }

    /// Returns the user data for the selection function.
    @inlinable func getUserData() -> gpointer! {
        let rv = gtk_tree_selection_get_user_data(tree_selection_ptr)
        return rv
    }

    /// Returns `true` if the row at `iter` is currently selected.
    @inlinable func iterIsSelected<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let rv = ((gtk_tree_selection_iter_is_selected(tree_selection_ptr, iter.tree_iter_ptr)) != 0)
        return rv
    }

    /// Returns `true` if the row pointed to by `path` is currently selected.  If `path`
    /// does not point to a valid location, `false` is returned
    @inlinable func pathIsSelected<TreePathT: TreePathProtocol>(path: TreePathT) -> Bool {
        let rv = ((gtk_tree_selection_path_is_selected(tree_selection_ptr, path.tree_path_ptr)) != 0)
        return rv
    }

    /// Selects all the nodes. `selection` must be set to `GTK_SELECTION_MULTIPLE`
    /// mode.
    @inlinable func selectAll() {
        gtk_tree_selection_select_all(tree_selection_ptr)
    
    }

    /// Selects the specified iterator.
    @inlinable func select<TreeIterT: TreeIterProtocol>(iter: TreeIterT) {
        gtk_tree_selection_select_iter(tree_selection_ptr, iter.tree_iter_ptr)
    
    }

    /// Select the row at `path`.
    @inlinable func select<TreePathT: TreePathProtocol>(path: TreePathT) {
        gtk_tree_selection_select_path(tree_selection_ptr, path.tree_path_ptr)
    
    }

    /// Selects a range of nodes, determined by `start_path` and `end_path` inclusive.
    /// `selection` must be set to `GTK_SELECTION_MULTIPLE` mode.
    @inlinable func selectRange<TreePathT: TreePathProtocol>(startPath: TreePathT, endPath: TreePathT) {
        gtk_tree_selection_select_range(tree_selection_ptr, startPath.tree_path_ptr, endPath.tree_path_ptr)
    
    }

    /// Calls a function for each selected node. Note that you cannot modify
    /// the tree or selection from within this function. As a result,
    /// `gtk_tree_selection_get_selected_rows()` might be more useful.
    @inlinable func selectedForeach(`func`: GtkTreeSelectionForeachFunc?, data: gpointer! = nil) {
        gtk_tree_selection_selected_foreach(tree_selection_ptr, `func`, data)
    
    }

    /// Sets the selection mode of the `selection`.  If the previous type was
    /// `GTK_SELECTION_MULTIPLE`, then the anchor is kept selected, if it was
    /// previously selected.
    @inlinable func setMode(type: GtkSelectionMode) {
        gtk_tree_selection_set_mode(tree_selection_ptr, type)
    
    }

    /// Sets the selection function.
    /// 
    /// If set, this function is called before any node is selected or unselected,
    /// giving some control over which nodes are selected. The select function
    /// should return `true` if the state of the node may be toggled, and `false`
    /// if the state of the node should be left unchanged.
    @inlinable func setSelectFunction(`func`: GtkTreeSelectionFunc? = nil, data: gpointer! = nil, destroy: GDestroyNotify?) {
        gtk_tree_selection_set_select_function(tree_selection_ptr, `func`, data, destroy)
    
    }

    /// Unselects all the nodes.
    @inlinable func unselectAll() {
        gtk_tree_selection_unselect_all(tree_selection_ptr)
    
    }

    /// Unselects the specified iterator.
    @inlinable func unselect<TreeIterT: TreeIterProtocol>(iter: TreeIterT) {
        gtk_tree_selection_unselect_iter(tree_selection_ptr, iter.tree_iter_ptr)
    
    }

    /// Unselects the row at `path`.
    @inlinable func unselect<TreePathT: TreePathProtocol>(path: TreePathT) {
        gtk_tree_selection_unselect_path(tree_selection_ptr, path.tree_path_ptr)
    
    }

    /// Unselects a range of nodes, determined by `start_path` and `end_path`
    /// inclusive.
    @inlinable func unselectRange<TreePathT: TreePathProtocol>(startPath: TreePathT, endPath: TreePathT) {
        gtk_tree_selection_unselect_range(tree_selection_ptr, startPath.tree_path_ptr, endPath.tree_path_ptr)
    
    }
    /// Selection mode.
    /// See `gtk_tree_selection_set_mode()` for more information on this property.
    @inlinable var mode: GtkSelectionMode {
        /// Gets the selection mode for `selection`. See
        /// `gtk_tree_selection_set_mode()`.
        get {
            let rv = gtk_tree_selection_get_mode(tree_selection_ptr)
            return rv
        }
        /// Sets the selection mode of the `selection`.  If the previous type was
        /// `GTK_SELECTION_MULTIPLE`, then the anchor is kept selected, if it was
        /// previously selected.
        nonmutating set {
            gtk_tree_selection_set_mode(tree_selection_ptr, newValue)
        }
    }

    /// Returns the current selection function.
    @inlinable var selectFunction: GtkTreeSelectionFunc! {
        /// Returns the current selection function.
        get {
            let rv = gtk_tree_selection_get_select_function(tree_selection_ptr)
            return rv
        }
    }

    /// Returns the tree view associated with `selection`.
    @inlinable var treeView: TreeViewRef! {
        /// Returns the tree view associated with `selection`.
        get {
            let rv = TreeViewRef(gconstpointer: gconstpointer(gtk_tree_selection_get_tree_view(tree_selection_ptr)))
            return rv
        }
    }

    /// Returns the user data for the selection function.
    @inlinable var userData: gpointer! {
        /// Returns the user data for the selection function.
        get {
            let rv = gtk_tree_selection_get_user_data(tree_selection_ptr)
            return rv
        }
    }

    // var parent is unavailable because parent is private

    // var priv is unavailable because priv is private

}



// MARK: - TreeStore Class

/// The `GtkTreeStore` object is a list model for use with a `GtkTreeView`
/// widget.  It implements the `GtkTreeModel` interface, and consequentially,
/// can use all of the methods available there.  It also implements the
/// `GtkTreeSortable` interface so it can be sorted by the view.  Finally,
/// it also implements the tree
/// [drag and drop](#gtk3-GtkTreeView-drag-and-drop)
/// interfaces.
/// 
/// # GtkTreeStore as GtkBuildable
/// 
/// The GtkTreeStore implementation of the `GtkBuildable` interface allows
/// to specify the model columns with a &lt;columns&gt; element that may contain
/// multiple &lt;column&gt; elements, each specifying one model column. The “type”
/// attribute specifies the data type for the column.
/// 
/// An example of a UI Definition fragment for a tree store:
/// ```
/// <object class="GtkTreeStore">
///   <columns>
///     <column type="gchararray"/>
///     <column type="gchararray"/>
///     <column type="gint"/>
///   </columns>
/// </object>
/// ```
/// 
///
/// The `TreeStoreProtocol` protocol exposes the methods and properties of an underlying `GtkTreeStore` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeStore`.
/// Alternatively, use `TreeStoreRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeStoreProtocol: GLibObject.ObjectProtocol, BuildableProtocol, TreeDragDestProtocol, TreeDragSourceProtocol, TreeModelProtocol, TreeSortableProtocol {
        /// Untyped pointer to the underlying `GtkTreeStore` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeStore` instance.
    var tree_store_ptr: UnsafeMutablePointer<GtkTreeStore>! { get }

    /// Required Initialiser for types conforming to `TreeStoreProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GtkTreeStore` object is a list model for use with a `GtkTreeView`
/// widget.  It implements the `GtkTreeModel` interface, and consequentially,
/// can use all of the methods available there.  It also implements the
/// `GtkTreeSortable` interface so it can be sorted by the view.  Finally,
/// it also implements the tree
/// [drag and drop](#gtk3-GtkTreeView-drag-and-drop)
/// interfaces.
/// 
/// # GtkTreeStore as GtkBuildable
/// 
/// The GtkTreeStore implementation of the `GtkBuildable` interface allows
/// to specify the model columns with a &lt;columns&gt; element that may contain
/// multiple &lt;column&gt; elements, each specifying one model column. The “type”
/// attribute specifies the data type for the column.
/// 
/// An example of a UI Definition fragment for a tree store:
/// ```
/// <object class="GtkTreeStore">
///   <columns>
///     <column type="gchararray"/>
///     <column type="gchararray"/>
///     <column type="gint"/>
///   </columns>
/// </object>
/// ```
/// 
///
/// The `TreeStoreRef` type acts as a lightweight Swift reference to an underlying `GtkTreeStore` instance.
/// It exposes methods that can operate on this data type through `TreeStoreProtocol` conformance.
/// Use `TreeStoreRef` only as an `unowned` reference to an existing `GtkTreeStore` instance.
///
public struct TreeStoreRef: TreeStoreProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeStore` instance.
    /// For type-safe access, use the generated, typed pointer `tree_store_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeStoreRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeStore>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeStore>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeStore>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeStore>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeStoreProtocol`
    @inlinable init<T: TreeStoreProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeStoreProtocol>(_ other: T) -> TreeStoreRef { TreeStoreRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    
    // *** new() is not available because it has a varargs (...) parameter!


    /// Non vararg creation function.  Used primarily by language bindings.
    @inlinable init(nColumns: Int, types: UnsafeMutablePointer<GType>!) {
        let rv = gtk_tree_store_newv(gint(nColumns), types)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Non vararg creation function.  Used primarily by language bindings.
    @inlinable static func treeStoreNewv(nColumns: Int, types: UnsafeMutablePointer<GType>!) -> TreeStoreRef! {
        guard let rv = TreeStoreRef(gconstpointer: gconstpointer(gtk_tree_store_newv(gint(nColumns), types))) else { return nil }
        return rv
    }
}

/// The `GtkTreeStore` object is a list model for use with a `GtkTreeView`
/// widget.  It implements the `GtkTreeModel` interface, and consequentially,
/// can use all of the methods available there.  It also implements the
/// `GtkTreeSortable` interface so it can be sorted by the view.  Finally,
/// it also implements the tree
/// [drag and drop](#gtk3-GtkTreeView-drag-and-drop)
/// interfaces.
/// 
/// # GtkTreeStore as GtkBuildable
/// 
/// The GtkTreeStore implementation of the `GtkBuildable` interface allows
/// to specify the model columns with a &lt;columns&gt; element that may contain
/// multiple &lt;column&gt; elements, each specifying one model column. The “type”
/// attribute specifies the data type for the column.
/// 
/// An example of a UI Definition fragment for a tree store:
/// ```
/// <object class="GtkTreeStore">
///   <columns>
///     <column type="gchararray"/>
///     <column type="gchararray"/>
///     <column type="gint"/>
///   </columns>
/// </object>
/// ```
/// 
///
/// The `TreeStore` type acts as a reference-counted owner of an underlying `GtkTreeStore` instance.
/// It provides the methods that can operate on this data type through `TreeStoreProtocol` conformance.
/// Use `TreeStore` as a strong reference or owner of a `GtkTreeStore` instance.
///
open class TreeStore: GLibObject.Object, TreeStoreProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeStore>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeStore>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeStore>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeStore>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeStore`.
    /// i.e., ownership is transferred to the `TreeStore` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeStore>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeStoreProtocol`
    /// Will retain `GtkTreeStore`.
    /// - Parameter other: an instance of a related type that implements `TreeStoreProtocol`
    @inlinable public init<T: TreeStoreProtocol>(treeStore other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeStoreProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }


    // *** new() is not available because it has a varargs (...) parameter!


    /// Non vararg creation function.  Used primarily by language bindings.
    @inlinable public init(nColumns: Int, types: UnsafeMutablePointer<GType>!) {
        let rv = gtk_tree_store_newv(gint(nColumns), types)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Non vararg creation function.  Used primarily by language bindings.
    @inlinable public static func treeStoreNewv(nColumns: Int, types: UnsafeMutablePointer<GType>!) -> TreeStore! {
        guard let rv = TreeStore(gconstpointer: gconstpointer(gtk_tree_store_newv(gint(nColumns), types))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

// MARK: no TreeStore properties

public enum TreeStoreSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: TreeStore has no signals
// MARK: TreeStore Class: TreeStoreProtocol extension (methods and fields)
public extension TreeStoreProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeStore` instance.
    @inlinable var tree_store_ptr: UnsafeMutablePointer<GtkTreeStore>! { return ptr?.assumingMemoryBound(to: GtkTreeStore.self) }

    /// Appends a new row to `tree_store`.  If `parent` is non-`nil`, then it will append the
    /// new row after the last child of `parent`, otherwise it will append a row to
    /// the top level.  `iter` will be changed to point to this new row.  The row will
    /// be empty after this function is called.  To fill in values, you need to call
    /// `gtk_tree_store_set()` or `gtk_tree_store_set_value()`.
    @inlinable func append<TreeIterT: TreeIterProtocol>(iter: TreeIterT, parent: TreeIterT?) {
        gtk_tree_store_append(tree_store_ptr, iter.tree_iter_ptr, parent?.tree_iter_ptr)
    
    }

    /// Removes all rows from `tree_store`
    @inlinable func clear() {
        gtk_tree_store_clear(tree_store_ptr)
    
    }

    /// Creates a new row at `position`.  If parent is non-`nil`, then the row will be
    /// made a child of `parent`.  Otherwise, the row will be created at the toplevel.
    /// If `position` is -1 or is larger than the number of rows at that level, then
    /// the new row will be inserted to the end of the list.  `iter` will be changed
    /// to point to this new row.  The row will be empty after this function is
    /// called.  To fill in values, you need to call `gtk_tree_store_set()` or
    /// `gtk_tree_store_set_value()`.
    @inlinable func insert<TreeIterT: TreeIterProtocol>(iter: TreeIterT, parent: TreeIterT?, position: Int) {
        gtk_tree_store_insert(tree_store_ptr, iter.tree_iter_ptr, parent?.tree_iter_ptr, gint(position))
    
    }

    /// Inserts a new row after `sibling`.  If `sibling` is `nil`, then the row will be
    /// prepended to `parent` ’s children.  If `parent` and `sibling` are `nil`, then
    /// the row will be prepended to the toplevel.  If both `sibling` and `parent` are
    /// set, then `parent` must be the parent of `sibling`.  When `sibling` is set,
    /// `parent` is optional.
    /// 
    /// `iter` will be changed to point to this new row.  The row will be empty after
    /// this function is called.  To fill in values, you need to call
    /// `gtk_tree_store_set()` or `gtk_tree_store_set_value()`.
    @inlinable func insertAfter<TreeIterT: TreeIterProtocol>(iter: TreeIterT, parent: TreeIterT?, sibling: TreeIterT?) {
        gtk_tree_store_insert_after(tree_store_ptr, iter.tree_iter_ptr, parent?.tree_iter_ptr, sibling?.tree_iter_ptr)
    
    }

    /// Inserts a new row before `sibling`.  If `sibling` is `nil`, then the row will
    /// be appended to `parent` ’s children.  If `parent` and `sibling` are `nil`, then
    /// the row will be appended to the toplevel.  If both `sibling` and `parent` are
    /// set, then `parent` must be the parent of `sibling`.  When `sibling` is set,
    /// `parent` is optional.
    /// 
    /// `iter` will be changed to point to this new row.  The row will be empty after
    /// this function is called.  To fill in values, you need to call
    /// `gtk_tree_store_set()` or `gtk_tree_store_set_value()`.
    @inlinable func insertBefore<TreeIterT: TreeIterProtocol>(iter: TreeIterT, parent: TreeIterT?, sibling: TreeIterT?) {
        gtk_tree_store_insert_before(tree_store_ptr, iter.tree_iter_ptr, parent?.tree_iter_ptr, sibling?.tree_iter_ptr)
    
    }


    // *** insertWithValues() is not available because it has a varargs (...) parameter!


    /// A variant of `gtk_tree_store_insert_with_values()` which takes
    /// the columns and values as two arrays, instead of varargs.  This
    /// function is mainly intended for language bindings.
    @inlinable func insertWithValuesv(iter: TreeIterRef? = nil, parent: TreeIterRef? = nil, position: Int, columns: UnsafeMutablePointer<gint>!, values: UnsafeMutablePointer<GValue>!, nValues: Int) {
        gtk_tree_store_insert_with_valuesv(tree_store_ptr, iter?.tree_iter_ptr, parent?.tree_iter_ptr, gint(position), columns, values, gint(nValues))
    
    }
    /// A variant of `gtk_tree_store_insert_with_values()` which takes
    /// the columns and values as two arrays, instead of varargs.  This
    /// function is mainly intended for language bindings.
    @inlinable func insertWithValuesv<TreeIterT: TreeIterProtocol>(iter: TreeIterT?, parent: TreeIterT?, position: Int, columns: UnsafeMutablePointer<gint>!, values: UnsafeMutablePointer<GValue>!, nValues: Int) {
        gtk_tree_store_insert_with_valuesv(tree_store_ptr, iter?.tree_iter_ptr, parent?.tree_iter_ptr, gint(position), columns, values, gint(nValues))
    
    }

    /// Returns `true` if `iter` is an ancestor of `descendant`.  That is, `iter` is the
    /// parent (or grandparent or great-grandparent) of `descendant`.
    @inlinable func isAncestor<TreeIterT: TreeIterProtocol>(iter: TreeIterT, descendant: TreeIterT) -> Bool {
        let rv = ((gtk_tree_store_is_ancestor(tree_store_ptr, iter.tree_iter_ptr, descendant.tree_iter_ptr)) != 0)
        return rv
    }

    /// Returns the depth of `iter`.  This will be 0 for anything on the root level, 1
    /// for anything down a level, etc.
    @inlinable func iterDepth<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Int {
        let rv = Int(gtk_tree_store_iter_depth(tree_store_ptr, iter.tree_iter_ptr))
        return rv
    }

    /// WARNING: This function is slow. Only use it for debugging and/or testing
    /// purposes.
    /// 
    /// Checks if the given iter is a valid iter for this `GtkTreeStore`.
    @inlinable func iterIsValid<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let rv = ((gtk_tree_store_iter_is_valid(tree_store_ptr, iter.tree_iter_ptr)) != 0)
        return rv
    }

    /// Moves `iter` in `tree_store` to the position after `position`. `iter` and
    /// `position` should be in the same level. Note that this function only
    /// works with unsorted stores. If `position` is `nil`, `iter` will be moved
    /// to the start of the level.
    @inlinable func moveAfter<TreeIterT: TreeIterProtocol>(iter: TreeIterT, position: TreeIterT?) {
        gtk_tree_store_move_after(tree_store_ptr, iter.tree_iter_ptr, position?.tree_iter_ptr)
    
    }

    /// Moves `iter` in `tree_store` to the position before `position`. `iter` and
    /// `position` should be in the same level. Note that this function only
    /// works with unsorted stores. If `position` is `nil`, `iter` will be
    /// moved to the end of the level.
    @inlinable func moveBefore<TreeIterT: TreeIterProtocol>(iter: TreeIterT, position: TreeIterT?) {
        gtk_tree_store_move_before(tree_store_ptr, iter.tree_iter_ptr, position?.tree_iter_ptr)
    
    }

    /// Prepends a new row to `tree_store`.  If `parent` is non-`nil`, then it will prepend
    /// the new row before the first child of `parent`, otherwise it will prepend a row
    /// to the top level.  `iter` will be changed to point to this new row.  The row
    /// will be empty after this function is called.  To fill in values, you need to
    /// call `gtk_tree_store_set()` or `gtk_tree_store_set_value()`.
    @inlinable func prepend<TreeIterT: TreeIterProtocol>(iter: TreeIterT, parent: TreeIterT?) {
        gtk_tree_store_prepend(tree_store_ptr, iter.tree_iter_ptr, parent?.tree_iter_ptr)
    
    }

    /// Removes `iter` from `tree_store`.  After being removed, `iter` is set to the
    /// next valid row at that level, or invalidated if it previously pointed to the
    /// last one.
    @inlinable func remove<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let rv = ((gtk_tree_store_remove(tree_store_ptr, iter.tree_iter_ptr)) != 0)
        return rv
    }

    /// Reorders the children of `parent` in `tree_store` to follow the order
    /// indicated by `new_order`. Note that this function only works with
    /// unsorted stores.
    @inlinable func reorder(parent: TreeIterRef? = nil, newOrder: UnsafeMutablePointer<gint>!) {
        gtk_tree_store_reorder(tree_store_ptr, parent?.tree_iter_ptr, newOrder)
    
    }
    /// Reorders the children of `parent` in `tree_store` to follow the order
    /// indicated by `new_order`. Note that this function only works with
    /// unsorted stores.
    @inlinable func reorder<TreeIterT: TreeIterProtocol>(parent: TreeIterT?, newOrder: UnsafeMutablePointer<gint>!) {
        gtk_tree_store_reorder(tree_store_ptr, parent?.tree_iter_ptr, newOrder)
    
    }


    // *** set() is not available because it has a varargs (...) parameter!


    /// This function is meant primarily for `GObjects` that inherit from
    /// `GtkTreeStore`, and should only be used when constructing a new
    /// `GtkTreeStore`.  It will not function after a row has been added,
    /// or a method on the `GtkTreeModel` interface is called.
    @inlinable func setColumnTypes(nColumns: Int, types: UnsafeMutablePointer<GType>!) {
        gtk_tree_store_set_column_types(tree_store_ptr, gint(nColumns), types)
    
    }

    /// See `gtk_tree_store_set()`; this version takes a va_list for
    /// use by language bindings.
    @inlinable func setValist<TreeIterT: TreeIterProtocol>(iter: TreeIterT, varArgs: CVaListPointer) {
        gtk_tree_store_set_valist(tree_store_ptr, iter.tree_iter_ptr, varArgs)
    
    }

    /// Sets the data in the cell specified by `iter` and `column`.
    /// The type of `value` must be convertible to the type of the
    /// column.
    @inlinable func setValue<TreeIterT: TreeIterProtocol, ValueT: GLibObject.ValueProtocol>(iter: TreeIterT, column: Int, value: ValueT) {
        gtk_tree_store_set_value(tree_store_ptr, iter.tree_iter_ptr, gint(column), value.value_ptr)
    
    }

    /// A variant of `gtk_tree_store_set_valist()` which takes
    /// the columns and values as two arrays, instead of varargs.  This
    /// function is mainly intended for language bindings or in case
    /// the number of columns to change is not known until run-time.
    @inlinable func setValuesv<TreeIterT: TreeIterProtocol>(iter: TreeIterT, columns: UnsafeMutablePointer<gint>!, values: UnsafeMutablePointer<GValue>!, nValues: Int) {
        gtk_tree_store_set_valuesv(tree_store_ptr, iter.tree_iter_ptr, columns, values, gint(nValues))
    
    }

    /// Swaps `a` and `b` in the same level of `tree_store`. Note that this function
    /// only works with unsorted stores.
    @inlinable func swap<TreeIterT: TreeIterProtocol>(a: TreeIterT, b: TreeIterT) {
        gtk_tree_store_swap(tree_store_ptr, a.tree_iter_ptr, b.tree_iter_ptr)
    
    }

    @inlinable var parent: GObject {
        get {
            let rv = tree_store_ptr.pointee.parent
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TreeView Class

/// Widget that displays any object that implements the `GtkTreeModel` interface.
/// 
/// Please refer to the
/// [tree widget conceptual overview](#TreeWidget)
/// for an overview of all the objects and data types related
/// to the tree widget and how they work together.
/// 
/// Several different coordinate systems are exposed in the GtkTreeView API.
/// These are:
/// 
/// ![](tree-view-coordinates.png)
/// 
/// Coordinate systems in GtkTreeView API:
/// 
/// - Widget coordinates: Coordinates relative to the widget (usually `widget-&gt;window`).
/// 
/// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
/// 
/// - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
///   coordinates start at (0, 0) for row 0 of the tree.
/// 
/// Several functions are available for converting between the different
/// coordinate systems.  The most common translations are between widget and bin
/// window coordinates and between bin window and tree coordinates. For the
/// former you can use `gtk_tree_view_convert_widget_to_bin_window_coords()`
/// (and vice versa), for the latter `gtk_tree_view_convert_bin_window_to_tree_coords()`
/// (and vice versa).
/// 
/// # GtkTreeView as GtkBuildable
/// 
/// The GtkTreeView implementation of the GtkBuildable interface accepts
/// `GtkTreeViewColumn` objects as &lt;child&gt; elements and exposes the internal
/// `GtkTreeSelection` in UI definitions.
/// 
/// An example of a UI definition fragment with GtkTreeView:
/// ```
/// <object class="GtkTreeView" id="treeview">
///   <property name="model">liststore1</property>
///   <child>
///     <object class="GtkTreeViewColumn" id="test-column">
///       <property name="title">Test</property>
///       <child>
///         <object class="GtkCellRendererText" id="test-renderer"/>
///         <attributes>
///           <attribute name="text">1</attribute>
///         </attributes>
///       </child>
///     </object>
///   </child>
///   <child internal-child="selection">
///     <object class="GtkTreeSelection" id="selection">
///       <signal name="changed" handler="on_treeview_selection_changed"/>
///     </object>
///   </child>
/// </object>
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// treeview.view
/// ├── header
/// │   ├── <column header>
/// ┊   ┊
/// │   ╰── <column header>
/// │
/// ╰── [rubberband]
/// ```
/// 
/// GtkTreeView has a main CSS node with name treeview and style class .view.
/// It has a subnode with name header, which is the parent for all the column
/// header widgets' CSS nodes.
/// For rubberband selection, a subnode with name rubberband is used.
///
/// The `TreeViewProtocol` protocol exposes the methods and properties of an underlying `GtkTreeView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeView`.
/// Alternatively, use `TreeViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeViewProtocol: ContainerProtocol, ScrollableProtocol {
        /// Untyped pointer to the underlying `GtkTreeView` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeView` instance.
    var tree_view_ptr: UnsafeMutablePointer<GtkTreeView>! { get }

    /// Required Initialiser for types conforming to `TreeViewProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Widget that displays any object that implements the `GtkTreeModel` interface.
/// 
/// Please refer to the
/// [tree widget conceptual overview](#TreeWidget)
/// for an overview of all the objects and data types related
/// to the tree widget and how they work together.
/// 
/// Several different coordinate systems are exposed in the GtkTreeView API.
/// These are:
/// 
/// ![](tree-view-coordinates.png)
/// 
/// Coordinate systems in GtkTreeView API:
/// 
/// - Widget coordinates: Coordinates relative to the widget (usually `widget-&gt;window`).
/// 
/// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
/// 
/// - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
///   coordinates start at (0, 0) for row 0 of the tree.
/// 
/// Several functions are available for converting between the different
/// coordinate systems.  The most common translations are between widget and bin
/// window coordinates and between bin window and tree coordinates. For the
/// former you can use `gtk_tree_view_convert_widget_to_bin_window_coords()`
/// (and vice versa), for the latter `gtk_tree_view_convert_bin_window_to_tree_coords()`
/// (and vice versa).
/// 
/// # GtkTreeView as GtkBuildable
/// 
/// The GtkTreeView implementation of the GtkBuildable interface accepts
/// `GtkTreeViewColumn` objects as &lt;child&gt; elements and exposes the internal
/// `GtkTreeSelection` in UI definitions.
/// 
/// An example of a UI definition fragment with GtkTreeView:
/// ```
/// <object class="GtkTreeView" id="treeview">
///   <property name="model">liststore1</property>
///   <child>
///     <object class="GtkTreeViewColumn" id="test-column">
///       <property name="title">Test</property>
///       <child>
///         <object class="GtkCellRendererText" id="test-renderer"/>
///         <attributes>
///           <attribute name="text">1</attribute>
///         </attributes>
///       </child>
///     </object>
///   </child>
///   <child internal-child="selection">
///     <object class="GtkTreeSelection" id="selection">
///       <signal name="changed" handler="on_treeview_selection_changed"/>
///     </object>
///   </child>
/// </object>
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// treeview.view
/// ├── header
/// │   ├── <column header>
/// ┊   ┊
/// │   ╰── <column header>
/// │
/// ╰── [rubberband]
/// ```
/// 
/// GtkTreeView has a main CSS node with name treeview and style class .view.
/// It has a subnode with name header, which is the parent for all the column
/// header widgets' CSS nodes.
/// For rubberband selection, a subnode with name rubberband is used.
///
/// The `TreeViewRef` type acts as a lightweight Swift reference to an underlying `GtkTreeView` instance.
/// It exposes methods that can operate on this data type through `TreeViewProtocol` conformance.
/// Use `TreeViewRef` only as an `unowned` reference to an existing `GtkTreeView` instance.
///
public struct TreeViewRef: TreeViewProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeView` instance.
    /// For type-safe access, use the generated, typed pointer `tree_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeViewRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeView>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeView>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeView>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeView>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeViewProtocol`
    @inlinable init<T: TreeViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeViewProtocol>(_ other: T) -> TreeViewRef { TreeViewRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTreeView` widget.
    @inlinable init() {
        let rv = gtk_tree_view_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkTreeView` widget with the model initialized to `model`.
    @inlinable init<TreeModelT: TreeModelProtocol>(model: TreeModelT) {
        let rv = gtk_tree_view_new_with_model(model.tree_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkTreeView` widget with the model initialized to `model`.
    @inlinable static func newWith<TreeModelT: TreeModelProtocol>(model: TreeModelT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tree_view_new_with_model(model.tree_model_ptr))) else { return nil }
        return rv
    }
}

/// Widget that displays any object that implements the `GtkTreeModel` interface.
/// 
/// Please refer to the
/// [tree widget conceptual overview](#TreeWidget)
/// for an overview of all the objects and data types related
/// to the tree widget and how they work together.
/// 
/// Several different coordinate systems are exposed in the GtkTreeView API.
/// These are:
/// 
/// ![](tree-view-coordinates.png)
/// 
/// Coordinate systems in GtkTreeView API:
/// 
/// - Widget coordinates: Coordinates relative to the widget (usually `widget-&gt;window`).
/// 
/// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
/// 
/// - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
///   coordinates start at (0, 0) for row 0 of the tree.
/// 
/// Several functions are available for converting between the different
/// coordinate systems.  The most common translations are between widget and bin
/// window coordinates and between bin window and tree coordinates. For the
/// former you can use `gtk_tree_view_convert_widget_to_bin_window_coords()`
/// (and vice versa), for the latter `gtk_tree_view_convert_bin_window_to_tree_coords()`
/// (and vice versa).
/// 
/// # GtkTreeView as GtkBuildable
/// 
/// The GtkTreeView implementation of the GtkBuildable interface accepts
/// `GtkTreeViewColumn` objects as &lt;child&gt; elements and exposes the internal
/// `GtkTreeSelection` in UI definitions.
/// 
/// An example of a UI definition fragment with GtkTreeView:
/// ```
/// <object class="GtkTreeView" id="treeview">
///   <property name="model">liststore1</property>
///   <child>
///     <object class="GtkTreeViewColumn" id="test-column">
///       <property name="title">Test</property>
///       <child>
///         <object class="GtkCellRendererText" id="test-renderer"/>
///         <attributes>
///           <attribute name="text">1</attribute>
///         </attributes>
///       </child>
///     </object>
///   </child>
///   <child internal-child="selection">
///     <object class="GtkTreeSelection" id="selection">
///       <signal name="changed" handler="on_treeview_selection_changed"/>
///     </object>
///   </child>
/// </object>
/// ```
/// 
/// # CSS nodes
/// 
/// (plain Language Example):
/// ```plain
/// treeview.view
/// ├── header
/// │   ├── <column header>
/// ┊   ┊
/// │   ╰── <column header>
/// │
/// ╰── [rubberband]
/// ```
/// 
/// GtkTreeView has a main CSS node with name treeview and style class .view.
/// It has a subnode with name header, which is the parent for all the column
/// header widgets' CSS nodes.
/// For rubberband selection, a subnode with name rubberband is used.
///
/// The `TreeView` type acts as a reference-counted owner of an underlying `GtkTreeView` instance.
/// It provides the methods that can operate on this data type through `TreeViewProtocol` conformance.
/// Use `TreeView` as a strong reference or owner of a `GtkTreeView` instance.
///
open class TreeView: Container, TreeViewProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeView>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeView>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeView>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeView>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeView`.
    /// i.e., ownership is transferred to the `TreeView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeView>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeViewProtocol`
    /// Will retain `GtkTreeView`.
    /// - Parameter other: an instance of a related type that implements `TreeViewProtocol`
    @inlinable public init<T: TreeViewProtocol>(treeView other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkTreeView` widget.
    @inlinable public init() {
        let rv = gtk_tree_view_new()
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkTreeView` widget with the model initialized to `model`.
    @inlinable public init<TreeModelT: TreeModelProtocol>(model: TreeModelT) {
        let rv = gtk_tree_view_new_with_model(model.tree_model_ptr)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkTreeView` widget with the model initialized to `model`.
    @inlinable public static func newWith<TreeModelT: TreeModelProtocol>(model: TreeModelT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_tree_view_new_with_model(model.tree_model_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum TreeViewPropertyName: String, PropertyNameProtocol {
    /// The activate-on-single-click property specifies whether the "row-activated" signal
    /// will be emitted after a single click.
    case activateOnSingleClick = "activate-on-single-click"
    case appPaintable = "app-paintable"
    case borderWidth = "border-width"
    case canDefault = "can-default"
    case canFocus = "can-focus"
    case child = "child"
    case compositeChild = "composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case doubleBuffered = "double-buffered"
    case enableGridLines = "enable-grid-lines"
    case enableSearch = "enable-search"
    case enableTreeLines = "enable-tree-lines"
    case events = "events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case expand = "expand"
    case expanderColumn = "expander-column"
    /// Setting the `fixed-height-mode` property to `true` speeds up
    /// `GtkTreeView` by assuming that all rows have the same height.
    /// Only enable this option if all rows are the same height.
    /// Please see `gtk_tree_view_set_fixed_height_mode()` for more
    /// information on this option.
    case fixedHeightMode = "fixed-height-mode"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case focusOnClick = "focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case halign = "halign"
    case hasDefault = "has-default"
    case hasFocus = "has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case hasTooltip = "has-tooltip"
    case headersClickable = "headers-clickable"
    case headersVisible = "headers-visible"
    case heightRequest = "height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case hexpand = "hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case hexpandSet = "hexpand-set"
    /// Enables or disables the hover expansion mode of `tree_view`.
    /// Hover expansion makes rows expand or collapse if the pointer moves
    /// over them.
    /// 
    /// This mode is primarily intended for treeviews in popups, e.g.
    /// in `GtkComboBox` or `GtkEntryCompletion`.
    case hoverExpand = "hover-expand"
    /// Enables or disables the hover selection mode of `tree_view`.
    /// Hover selection makes the selected row follow the pointer.
    /// Currently, this works only for the selection modes
    /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
    /// 
    /// This mode is primarily intended for treeviews in popups, e.g.
    /// in `GtkComboBox` or `GtkEntryCompletion`.
    case hoverSelection = "hover-selection"
    case isFocus = "is-focus"
    /// Extra indentation for each level.
    case levelIndentation = "level-indentation"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case margin = "margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginEnd = "margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case marginLeft = "margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case marginRight = "margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case marginTop = "margin-top"
    case model = "model"
    case name = "name"
    case noShowAll = "no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case opacity = "opacity"
    case parent = "parent"
    case receivesDefault = "receives-default"
    case reorderable = "reorderable"
    case resizeMode = "resize-mode"
    case rubberBanding = "rubber-banding"
    /// Sets a hint to the theme to draw rows in alternating colors.
    ///
    /// **rules-hint is deprecated:**
    /// The theme is responsible for drawing rows
    ///   using zebra striping
    case rulesHint = "rules-hint"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case scaleFactor = "scale-factor"
    case searchColumn = "search-column"
    case sensitive = "sensitive"
    /// `true` if the view has expanders.
    case showExpanders = "show-expanders"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case style = "style"
    case tooltipColumn = "tooltip-column"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case valign = "valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case vexpand = "vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case vexpandSet = "vexpand-set"
    case visible = "visible"
    case widthRequest = "width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case window = "window"
}

public extension TreeViewProtocol {
    /// Bind a `TreeViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeView property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeViewPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeView property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeViewPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeViewSignalName: String, SignalNameProtocol {
    case accelClosuresChanged = "accel-closures-changed"
    case add = "add"
    /// The `button-press-event` signal will be emitted when a button
    /// (typically from a mouse) is pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonPressEvent = "button-press-event"
    /// The `button-release-event` signal will be emitted when a button
    /// (typically from a mouse) is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the
    /// widget needs to enable the `GDK_BUTTON_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case buttonReleaseEvent = "button-release-event"
    /// Determines whether an accelerator that activates the signal
    /// identified by `signal_id` can currently be activated.
    /// This signal is present to allow applications and derived
    /// widgets to override the default `GtkWidget` handling
    /// for determining whether an accelerator can be activated.
    case canActivateAccel = "can-activate-accel"
    case checkResize = "check-resize"
    /// The `child-notify` signal is emitted for each
    /// [child property](#child-properties)  that has
    /// changed on an object. The signal's detail holds the property name.
    case childNotify = "child-notify"
    /// The number of columns of the treeview has changed.
    case columnsChanged = "columns-changed"
    /// The `composited-changed` signal is emitted when the composited
    /// status of `widgets` screen changes.
    /// See `gdk_screen_is_composited()`.
    ///
    /// **composited-changed is deprecated:**
    /// Use GdkScreen::composited-changed instead.
    case compositedChanged = "composited-changed"
    /// The `configure-event` signal will be emitted when the size, position or
    /// stacking of the `widget`'s window has changed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case configureEvent = "configure-event"
    /// The position of the cursor (focused cell) has changed.
    case cursorChanged = "cursor-changed"
    /// Emitted when a redirected window belonging to `widget` gets drawn into.
    /// The region/area members of the event shows what area of the redirected
    /// drawable was drawn into.
    case damageEvent = "damage-event"
    /// The `delete-event` signal is emitted if a user requests that
    /// a toplevel window is closed. The default handler for this signal
    /// destroys the window. Connecting `gtk_widget_hide_on_delete()` to
    /// this signal will cause the window to be hidden instead, so that
    /// it can later be shown again without reconstructing it.
    case deleteEvent = "delete-event"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold. May result in finalization of the widget
    /// if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// The `destroy-event` signal is emitted when a `GdkWindow` is destroyed.
    /// You rarely get this signal, because most widgets disconnect themselves
    /// from their window before they destroy it, so no widget owns the
    /// window at destroy time.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case destroyEvent = "destroy-event"
    /// The `direction-changed` signal is emitted when the text direction
    /// of a widget changes.
    case directionChanged = "direction-changed"
    /// The `drag-begin` signal is emitted on the drag source when a drag is
    /// started. A typical reason to connect to this signal is to set up a
    /// custom drag icon with e.g. `gtk_drag_source_set_icon_pixbuf()`.
    /// 
    /// Note that some widgets set up a drag icon in the default handler of
    /// this signal, so you may have to use `g_signal_connect_after()` to
    /// override what the default handler did.
    case dragBegin = "drag-begin"
    /// The `drag-data-delete` signal is emitted on the drag source when a drag
    /// with the action `GDK_ACTION_MOVE` is successfully completed. The signal
    /// handler is responsible for deleting the data that has been dropped. What
    /// "delete" means depends on the context of the drag operation.
    case dragDataDelete = "drag-data-delete"
    /// The `drag-data-get` signal is emitted on the drag source when the drop
    /// site requests the data which is dragged. It is the responsibility of
    /// the signal handler to fill `data` with the data in the format which
    /// is indicated by `info`. See `gtk_selection_data_set()` and
    /// `gtk_selection_data_set_text()`.
    case dragDataGet = "drag-data-get"
    /// The `drag-data-received` signal is emitted on the drop site when the
    /// dragged data has been received. If the data was received in order to
    /// determine whether the drop will be accepted, the handler is expected
    /// to call `gdk_drag_status()` and not finish the drag.
    /// If the data was received in response to a `GtkWidget::drag-drop` signal
    /// (and this is the last target to be received), the handler for this
    /// signal is expected to process the received data and then call
    /// `gtk_drag_finish()`, setting the `success` parameter depending on
    /// whether the data was processed successfully.
    /// 
    /// Applications must create some means to determine why the signal was emitted
    /// and therefore whether to call `gdk_drag_status()` or `gtk_drag_finish()`.
    /// 
    /// The handler may inspect the selected action with
    /// `gdk_drag_context_get_selected_action()` before calling
    /// `gtk_drag_finish()`, e.g. to implement `GDK_ACTION_ASK` as
    /// shown in the following example:
    /// (C Language Example):
    /// ```C
    /// void
    /// drag_data_received (GtkWidget          *widget,
    ///                     GdkDragContext     *context,
    ///                     gint                x,
    ///                     gint                y,
    ///                     GtkSelectionData   *data,
    ///                     guint               info,
    ///                     guint               time)
    /// {
    ///   if ((data->length >= 0) && (data->format == 8))
    ///     {
    ///       GdkDragAction action;
    /// 
    ///       // handle data here
    /// 
    ///       action = gdk_drag_context_get_selected_action (context);
    ///       if (action == GDK_ACTION_ASK)
    ///         {
    ///           GtkWidget *dialog;
    ///           gint response;
    /// 
    ///           dialog = gtk_message_dialog_new (NULL,
    ///                                            GTK_DIALOG_MODAL |
    ///                                            GTK_DIALOG_DESTROY_WITH_PARENT,
    ///                                            GTK_MESSAGE_INFO,
    ///                                            GTK_BUTTONS_YES_NO,
    ///                                            "Move the data ?\n");
    ///           response = gtk_dialog_run (GTK_DIALOG (dialog));
    ///           gtk_widget_destroy (dialog);
    /// 
    ///           if (response == GTK_RESPONSE_YES)
    ///             action = GDK_ACTION_MOVE;
    ///           else
    ///             action = GDK_ACTION_COPY;
    ///          }
    /// 
    ///       gtk_drag_finish (context, TRUE, action == GDK_ACTION_MOVE, time);
    ///     }
    ///   else
    ///     gtk_drag_finish (context, FALSE, FALSE, time);
    ///  }
    /// ```
    /// 
    case dragDataReceived = "drag-data-received"
    /// The `drag-drop` signal is emitted on the drop site when the user drops
    /// the data onto the widget. The signal handler must determine whether
    /// the cursor position is in a drop zone or not. If it is not in a drop
    /// zone, it returns `false` and no further processing is necessary.
    /// Otherwise, the handler returns `true`. In this case, the handler must
    /// ensure that `gtk_drag_finish()` is called to let the source know that
    /// the drop is done. The call to `gtk_drag_finish()` can be done either
    /// directly or in a `GtkWidget::drag-data-received` handler which gets
    /// triggered by calling `gtk_drag_get_data()` to receive the data for one
    /// or more of the supported targets.
    case dragDrop = "drag-drop"
    /// The `drag-end` signal is emitted on the drag source when a drag is
    /// finished.  A typical reason to connect to this signal is to undo
    /// things done in `GtkWidget::drag-begin`.
    case dragEnd = "drag-end"
    /// The `drag-failed` signal is emitted on the drag source when a drag has
    /// failed. The signal handler may hook custom code to handle a failed DnD
    /// operation based on the type of error, it returns `true` is the failure has
    /// been already handled (not showing the default "drag operation failed"
    /// animation), otherwise it returns `false`.
    case dragFailed = "drag-failed"
    /// The `drag-leave` signal is emitted on the drop site when the cursor
    /// leaves the widget. A typical reason to connect to this signal is to
    /// undo things done in `GtkWidget::drag-motion`, e.g. undo highlighting
    /// with `gtk_drag_unhighlight()`.
    /// 
    /// 
    /// Likewise, the `GtkWidget::drag-leave` signal is also emitted before the
    /// `drag-drop` signal, for instance to allow cleaning up of a preview item
    /// created in the `GtkWidget::drag-motion` signal handler.
    case dragLeave = "drag-leave"
    /// The `drag-motion` signal is emitted on the drop site when the user
    /// moves the cursor over the widget during a drag. The signal handler
    /// must determine whether the cursor position is in a drop zone or not.
    /// If it is not in a drop zone, it returns `false` and no further processing
    /// is necessary. Otherwise, the handler returns `true`. In this case, the
    /// handler is responsible for providing the necessary information for
    /// displaying feedback to the user, by calling `gdk_drag_status()`.
    /// 
    /// If the decision whether the drop will be accepted or rejected can't be
    /// made based solely on the cursor position and the type of the data, the
    /// handler may inspect the dragged data by calling `gtk_drag_get_data()` and
    /// defer the `gdk_drag_status()` call to the `GtkWidget::drag-data-received`
    /// handler. Note that you must pass `GTK_DEST_DEFAULT_DROP`,
    /// `GTK_DEST_DEFAULT_MOTION` or `GTK_DEST_DEFAULT_ALL` to `gtk_drag_dest_set()`
    /// when using the drag-motion signal that way.
    /// 
    /// Also note that there is no drag-enter signal. The drag receiver has to
    /// keep track of whether he has received any drag-motion signals since the
    /// last `GtkWidget::drag-leave` and if not, treat the drag-motion signal as
    /// an "enter" signal. Upon an "enter", the handler will typically highlight
    /// the drop site with `gtk_drag_highlight()`.
    /// (C Language Example):
    /// ```C
    /// static void
    /// drag_motion (GtkWidget      *widget,
    ///              GdkDragContext *context,
    ///              gint            x,
    ///              gint            y,
    ///              guint           time)
    /// {
    ///   GdkAtom target;
    /// 
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (!private_data->drag_highlight)
    ///    {
    ///      private_data->drag_highlight = 1;
    ///      gtk_drag_highlight (widget);
    ///    }
    /// 
    ///   target = gtk_drag_dest_find_target (widget, context, NULL);
    ///   if (target == GDK_NONE)
    ///     gdk_drag_status (context, 0, time);
    ///   else
    ///    {
    ///      private_data->pending_status
    ///         = gdk_drag_context_get_suggested_action (context);
    ///      gtk_drag_get_data (widget, context, target, time);
    ///    }
    /// 
    ///   return TRUE;
    /// }
    /// 
    /// static void
    /// drag_data_received (GtkWidget        *widget,
    ///                     GdkDragContext   *context,
    ///                     gint              x,
    ///                     gint              y,
    ///                     GtkSelectionData *selection_data,
    ///                     guint             info,
    ///                     guint             time)
    /// {
    ///   PrivateData *private_data = GET_PRIVATE_DATA (widget);
    /// 
    ///   if (private_data->suggested_action)
    ///    {
    ///      private_data->suggested_action = 0;
    /// 
    ///      // We are getting this data due to a request in drag_motion,
    ///      // rather than due to a request in drag_drop, so we are just
    ///      // supposed to call gdk_drag_status(), not actually paste in
    ///      // the data.
    /// 
    ///      str = gtk_selection_data_get_text (selection_data);
    ///      if (!data_is_acceptable (str))
    ///        gdk_drag_status (context, 0, time);
    ///      else
    ///        gdk_drag_status (context,
    ///                         private_data->suggested_action,
    ///                         time);
    ///    }
    ///   else
    ///    {
    ///      // accept the drop
    ///    }
    /// }
    /// ```
    /// 
    case dragMotion = "drag-motion"
    /// This signal is emitted when a widget is supposed to render itself.
    /// The `widget`'s top left corner must be painted at the origin of
    /// the passed in context and be sized to the values returned by
    /// `gtk_widget_get_allocated_width()` and
    /// `gtk_widget_get_allocated_height()`.
    /// 
    /// Signal handlers connected to this signal can modify the cairo
    /// context passed as `cr` in any way they like and don't need to
    /// restore it. The signal emission takes care of calling `cairo_save()`
    /// before and `cairo_restore()` after invoking the handler.
    /// 
    /// The signal handler will get a `cr` with a clip region already set to the
    /// widget's dirty region, i.e. to the area that needs repainting.  Complicated
    /// widgets that want to avoid redrawing themselves completely can get the full
    /// extents of the clip region with `gdk_cairo_get_clip_rectangle()`, or they can
    /// get a finer-grained representation of the dirty region with
    /// `cairo_copy_clip_rectangle_list()`.
    case draw = "draw"
    /// The `enter-notify-event` will be emitted when the pointer enters
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_ENTER_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case enterNotifyEvent = "enter-notify-event"
    /// The GTK+ main loop will emit three signals for each GDK event delivered
    /// to a widget: one generic `event` signal, another, more specific,
    /// signal that matches the type of event delivered (e.g.
    /// `GtkWidget::key-press-event`) and finally a generic
    /// `GtkWidget::event-after` signal.
    case event = "event"
    /// After the emission of the `GtkWidget::event` signal and (optionally)
    /// the second more specific signal, `event-after` will be emitted
    /// regardless of the previous two signals handlers return values.
    case eventAfter = "event-after"
    case expandCollapseCursorRow = "expand-collapse-cursor-row"
    case focus = "focus"
    /// The `focus-in-event` signal will be emitted when the keyboard focus
    /// enters the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusInEvent = "focus-in-event"
    /// The `focus-out-event` signal will be emitted when the keyboard focus
    /// leaves the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_FOCUS_CHANGE_MASK` mask.
    case focusOutEvent = "focus-out-event"
    /// Emitted when a pointer or keyboard grab on a window belonging
    /// to `widget` gets broken.
    /// 
    /// On X11, this happens when the grab window becomes unviewable
    /// (i.e. it or one of its ancestors is unmapped), or if the same
    /// application grabs the pointer or keyboard again.
    case grabBrokenEvent = "grab-broken-event"
    case grabFocus = "grab-focus"
    /// The `grab-notify` signal is emitted when a widget becomes
    /// shadowed by a GTK+ grab (not a pointer or keyboard grab) on
    /// another widget, or when it becomes unshadowed due to a grab
    /// being removed.
    /// 
    /// A widget is shadowed by a `gtk_grab_add()` when the topmost
    /// grab widget in the grab stack of its window group is not
    /// its ancestor.
    case grabNotify = "grab-notify"
    /// The `hide` signal is emitted when `widget` is hidden, for example with
    /// `gtk_widget_hide()`.
    case hide = "hide"
    /// The `hierarchy-changed` signal is emitted when the
    /// anchored state of a widget changes. A widget is
    /// “anchored” when its toplevel
    /// ancestor is a `GtkWindow`. This signal is emitted when
    /// a widget changes from un-anchored to anchored or vice-versa.
    case hierarchyChanged = "hierarchy-changed"
    /// The `key-press-event` signal is emitted when a key is pressed. The signal
    /// emission will reoccur at the key-repeat rate when the key is kept pressed.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_PRESS_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyPressEvent = "key-press-event"
    /// The `key-release-event` signal is emitted when a key is released.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_KEY_RELEASE_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case keyReleaseEvent = "key-release-event"
    /// Gets emitted if keyboard navigation fails.
    /// See `gtk_widget_keynav_failed()` for details.
    case keynavFailed = "keynav-failed"
    /// The `leave-notify-event` will be emitted when the pointer leaves
    /// the `widget`'s window.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_LEAVE_NOTIFY_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case leaveNotifyEvent = "leave-notify-event"
    /// The `map` signal is emitted when `widget` is going to be mapped, that is
    /// when the widget is visible (which is controlled with
    /// `gtk_widget_set_visible()`) and all its parents up to the toplevel widget
    /// are also visible. Once the map has occurred, `GtkWidget::map-event` will
    /// be emitted.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of `GtkWidget::unmap`.
    case map = "map"
    /// The `map-event` signal will be emitted when the `widget`'s window is
    /// mapped. A window is mapped when it becomes visible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case mapEvent = "map-event"
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// The `motion-notify-event` signal is emitted when the pointer moves
    /// over the widget's `GdkWindow`.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_POINTER_MOTION_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case motionNotifyEvent = "motion-notify-event"
    /// The `GtkTreeView::move-cursor` signal is a [keybinding
    /// signal](#GtkBindingSignal) which gets emitted when the user
    /// presses one of the cursor keys.
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically. In contrast to `gtk_tree_view_set_cursor()` and
    /// `gtk_tree_view_set_cursor_on_cell()` when moving horizontally
    /// `GtkTreeView::move-cursor` does not reset the current selection.
    case moveCursor = "move-cursor"
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `parent-set` signal is emitted when a new parent
    /// has been set on a widget.
    case parentSet = "parent-set"
    /// This signal gets emitted whenever a widget should pop up a context
    /// menu. This usually happens through the standard key binding mechanism;
    /// by pressing a certain key while a widget is focused, the user can cause
    /// the widget to pop up a menu.  For example, the `GtkEntry` widget creates
    /// a menu with clipboard commands. See the
    /// [Popup Menu Migration Checklist](#checklist-popup-menu)
    /// for an example of how to use this signal.
    case popupMenu = "popup-menu"
    /// The `property-notify-event` signal will be emitted when a property on
    /// the `widget`'s window has been changed or deleted.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROPERTY_CHANGE_MASK` mask.
    case propertyNotifyEvent = "property-notify-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_IN_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityInEvent = "proximity-in-event"
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_PROXIMITY_OUT_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case proximityOutEvent = "proximity-out-event"
    /// Emitted when `GtkWidget:has-tooltip` is `true` and the hover timeout
    /// has expired with the cursor hovering "above" `widget`; or emitted when `widget` got
    /// focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// The `realize` signal is emitted when `widget` is associated with a
    /// `GdkWindow`, which means that `gtk_widget_realize()` has been called or the
    /// widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    case remove = "remove"
    /// The "row-activated" signal is emitted when the method
    /// `gtk_tree_view_row_activated()` is called, when the user double
    /// clicks a treeview row with the "activate-on-single-click"
    /// property set to `false`, or when the user single clicks a row when
    /// the "activate-on-single-click" property set to `true`. It is also
    /// emitted when a non-editable row is selected and one of the keys:
    /// Space, Shift+Space, Return or Enter is pressed.
    /// 
    /// For selection handling refer to the
    /// [tree widget conceptual overview](#TreeWidget)
    /// as well as `GtkTreeSelection`.
    case rowActivated = "row-activated"
    /// The given row has been collapsed (child nodes are hidden).
    case rowCollapsed = "row-collapsed"
    /// The given row has been expanded (child nodes are shown).
    case rowExpanded = "row-expanded"
    /// The `screen-changed` signal gets emitted when the
    /// screen of a widget has changed.
    case screenChanged = "screen-changed"
    /// The `scroll-event` signal is emitted when a button in the 4 to 7
    /// range is pressed. Wheel mice are usually configured to generate
    /// button press events for buttons 4 and 5 when the wheel is turned.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_SCROLL_MASK` mask.
    /// 
    /// This signal will be sent to the grab widget if there is one.
    case scrollEvent = "scroll-event"
    case selectAll = "select-all"
    case selectCursorParent = "select-cursor-parent"
    case selectCursorRow = "select-cursor-row"
    /// The `selection-clear-event` signal will be emitted when the
    /// the `widget`'s window has lost ownership of a selection.
    case selectionClearEvent = "selection-clear-event"
    case selectionGet = "selection-get"
    case selectionNotifyEvent = "selection-notify-event"
    case selectionReceived = "selection-received"
    /// The `selection-request-event` signal will be emitted when
    /// another client requests ownership of the selection owned by
    /// the `widget`'s window.
    case selectionRequestEvent = "selection-request-event"
    case setFocusChild = "set-focus-child"
    /// The `show` signal is emitted when `widget` is shown, for example with
    /// `gtk_widget_show()`.
    case show = "show"
    case showHelp = "show-help"
    case sizeAllocate = "size-allocate"
    case startInteractiveSearch = "start-interactive-search"
    /// The `state-changed` signal is emitted when the widget state changes.
    /// See `gtk_widget_get_state()`.
    ///
    /// **state-changed is deprecated:**
    /// Use #GtkWidget::state-flags-changed instead.
    case stateChanged = "state-changed"
    /// The `state-flags-changed` signal is emitted when the widget state
    /// changes, see `gtk_widget_get_state_flags()`.
    case stateFlagsChanged = "state-flags-changed"
    /// The `style-set` signal is emitted when a new style has been set
    /// on a widget. Note that style-modifying functions like
    /// `gtk_widget_modify_base()` also cause this signal to be emitted.
    /// 
    /// Note that this signal is emitted for changes to the deprecated
    /// `GtkStyle`. To track changes to the `GtkStyleContext` associated
    /// with a widget, use the `GtkWidget::style-updated` signal.
    ///
    /// **style-set is deprecated:**
    /// Use the #GtkWidget::style-updated signal
    case styleSet = "style-set"
    /// The `style-updated` signal is a convenience signal that is emitted when the
    /// `GtkStyleContext::changed` signal is emitted on the `widget`'s associated
    /// `GtkStyleContext` as returned by `gtk_widget_get_style_context()`.
    /// 
    /// Note that style-modifying functions like `gtk_widget_override_color()` also
    /// cause this signal to be emitted.
    case styleUpdated = "style-updated"
    /// The given row is about to be collapsed (hide its children nodes). Use this
    /// signal if you need to control the collapsibility of individual rows.
    case testCollapseRow = "test-collapse-row"
    /// The given row is about to be expanded (show its children nodes). Use this
    /// signal if you need to control the expandability of individual rows.
    case testExpandRow = "test-expand-row"
    case toggleCursorRow = "toggle-cursor-row"
    case touchEvent = "touch-event"
    /// The `unmap` signal is emitted when `widget` is going to be unmapped, which
    /// means that either it or any of its parents up to the toplevel widget have
    /// been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer, it can be
    /// used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// The `unmap-event` signal will be emitted when the `widget`'s window is
    /// unmapped. A window is unmapped when it becomes invisible on the screen.
    /// 
    /// To receive this signal, the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable this mask
    /// automatically for all new windows.
    case unmapEvent = "unmap-event"
    /// The `unrealize` signal is emitted when the `GdkWindow` associated with
    /// `widget` is destroyed, which means that `gtk_widget_unrealize()` has been
    /// called or the widget has been unmapped (that is, it is going to be
    /// hidden).
    case unrealize = "unrealize"
    case unselectAll = "unselect-all"
    /// The `visibility-notify-event` will be emitted when the `widget`'s
    /// window is obscured or unobscured.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget needs
    /// to enable the `GDK_VISIBILITY_NOTIFY_MASK` mask.
    ///
    /// **visibility-notify-event is deprecated:**
    /// Modern composited windowing systems with pervasive
    ///     transparency make it impossible to track the visibility of a window
    ///     reliably, so this signal can not be guaranteed to provide useful
    ///     information.
    case visibilityNotifyEvent = "visibility-notify-event"
    /// The `window-state-event` will be emitted when the state of the
    /// toplevel window associated to the `widget` changes.
    /// 
    /// To receive this signal the `GdkWindow` associated to the widget
    /// needs to enable the `GDK_STRUCTURE_MASK` mask. GDK will enable
    /// this mask automatically for all new windows.
    case windowStateEvent = "window-state-event"
    /// The activate-on-single-click property specifies whether the "row-activated" signal
    /// will be emitted after a single click.
    case notifyActivateOnSingleClick = "notify::activate-on-single-click"
    case notifyAppPaintable = "notify::app-paintable"
    case notifyBorderWidth = "notify::border-width"
    case notifyCanDefault = "notify::can-default"
    case notifyCanFocus = "notify::can-focus"
    case notifyChild = "notify::child"
    case notifyCompositeChild = "notify::composite-child"
    /// Whether the widget is double buffered.
    ///
    /// **double-buffered is deprecated:**
    /// Widgets should not use this property.
    case notifyDoubleBuffered = "notify::double-buffered"
    case notifyEnableGridLines = "notify::enable-grid-lines"
    case notifyEnableSearch = "notify::enable-search"
    case notifyEnableTreeLines = "notify::enable-tree-lines"
    case notifyEvents = "notify::events"
    /// Whether to expand in both directions. Setting this sets both `GtkWidget:hexpand` and `GtkWidget:vexpand`
    case notifyExpand = "notify::expand"
    case notifyExpanderColumn = "notify::expander-column"
    /// Setting the `fixed-height-mode` property to `true` speeds up
    /// `GtkTreeView` by assuming that all rows have the same height.
    /// Only enable this option if all rows are the same height.
    /// Please see `gtk_tree_view_set_fixed_height_mode()` for more
    /// information on this option.
    case notifyFixedHeightMode = "notify::fixed-height-mode"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    /// 
    /// Before 3.20, several widgets (GtkButton, GtkFileChooserButton,
    /// GtkComboBox) implemented this property individually.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// How to distribute horizontal space if widget gets extra space, see `GtkAlign`
    case notifyHalign = "notify::halign"
    case notifyHasDefault = "notify::has-default"
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of `GtkWidget::query-tooltip` on `widget`.
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using `GtkWidget::query-tooltip` to determine
    /// whether it will provide a tooltip or not.
    /// 
    /// Note that setting this property to `true` for the first time will change
    /// the event masks of the GdkWindows of this widget to include leave-notify
    /// and motion-notify events.  This cannot and will not be undone when the
    /// property is set to `false` again.
    case notifyHasTooltip = "notify::has-tooltip"
    case notifyHeadersClickable = "notify::headers-clickable"
    case notifyHeadersVisible = "notify::headers-visible"
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally. See `gtk_widget_set_hexpand()`.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `GtkWidget:hexpand` property. See `gtk_widget_get_hexpand_set()`.
    case notifyHexpandSet = "notify::hexpand-set"
    /// Enables or disables the hover expansion mode of `tree_view`.
    /// Hover expansion makes rows expand or collapse if the pointer moves
    /// over them.
    /// 
    /// This mode is primarily intended for treeviews in popups, e.g.
    /// in `GtkComboBox` or `GtkEntryCompletion`.
    case notifyHoverExpand = "notify::hover-expand"
    /// Enables or disables the hover selection mode of `tree_view`.
    /// Hover selection makes the selected row follow the pointer.
    /// Currently, this works only for the selection modes
    /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
    /// 
    /// This mode is primarily intended for treeviews in popups, e.g.
    /// in `GtkComboBox` or `GtkEntryCompletion`.
    case notifyHoverSelection = "notify::hover-selection"
    case notifyIsFocus = "notify::is-focus"
    /// Extra indentation for each level.
    case notifyLevelIndentation = "notify::level-indentation"
    /// Sets all four sides' margin at once. If read, returns max
    /// margin on any side.
    case notifyMargin = "notify::margin"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on left side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-left is deprecated:**
    /// Use #GtkWidget:margin-start instead.
    case notifyMarginLeft = "notify::margin-left"
    /// Margin on right side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    ///
    /// **margin-right is deprecated:**
    /// Use #GtkWidget:margin-end instead.
    case notifyMarginRight = "notify::margin-right"
    /// Margin on start of widget, horizontally. This property supports
    /// left-to-right and right-to-left text directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// `gtk_widget_set_size_request()` for example.
    case notifyMarginTop = "notify::margin-top"
    case notifyModel = "notify::model"
    case notifyName = "notify::name"
    case notifyNoShowAll = "notify::no-show-all"
    /// The requested opacity of the widget. See `gtk_widget_set_opacity()` for
    /// more details about window opacity.
    /// 
    /// Before 3.8 this was only available in GtkWindow
    case notifyOpacity = "notify::opacity"
    case notifyParent = "notify::parent"
    case notifyReceivesDefault = "notify::receives-default"
    case notifyReorderable = "notify::reorderable"
    case notifyResizeMode = "notify::resize-mode"
    case notifyRubberBanding = "notify::rubber-banding"
    /// Sets a hint to the theme to draw rows in alternating colors.
    ///
    /// **rules-hint is deprecated:**
    /// The theme is responsible for drawing rows
    ///   using zebra striping
    case notifyRulesHint = "notify::rules-hint"
    /// The scale factor of the widget. See `gtk_widget_get_scale_factor()` for
    /// more details about widget scaling.
    case notifyScaleFactor = "notify::scale-factor"
    case notifySearchColumn = "notify::search-column"
    case notifySensitive = "notify::sensitive"
    /// `true` if the view has expanders.
    case notifyShowExpanders = "notify::show-expanders"
    /// The style of the widget, which contains information about how it will look (colors, etc).
    ///
    /// **style is deprecated:**
    /// Use #GtkStyleContext instead
    case notifyStyle = "notify::style"
    case notifyTooltipColumn = "notify::tooltip-column"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with the [Pango text markup language](#PangoMarkupFormat).
    /// Also see `gtk_tooltip_set_markup()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see `gtk_tooltip_set_text()`.
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`: `GtkWidget:has-tooltip`
    /// will automatically be set to `true` and there will be taken care of
    /// `GtkWidget::query-tooltip` in the default signal handler.
    /// 
    /// Note that if both `GtkWidget:tooltip-text` and `GtkWidget:tooltip-markup`
    /// are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space, see `GtkAlign`
    case notifyValign = "notify::valign"
    /// Whether to expand vertically. See `gtk_widget_set_vexpand()`.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `GtkWidget:vexpand` property. See `gtk_widget_get_vexpand_set()`.
    case notifyVexpandSet = "notify::vexpand-set"
    case notifyVisible = "notify::visible"
    case notifyWidthRequest = "notify::width-request"
    /// The widget's window if it is realized, `nil` otherwise.
    case notifyWindow = "notify::window"
}

// MARK: TreeView signals
public extension TreeViewProtocol {
    /// Connect a Swift signal handler to the given, typed `TreeViewSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeViewSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TreeViewSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeViewSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// The number of columns of the treeview has changed.
    /// - Note: This represents the underlying `columns-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `columnsChanged` signal is emitted
    @discardableResult @inlinable func onColumnsChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TreeViewRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .columnsChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `columns-changed` signal for using the `connect(signal:)` methods
    static var columnsChangedSignal: TreeViewSignalName { .columnsChanged }
    
    /// The position of the cursor (focused cell) has changed.
    /// - Note: This represents the underlying `cursor-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `cursorChanged` signal is emitted
    @discardableResult @inlinable func onCursorChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TreeViewRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .cursorChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `cursor-changed` signal for using the `connect(signal:)` methods
    static var cursorChangedSignal: TreeViewSignalName { .cursorChanged }
    
    /// - Note: This represents the underlying `expand-collapse-cursor-row` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter object: none
    /// - Parameter p0: none
    /// - Parameter p1: none
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `expandCollapseCursorRow` signal is emitted
    @discardableResult @inlinable func onExpandCollapseCursorRow(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ object: Bool, _ p0: Bool, _ p1: Bool) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder4<TreeViewRef, Bool, Bool, Bool, Bool>
        let cCallback: @convention(c) (gpointer, gboolean, gboolean, gboolean, gpointer) -> gboolean = { unownedSelf, arg1, arg2, arg3, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(TreeViewRef(raw: unownedSelf), ((arg1) != 0), ((arg2) != 0), ((arg3) != 0))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .expandCollapseCursorRow,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `expand-collapse-cursor-row` signal for using the `connect(signal:)` methods
    static var expandCollapseCursorRowSignal: TreeViewSignalName { .expandCollapseCursorRow }
    
    /// The `GtkTreeView::move-cursor` signal is a [keybinding
    /// signal](#GtkBindingSignal) which gets emitted when the user
    /// presses one of the cursor keys.
    /// 
    /// Applications should not connect to it, but may emit it with
    /// `g_signal_emit_by_name()` if they need to control the cursor
    /// programmatically. In contrast to `gtk_tree_view_set_cursor()` and
    /// `gtk_tree_view_set_cursor_on_cell()` when moving horizontally
    /// `GtkTreeView::move-cursor` does not reset the current selection.
    /// - Note: This represents the underlying `move-cursor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter step: the granularity of the move, as a `GtkMovementStep`. `GTK_MOVEMENT_LOGICAL_POSITIONS`, `GTK_MOVEMENT_VISUAL_POSITIONS`, `GTK_MOVEMENT_DISPLAY_LINES`, `GTK_MOVEMENT_PAGES` and `GTK_MOVEMENT_BUFFER_ENDS` are supported. `GTK_MOVEMENT_LOGICAL_POSITIONS` and `GTK_MOVEMENT_VISUAL_POSITIONS` are treated identically.
    /// - Parameter direction: the direction to move: +1 to move forwards; -1 to move backwards. The resulting movement is undefined for all other values.
    /// - Parameter handler: `true` if `step` is supported, `false` otherwise.
    /// Run the given callback whenever the `moveCursor` signal is emitted
    @discardableResult @inlinable func onMoveCursor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ step: MovementStep, _ direction: Int) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TreeViewRef, MovementStep, Int, Bool>
        let cCallback: @convention(c) (gpointer, UInt32, gint, gpointer) -> gboolean = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(TreeViewRef(raw: unownedSelf), MovementStep(arg1), Int(arg2))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .moveCursor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `move-cursor` signal for using the `connect(signal:)` methods
    static var moveCursorSignal: TreeViewSignalName { .moveCursor }
    
    /// The "row-activated" signal is emitted when the method
    /// `gtk_tree_view_row_activated()` is called, when the user double
    /// clicks a treeview row with the "activate-on-single-click"
    /// property set to `false`, or when the user single clicks a row when
    /// the "activate-on-single-click" property set to `true`. It is also
    /// emitted when a non-editable row is selected and one of the keys:
    /// Space, Shift+Space, Return or Enter is pressed.
    /// 
    /// For selection handling refer to the
    /// [tree widget conceptual overview](#TreeWidget)
    /// as well as `GtkTreeSelection`.
    /// - Note: This represents the underlying `row-activated` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: the `GtkTreePath` for the activated row
    /// - Parameter column: the `GtkTreeViewColumn` in which the activation occurred
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `rowActivated` signal is emitted
    @discardableResult @inlinable func onRowActivated(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ path: TreePathRef, _ column: TreeViewColumnRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TreeViewRef, TreePathRef, TreeViewColumnRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), TreePathRef(raw: arg1), TreeViewColumnRef(raw: arg2))
            return output
        }
        return connect(
            signal: .rowActivated,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `row-activated` signal for using the `connect(signal:)` methods
    static var rowActivatedSignal: TreeViewSignalName { .rowActivated }
    
    /// The given row has been collapsed (child nodes are hidden).
    /// - Note: This represents the underlying `row-collapsed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter iter: the tree iter of the collapsed row
    /// - Parameter path: a tree path that points to the row
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `rowCollapsed` signal is emitted
    @discardableResult @inlinable func onRowCollapsed(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ iter: TreeIterRef, _ path: TreePathRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TreeViewRef, TreeIterRef, TreePathRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), TreeIterRef(raw: arg1), TreePathRef(raw: arg2))
            return output
        }
        return connect(
            signal: .rowCollapsed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `row-collapsed` signal for using the `connect(signal:)` methods
    static var rowCollapsedSignal: TreeViewSignalName { .rowCollapsed }
    
    /// The given row has been expanded (child nodes are shown).
    /// - Note: This represents the underlying `row-expanded` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter iter: the tree iter of the expanded row
    /// - Parameter path: a tree path that points to the row
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `rowExpanded` signal is emitted
    @discardableResult @inlinable func onRowExpanded(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ iter: TreeIterRef, _ path: TreePathRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TreeViewRef, TreeIterRef, TreePathRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), TreeIterRef(raw: arg1), TreePathRef(raw: arg2))
            return output
        }
        return connect(
            signal: .rowExpanded,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `row-expanded` signal for using the `connect(signal:)` methods
    static var rowExpandedSignal: TreeViewSignalName { .rowExpanded }
    
    /// - Note: This represents the underlying `select-all` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `selectAll` signal is emitted
    @discardableResult @inlinable func onSelectAll(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TreeViewRef, Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(TreeViewRef(raw: unownedSelf))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .selectAll,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `select-all` signal for using the `connect(signal:)` methods
    static var selectAllSignal: TreeViewSignalName { .selectAll }
    
    /// - Note: This represents the underlying `select-cursor-parent` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `selectCursorParent` signal is emitted
    @discardableResult @inlinable func onSelectCursorParent(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TreeViewRef, Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(TreeViewRef(raw: unownedSelf))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .selectCursorParent,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `select-cursor-parent` signal for using the `connect(signal:)` methods
    static var selectCursorParentSignal: TreeViewSignalName { .selectCursorParent }
    
    /// - Note: This represents the underlying `select-cursor-row` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter object: none
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `selectCursorRow` signal is emitted
    @discardableResult @inlinable func onSelectCursorRow(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ object: Bool) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, Bool, Bool>
        let cCallback: @convention(c) (gpointer, gboolean, gpointer) -> gboolean = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(TreeViewRef(raw: unownedSelf), ((arg1) != 0))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .selectCursorRow,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `select-cursor-row` signal for using the `connect(signal:)` methods
    static var selectCursorRowSignal: TreeViewSignalName { .selectCursorRow }
    
    /// - Note: This represents the underlying `start-interactive-search` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `startInteractiveSearch` signal is emitted
    @discardableResult @inlinable func onStartInteractiveSearch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TreeViewRef, Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(TreeViewRef(raw: unownedSelf))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .startInteractiveSearch,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `start-interactive-search` signal for using the `connect(signal:)` methods
    static var startInteractiveSearchSignal: TreeViewSignalName { .startInteractiveSearch }
    
    /// The given row is about to be collapsed (hide its children nodes). Use this
    /// signal if you need to control the collapsibility of individual rows.
    /// - Note: This represents the underlying `test-collapse-row` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter iter: the tree iter of the row to collapse
    /// - Parameter path: a tree path that points to the row
    /// - Parameter handler: `false` to allow collapsing, `true` to reject
    /// Run the given callback whenever the `testCollapseRow` signal is emitted
    @discardableResult @inlinable func onTestCollapseRow(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ iter: TreeIterRef, _ path: TreePathRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TreeViewRef, TreeIterRef, TreePathRef, Bool>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> gboolean = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(TreeViewRef(raw: unownedSelf), TreeIterRef(raw: arg1), TreePathRef(raw: arg2))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .testCollapseRow,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `test-collapse-row` signal for using the `connect(signal:)` methods
    static var testCollapseRowSignal: TreeViewSignalName { .testCollapseRow }
    
    /// The given row is about to be expanded (show its children nodes). Use this
    /// signal if you need to control the expandability of individual rows.
    /// - Note: This represents the underlying `test-expand-row` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter iter: the tree iter of the row to expand
    /// - Parameter path: a tree path that points to the row
    /// - Parameter handler: `false` to allow expansion, `true` to reject
    /// Run the given callback whenever the `testExpandRow` signal is emitted
    @discardableResult @inlinable func onTestExpandRow(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ iter: TreeIterRef, _ path: TreePathRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<TreeViewRef, TreeIterRef, TreePathRef, Bool>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> gboolean = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(TreeViewRef(raw: unownedSelf), TreeIterRef(raw: arg1), TreePathRef(raw: arg2))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .testExpandRow,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `test-expand-row` signal for using the `connect(signal:)` methods
    static var testExpandRowSignal: TreeViewSignalName { .testExpandRow }
    
    /// - Note: This represents the underlying `toggle-cursor-row` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggleCursorRow` signal is emitted
    @discardableResult @inlinable func onToggleCursorRow(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TreeViewRef, Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(TreeViewRef(raw: unownedSelf))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .toggleCursorRow,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggle-cursor-row` signal for using the `connect(signal:)` methods
    static var toggleCursorRowSignal: TreeViewSignalName { .toggleCursorRow }
    
    /// - Note: This represents the underlying `unselect-all` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `unselectAll` signal is emitted
    @discardableResult @inlinable func onUnselectAll(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TreeViewRef, Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(TreeViewRef(raw: unownedSelf))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .unselectAll,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `unselect-all` signal for using the `connect(signal:)` methods
    static var unselectAllSignal: TreeViewSignalName { .unselectAll }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::activate-on-single-click` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActivateOnSingleClick` signal is emitted
    @discardableResult @inlinable func onNotifyActivateOnSingleClick(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyActivateOnSingleClick,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::activate-on-single-click` signal for using the `connect(signal:)` methods
    static var notifyActivateOnSingleClickSignal: TreeViewSignalName { .notifyActivateOnSingleClick }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::enable-grid-lines` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEnableGridLines` signal is emitted
    @discardableResult @inlinable func onNotifyEnableGridLines(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEnableGridLines,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::enable-grid-lines` signal for using the `connect(signal:)` methods
    static var notifyEnableGridLinesSignal: TreeViewSignalName { .notifyEnableGridLines }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::enable-search` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEnableSearch` signal is emitted
    @discardableResult @inlinable func onNotifyEnableSearch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEnableSearch,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::enable-search` signal for using the `connect(signal:)` methods
    static var notifyEnableSearchSignal: TreeViewSignalName { .notifyEnableSearch }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::enable-tree-lines` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEnableTreeLines` signal is emitted
    @discardableResult @inlinable func onNotifyEnableTreeLines(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEnableTreeLines,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::enable-tree-lines` signal for using the `connect(signal:)` methods
    static var notifyEnableTreeLinesSignal: TreeViewSignalName { .notifyEnableTreeLines }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::expander-column` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyExpanderColumn` signal is emitted
    @discardableResult @inlinable func onNotifyExpanderColumn(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyExpanderColumn,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::expander-column` signal for using the `connect(signal:)` methods
    static var notifyExpanderColumnSignal: TreeViewSignalName { .notifyExpanderColumn }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::fixed-height-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFixedHeightMode` signal is emitted
    @discardableResult @inlinable func onNotifyFixedHeightMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFixedHeightMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::fixed-height-mode` signal for using the `connect(signal:)` methods
    static var notifyFixedHeightModeSignal: TreeViewSignalName { .notifyFixedHeightMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::headers-clickable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHeadersClickable` signal is emitted
    @discardableResult @inlinable func onNotifyHeadersClickable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyHeadersClickable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::headers-clickable` signal for using the `connect(signal:)` methods
    static var notifyHeadersClickableSignal: TreeViewSignalName { .notifyHeadersClickable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::headers-visible` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHeadersVisible` signal is emitted
    @discardableResult @inlinable func onNotifyHeadersVisible(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyHeadersVisible,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::headers-visible` signal for using the `connect(signal:)` methods
    static var notifyHeadersVisibleSignal: TreeViewSignalName { .notifyHeadersVisible }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::hover-expand` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHoverExpand` signal is emitted
    @discardableResult @inlinable func onNotifyHoverExpand(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyHoverExpand,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::hover-expand` signal for using the `connect(signal:)` methods
    static var notifyHoverExpandSignal: TreeViewSignalName { .notifyHoverExpand }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::hover-selection` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHoverSelection` signal is emitted
    @discardableResult @inlinable func onNotifyHoverSelection(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyHoverSelection,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::hover-selection` signal for using the `connect(signal:)` methods
    static var notifyHoverSelectionSignal: TreeViewSignalName { .notifyHoverSelection }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::level-indentation` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLevelIndentation` signal is emitted
    @discardableResult @inlinable func onNotifyLevelIndentation(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLevelIndentation,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::level-indentation` signal for using the `connect(signal:)` methods
    static var notifyLevelIndentationSignal: TreeViewSignalName { .notifyLevelIndentation }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::model` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyModel` signal is emitted
    @discardableResult @inlinable func onNotifyModel(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyModel,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::model` signal for using the `connect(signal:)` methods
    static var notifyModelSignal: TreeViewSignalName { .notifyModel }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::reorderable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyReorderable` signal is emitted
    @discardableResult @inlinable func onNotifyReorderable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyReorderable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::reorderable` signal for using the `connect(signal:)` methods
    static var notifyReorderableSignal: TreeViewSignalName { .notifyReorderable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::rubber-banding` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRubberBanding` signal is emitted
    @discardableResult @inlinable func onNotifyRubberBanding(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyRubberBanding,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::rubber-banding` signal for using the `connect(signal:)` methods
    static var notifyRubberBandingSignal: TreeViewSignalName { .notifyRubberBanding }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::rules-hint` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRulesHint` signal is emitted
    @discardableResult @inlinable func onNotifyRulesHint(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyRulesHint,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::rules-hint` signal for using the `connect(signal:)` methods
    static var notifyRulesHintSignal: TreeViewSignalName { .notifyRulesHint }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::search-column` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySearchColumn` signal is emitted
    @discardableResult @inlinable func onNotifySearchColumn(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySearchColumn,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::search-column` signal for using the `connect(signal:)` methods
    static var notifySearchColumnSignal: TreeViewSignalName { .notifySearchColumn }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-expanders` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowExpanders` signal is emitted
    @discardableResult @inlinable func onNotifyShowExpanders(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyShowExpanders,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-expanders` signal for using the `connect(signal:)` methods
    static var notifyShowExpandersSignal: TreeViewSignalName { .notifyShowExpanders }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::tooltip-column` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTooltipColumn` signal is emitted
    @discardableResult @inlinable func onNotifyTooltipColumn(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyTooltipColumn,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::tooltip-column` signal for using the `connect(signal:)` methods
    static var notifyTooltipColumnSignal: TreeViewSignalName { .notifyTooltipColumn }
    
}

// MARK: TreeView Class: TreeViewProtocol extension (methods and fields)
public extension TreeViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeView` instance.
    @inlinable var tree_view_ptr: UnsafeMutablePointer<GtkTreeView>! { return ptr?.assumingMemoryBound(to: GtkTreeView.self) }

    /// Appends `column` to the list of columns. If `tree_view` has “fixed_height”
    /// mode enabled, then `column` must have its “sizing” property set to be
    /// GTK_TREE_VIEW_COLUMN_FIXED.
    @inlinable func append<TreeViewColumnT: TreeViewColumnProtocol>(column: TreeViewColumnT) -> Int {
        let rv = Int(gtk_tree_view_append_column(tree_view_ptr, column.tree_view_column_ptr))
        return rv
    }

    /// Recursively collapses all visible, expanded nodes in `tree_view`.
    @inlinable func collapseAll() {
        gtk_tree_view_collapse_all(tree_view_ptr)
    
    }

    /// Collapses a row (hides its child rows, if they exist).
    @inlinable func collapseRow<TreePathT: TreePathProtocol>(path: TreePathT) -> Bool {
        let rv = ((gtk_tree_view_collapse_row(tree_view_ptr, path.tree_path_ptr)) != 0)
        return rv
    }

    /// Resizes all columns to their optimal width. Only works after the
    /// treeview has been realized.
    @inlinable func columnsAutosize() {
        gtk_tree_view_columns_autosize(tree_view_ptr)
    
    }

    /// Converts bin_window coordinates to coordinates for the
    /// tree (the full scrollable area of the tree).
    @inlinable func convertBinWindowToTreeCoords(bx: Int, by: Int, tx: UnsafeMutablePointer<gint>!, ty: UnsafeMutablePointer<gint>!) {
        gtk_tree_view_convert_bin_window_to_tree_coords(tree_view_ptr, gint(bx), gint(by), tx, ty)
    
    }

    /// Converts bin_window coordinates (see `gtk_tree_view_get_bin_window()`)
    /// to widget relative coordinates.
    @inlinable func convertBinWindowToWidgetCoords(bx: Int, by: Int, wx: UnsafeMutablePointer<gint>!, wy: UnsafeMutablePointer<gint>!) {
        gtk_tree_view_convert_bin_window_to_widget_coords(tree_view_ptr, gint(bx), gint(by), wx, wy)
    
    }

    /// Converts tree coordinates (coordinates in full scrollable area of the tree)
    /// to bin_window coordinates.
    @inlinable func convertTreeToBinWindowCoords(tx: Int, ty: Int, bx: UnsafeMutablePointer<gint>!, by: UnsafeMutablePointer<gint>!) {
        gtk_tree_view_convert_tree_to_bin_window_coords(tree_view_ptr, gint(tx), gint(ty), bx, by)
    
    }

    /// Converts tree coordinates (coordinates in full scrollable area of the tree)
    /// to widget coordinates.
    @inlinable func convertTreeToWidgetCoords(tx: Int, ty: Int, wx: UnsafeMutablePointer<gint>!, wy: UnsafeMutablePointer<gint>!) {
        gtk_tree_view_convert_tree_to_widget_coords(tree_view_ptr, gint(tx), gint(ty), wx, wy)
    
    }

    /// Converts widget coordinates to coordinates for the bin_window
    /// (see `gtk_tree_view_get_bin_window()`).
    @inlinable func convertWidgetToBinWindowCoords(wx: Int, wy: Int, bx: UnsafeMutablePointer<gint>!, by: UnsafeMutablePointer<gint>!) {
        gtk_tree_view_convert_widget_to_bin_window_coords(tree_view_ptr, gint(wx), gint(wy), bx, by)
    
    }

    /// Converts widget coordinates to coordinates for the
    /// tree (the full scrollable area of the tree).
    @inlinable func convertWidgetToTreeCoords(wx: Int, wy: Int, tx: UnsafeMutablePointer<gint>!, ty: UnsafeMutablePointer<gint>!) {
        gtk_tree_view_convert_widget_to_tree_coords(tree_view_ptr, gint(wx), gint(wy), tx, ty)
    
    }

    /// Creates a `cairo_surface_t` representation of the row at `path`.
    /// This image is used for a drag icon.
    @inlinable func createRowDragIcon<TreePathT: TreePathProtocol>(path: TreePathT) -> Cairo.SurfaceRef! {
        let rv = Cairo.SurfaceRef(gtk_tree_view_create_row_drag_icon(tree_view_ptr, path.tree_path_ptr))
        return rv
    }

    /// Turns `tree_view` into a drop destination for automatic DND. Calling
    /// this method sets `GtkTreeView:reorderable` to `false`.
    @inlinable func enableModelDragDest(targets: UnsafePointer<GtkTargetEntry>!, nTargets: Int, actions: Gdk.DragAction) {
        gtk_tree_view_enable_model_drag_dest(tree_view_ptr, targets, gint(nTargets), actions.value)
    
    }

    /// Turns `tree_view` into a drag source for automatic DND. Calling this
    /// method sets `GtkTreeView:reorderable` to `false`.
    @inlinable func enableModelDragSource(startButtonMask: Gdk.ModifierType, targets: UnsafePointer<GtkTargetEntry>!, nTargets: Int, actions: Gdk.DragAction) {
        gtk_tree_view_enable_model_drag_source(tree_view_ptr, startButtonMask.value, targets, gint(nTargets), actions.value)
    
    }

    /// Recursively expands all nodes in the `tree_view`.
    @inlinable func expandAll() {
        gtk_tree_view_expand_all(tree_view_ptr)
    
    }

    /// Opens the row so its children are visible.
    @inlinable func expandRow<TreePathT: TreePathProtocol>(path: TreePathT, openAll: Bool) -> Bool {
        let rv = ((gtk_tree_view_expand_row(tree_view_ptr, path.tree_path_ptr, gboolean((openAll) ? 1 : 0))) != 0)
        return rv
    }

    /// Expands the row at `path`. This will also expand all parent rows of
    /// `path` as necessary.
    @inlinable func expandTo<TreePathT: TreePathProtocol>(path: TreePathT) {
        gtk_tree_view_expand_to_path(tree_view_ptr, path.tree_path_ptr)
    
    }

    /// Gets the setting set by `gtk_tree_view_set_activate_on_single_click()`.
    @inlinable func getActivateOnSingleClick() -> Bool {
        let rv = ((gtk_tree_view_get_activate_on_single_click(tree_view_ptr)) != 0)
        return rv
    }

    /// Fills the bounding rectangle in bin_window coordinates for the cell at the
    /// row specified by `path` and the column specified by `column`.  If `path` is
    /// `nil`, or points to a node not found in the tree, the `y` and `height` fields of
    /// the rectangle will be filled with 0. If `column` is `nil`, the `x` and `width`
    /// fields will be filled with 0.  The returned rectangle is equivalent to the
    /// `background_area` passed to `gtk_cell_renderer_render()`.  These background
    /// areas tile to cover the entire bin window.  Contrast with the `cell_area`,
    /// returned by `gtk_tree_view_get_cell_area()`, which returns only the cell
    /// itself, excluding surrounding borders and the tree expander area.
    @inlinable func getBackgroundArea<RectangleT: Gdk.RectangleProtocol>(path: TreePathRef? = nil, column: TreeViewColumnRef? = nil, rect: RectangleT) {
        gtk_tree_view_get_background_area(tree_view_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, rect.rectangle_ptr)
    
    }
    /// Fills the bounding rectangle in bin_window coordinates for the cell at the
    /// row specified by `path` and the column specified by `column`.  If `path` is
    /// `nil`, or points to a node not found in the tree, the `y` and `height` fields of
    /// the rectangle will be filled with 0. If `column` is `nil`, the `x` and `width`
    /// fields will be filled with 0.  The returned rectangle is equivalent to the
    /// `background_area` passed to `gtk_cell_renderer_render()`.  These background
    /// areas tile to cover the entire bin window.  Contrast with the `cell_area`,
    /// returned by `gtk_tree_view_get_cell_area()`, which returns only the cell
    /// itself, excluding surrounding borders and the tree expander area.
    @inlinable func getBackgroundArea<RectangleT: Gdk.RectangleProtocol, TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(path: TreePathT?, column: TreeViewColumnT?, rect: RectangleT) {
        gtk_tree_view_get_background_area(tree_view_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, rect.rectangle_ptr)
    
    }

    /// Returns the window that `tree_view` renders to.
    /// This is used primarily to compare to `event-&gt;window`
    /// to confirm that the event on `tree_view` is on the right window.
    @inlinable func getBinWindow() -> Gdk.WindowRef! {
        let rv = Gdk.WindowRef(gtk_tree_view_get_bin_window(tree_view_ptr))
        return rv
    }

    /// Fills the bounding rectangle in bin_window coordinates for the cell at the
    /// row specified by `path` and the column specified by `column`.  If `path` is
    /// `nil`, or points to a path not currently displayed, the `y` and `height` fields
    /// of the rectangle will be filled with 0. If `column` is `nil`, the `x` and `width`
    /// fields will be filled with 0.  The sum of all cell rects does not cover the
    /// entire tree; there are extra pixels in between rows, for example. The
    /// returned rectangle is equivalent to the `cell_area` passed to
    /// `gtk_cell_renderer_render()`.  This function is only valid if `tree_view` is
    /// realized.
    @inlinable func getCellArea<RectangleT: Gdk.RectangleProtocol>(path: TreePathRef? = nil, column: TreeViewColumnRef? = nil, rect: RectangleT) {
        gtk_tree_view_get_cell_area(tree_view_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, rect.rectangle_ptr)
    
    }
    /// Fills the bounding rectangle in bin_window coordinates for the cell at the
    /// row specified by `path` and the column specified by `column`.  If `path` is
    /// `nil`, or points to a path not currently displayed, the `y` and `height` fields
    /// of the rectangle will be filled with 0. If `column` is `nil`, the `x` and `width`
    /// fields will be filled with 0.  The sum of all cell rects does not cover the
    /// entire tree; there are extra pixels in between rows, for example. The
    /// returned rectangle is equivalent to the `cell_area` passed to
    /// `gtk_cell_renderer_render()`.  This function is only valid if `tree_view` is
    /// realized.
    @inlinable func getCellArea<RectangleT: Gdk.RectangleProtocol, TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(path: TreePathT?, column: TreeViewColumnT?, rect: RectangleT) {
        gtk_tree_view_get_cell_area(tree_view_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, rect.rectangle_ptr)
    
    }

    /// Gets the `GtkTreeViewColumn` at the given position in the `tree_view`.
    @inlinable func getColumn(n: Int) -> TreeViewColumnRef! {
        let rv = TreeViewColumnRef(gconstpointer: gconstpointer(gtk_tree_view_get_column(tree_view_ptr, gint(n))))
        return rv
    }

    /// Returns a `GList` of all the `GtkTreeViewColumn` s currently in `tree_view`.
    /// The returned list must be freed with g_list_free ().
    @inlinable func getColumns() -> GLib.ListRef! {
        let rv = GLib.ListRef(gtk_tree_view_get_columns(tree_view_ptr))
        return rv
    }

    /// Fills in `path` and `focus_column` with the current path and focus column.  If
    /// the cursor isn’t currently set, then *`path` will be `nil`.  If no column
    /// currently has focus, then *`focus_column` will be `nil`.
    /// 
    /// The returned `GtkTreePath` must be freed with `gtk_tree_path_free()` when
    /// you are done with it.
    @inlinable func getCursor(path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>? = nil, focusColumn: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeViewColumn>?>? = nil) {
        gtk_tree_view_get_cursor(tree_view_ptr, path, focusColumn)
    
    }

    /// Determines the destination row for a given position.  `drag_x` and
    /// `drag_y` are expected to be in widget coordinates.  This function is only
    /// meaningful if `tree_view` is realized.  Therefore this function will always
    /// return `false` if `tree_view` is not realized or does not have a model.
    @inlinable func getDestRowAtPos(dragX: Int, dragY: Int, path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>? = nil, pos: UnsafeMutablePointer<GtkTreeViewDropPosition>! = nil) -> Bool {
        let rv = ((gtk_tree_view_get_dest_row_at_pos(tree_view_ptr, gint(dragX), gint(dragY), path, pos)) != 0)
        return rv
    }

    /// Gets information about the row that is highlighted for feedback.
    @inlinable func getDragDestRow(path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>? = nil, pos: UnsafeMutablePointer<GtkTreeViewDropPosition>! = nil) {
        gtk_tree_view_get_drag_dest_row(tree_view_ptr, path, pos)
    
    }

    /// Returns whether or not the tree allows to start interactive searching
    /// by typing in text.
    @inlinable func getEnableSearch() -> Bool {
        let rv = ((gtk_tree_view_get_enable_search(tree_view_ptr)) != 0)
        return rv
    }

    /// Returns whether or not tree lines are drawn in `tree_view`.
    @inlinable func getEnableTreeLines() -> Bool {
        let rv = ((gtk_tree_view_get_enable_tree_lines(tree_view_ptr)) != 0)
        return rv
    }

    /// Returns the column that is the current expander column.
    /// This column has the expander arrow drawn next to it.
    @inlinable func getExpanderColumn() -> TreeViewColumnRef! {
        let rv = TreeViewColumnRef(gconstpointer: gconstpointer(gtk_tree_view_get_expander_column(tree_view_ptr)))
        return rv
    }

    /// Returns whether fixed height mode is turned on for `tree_view`.
    @inlinable func getFixedHeightMode() -> Bool {
        let rv = ((gtk_tree_view_get_fixed_height_mode(tree_view_ptr)) != 0)
        return rv
    }

    /// Returns which grid lines are enabled in `tree_view`.
    @inlinable func getGridLines() -> GtkTreeViewGridLines {
        let rv = gtk_tree_view_get_grid_lines(tree_view_ptr)
        return rv
    }

    /// Gets the `GtkAdjustment` currently being used for the horizontal aspect.
    ///
    /// **get_hadjustment is deprecated:**
    /// Use gtk_scrollable_get_hadjustment()
    @available(*, deprecated)
    @inlinable func getHadjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_tree_view_get_hadjustment(tree_view_ptr)))
        return rv
    }

    /// Returns whether all header columns are clickable.
    @inlinable func getHeadersClickable() -> Bool {
        let rv = ((gtk_tree_view_get_headers_clickable(tree_view_ptr)) != 0)
        return rv
    }

    /// Returns `true` if the headers on the `tree_view` are visible.
    @inlinable func getHeadersVisible() -> Bool {
        let rv = ((gtk_tree_view_get_headers_visible(tree_view_ptr)) != 0)
        return rv
    }

    /// Returns whether hover expansion mode is turned on for `tree_view`.
    @inlinable func getHoverExpand() -> Bool {
        let rv = ((gtk_tree_view_get_hover_expand(tree_view_ptr)) != 0)
        return rv
    }

    /// Returns whether hover selection mode is turned on for `tree_view`.
    @inlinable func getHoverSelection() -> Bool {
        let rv = ((gtk_tree_view_get_hover_selection(tree_view_ptr)) != 0)
        return rv
    }

    /// Returns the amount, in pixels, of extra indentation for child levels
    /// in `tree_view`.
    @inlinable func getLevelIndentation() -> Int {
        let rv = Int(gtk_tree_view_get_level_indentation(tree_view_ptr))
        return rv
    }

    /// Returns the model the `GtkTreeView` is based on.  Returns `nil` if the
    /// model is unset.
    @inlinable func getModel() -> TreeModelRef! {
        let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_tree_view_get_model(tree_view_ptr)))
        return rv
    }

    /// Queries the number of columns in the given `tree_view`.
    @inlinable func getNColumns() -> Int {
        let rv = Int(gtk_tree_view_get_n_columns(tree_view_ptr))
        return rv
    }

    /// Finds the path at the point (`x`, `y`), relative to bin_window coordinates
    /// (please see `gtk_tree_view_get_bin_window()`).
    /// That is, `x` and `y` are relative to an events coordinates. `x` and `y` must
    /// come from an event on the `tree_view` only where `event-&gt;window ==
    /// gtk_tree_view_get_bin_window ()`. It is primarily for
    /// things like popup menus. If `path` is non-`nil`, then it will be filled
    /// with the `GtkTreePath` at that point.  This path should be freed with
    /// `gtk_tree_path_free()`.  If `column` is non-`nil`, then it will be filled
    /// with the column at that point.  `cell_x` and `cell_y` return the coordinates
    /// relative to the cell background (i.e. the `background_area` passed to
    /// `gtk_cell_renderer_render()`).  This function is only meaningful if
    /// `tree_view` is realized.  Therefore this function will always return `false`
    /// if `tree_view` is not realized or does not have a model.
    /// 
    /// For converting widget coordinates (eg. the ones you get from
    /// GtkWidget`query-tooltip`), please see
    /// `gtk_tree_view_convert_widget_to_bin_window_coords()`.
    @inlinable func getPathAtPos(x: Int, y: Int, path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>? = nil, column: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeViewColumn>?>? = nil, cellX: UnsafeMutablePointer<gint>! = nil, cellY: UnsafeMutablePointer<gint>! = nil) -> Bool {
        let rv = ((gtk_tree_view_get_path_at_pos(tree_view_ptr, gint(x), gint(y), path, column, cellX, cellY)) != 0)
        return rv
    }

    /// Retrieves whether the user can reorder the tree via drag-and-drop. See
    /// `gtk_tree_view_set_reorderable()`.
    @inlinable func getReorderable() -> Bool {
        let rv = ((gtk_tree_view_get_reorderable(tree_view_ptr)) != 0)
        return rv
    }

    /// Returns the current row separator function.
    @inlinable func getRowSeparatorFunc() -> GtkTreeViewRowSeparatorFunc! {
        let rv = gtk_tree_view_get_row_separator_func(tree_view_ptr)
        return rv
    }

    /// Returns whether rubber banding is turned on for `tree_view`.  If the
    /// selection mode is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the
    /// user to select multiple rows by dragging the mouse.
    @inlinable func getRubberBanding() -> Bool {
        let rv = ((gtk_tree_view_get_rubber_banding(tree_view_ptr)) != 0)
        return rv
    }

    /// Gets the setting set by `gtk_tree_view_set_rules_hint()`.
    ///
    /// **get_rules_hint is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getRulesHint() -> Bool {
        let rv = ((gtk_tree_view_get_rules_hint(tree_view_ptr)) != 0)
        return rv
    }

    /// Gets the column searched on by the interactive search code.
    @inlinable func getSearchColumn() -> Int {
        let rv = Int(gtk_tree_view_get_search_column(tree_view_ptr))
        return rv
    }

    /// Returns the `GtkEntry` which is currently in use as interactive search
    /// entry for `tree_view`.  In case the built-in entry is being used, `nil`
    /// will be returned.
    @inlinable func getSearchEntry() -> EntryRef! {
        let rv = EntryRef(gconstpointer: gconstpointer(gtk_tree_view_get_search_entry(tree_view_ptr)))
        return rv
    }

    /// Returns the compare function currently in use.
    @inlinable func getSearchEqualFunc() -> GtkTreeViewSearchEqualFunc! {
        let rv = gtk_tree_view_get_search_equal_func(tree_view_ptr)
        return rv
    }

    /// Returns the positioning function currently in use.
    @inlinable func getSearchPositionFunc() -> GtkTreeViewSearchPositionFunc! {
        let rv = gtk_tree_view_get_search_position_func(tree_view_ptr)
        return rv
    }

    /// Gets the `GtkTreeSelection` associated with `tree_view`.
    @inlinable func getSelection() -> TreeSelectionRef! {
        let rv = TreeSelectionRef(gconstpointer: gconstpointer(gtk_tree_view_get_selection(tree_view_ptr)))
        return rv
    }

    /// Returns whether or not expanders are drawn in `tree_view`.
    @inlinable func getShowExpanders() -> Bool {
        let rv = ((gtk_tree_view_get_show_expanders(tree_view_ptr)) != 0)
        return rv
    }

    /// Returns the column of `tree_view`’s model which is being used for
    /// displaying tooltips on `tree_view`’s rows.
    @inlinable func getTooltipColumn() -> Int {
        let rv = Int(gtk_tree_view_get_tooltip_column(tree_view_ptr))
        return rv
    }

    /// This function is supposed to be used in a `GtkWidget::query-tooltip`
    /// signal handler for `GtkTreeView`.  The `x`, `y` and `keyboard_tip` values
    /// which are received in the signal handler, should be passed to this
    /// function without modification.
    /// 
    /// The return value indicates whether there is a tree view row at the given
    /// coordinates (`true`) or not (`false`) for mouse tooltips.  For keyboard
    /// tooltips the row returned will be the cursor row.  When `true`, then any of
    /// `model`, `path` and `iter` which have been provided will be set to point to
    /// that row and the corresponding model.  `x` and `y` will always be converted
    /// to be relative to `tree_view`’s bin_window if `keyboard_tooltip` is `false`.
    @inlinable func getTooltipContext(x: UnsafeMutablePointer<gint>!, y: UnsafeMutablePointer<gint>!, keyboardTip: Bool, model: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeModel>?>? = nil, path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>! = nil, iter: TreeIterRef? = nil) -> Bool {
        let rv = ((gtk_tree_view_get_tooltip_context(tree_view_ptr, x, y, gboolean((keyboardTip) ? 1 : 0), model, path, iter?.tree_iter_ptr)) != 0)
        return rv
    }
    /// This function is supposed to be used in a `GtkWidget::query-tooltip`
    /// signal handler for `GtkTreeView`.  The `x`, `y` and `keyboard_tip` values
    /// which are received in the signal handler, should be passed to this
    /// function without modification.
    /// 
    /// The return value indicates whether there is a tree view row at the given
    /// coordinates (`true`) or not (`false`) for mouse tooltips.  For keyboard
    /// tooltips the row returned will be the cursor row.  When `true`, then any of
    /// `model`, `path` and `iter` which have been provided will be set to point to
    /// that row and the corresponding model.  `x` and `y` will always be converted
    /// to be relative to `tree_view`’s bin_window if `keyboard_tooltip` is `false`.
    @inlinable func getTooltipContext<TreeIterT: TreeIterProtocol>(x: UnsafeMutablePointer<gint>!, y: UnsafeMutablePointer<gint>!, keyboardTip: Bool, model: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeModel>?>? = nil, path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>! = nil, iter: TreeIterT?) -> Bool {
        let rv = ((gtk_tree_view_get_tooltip_context(tree_view_ptr, x, y, gboolean((keyboardTip) ? 1 : 0), model, path, iter?.tree_iter_ptr)) != 0)
        return rv
    }

    /// Gets the `GtkAdjustment` currently being used for the vertical aspect.
    ///
    /// **get_vadjustment is deprecated:**
    /// Use gtk_scrollable_get_vadjustment()
    @available(*, deprecated)
    @inlinable func getVadjustment() -> AdjustmentRef! {
        let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_tree_view_get_vadjustment(tree_view_ptr)))
        return rv
    }

    /// Sets `start_path` and `end_path` to be the first and last visible path.
    /// Note that there may be invisible paths in between.
    /// 
    /// The paths should be freed with `gtk_tree_path_free()` after use.
    @inlinable func getVisibleRange(startPath: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>! = nil, endPath: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>! = nil) -> Bool {
        let rv = ((gtk_tree_view_get_visible_range(tree_view_ptr, startPath, endPath)) != 0)
        return rv
    }

    /// Fills `visible_rect` with the currently-visible region of the
    /// buffer, in tree coordinates. Convert to bin_window coordinates with
    /// `gtk_tree_view_convert_tree_to_bin_window_coords()`.
    /// Tree coordinates start at 0,0 for row 0 of the tree, and cover the entire
    /// scrollable area of the tree.
    @inlinable func get<RectangleT: Gdk.RectangleProtocol>(visibleRect: RectangleT) {
        gtk_tree_view_get_visible_rect(tree_view_ptr, visibleRect.rectangle_ptr)
    
    }

    /// This inserts the `column` into the `tree_view` at `position`.  If `position` is
    /// -1, then the column is inserted at the end. If `tree_view` has
    /// “fixed_height” mode enabled, then `column` must have its “sizing” property
    /// set to be GTK_TREE_VIEW_COLUMN_FIXED.
    @inlinable func insert<TreeViewColumnT: TreeViewColumnProtocol>(column: TreeViewColumnT, position: Int) -> Int {
        let rv = Int(gtk_tree_view_insert_column(tree_view_ptr, column.tree_view_column_ptr, gint(position)))
        return rv
    }


    // *** insertColumnWithAttributes() is not available because it has a varargs (...) parameter!


    /// Convenience function that inserts a new column into the `GtkTreeView`
    /// with the given cell renderer and a `GtkTreeCellDataFunc` to set cell renderer
    /// attributes (normally using data from the model). See also
    /// `gtk_tree_view_column_set_cell_data_func()`, `gtk_tree_view_column_pack_start()`.
    /// If `tree_view` has “fixed_height” mode enabled, then the new column will have its
    /// “sizing” property set to be GTK_TREE_VIEW_COLUMN_FIXED.
    @inlinable func insertColumnWithDataFunc<CellRendererT: CellRendererProtocol>(position: Int, title: UnsafePointer<gchar>!, cell: CellRendererT, `func`: GtkTreeCellDataFunc?, data: gpointer! = nil, dnotify: GDestroyNotify?) -> Int {
        let rv = Int(gtk_tree_view_insert_column_with_data_func(tree_view_ptr, gint(position), title, cell.cell_renderer_ptr, `func`, data, dnotify))
        return rv
    }

    /// Determine whether the point (`x`, `y`) in `tree_view` is blank, that is no
    /// cell content nor an expander arrow is drawn at the location. If so, the
    /// location can be considered as the background. You might wish to take
    /// special action on clicks on the background, such as clearing a current
    /// selection, having a custom context menu or starting rubber banding.
    /// 
    /// The `x` and `y` coordinate that are provided must be relative to bin_window
    /// coordinates.  That is, `x` and `y` must come from an event on `tree_view`
    /// where `event-&gt;window == gtk_tree_view_get_bin_window ()`.
    /// 
    /// For converting widget coordinates (eg. the ones you get from
    /// GtkWidget`query-tooltip`), please see
    /// `gtk_tree_view_convert_widget_to_bin_window_coords()`.
    /// 
    /// The `path`, `column`, `cell_x` and `cell_y` arguments will be filled in
    /// likewise as for `gtk_tree_view_get_path_at_pos()`.  Please see
    /// `gtk_tree_view_get_path_at_pos()` for more information.
    @inlinable func isBlankAtPos(x: Int, y: Int, path: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreePath>?>? = nil, column: UnsafeMutablePointer<UnsafeMutablePointer<GtkTreeViewColumn>?>? = nil, cellX: UnsafeMutablePointer<gint>! = nil, cellY: UnsafeMutablePointer<gint>! = nil) -> Bool {
        let rv = ((gtk_tree_view_is_blank_at_pos(tree_view_ptr, gint(x), gint(y), path, column, cellX, cellY)) != 0)
        return rv
    }

    /// Calls `func` on all expanded rows.
    @inlinable func mapExpandedRows(`func`: GtkTreeViewMappingFunc?, data: gpointer! = nil) {
        gtk_tree_view_map_expanded_rows(tree_view_ptr, `func`, data)
    
    }

    /// Moves `column` to be after to `base_column`.  If `base_column` is `nil`, then
    /// `column` is placed in the first position.
    @inlinable func moveColumnAfter<TreeViewColumnT: TreeViewColumnProtocol>(column: TreeViewColumnT, baseColumn: TreeViewColumnT?) {
        gtk_tree_view_move_column_after(tree_view_ptr, column.tree_view_column_ptr, baseColumn?.tree_view_column_ptr)
    
    }

    /// Removes `column` from `tree_view`.
    @inlinable func remove<TreeViewColumnT: TreeViewColumnProtocol>(column: TreeViewColumnT) -> Int {
        let rv = Int(gtk_tree_view_remove_column(tree_view_ptr, column.tree_view_column_ptr))
        return rv
    }

    /// Activates the cell determined by `path` and `column`.
    @inlinable func rowActivated<TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(path: TreePathT, column: TreeViewColumnT) {
        gtk_tree_view_row_activated(tree_view_ptr, path.tree_path_ptr, column.tree_view_column_ptr)
    
    }

    /// Returns `true` if the node pointed to by `path` is expanded in `tree_view`.
    @inlinable func rowExpanded<TreePathT: TreePathProtocol>(path: TreePathT) -> Bool {
        let rv = ((gtk_tree_view_row_expanded(tree_view_ptr, path.tree_path_ptr)) != 0)
        return rv
    }

    /// Moves the alignments of `tree_view` to the position specified by `column` and
    /// `path`.  If `column` is `nil`, then no horizontal scrolling occurs.  Likewise,
    /// if `path` is `nil` no vertical scrolling occurs.  At a minimum, one of `column`
    /// or `path` need to be non-`nil`.  `row_align` determines where the row is
    /// placed, and `col_align` determines where `column` is placed.  Both are expected
    /// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
    /// right/bottom alignment, 0.5 means center.
    /// 
    /// If `use_align` is `false`, then the alignment arguments are ignored, and the
    /// tree does the minimum amount of work to scroll the cell onto the screen.
    /// This means that the cell will be scrolled to the edge closest to its current
    /// position.  If the cell is currently visible on the screen, nothing is done.
    /// 
    /// This function only works if the model is set, and `path` is a valid row on the
    /// model.  If the model changes before the `tree_view` is realized, the centered
    /// path will be modified to reflect this change.
    @inlinable func scrollToCell(path: TreePathRef? = nil, column: TreeViewColumnRef? = nil, useAlign: Bool, rowAlign: Double, colAlign: Double) {
        gtk_tree_view_scroll_to_cell(tree_view_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, gboolean((useAlign) ? 1 : 0), gfloat(rowAlign), gfloat(colAlign))
    
    }
    /// Moves the alignments of `tree_view` to the position specified by `column` and
    /// `path`.  If `column` is `nil`, then no horizontal scrolling occurs.  Likewise,
    /// if `path` is `nil` no vertical scrolling occurs.  At a minimum, one of `column`
    /// or `path` need to be non-`nil`.  `row_align` determines where the row is
    /// placed, and `col_align` determines where `column` is placed.  Both are expected
    /// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
    /// right/bottom alignment, 0.5 means center.
    /// 
    /// If `use_align` is `false`, then the alignment arguments are ignored, and the
    /// tree does the minimum amount of work to scroll the cell onto the screen.
    /// This means that the cell will be scrolled to the edge closest to its current
    /// position.  If the cell is currently visible on the screen, nothing is done.
    /// 
    /// This function only works if the model is set, and `path` is a valid row on the
    /// model.  If the model changes before the `tree_view` is realized, the centered
    /// path will be modified to reflect this change.
    @inlinable func scrollToCell<TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(path: TreePathT?, column: TreeViewColumnT?, useAlign: Bool, rowAlign: Double, colAlign: Double) {
        gtk_tree_view_scroll_to_cell(tree_view_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, gboolean((useAlign) ? 1 : 0), gfloat(rowAlign), gfloat(colAlign))
    
    }

    /// Scrolls the tree view such that the top-left corner of the visible
    /// area is `tree_x`, `tree_y`, where `tree_x` and `tree_y` are specified
    /// in tree coordinates.  The `tree_view` must be realized before
    /// this function is called.  If it isn't, you probably want to be
    /// using `gtk_tree_view_scroll_to_cell()`.
    /// 
    /// If either `tree_x` or `tree_y` are -1, then that direction isn’t scrolled.
    @inlinable func scrollToPoint(treeX: Int, treeY: Int) {
        gtk_tree_view_scroll_to_point(tree_view_ptr, gint(treeX), gint(treeY))
    
    }

    /// Cause the `GtkTreeView::row-activated` signal to be emitted
    /// on a single click instead of a double click.
    @inlinable func setActivateOnSingleClick(single: Bool) {
        gtk_tree_view_set_activate_on_single_click(tree_view_ptr, gboolean((single) ? 1 : 0))
    
    }

    /// Sets a user function for determining where a column may be dropped when
    /// dragged.  This function is called on every column pair in turn at the
    /// beginning of a column drag to determine where a drop can take place.  The
    /// arguments passed to `func` are: the `tree_view`, the `GtkTreeViewColumn` being
    /// dragged, the two `GtkTreeViewColumn` s determining the drop spot, and
    /// `user_data`.  If either of the `GtkTreeViewColumn` arguments for the drop spot
    /// are `nil`, then they indicate an edge.  If `func` is set to be `nil`, then
    /// `tree_view` reverts to the default behavior of allowing all columns to be
    /// dropped everywhere.
    @inlinable func setColumnDragFunction(`func`: GtkTreeViewColumnDropFunc? = nil, userData: gpointer! = nil, destroy: GDestroyNotify? = nil) {
        gtk_tree_view_set_column_drag_function(tree_view_ptr, `func`, userData, destroy)
    
    }

    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular row.  If
    /// `focus_column` is not `nil`, then focus is given to the column specified by
    /// it. Additionally, if `focus_column` is specified, and `start_editing` is
    /// `true`, then editing should be started in the specified cell.
    /// This function is often followed by `gtk_widget_grab_focus` (`tree_view`)
    /// in order to give keyboard focus to the widget.  Please note that editing
    /// can only happen when the widget is realized.
    /// 
    /// If `path` is invalid for `model`, the current cursor (if any) will be unset
    /// and the function will return without failing.
    @inlinable func setCursor<TreePathT: TreePathProtocol>(path: TreePathT, focusColumn: TreeViewColumnRef? = nil, startEditing: Bool) {
        gtk_tree_view_set_cursor(tree_view_ptr, path.tree_path_ptr, focusColumn?.tree_view_column_ptr, gboolean((startEditing) ? 1 : 0))
    
    }
    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular row.  If
    /// `focus_column` is not `nil`, then focus is given to the column specified by
    /// it. Additionally, if `focus_column` is specified, and `start_editing` is
    /// `true`, then editing should be started in the specified cell.
    /// This function is often followed by `gtk_widget_grab_focus` (`tree_view`)
    /// in order to give keyboard focus to the widget.  Please note that editing
    /// can only happen when the widget is realized.
    /// 
    /// If `path` is invalid for `model`, the current cursor (if any) will be unset
    /// and the function will return without failing.
    @inlinable func setCursor<TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(path: TreePathT, focusColumn: TreeViewColumnT?, startEditing: Bool) {
        gtk_tree_view_set_cursor(tree_view_ptr, path.tree_path_ptr, focusColumn?.tree_view_column_ptr, gboolean((startEditing) ? 1 : 0))
    
    }

    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular row.  If
    /// `focus_column` is not `nil`, then focus is given to the column specified by
    /// it. If `focus_column` and `focus_cell` are not `nil`, and `focus_column`
    /// contains 2 or more editable or activatable cells, then focus is given to
    /// the cell specified by `focus_cell`. Additionally, if `focus_column` is
    /// specified, and `start_editing` is `true`, then editing should be started in
    /// the specified cell.  This function is often followed by
    /// `gtk_widget_grab_focus` (`tree_view`) in order to give keyboard focus to the
    /// widget.  Please note that editing can only happen when the widget is
    /// realized.
    /// 
    /// If `path` is invalid for `model`, the current cursor (if any) will be unset
    /// and the function will return without failing.
    @inlinable func setCursorOnCell<TreePathT: TreePathProtocol>(path: TreePathT, focusColumn: TreeViewColumnRef? = nil, focusCell: CellRendererRef? = nil, startEditing: Bool) {
        gtk_tree_view_set_cursor_on_cell(tree_view_ptr, path.tree_path_ptr, focusColumn?.tree_view_column_ptr, focusCell?.cell_renderer_ptr, gboolean((startEditing) ? 1 : 0))
    
    }
    /// Sets the current keyboard focus to be at `path`, and selects it.  This is
    /// useful when you want to focus the user’s attention on a particular row.  If
    /// `focus_column` is not `nil`, then focus is given to the column specified by
    /// it. If `focus_column` and `focus_cell` are not `nil`, and `focus_column`
    /// contains 2 or more editable or activatable cells, then focus is given to
    /// the cell specified by `focus_cell`. Additionally, if `focus_column` is
    /// specified, and `start_editing` is `true`, then editing should be started in
    /// the specified cell.  This function is often followed by
    /// `gtk_widget_grab_focus` (`tree_view`) in order to give keyboard focus to the
    /// widget.  Please note that editing can only happen when the widget is
    /// realized.
    /// 
    /// If `path` is invalid for `model`, the current cursor (if any) will be unset
    /// and the function will return without failing.
    @inlinable func setCursorOnCell<CellRendererT: CellRendererProtocol, TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(path: TreePathT, focusColumn: TreeViewColumnT?, focusCell: CellRendererT?, startEditing: Bool) {
        gtk_tree_view_set_cursor_on_cell(tree_view_ptr, path.tree_path_ptr, focusColumn?.tree_view_column_ptr, focusCell?.cell_renderer_ptr, gboolean((startEditing) ? 1 : 0))
    
    }

    /// This function should almost never be used.  It is meant for private use by
    /// ATK for determining the number of visible children that are removed when the
    /// user collapses a row, or a row is deleted.
    ///
    /// **set_destroy_count_func is deprecated:**
    /// Accessibility does not need the function anymore.
    @available(*, deprecated)
    @inlinable func setDestroyCountFunc(`func`: GtkTreeDestroyCountFunc? = nil, data: gpointer! = nil, destroy: GDestroyNotify? = nil) {
        gtk_tree_view_set_destroy_count_func(tree_view_ptr, `func`, data, destroy)
    
    }

    /// Sets the row that is highlighted for feedback.
    /// If `path` is `nil`, an existing highlight is removed.
    @inlinable func setDragDestRow(path: TreePathRef? = nil, pos: GtkTreeViewDropPosition) {
        gtk_tree_view_set_drag_dest_row(tree_view_ptr, path?.tree_path_ptr, pos)
    
    }
    /// Sets the row that is highlighted for feedback.
    /// If `path` is `nil`, an existing highlight is removed.
    @inlinable func setDragDestRow<TreePathT: TreePathProtocol>(path: TreePathT?, pos: GtkTreeViewDropPosition) {
        gtk_tree_view_set_drag_dest_row(tree_view_ptr, path?.tree_path_ptr, pos)
    
    }

    /// If `enable_search` is set, then the user can type in text to search through
    /// the tree interactively (this is sometimes called "typeahead find").
    /// 
    /// Note that even if this is `false`, the user can still initiate a search
    /// using the “start-interactive-search” key binding.
    @inlinable func set(enableSearch: Bool) {
        gtk_tree_view_set_enable_search(tree_view_ptr, gboolean((enableSearch) ? 1 : 0))
    
    }

    /// Sets whether to draw lines interconnecting the expanders in `tree_view`.
    /// This does not have any visible effects for lists.
    @inlinable func setEnableTreeLines(enabled: Bool) {
        gtk_tree_view_set_enable_tree_lines(tree_view_ptr, gboolean((enabled) ? 1 : 0))
    
    }

    /// Sets the column to draw the expander arrow at. It must be in `tree_view`.
    /// If `column` is `nil`, then the expander arrow is always at the first
    /// visible column.
    /// 
    /// If you do not want expander arrow to appear in your tree, set the
    /// expander column to a hidden column.
    @inlinable func setExpander(column: TreeViewColumnRef? = nil) {
        gtk_tree_view_set_expander_column(tree_view_ptr, column?.tree_view_column_ptr)
    
    }
    /// Sets the column to draw the expander arrow at. It must be in `tree_view`.
    /// If `column` is `nil`, then the expander arrow is always at the first
    /// visible column.
    /// 
    /// If you do not want expander arrow to appear in your tree, set the
    /// expander column to a hidden column.
    @inlinable func setExpander<TreeViewColumnT: TreeViewColumnProtocol>(column: TreeViewColumnT?) {
        gtk_tree_view_set_expander_column(tree_view_ptr, column?.tree_view_column_ptr)
    
    }

    /// Enables or disables the fixed height mode of `tree_view`.
    /// Fixed height mode speeds up `GtkTreeView` by assuming that all
    /// rows have the same height.
    /// Only enable this option if all rows are the same height and all
    /// columns are of type `GTK_TREE_VIEW_COLUMN_FIXED`.
    @inlinable func setFixedHeightMode(enable: Bool) {
        gtk_tree_view_set_fixed_height_mode(tree_view_ptr, gboolean((enable) ? 1 : 0))
    
    }

    /// Sets which grid lines to draw in `tree_view`.
    @inlinable func set(gridLines: GtkTreeViewGridLines) {
        gtk_tree_view_set_grid_lines(tree_view_ptr, gridLines)
    
    }

    /// Sets the `GtkAdjustment` for the current horizontal aspect.
    ///
    /// **set_hadjustment is deprecated:**
    /// Use gtk_scrollable_set_hadjustment()
    @available(*, deprecated)
    @inlinable func setHadjustment(adjustment: AdjustmentRef? = nil) {
        gtk_tree_view_set_hadjustment(tree_view_ptr, adjustment?.adjustment_ptr)
    
    }
    /// Sets the `GtkAdjustment` for the current horizontal aspect.
    ///
    /// **set_hadjustment is deprecated:**
    /// Use gtk_scrollable_set_hadjustment()
    @available(*, deprecated)
    @inlinable func setHadjustment<AdjustmentT: AdjustmentProtocol>(adjustment: AdjustmentT?) {
        gtk_tree_view_set_hadjustment(tree_view_ptr, adjustment?.adjustment_ptr)
    
    }

    /// Allow the column title buttons to be clicked.
    @inlinable func setHeadersClickable(setting: Bool) {
        gtk_tree_view_set_headers_clickable(tree_view_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Sets the visibility state of the headers.
    @inlinable func set(headersVisible: Bool) {
        gtk_tree_view_set_headers_visible(tree_view_ptr, gboolean((headersVisible) ? 1 : 0))
    
    }

    /// Enables or disables the hover expansion mode of `tree_view`.
    /// Hover expansion makes rows expand or collapse if the pointer
    /// moves over them.
    @inlinable func setHover(expand: Bool) {
        gtk_tree_view_set_hover_expand(tree_view_ptr, gboolean((expand) ? 1 : 0))
    
    }

    /// Enables or disables the hover selection mode of `tree_view`.
    /// Hover selection makes the selected row follow the pointer.
    /// Currently, this works only for the selection modes
    /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
    @inlinable func setHoverSelection(hover: Bool) {
        gtk_tree_view_set_hover_selection(tree_view_ptr, gboolean((hover) ? 1 : 0))
    
    }

    /// Sets the amount of extra indentation for child levels to use in `tree_view`
    /// in addition to the default indentation.  The value should be specified in
    /// pixels, a value of 0 disables this feature and in this case only the default
    /// indentation will be used.
    /// This does not have any visible effects for lists.
    @inlinable func setLevel(indentation: Int) {
        gtk_tree_view_set_level_indentation(tree_view_ptr, gint(indentation))
    
    }

    /// Sets the model for a `GtkTreeView`.  If the `tree_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is `nil`,
    /// then it will unset the old model.
    @inlinable func set(model: TreeModelRef? = nil) {
        gtk_tree_view_set_model(tree_view_ptr, model?.tree_model_ptr)
    
    }
    /// Sets the model for a `GtkTreeView`.  If the `tree_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is `nil`,
    /// then it will unset the old model.
    @inlinable func set<TreeModelT: TreeModelProtocol>(model: TreeModelT?) {
        gtk_tree_view_set_model(tree_view_ptr, model?.tree_model_ptr)
    
    }

    /// This function is a convenience function to allow you to reorder
    /// models that support the `GtkTreeDragSourceIface` and the
    /// `GtkTreeDragDestIface`.  Both `GtkTreeStore` and `GtkListStore` support
    /// these.  If `reorderable` is `true`, then the user can reorder the
    /// model by dragging and dropping rows. The developer can listen to
    /// these changes by connecting to the model’s `GtkTreeModel::row-inserted`
    /// and `GtkTreeModel::row-deleted` signals. The reordering is implemented
    /// by setting up the tree view as a drag source and destination.
    /// Therefore, drag and drop can not be used in a reorderable view for any
    /// other purpose.
    /// 
    /// This function does not give you any degree of control over the order -- any
    /// reordering is allowed.  If more control is needed, you should probably
    /// handle drag and drop manually.
    @inlinable func set(reorderable: Bool) {
        gtk_tree_view_set_reorderable(tree_view_ptr, gboolean((reorderable) ? 1 : 0))
    
    }

    /// Sets the row separator function, which is used to determine
    /// whether a row should be drawn as a separator. If the row separator
    /// function is `nil`, no separators are drawn. This is the default value.
    @inlinable func setRowSeparatorFunc(`func`: GtkTreeViewRowSeparatorFunc? = nil, data: gpointer! = nil, destroy: GDestroyNotify? = nil) {
        gtk_tree_view_set_row_separator_func(tree_view_ptr, `func`, data, destroy)
    
    }

    /// Enables or disables rubber banding in `tree_view`.  If the selection mode
    /// is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the user to select
    /// multiple rows by dragging the mouse.
    @inlinable func setRubberBanding(enable: Bool) {
        gtk_tree_view_set_rubber_banding(tree_view_ptr, gboolean((enable) ? 1 : 0))
    
    }

    /// Sets a hint for the theme to draw even/odd rows in the `tree_view`
    /// with different colors, also known as "zebra striping".
    /// 
    /// This function tells the GTK+ theme that the user interface for your
    /// application requires users to read across tree rows and associate
    /// cells with one another.
    /// 
    /// Do not use it just because you prefer the appearance of the ruled
    /// tree; that’s a question for the theme. Some themes will draw tree
    /// rows in alternating colors even when rules are turned off, and
    /// users who prefer that appearance all the time can choose those
    /// themes. You should call this function only as a semantic hint to
    /// the theme engine that your tree makes alternating colors useful
    /// from a functional standpoint (since it has lots of columns,
    /// generally).
    ///
    /// **set_rules_hint is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func setRulesHint(setting: Bool) {
        gtk_tree_view_set_rules_hint(tree_view_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Sets `column` as the column where the interactive search code should
    /// search in for the current model.
    /// 
    /// If the search column is set, users can use the “start-interactive-search”
    /// key binding to bring up search popup. The enable-search property controls
    /// whether simply typing text will also start an interactive search.
    /// 
    /// Note that `column` refers to a column of the current model. The search
    /// column is reset to -1 when the model is changed.
    @inlinable func setSearch(column: Int) {
        gtk_tree_view_set_search_column(tree_view_ptr, gint(column))
    
    }

    /// Sets the entry which the interactive search code will use for this
    /// `tree_view`.  This is useful when you want to provide a search entry
    /// in our interface at all time at a fixed position.  Passing `nil` for
    /// `entry` will make the interactive search code use the built-in popup
    /// entry again.
    @inlinable func setSearch(entry: EntryRef? = nil) {
        gtk_tree_view_set_search_entry(tree_view_ptr, entry?.entry_ptr)
    
    }
    /// Sets the entry which the interactive search code will use for this
    /// `tree_view`.  This is useful when you want to provide a search entry
    /// in our interface at all time at a fixed position.  Passing `nil` for
    /// `entry` will make the interactive search code use the built-in popup
    /// entry again.
    @inlinable func setSearch<EntryT: EntryProtocol>(entry: EntryT?) {
        gtk_tree_view_set_search_entry(tree_view_ptr, entry?.entry_ptr)
    
    }

    /// Sets the compare function for the interactive search capabilities; note
    /// that somewhat like `strcmp()` returning 0 for equality
    /// `GtkTreeViewSearchEqualFunc` returns `false` on matches.
    @inlinable func set(searchEqualFunc: GtkTreeViewSearchEqualFunc?, searchUserData: gpointer! = nil, searchDestroy: GDestroyNotify? = nil) {
        gtk_tree_view_set_search_equal_func(tree_view_ptr, searchEqualFunc, searchUserData, searchDestroy)
    
    }

    /// Sets the function to use when positioning the search dialog.
    @inlinable func setSearchPositionFunc(`func`: GtkTreeViewSearchPositionFunc? = nil, data: gpointer! = nil, destroy: GDestroyNotify? = nil) {
        gtk_tree_view_set_search_position_func(tree_view_ptr, `func`, data, destroy)
    
    }

    /// Sets whether to draw and enable expanders and indent child rows in
    /// `tree_view`.  When disabled there will be no expanders visible in trees
    /// and there will be no way to expand and collapse rows by default.  Also
    /// note that hiding the expanders will disable the default indentation.  You
    /// can set a custom indentation in this case using
    /// `gtk_tree_view_set_level_indentation()`.
    /// This does not have any visible effects for lists.
    @inlinable func setShowExpanders(enabled: Bool) {
        gtk_tree_view_set_show_expanders(tree_view_ptr, gboolean((enabled) ? 1 : 0))
    
    }

    /// Sets the tip area of `tooltip` to the area `path`, `column` and `cell` have
    /// in common.  For example if `path` is `nil` and `column` is set, the tip
    /// area will be set to the full area covered by `column`.  See also
    /// `gtk_tooltip_set_tip_area()`.
    /// 
    /// Note that if `path` is not specified and `cell` is set and part of a column
    /// containing the expander, the tooltip might not show and hide at the correct
    /// position.  In such cases `path` must be set to the current node under the
    /// mouse cursor for this function to operate correctly.
    /// 
    /// See also `gtk_tree_view_set_tooltip_column()` for a simpler alternative.
    @inlinable func setTooltipCell<TooltipT: TooltipProtocol>(tooltip: TooltipT, path: TreePathRef? = nil, column: TreeViewColumnRef? = nil, cell: CellRendererRef? = nil) {
        gtk_tree_view_set_tooltip_cell(tree_view_ptr, tooltip.tooltip_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, cell?.cell_renderer_ptr)
    
    }
    /// Sets the tip area of `tooltip` to the area `path`, `column` and `cell` have
    /// in common.  For example if `path` is `nil` and `column` is set, the tip
    /// area will be set to the full area covered by `column`.  See also
    /// `gtk_tooltip_set_tip_area()`.
    /// 
    /// Note that if `path` is not specified and `cell` is set and part of a column
    /// containing the expander, the tooltip might not show and hide at the correct
    /// position.  In such cases `path` must be set to the current node under the
    /// mouse cursor for this function to operate correctly.
    /// 
    /// See also `gtk_tree_view_set_tooltip_column()` for a simpler alternative.
    @inlinable func setTooltipCell<CellRendererT: CellRendererProtocol, TooltipT: TooltipProtocol, TreePathT: TreePathProtocol, TreeViewColumnT: TreeViewColumnProtocol>(tooltip: TooltipT, path: TreePathT?, column: TreeViewColumnT?, cell: CellRendererT?) {
        gtk_tree_view_set_tooltip_cell(tree_view_ptr, tooltip.tooltip_ptr, path?.tree_path_ptr, column?.tree_view_column_ptr, cell?.cell_renderer_ptr)
    
    }

    /// If you only plan to have simple (text-only) tooltips on full rows, you
    /// can use this function to have `GtkTreeView` handle these automatically
    /// for you. `column` should be set to the column in `tree_view`’s model
    /// containing the tooltip texts, or -1 to disable this feature.
    /// 
    /// When enabled, `GtkWidget:has-tooltip` will be set to `true` and
    /// `tree_view` will connect a `GtkWidget::query-tooltip` signal handler.
    /// 
    /// Note that the signal handler sets the text with `gtk_tooltip_set_markup()`,
    /// so &, &lt;, etc have to be escaped in the text.
    @inlinable func setTooltip(column: Int) {
        gtk_tree_view_set_tooltip_column(tree_view_ptr, gint(column))
    
    }

    /// Sets the tip area of `tooltip` to be the area covered by the row at `path`.
    /// See also `gtk_tree_view_set_tooltip_column()` for a simpler alternative.
    /// See also `gtk_tooltip_set_tip_area()`.
    @inlinable func setTooltipRow<TooltipT: TooltipProtocol, TreePathT: TreePathProtocol>(tooltip: TooltipT, path: TreePathT) {
        gtk_tree_view_set_tooltip_row(tree_view_ptr, tooltip.tooltip_ptr, path.tree_path_ptr)
    
    }

    /// Sets the `GtkAdjustment` for the current vertical aspect.
    ///
    /// **set_vadjustment is deprecated:**
    /// Use gtk_scrollable_set_vadjustment()
    @available(*, deprecated)
    @inlinable func setVadjustment(adjustment: AdjustmentRef? = nil) {
        gtk_tree_view_set_vadjustment(tree_view_ptr, adjustment?.adjustment_ptr)
    
    }
    /// Sets the `GtkAdjustment` for the current vertical aspect.
    ///
    /// **set_vadjustment is deprecated:**
    /// Use gtk_scrollable_set_vadjustment()
    @available(*, deprecated)
    @inlinable func setVadjustment<AdjustmentT: AdjustmentProtocol>(adjustment: AdjustmentT?) {
        gtk_tree_view_set_vadjustment(tree_view_ptr, adjustment?.adjustment_ptr)
    
    }

    /// Undoes the effect of
    /// `gtk_tree_view_enable_model_drag_dest()`. Calling this method sets
    /// `GtkTreeView:reorderable` to `false`.
    @inlinable func unsetRowsDragDest() {
        gtk_tree_view_unset_rows_drag_dest(tree_view_ptr)
    
    }

    /// Undoes the effect of
    /// `gtk_tree_view_enable_model_drag_source()`. Calling this method sets
    /// `GtkTreeView:reorderable` to `false`.
    @inlinable func unsetRowsDragSource() {
        gtk_tree_view_unset_rows_drag_source(tree_view_ptr)
    
    }
    /// Gets the setting set by `gtk_tree_view_set_activate_on_single_click()`.
    @inlinable var activateOnSingleClick: Bool {
        /// Gets the setting set by `gtk_tree_view_set_activate_on_single_click()`.
        get {
            let rv = ((gtk_tree_view_get_activate_on_single_click(tree_view_ptr)) != 0)
            return rv
        }
        /// Cause the `GtkTreeView::row-activated` signal to be emitted
        /// on a single click instead of a double click.
        nonmutating set {
            gtk_tree_view_set_activate_on_single_click(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the window that `tree_view` renders to.
    /// This is used primarily to compare to `event-&gt;window`
    /// to confirm that the event on `tree_view` is on the right window.
    @inlinable var binWindow: Gdk.WindowRef! {
        /// Returns the window that `tree_view` renders to.
        /// This is used primarily to compare to `event-&gt;window`
        /// to confirm that the event on `tree_view` is on the right window.
        get {
            let rv = Gdk.WindowRef(gtk_tree_view_get_bin_window(tree_view_ptr))
            return rv
        }
    }

    /// Returns a `GList` of all the `GtkTreeViewColumn` s currently in `tree_view`.
    /// The returned list must be freed with g_list_free ().
    @inlinable var columns: GLib.ListRef! {
        /// Returns a `GList` of all the `GtkTreeViewColumn` s currently in `tree_view`.
        /// The returned list must be freed with g_list_free ().
        get {
            let rv = GLib.ListRef(gtk_tree_view_get_columns(tree_view_ptr))
            return rv
        }
    }

    /// Returns whether or not the tree allows to start interactive searching
    /// by typing in text.
    @inlinable var enableSearch: Bool {
        /// Returns whether or not the tree allows to start interactive searching
        /// by typing in text.
        get {
            let rv = ((gtk_tree_view_get_enable_search(tree_view_ptr)) != 0)
            return rv
        }
        /// If `enable_search` is set, then the user can type in text to search through
        /// the tree interactively (this is sometimes called "typeahead find").
        /// 
        /// Note that even if this is `false`, the user can still initiate a search
        /// using the “start-interactive-search” key binding.
        nonmutating set {
            gtk_tree_view_set_enable_search(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether or not tree lines are drawn in `tree_view`.
    @inlinable var enableTreeLines: Bool {
        /// Returns whether or not tree lines are drawn in `tree_view`.
        get {
            let rv = ((gtk_tree_view_get_enable_tree_lines(tree_view_ptr)) != 0)
            return rv
        }
        /// Sets whether to draw lines interconnecting the expanders in `tree_view`.
        /// This does not have any visible effects for lists.
        nonmutating set {
            gtk_tree_view_set_enable_tree_lines(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the column that is the current expander column.
    /// This column has the expander arrow drawn next to it.
    @inlinable var expanderColumn: TreeViewColumnRef! {
        /// Returns the column that is the current expander column.
        /// This column has the expander arrow drawn next to it.
        get {
            let rv = TreeViewColumnRef(gconstpointer: gconstpointer(gtk_tree_view_get_expander_column(tree_view_ptr)))
            return rv
        }
        /// Sets the column to draw the expander arrow at. It must be in `tree_view`.
        /// If `column` is `nil`, then the expander arrow is always at the first
        /// visible column.
        /// 
        /// If you do not want expander arrow to appear in your tree, set the
        /// expander column to a hidden column.
        nonmutating set {
            gtk_tree_view_set_expander_column(tree_view_ptr, UnsafeMutablePointer<GtkTreeViewColumn>(newValue?.tree_view_column_ptr))
        }
    }

    /// Returns whether fixed height mode is turned on for `tree_view`.
    @inlinable var fixedHeightMode: Bool {
        /// Returns whether fixed height mode is turned on for `tree_view`.
        get {
            let rv = ((gtk_tree_view_get_fixed_height_mode(tree_view_ptr)) != 0)
            return rv
        }
        /// Enables or disables the fixed height mode of `tree_view`.
        /// Fixed height mode speeds up `GtkTreeView` by assuming that all
        /// rows have the same height.
        /// Only enable this option if all rows are the same height and all
        /// columns are of type `GTK_TREE_VIEW_COLUMN_FIXED`.
        nonmutating set {
            gtk_tree_view_set_fixed_height_mode(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns which grid lines are enabled in `tree_view`.
    @inlinable var gridLines: GtkTreeViewGridLines {
        /// Returns which grid lines are enabled in `tree_view`.
        get {
            let rv = gtk_tree_view_get_grid_lines(tree_view_ptr)
            return rv
        }
        /// Sets which grid lines to draw in `tree_view`.
        nonmutating set {
            gtk_tree_view_set_grid_lines(tree_view_ptr, newValue)
        }
    }

    /// Gets the `GtkAdjustment` currently being used for the horizontal aspect.
    ///
    /// **get_hadjustment is deprecated:**
    /// Use gtk_scrollable_get_hadjustment()
    @inlinable var hadjustment: AdjustmentRef! {
        /// Gets the `GtkAdjustment` currently being used for the horizontal aspect.
        ///
        /// **get_hadjustment is deprecated:**
        /// Use gtk_scrollable_get_hadjustment()
        @available(*, deprecated)
    get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_tree_view_get_hadjustment(tree_view_ptr)))
            return rv
        }
        /// Sets the `GtkAdjustment` for the current horizontal aspect.
        ///
        /// **set_hadjustment is deprecated:**
        /// Use gtk_scrollable_set_hadjustment()
        @available(*, deprecated)
    nonmutating set {
            gtk_tree_view_set_hadjustment(tree_view_ptr, UnsafeMutablePointer<GtkAdjustment>(newValue?.adjustment_ptr))
        }
    }

    /// Returns whether all header columns are clickable.
    @inlinable var headersClickable: Bool {
        /// Returns whether all header columns are clickable.
        get {
            let rv = ((gtk_tree_view_get_headers_clickable(tree_view_ptr)) != 0)
            return rv
        }
        /// Allow the column title buttons to be clicked.
        nonmutating set {
            gtk_tree_view_set_headers_clickable(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns `true` if the headers on the `tree_view` are visible.
    @inlinable var headersVisible: Bool {
        /// Returns `true` if the headers on the `tree_view` are visible.
        get {
            let rv = ((gtk_tree_view_get_headers_visible(tree_view_ptr)) != 0)
            return rv
        }
        /// Sets the visibility state of the headers.
        nonmutating set {
            gtk_tree_view_set_headers_visible(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether hover expansion mode is turned on for `tree_view`.
    @inlinable var hoverExpand: Bool {
        /// Returns whether hover expansion mode is turned on for `tree_view`.
        get {
            let rv = ((gtk_tree_view_get_hover_expand(tree_view_ptr)) != 0)
            return rv
        }
        /// Enables or disables the hover expansion mode of `tree_view`.
        /// Hover expansion makes rows expand or collapse if the pointer
        /// moves over them.
        nonmutating set {
            gtk_tree_view_set_hover_expand(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether hover selection mode is turned on for `tree_view`.
    @inlinable var hoverSelection: Bool {
        /// Returns whether hover selection mode is turned on for `tree_view`.
        get {
            let rv = ((gtk_tree_view_get_hover_selection(tree_view_ptr)) != 0)
            return rv
        }
        /// Enables or disables the hover selection mode of `tree_view`.
        /// Hover selection makes the selected row follow the pointer.
        /// Currently, this works only for the selection modes
        /// `GTK_SELECTION_SINGLE` and `GTK_SELECTION_BROWSE`.
        nonmutating set {
            gtk_tree_view_set_hover_selection(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether a rubber banding operation is currently being done
    /// in `tree_view`.
    @inlinable var isRubberBandingActive: Bool {
        /// Returns whether a rubber banding operation is currently being done
        /// in `tree_view`.
        get {
            let rv = ((gtk_tree_view_is_rubber_banding_active(tree_view_ptr)) != 0)
            return rv
        }
    }

    /// Returns the amount, in pixels, of extra indentation for child levels
    /// in `tree_view`.
    @inlinable var levelIndentation: Int {
        /// Returns the amount, in pixels, of extra indentation for child levels
        /// in `tree_view`.
        get {
            let rv = Int(gtk_tree_view_get_level_indentation(tree_view_ptr))
            return rv
        }
        /// Sets the amount of extra indentation for child levels to use in `tree_view`
        /// in addition to the default indentation.  The value should be specified in
        /// pixels, a value of 0 disables this feature and in this case only the default
        /// indentation will be used.
        /// This does not have any visible effects for lists.
        nonmutating set {
            gtk_tree_view_set_level_indentation(tree_view_ptr, gint(newValue))
        }
    }

    @inlinable var model: TreeModelRef! {
        /// Returns the model the `GtkTreeView` is based on.  Returns `nil` if the
        /// model is unset.
        get {
            let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_tree_view_get_model(tree_view_ptr)))
            return rv
        }
        /// Sets the model for a `GtkTreeView`.  If the `tree_view` already has a model
        /// set, it will remove it before setting the new model.  If `model` is `nil`,
        /// then it will unset the old model.
        nonmutating set {
            gtk_tree_view_set_model(tree_view_ptr, UnsafeMutablePointer<GtkTreeModel>(newValue?.tree_model_ptr))
        }
    }

    /// Queries the number of columns in the given `tree_view`.
    @inlinable var nColumns: Int {
        /// Queries the number of columns in the given `tree_view`.
        get {
            let rv = Int(gtk_tree_view_get_n_columns(tree_view_ptr))
            return rv
        }
    }

    @inlinable var reorderable: Bool {
        /// Retrieves whether the user can reorder the tree via drag-and-drop. See
        /// `gtk_tree_view_set_reorderable()`.
        get {
            let rv = ((gtk_tree_view_get_reorderable(tree_view_ptr)) != 0)
            return rv
        }
        /// This function is a convenience function to allow you to reorder
        /// models that support the `GtkTreeDragSourceIface` and the
        /// `GtkTreeDragDestIface`.  Both `GtkTreeStore` and `GtkListStore` support
        /// these.  If `reorderable` is `true`, then the user can reorder the
        /// model by dragging and dropping rows. The developer can listen to
        /// these changes by connecting to the model’s `GtkTreeModel::row-inserted`
        /// and `GtkTreeModel::row-deleted` signals. The reordering is implemented
        /// by setting up the tree view as a drag source and destination.
        /// Therefore, drag and drop can not be used in a reorderable view for any
        /// other purpose.
        /// 
        /// This function does not give you any degree of control over the order -- any
        /// reordering is allowed.  If more control is needed, you should probably
        /// handle drag and drop manually.
        nonmutating set {
            gtk_tree_view_set_reorderable(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the current row separator function.
    @inlinable var rowSeparatorFunc: GtkTreeViewRowSeparatorFunc! {
        /// Returns the current row separator function.
        get {
            let rv = gtk_tree_view_get_row_separator_func(tree_view_ptr)
            return rv
        }
    }

    /// Returns whether rubber banding is turned on for `tree_view`.  If the
    /// selection mode is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the
    /// user to select multiple rows by dragging the mouse.
    @inlinable var rubberBanding: Bool {
        /// Returns whether rubber banding is turned on for `tree_view`.  If the
        /// selection mode is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the
        /// user to select multiple rows by dragging the mouse.
        get {
            let rv = ((gtk_tree_view_get_rubber_banding(tree_view_ptr)) != 0)
            return rv
        }
        /// Enables or disables rubber banding in `tree_view`.  If the selection mode
        /// is `GTK_SELECTION_MULTIPLE`, rubber banding will allow the user to select
        /// multiple rows by dragging the mouse.
        nonmutating set {
            gtk_tree_view_set_rubber_banding(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the setting set by `gtk_tree_view_set_rules_hint()`.
    ///
    /// **get_rules_hint is deprecated:**
    /// This method is deprecated.
    @inlinable var rulesHint: Bool {
        /// Gets the setting set by `gtk_tree_view_set_rules_hint()`.
        ///
        /// **get_rules_hint is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    get {
            let rv = ((gtk_tree_view_get_rules_hint(tree_view_ptr)) != 0)
            return rv
        }
        /// Sets a hint for the theme to draw even/odd rows in the `tree_view`
        /// with different colors, also known as "zebra striping".
        /// 
        /// This function tells the GTK+ theme that the user interface for your
        /// application requires users to read across tree rows and associate
        /// cells with one another.
        /// 
        /// Do not use it just because you prefer the appearance of the ruled
        /// tree; that’s a question for the theme. Some themes will draw tree
        /// rows in alternating colors even when rules are turned off, and
        /// users who prefer that appearance all the time can choose those
        /// themes. You should call this function only as a semantic hint to
        /// the theme engine that your tree makes alternating colors useful
        /// from a functional standpoint (since it has lots of columns,
        /// generally).
        ///
        /// **set_rules_hint is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    nonmutating set {
            gtk_tree_view_set_rules_hint(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the column searched on by the interactive search code.
    @inlinable var searchColumn: Int {
        /// Gets the column searched on by the interactive search code.
        get {
            let rv = Int(gtk_tree_view_get_search_column(tree_view_ptr))
            return rv
        }
        /// Sets `column` as the column where the interactive search code should
        /// search in for the current model.
        /// 
        /// If the search column is set, users can use the “start-interactive-search”
        /// key binding to bring up search popup. The enable-search property controls
        /// whether simply typing text will also start an interactive search.
        /// 
        /// Note that `column` refers to a column of the current model. The search
        /// column is reset to -1 when the model is changed.
        nonmutating set {
            gtk_tree_view_set_search_column(tree_view_ptr, gint(newValue))
        }
    }

    /// Returns the `GtkEntry` which is currently in use as interactive search
    /// entry for `tree_view`.  In case the built-in entry is being used, `nil`
    /// will be returned.
    @inlinable var searchEntry: EntryRef! {
        /// Returns the `GtkEntry` which is currently in use as interactive search
        /// entry for `tree_view`.  In case the built-in entry is being used, `nil`
        /// will be returned.
        get {
            let rv = EntryRef(gconstpointer: gconstpointer(gtk_tree_view_get_search_entry(tree_view_ptr)))
            return rv
        }
        /// Sets the entry which the interactive search code will use for this
        /// `tree_view`.  This is useful when you want to provide a search entry
        /// in our interface at all time at a fixed position.  Passing `nil` for
        /// `entry` will make the interactive search code use the built-in popup
        /// entry again.
        nonmutating set {
            gtk_tree_view_set_search_entry(tree_view_ptr, UnsafeMutablePointer<GtkEntry>(newValue?.entry_ptr))
        }
    }

    /// Returns the compare function currently in use.
    @inlinable var searchEqualFunc: GtkTreeViewSearchEqualFunc! {
        /// Returns the compare function currently in use.
        get {
            let rv = gtk_tree_view_get_search_equal_func(tree_view_ptr)
            return rv
        }
    }

    /// Returns the positioning function currently in use.
    @inlinable var searchPositionFunc: GtkTreeViewSearchPositionFunc! {
        /// Returns the positioning function currently in use.
        get {
            let rv = gtk_tree_view_get_search_position_func(tree_view_ptr)
            return rv
        }
    }

    /// Gets the `GtkTreeSelection` associated with `tree_view`.
    @inlinable var selection: TreeSelectionRef! {
        /// Gets the `GtkTreeSelection` associated with `tree_view`.
        get {
            let rv = TreeSelectionRef(gconstpointer: gconstpointer(gtk_tree_view_get_selection(tree_view_ptr)))
            return rv
        }
    }

    /// Returns whether or not expanders are drawn in `tree_view`.
    @inlinable var showExpanders: Bool {
        /// Returns whether or not expanders are drawn in `tree_view`.
        get {
            let rv = ((gtk_tree_view_get_show_expanders(tree_view_ptr)) != 0)
            return rv
        }
        /// Sets whether to draw and enable expanders and indent child rows in
        /// `tree_view`.  When disabled there will be no expanders visible in trees
        /// and there will be no way to expand and collapse rows by default.  Also
        /// note that hiding the expanders will disable the default indentation.  You
        /// can set a custom indentation in this case using
        /// `gtk_tree_view_set_level_indentation()`.
        /// This does not have any visible effects for lists.
        nonmutating set {
            gtk_tree_view_set_show_expanders(tree_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the column of `tree_view`’s model which is being used for
    /// displaying tooltips on `tree_view`’s rows.
    @inlinable var tooltipColumn: Int {
        /// Returns the column of `tree_view`’s model which is being used for
        /// displaying tooltips on `tree_view`’s rows.
        get {
            let rv = Int(gtk_tree_view_get_tooltip_column(tree_view_ptr))
            return rv
        }
        /// If you only plan to have simple (text-only) tooltips on full rows, you
        /// can use this function to have `GtkTreeView` handle these automatically
        /// for you. `column` should be set to the column in `tree_view`’s model
        /// containing the tooltip texts, or -1 to disable this feature.
        /// 
        /// When enabled, `GtkWidget:has-tooltip` will be set to `true` and
        /// `tree_view` will connect a `GtkWidget::query-tooltip` signal handler.
        /// 
        /// Note that the signal handler sets the text with `gtk_tooltip_set_markup()`,
        /// so &, &lt;, etc have to be escaped in the text.
        nonmutating set {
            gtk_tree_view_set_tooltip_column(tree_view_ptr, gint(newValue))
        }
    }

    /// Gets the `GtkAdjustment` currently being used for the vertical aspect.
    ///
    /// **get_vadjustment is deprecated:**
    /// Use gtk_scrollable_get_vadjustment()
    @inlinable var vadjustment: AdjustmentRef! {
        /// Gets the `GtkAdjustment` currently being used for the vertical aspect.
        ///
        /// **get_vadjustment is deprecated:**
        /// Use gtk_scrollable_get_vadjustment()
        @available(*, deprecated)
    get {
            let rv = AdjustmentRef(gconstpointer: gconstpointer(gtk_tree_view_get_vadjustment(tree_view_ptr)))
            return rv
        }
        /// Sets the `GtkAdjustment` for the current vertical aspect.
        ///
        /// **set_vadjustment is deprecated:**
        /// Use gtk_scrollable_set_vadjustment()
        @available(*, deprecated)
    nonmutating set {
            gtk_tree_view_set_vadjustment(tree_view_ptr, UnsafeMutablePointer<GtkAdjustment>(newValue?.adjustment_ptr))
        }
    }

    @inlinable var parent: GtkContainer {
        get {
            let rv = tree_view_ptr.pointee.parent
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TreeViewAccessible Class


///
/// The `TreeViewAccessibleProtocol` protocol exposes the methods and properties of an underlying `GtkTreeViewAccessible` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeViewAccessible`.
/// Alternatively, use `TreeViewAccessibleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeViewAccessibleProtocol: ContainerAccessibleProtocol, Atk.SelectionProtocol, Atk.TableProtocol, CellAccessibleParentProtocol {
        /// Untyped pointer to the underlying `GtkTreeViewAccessible` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeViewAccessible` instance.
    var tree_view_accessible_ptr: UnsafeMutablePointer<GtkTreeViewAccessible>! { get }

    /// Required Initialiser for types conforming to `TreeViewAccessibleProtocol`
    init(raw: UnsafeMutableRawPointer)
}


///
/// The `TreeViewAccessibleRef` type acts as a lightweight Swift reference to an underlying `GtkTreeViewAccessible` instance.
/// It exposes methods that can operate on this data type through `TreeViewAccessibleProtocol` conformance.
/// Use `TreeViewAccessibleRef` only as an `unowned` reference to an existing `GtkTreeViewAccessible` instance.
///
public struct TreeViewAccessibleRef: TreeViewAccessibleProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeViewAccessible` instance.
    /// For type-safe access, use the generated, typed pointer `tree_view_accessible_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeViewAccessibleRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeViewAccessible>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeViewAccessible>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeViewAccessible>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeViewAccessible>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeViewAccessibleProtocol`
    @inlinable init<T: TreeViewAccessibleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeViewAccessibleProtocol>(_ other: T) -> TreeViewAccessibleRef { TreeViewAccessibleRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }


///
/// The `TreeViewAccessible` type acts as a reference-counted owner of an underlying `GtkTreeViewAccessible` instance.
/// It provides the methods that can operate on this data type through `TreeViewAccessibleProtocol` conformance.
/// Use `TreeViewAccessible` as a strong reference or owner of a `GtkTreeViewAccessible` instance.
///
open class TreeViewAccessible: ContainerAccessible, TreeViewAccessibleProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeViewAccessible>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeViewAccessible>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewAccessible` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeViewAccessible>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeViewAccessible>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeViewAccessible`.
    /// i.e., ownership is transferred to the `TreeViewAccessible` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeViewAccessible>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeViewAccessibleProtocol`
    /// Will retain `GtkTreeViewAccessible`.
    /// - Parameter other: an instance of a related type that implements `TreeViewAccessibleProtocol`
    @inlinable public init<T: TreeViewAccessibleProtocol>(treeViewAccessible other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewAccessibleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum TreeViewAccessiblePropertyName: String, PropertyNameProtocol {
    case accessibleComponentLayer = "accessible-component-layer"
    case accessibleComponentMdiZorder = "accessible-component-mdi-zorder"
    case accessibleDescription = "accessible-description"
    case accessibleHypertextNlinks = "accessible-hypertext-nlinks"
    case accessibleName = "accessible-name"
    case accessibleParent = "accessible-parent"
    case accessibleRole = "accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case accessibleTableCaption = "accessible-table-caption"
    case accessibleTableCaptionObject = "accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case accessibleTableColumnDescription = "accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case accessibleTableColumnHeader = "accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case accessibleTableRowDescription = "accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case accessibleTableRowHeader = "accessible-table-row-header"
    case accessibleTableSummary = "accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case accessibleValue = "accessible-value"
    case widget = "widget"
}

public extension TreeViewAccessibleProtocol {
    /// Bind a `TreeViewAccessiblePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeViewAccessiblePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeViewAccessible property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeViewAccessiblePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeViewAccessible property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeViewAccessiblePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeViewAccessibleSignalName: String, SignalNameProtocol {
    /// The "active-descendant-changed" signal is emitted by an object
    /// which has the state ATK_STATE_MANAGES_DESCENDANTS when the focus
    /// object in the object changes. For instance, a table will emit the
    /// signal when the cell in the table which has focus changes.
    case activeDescendantChanged = "active-descendant-changed"
    /// The signal "children-changed" is emitted when a child is added or
    /// removed form an object. It supports two details: "add" and
    /// "remove"
    case childrenChanged = "children-changed"
    /// The signal "focus-event" is emitted when an object gained or lost
    /// focus.
    ///
    /// **focus-event is deprecated:**
    /// Use the #AtkObject::state-change signal instead.
    case focusEvent = "focus-event"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The signal "property-change" is emitted when an object's property
    /// value changes. `arg1` contains an `AtkPropertyValues` with the name
    /// and the new value of the property whose value has changed. Note
    /// that, as with GObject notify, getting this signal does not
    /// guarantee that the value of the property has actually changed; it
    /// may also be emitted when the setter of the property is called to
    /// reinstate the previous value.
    /// 
    /// Toolkit implementor note: ATK implementors should use
    /// `g_object_notify()` to emit property-changed
    /// notifications. `AtkObject::property-changed` is needed by the
    /// implementation of `atk_add_global_event_listener()` because GObject
    /// notify doesn't support emission hooks.
    case propertyChange = "property-change"
    /// The "state-change" signal is emitted when an object's state
    /// changes.  The detail value identifies the state type which has
    /// changed.
    case stateChange = "state-change"
    /// The "visible-data-changed" signal is emitted when the visual
    /// appearance of the object changed.
    case visibleDataChanged = "visible-data-changed"
    case notifyAccessibleComponentLayer = "notify::accessible-component-layer"
    case notifyAccessibleComponentMdiZorder = "notify::accessible-component-mdi-zorder"
    case notifyAccessibleDescription = "notify::accessible-description"
    case notifyAccessibleHypertextNlinks = "notify::accessible-hypertext-nlinks"
    case notifyAccessibleName = "notify::accessible-name"
    case notifyAccessibleParent = "notify::accessible-parent"
    case notifyAccessibleRole = "notify::accessible-role"
    /// Table caption.
    ///
    /// **accessible-table-caption is deprecated:**
    /// Since 1.3. Use table-caption-object instead.
    case notifyAccessibleTableCaption = "notify::accessible-table-caption"
    case notifyAccessibleTableCaptionObject = "notify::accessible-table-caption-object"
    /// Accessible table column description.
    ///
    /// **accessible-table-column-description is deprecated:**
    /// Since 2.12. Use atk_table_get_column_description()
    /// and atk_table_set_column_description() instead.
    case notifyAccessibleTableColumnDescription = "notify::accessible-table-column-description"
    /// Accessible table column header.
    ///
    /// **accessible-table-column-header is deprecated:**
    /// Since 2.12. Use atk_table_get_column_header() and
    /// atk_table_set_column_header() instead.
    case notifyAccessibleTableColumnHeader = "notify::accessible-table-column-header"
    /// Accessible table row description.
    ///
    /// **accessible-table-row-description is deprecated:**
    /// Since 2.12. Use atk_table_get_row_description() and
    /// atk_table_set_row_description() instead.
    case notifyAccessibleTableRowDescription = "notify::accessible-table-row-description"
    /// Accessible table row header.
    ///
    /// **accessible-table-row-header is deprecated:**
    /// Since 2.12. Use atk_table_get_row_header() and
    /// atk_table_set_row_header() instead.
    case notifyAccessibleTableRowHeader = "notify::accessible-table-row-header"
    case notifyAccessibleTableSummary = "notify::accessible-table-summary"
    /// Numeric value of this object, in case being and AtkValue.
    ///
    /// **accessible-value is deprecated:**
    /// Since 2.12. Use atk_value_get_value_and_text() to get
    /// the value, and value-changed signal to be notified on their value
    /// changes.
    case notifyAccessibleValue = "notify::accessible-value"
    case notifyWidget = "notify::widget"
}

// MARK: TreeViewAccessible has no signals
// MARK: TreeViewAccessible Class: TreeViewAccessibleProtocol extension (methods and fields)
public extension TreeViewAccessibleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeViewAccessible` instance.
    @inlinable var tree_view_accessible_ptr: UnsafeMutablePointer<GtkTreeViewAccessible>! { return ptr?.assumingMemoryBound(to: GtkTreeViewAccessible.self) }


    @inlinable var parent: GtkContainerAccessible {
        get {
            let rv = tree_view_accessible_ptr.pointee.parent
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - TreeViewColumn Class

/// The GtkTreeViewColumn object represents a visible column in a `GtkTreeView` widget.
/// It allows to set properties of the column header, and functions as a holding pen for
/// the cell renderers which determine how the data in the column is displayed.
/// 
/// Please refer to the [tree widget conceptual overview](#TreeWidget)
/// for an overview of all the objects and data types related to the tree widget and how
/// they work together.
///
/// The `TreeViewColumnProtocol` protocol exposes the methods and properties of an underlying `GtkTreeViewColumn` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `TreeViewColumn`.
/// Alternatively, use `TreeViewColumnRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol TreeViewColumnProtocol: GLibObject.InitiallyUnownedProtocol, BuildableProtocol, CellLayoutProtocol {
        /// Untyped pointer to the underlying `GtkTreeViewColumn` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkTreeViewColumn` instance.
    var tree_view_column_ptr: UnsafeMutablePointer<GtkTreeViewColumn>! { get }

    /// Required Initialiser for types conforming to `TreeViewColumnProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The GtkTreeViewColumn object represents a visible column in a `GtkTreeView` widget.
/// It allows to set properties of the column header, and functions as a holding pen for
/// the cell renderers which determine how the data in the column is displayed.
/// 
/// Please refer to the [tree widget conceptual overview](#TreeWidget)
/// for an overview of all the objects and data types related to the tree widget and how
/// they work together.
///
/// The `TreeViewColumnRef` type acts as a lightweight Swift reference to an underlying `GtkTreeViewColumn` instance.
/// It exposes methods that can operate on this data type through `TreeViewColumnProtocol` conformance.
/// Use `TreeViewColumnRef` only as an `unowned` reference to an existing `GtkTreeViewColumn` instance.
///
public struct TreeViewColumnRef: TreeViewColumnProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkTreeViewColumn` instance.
    /// For type-safe access, use the generated, typed pointer `tree_view_column_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension TreeViewColumnRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkTreeViewColumn>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkTreeViewColumn>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkTreeViewColumn>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkTreeViewColumn>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `TreeViewColumnProtocol`
    @inlinable init<T: TreeViewColumnProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: TreeViewColumnProtocol>(_ other: T) -> TreeViewColumnRef { TreeViewColumnRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkTreeViewColumn`.
    @inlinable init() {
        let rv = gtk_tree_view_column_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkTreeViewColumn` using `area` to render its cells.
    @inlinable init<CellAreaT: CellAreaProtocol>(area: CellAreaT) {
        let rv = gtk_tree_view_column_new_with_area(area.cell_area_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }


    // *** newWithAttributes() is not available because it has a varargs (...) parameter!

    /// Creates a new `GtkTreeViewColumn` using `area` to render its cells.
    @inlinable static func newWith<CellAreaT: CellAreaProtocol>(area: CellAreaT) -> TreeViewColumnRef! {
        guard let rv = TreeViewColumnRef(gconstpointer: gconstpointer(gtk_tree_view_column_new_with_area(area.cell_area_ptr))) else { return nil }
        return rv
    }


    // *** newWithAttributes() is not available because it has a varargs (...) parameter!

}

/// The GtkTreeViewColumn object represents a visible column in a `GtkTreeView` widget.
/// It allows to set properties of the column header, and functions as a holding pen for
/// the cell renderers which determine how the data in the column is displayed.
/// 
/// Please refer to the [tree widget conceptual overview](#TreeWidget)
/// for an overview of all the objects and data types related to the tree widget and how
/// they work together.
///
/// The `TreeViewColumn` type acts as a reference-counted owner of an underlying `GtkTreeViewColumn` instance.
/// It provides the methods that can operate on this data type through `TreeViewColumnProtocol` conformance.
/// Use `TreeViewColumn` as a strong reference or owner of a `GtkTreeViewColumn` instance.
///
open class TreeViewColumn: GLibObject.InitiallyUnowned, TreeViewColumnProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkTreeViewColumn>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkTreeViewColumn>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkTreeViewColumn>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkTreeViewColumn>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkTreeViewColumn`.
    /// i.e., ownership is transferred to the `TreeViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkTreeViewColumn>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `TreeViewColumnProtocol`
    /// Will retain `GtkTreeViewColumn`.
    /// - Parameter other: an instance of a related type that implements `TreeViewColumnProtocol`
    @inlinable public init<T: TreeViewColumnProtocol>(treeViewColumn other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `TreeViewColumnProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkTreeViewColumn`.
    @inlinable public init() {
        let rv = gtk_tree_view_column_new()
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkTreeViewColumn` using `area` to render its cells.
    @inlinable public init<CellAreaT: CellAreaProtocol>(area: CellAreaT) {
        let rv = gtk_tree_view_column_new_with_area(area.cell_area_ptr)
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


    // *** newWithAttributes() is not available because it has a varargs (...) parameter!


    /// Creates a new `GtkTreeViewColumn` using `area` to render its cells.
    @inlinable public static func newWith<CellAreaT: CellAreaProtocol>(area: CellAreaT) -> TreeViewColumn! {
        guard let rv = TreeViewColumn(gconstpointer: gconstpointer(gtk_tree_view_column_new_with_area(area.cell_area_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }


    // *** newWithAttributes() is not available because it has a varargs (...) parameter!


}

public enum TreeViewColumnPropertyName: String, PropertyNameProtocol {
    case alignment = "alignment"
    /// The `GtkCellArea` used to layout cell renderers for this column.
    /// 
    /// If no area is specified when creating the tree view column with `gtk_tree_view_column_new_with_area()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    case cellArea = "cell-area"
    case clickable = "clickable"
    case expand = "expand"
    case fixedWidth = "fixed-width"
    case maxWidth = "max-width"
    case minWidth = "min-width"
    case reorderable = "reorderable"
    case resizable = "resizable"
    case sizing = "sizing"
    /// Logical sort column ID this column sorts on when selected for sorting. Setting the sort column ID makes the column header
    /// clickable. Set to -1 to make the column unsortable.
    case sortColumnID = "sort-column-id"
    case sortIndicator = "sort-indicator"
    case sortOrder = "sort-order"
    case spacing = "spacing"
    case title = "title"
    case visible = "visible"
    case widget = "widget"
    case width = "width"
    case xOffset = "x-offset"
}

public extension TreeViewColumnProtocol {
    /// Bind a `TreeViewColumnPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: TreeViewColumnPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a TreeViewColumn property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: TreeViewColumnPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a TreeViewColumn property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: TreeViewColumnPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum TreeViewColumnSignalName: String, SignalNameProtocol {
    case clicked = "clicked"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyAlignment = "notify::alignment"
    /// The `GtkCellArea` used to layout cell renderers for this column.
    /// 
    /// If no area is specified when creating the tree view column with `gtk_tree_view_column_new_with_area()`
    /// a horizontally oriented `GtkCellAreaBox` will be used.
    case notifyCellArea = "notify::cell-area"
    case notifyClickable = "notify::clickable"
    case notifyExpand = "notify::expand"
    case notifyFixedWidth = "notify::fixed-width"
    case notifyMaxWidth = "notify::max-width"
    case notifyMinWidth = "notify::min-width"
    case notifyReorderable = "notify::reorderable"
    case notifyResizable = "notify::resizable"
    case notifySizing = "notify::sizing"
    /// Logical sort column ID this column sorts on when selected for sorting. Setting the sort column ID makes the column header
    /// clickable. Set to -1 to make the column unsortable.
    case notifySortColumnID = "notify::sort-column-id"
    case notifySortIndicator = "notify::sort-indicator"
    case notifySortOrder = "notify::sort-order"
    case notifySpacing = "notify::spacing"
    case notifyTitle = "notify::title"
    case notifyVisible = "notify::visible"
    case notifyWidget = "notify::widget"
    case notifyWidth = "notify::width"
    case notifyXOffset = "notify::x-offset"
}

// MARK: TreeViewColumn signals
public extension TreeViewColumnProtocol {
    /// Connect a Swift signal handler to the given, typed `TreeViewColumnSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeViewColumnSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `TreeViewColumnSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: TreeViewColumnSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// - Note: This represents the underlying `clicked` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `clicked` signal is emitted
    @discardableResult @inlinable func onClicked(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<TreeViewColumnRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .clicked,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `clicked` signal for using the `connect(signal:)` methods
    static var clickedSignal: TreeViewColumnSignalName { .clicked }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::alignment` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAlignment` signal is emitted
    @discardableResult @inlinable func onNotifyAlignment(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAlignment,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::alignment` signal for using the `connect(signal:)` methods
    static var notifyAlignmentSignal: TreeViewColumnSignalName { .notifyAlignment }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::cell-area` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCellArea` signal is emitted
    @discardableResult @inlinable func onNotifyCellArea(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyCellArea,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::cell-area` signal for using the `connect(signal:)` methods
    static var notifyCellAreaSignal: TreeViewColumnSignalName { .notifyCellArea }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::clickable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyClickable` signal is emitted
    @discardableResult @inlinable func onNotifyClickable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyClickable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::clickable` signal for using the `connect(signal:)` methods
    static var notifyClickableSignal: TreeViewColumnSignalName { .notifyClickable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::expand` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyExpand` signal is emitted
    @discardableResult @inlinable func onNotifyExpand(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyExpand,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::expand` signal for using the `connect(signal:)` methods
    static var notifyExpandSignal: TreeViewColumnSignalName { .notifyExpand }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::fixed-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFixedWidth` signal is emitted
    @discardableResult @inlinable func onNotifyFixedWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFixedWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::fixed-width` signal for using the `connect(signal:)` methods
    static var notifyFixedWidthSignal: TreeViewColumnSignalName { .notifyFixedWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::max-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMaxWidth` signal is emitted
    @discardableResult @inlinable func onNotifyMaxWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMaxWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::max-width` signal for using the `connect(signal:)` methods
    static var notifyMaxWidthSignal: TreeViewColumnSignalName { .notifyMaxWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::min-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMinWidth` signal is emitted
    @discardableResult @inlinable func onNotifyMinWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMinWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::min-width` signal for using the `connect(signal:)` methods
    static var notifyMinWidthSignal: TreeViewColumnSignalName { .notifyMinWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::reorderable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyReorderable` signal is emitted
    @discardableResult @inlinable func onNotifyReorderable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyReorderable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::reorderable` signal for using the `connect(signal:)` methods
    static var notifyReorderableSignal: TreeViewColumnSignalName { .notifyReorderable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::resizable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyResizable` signal is emitted
    @discardableResult @inlinable func onNotifyResizable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyResizable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::resizable` signal for using the `connect(signal:)` methods
    static var notifyResizableSignal: TreeViewColumnSignalName { .notifyResizable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::sizing` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySizing` signal is emitted
    @discardableResult @inlinable func onNotifySizing(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySizing,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::sizing` signal for using the `connect(signal:)` methods
    static var notifySizingSignal: TreeViewColumnSignalName { .notifySizing }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::sort-column-id` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySortColumnID` signal is emitted
    @discardableResult @inlinable func onNotifySortColumnID(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySortColumnID,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::sort-column-id` signal for using the `connect(signal:)` methods
    static var notifySortColumnIDSignal: TreeViewColumnSignalName { .notifySortColumnID }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::sort-indicator` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySortIndicator` signal is emitted
    @discardableResult @inlinable func onNotifySortIndicator(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySortIndicator,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::sort-indicator` signal for using the `connect(signal:)` methods
    static var notifySortIndicatorSignal: TreeViewColumnSignalName { .notifySortIndicator }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::sort-order` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySortOrder` signal is emitted
    @discardableResult @inlinable func onNotifySortOrder(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySortOrder,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::sort-order` signal for using the `connect(signal:)` methods
    static var notifySortOrderSignal: TreeViewColumnSignalName { .notifySortOrder }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::spacing` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySpacing` signal is emitted
    @discardableResult @inlinable func onNotifySpacing(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySpacing,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::spacing` signal for using the `connect(signal:)` methods
    static var notifySpacingSignal: TreeViewColumnSignalName { .notifySpacing }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::title` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTitle` signal is emitted
    @discardableResult @inlinable func onNotifyTitle(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyTitle,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::title` signal for using the `connect(signal:)` methods
    static var notifyTitleSignal: TreeViewColumnSignalName { .notifyTitle }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::visible` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVisible` signal is emitted
    @discardableResult @inlinable func onNotifyVisible(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyVisible,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::visible` signal for using the `connect(signal:)` methods
    static var notifyVisibleSignal: TreeViewColumnSignalName { .notifyVisible }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::widget` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWidget` signal is emitted
    @discardableResult @inlinable func onNotifyWidget(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWidget,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::widget` signal for using the `connect(signal:)` methods
    static var notifyWidgetSignal: TreeViewColumnSignalName { .notifyWidget }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWidth` signal is emitted
    @discardableResult @inlinable func onNotifyWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::width` signal for using the `connect(signal:)` methods
    static var notifyWidthSignal: TreeViewColumnSignalName { .notifyWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::x-offset` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyXOffset` signal is emitted
    @discardableResult @inlinable func onNotifyXOffset(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: TreeViewColumnRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<TreeViewColumnRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(TreeViewColumnRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyXOffset,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::x-offset` signal for using the `connect(signal:)` methods
    static var notifyXOffsetSignal: TreeViewColumnSignalName { .notifyXOffset }
    
}

// MARK: TreeViewColumn Class: TreeViewColumnProtocol extension (methods and fields)
public extension TreeViewColumnProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkTreeViewColumn` instance.
    @inlinable var tree_view_column_ptr: UnsafeMutablePointer<GtkTreeViewColumn>! { return ptr?.assumingMemoryBound(to: GtkTreeViewColumn.self) }

    /// Adds an attribute mapping to the list in `tree_column`.  The `column` is the
    /// column of the model to get a value from, and the `attribute` is the
    /// parameter on `cell_renderer` to be set from the value. So for example
    /// if column 2 of the model contains strings, you could have the
    /// “text” attribute of a `GtkCellRendererText` get its values from
    /// column 2.
    @inlinable func addAttribute<CellRendererT: CellRendererProtocol>(cellRenderer: CellRendererT, attribute: UnsafePointer<gchar>!, column: Int) {
        gtk_tree_view_column_add_attribute(tree_view_column_ptr, cellRenderer.cell_renderer_ptr, attribute, gint(column))
    
    }

    /// Obtains the horizontal position and size of a cell in a column. If the
    /// cell is not found in the column, `start_pos` and `width` are not changed and
    /// `false` is returned.
    @inlinable func cellGetPosition<CellRendererT: CellRendererProtocol>(cellRenderer: CellRendererT, xOffset: UnsafeMutablePointer<gint>! = nil, width: UnsafeMutablePointer<gint>! = nil) -> Bool {
        let rv = ((gtk_tree_view_column_cell_get_position(tree_view_column_ptr, cellRenderer.cell_renderer_ptr, xOffset, width)) != 0)
        return rv
    }

    /// Obtains the width and height needed to render the column.  This is used
    /// primarily by the `GtkTreeView`.
    @inlinable func cellGetSize(cellArea: Gdk.RectangleRef? = nil, xOffset: UnsafeMutablePointer<gint>! = nil, yOffset: UnsafeMutablePointer<gint>! = nil, width: UnsafeMutablePointer<gint>! = nil, height: UnsafeMutablePointer<gint>! = nil) {
        gtk_tree_view_column_cell_get_size(tree_view_column_ptr, cellArea?.rectangle_ptr, xOffset, yOffset, width, height)
    
    }
    /// Obtains the width and height needed to render the column.  This is used
    /// primarily by the `GtkTreeView`.
    @inlinable func cellGetSize<RectangleT: Gdk.RectangleProtocol>(cellArea: RectangleT?, xOffset: UnsafeMutablePointer<gint>! = nil, yOffset: UnsafeMutablePointer<gint>! = nil, width: UnsafeMutablePointer<gint>! = nil, height: UnsafeMutablePointer<gint>! = nil) {
        gtk_tree_view_column_cell_get_size(tree_view_column_ptr, cellArea?.rectangle_ptr, xOffset, yOffset, width, height)
    
    }

    /// Returns `true` if any of the cells packed into the `tree_column` are visible.
    /// For this to be meaningful, you must first initialize the cells with
    /// `gtk_tree_view_column_cell_set_cell_data()`
    @inlinable func cellIsVisible() -> Bool {
        let rv = ((gtk_tree_view_column_cell_is_visible(tree_view_column_ptr)) != 0)
        return rv
    }

    /// Sets the cell renderer based on the `tree_model` and `iter`.  That is, for
    /// every attribute mapping in `tree_column`, it will get a value from the set
    /// column on the `iter`, and use that value to set the attribute on the cell
    /// renderer.  This is used primarily by the `GtkTreeView`.
    @inlinable func cellSetCellData<TreeIterT: TreeIterProtocol, TreeModelT: TreeModelProtocol>(treeModel: TreeModelT, iter: TreeIterT, isExpander: Bool, isExpanded: Bool) {
        gtk_tree_view_column_cell_set_cell_data(tree_view_column_ptr, treeModel.tree_model_ptr, iter.tree_iter_ptr, gboolean((isExpander) ? 1 : 0), gboolean((isExpanded) ? 1 : 0))
    
    }

    /// Unsets all the mappings on all renderers on the `tree_column`.
    @inlinable func clear() {
        gtk_tree_view_column_clear(tree_view_column_ptr)
    
    }

    /// Clears all existing attributes previously set with
    /// `gtk_tree_view_column_set_attributes()`.
    @inlinable func clearAttributes<CellRendererT: CellRendererProtocol>(cellRenderer: CellRendererT) {
        gtk_tree_view_column_clear_attributes(tree_view_column_ptr, cellRenderer.cell_renderer_ptr)
    
    }

    /// Emits the “clicked” signal on the column.  This function will only work if
    /// `tree_column` is clickable.
    @inlinable func clicked() {
        gtk_tree_view_column_clicked(tree_view_column_ptr)
    
    }

    /// Sets the current keyboard focus to be at `cell`, if the column contains
    /// 2 or more editable and activatable cells.
    @inlinable func focus<CellRendererT: CellRendererProtocol>(cell: CellRendererT) {
        gtk_tree_view_column_focus_cell(tree_view_column_ptr, cell.cell_renderer_ptr)
    
    }

    /// Returns the current x alignment of `tree_column`.  This value can range
    /// between 0.0 and 1.0.
    @inlinable func getAlignment() -> Double {
        let rv = Double(gtk_tree_view_column_get_alignment(tree_view_column_ptr))
        return rv
    }

    /// Returns the button used in the treeview column header
    @inlinable func getButton() -> WidgetRef! {
        let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tree_view_column_get_button(tree_view_column_ptr)))
        return rv
    }

    /// Returns `true` if the user can click on the header for the column.
    @inlinable func getClickable() -> Bool {
        let rv = ((gtk_tree_view_column_get_clickable(tree_view_column_ptr)) != 0)
        return rv
    }

    /// Returns `true` if the column expands to fill available space.
    @inlinable func getExpand() -> Bool {
        let rv = ((gtk_tree_view_column_get_expand(tree_view_column_ptr)) != 0)
        return rv
    }

    /// Gets the fixed width of the column.  This may not be the actual displayed
    /// width of the column; for that, use `gtk_tree_view_column_get_width()`.
    @inlinable func getFixedWidth() -> Int {
        let rv = Int(gtk_tree_view_column_get_fixed_width(tree_view_column_ptr))
        return rv
    }

    /// Returns the maximum width in pixels of the `tree_column`, or -1 if no maximum
    /// width is set.
    @inlinable func getMaxWidth() -> Int {
        let rv = Int(gtk_tree_view_column_get_max_width(tree_view_column_ptr))
        return rv
    }

    /// Returns the minimum width in pixels of the `tree_column`, or -1 if no minimum
    /// width is set.
    @inlinable func getMinWidth() -> Int {
        let rv = Int(gtk_tree_view_column_get_min_width(tree_view_column_ptr))
        return rv
    }

    /// Returns `true` if the `tree_column` can be reordered by the user.
    @inlinable func getReorderable() -> Bool {
        let rv = ((gtk_tree_view_column_get_reorderable(tree_view_column_ptr)) != 0)
        return rv
    }

    /// Returns `true` if the `tree_column` can be resized by the end user.
    @inlinable func getResizable() -> Bool {
        let rv = ((gtk_tree_view_column_get_resizable(tree_view_column_ptr)) != 0)
        return rv
    }

    /// Returns the current type of `tree_column`.
    @inlinable func getSizing() -> GtkTreeViewColumnSizing {
        let rv = gtk_tree_view_column_get_sizing(tree_view_column_ptr)
        return rv
    }

    /// Gets the logical `sort_column_id` that the model sorts on when this
    /// column is selected for sorting.
    /// See `gtk_tree_view_column_set_sort_column_id()`.
    @inlinable func getSortColumnID() -> Int {
        let rv = Int(gtk_tree_view_column_get_sort_column_id(tree_view_column_ptr))
        return rv
    }

    /// Gets the value set by `gtk_tree_view_column_set_sort_indicator()`.
    @inlinable func getSortIndicator() -> Bool {
        let rv = ((gtk_tree_view_column_get_sort_indicator(tree_view_column_ptr)) != 0)
        return rv
    }

    /// Gets the value set by `gtk_tree_view_column_set_sort_order()`.
    @inlinable func getSortOrder() -> GtkSortType {
        let rv = gtk_tree_view_column_get_sort_order(tree_view_column_ptr)
        return rv
    }

    /// Returns the spacing of `tree_column`.
    @inlinable func getSpacing() -> Int {
        let rv = Int(gtk_tree_view_column_get_spacing(tree_view_column_ptr))
        return rv
    }

    /// Returns the title of the widget.
    @inlinable func getTitle() -> String! {
        let rv = gtk_tree_view_column_get_title(tree_view_column_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns the `GtkTreeView` wherein `tree_column` has been inserted.
    /// If `column` is currently not inserted in any tree view, `nil` is
    /// returned.
    @inlinable func getTreeView() -> WidgetRef! {
        let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tree_view_column_get_tree_view(tree_view_column_ptr)))
        return rv
    }

    /// Returns `true` if `tree_column` is visible.
    @inlinable func getVisible() -> Bool {
        let rv = ((gtk_tree_view_column_get_visible(tree_view_column_ptr)) != 0)
        return rv
    }

    /// Returns the `GtkWidget` in the button on the column header.
    /// If a custom widget has not been set then `nil` is returned.
    @inlinable func getWidget() -> WidgetRef! {
        let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tree_view_column_get_widget(tree_view_column_ptr)))
        return rv
    }

    /// Returns the current size of `tree_column` in pixels.
    @inlinable func getWidth() -> Int {
        let rv = Int(gtk_tree_view_column_get_width(tree_view_column_ptr))
        return rv
    }

    /// Returns the current X offset of `tree_column` in pixels.
    @inlinable func getXOffset() -> Int {
        let rv = Int(gtk_tree_view_column_get_x_offset(tree_view_column_ptr))
        return rv
    }

    /// Adds the `cell` to end of the column. If `expand` is `false`, then the `cell`
    /// is allocated no more space than it needs. Any unused space is divided
    /// evenly between cells for which `expand` is `true`.
    @inlinable func packEnd<CellRendererT: CellRendererProtocol>(cell: CellRendererT, expand: Bool) {
        gtk_tree_view_column_pack_end(tree_view_column_ptr, cell.cell_renderer_ptr, gboolean((expand) ? 1 : 0))
    
    }

    /// Packs the `cell` into the beginning of the column. If `expand` is `false`, then
    /// the `cell` is allocated no more space than it needs. Any unused space is divided
    /// evenly between cells for which `expand` is `true`.
    @inlinable func packStart<CellRendererT: CellRendererProtocol>(cell: CellRendererT, expand: Bool) {
        gtk_tree_view_column_pack_start(tree_view_column_ptr, cell.cell_renderer_ptr, gboolean((expand) ? 1 : 0))
    
    }

    /// Flags the column, and the cell renderers added to this column, to have
    /// their sizes renegotiated.
    @inlinable func queueResize() {
        gtk_tree_view_column_queue_resize(tree_view_column_ptr)
    
    }

    /// Sets the alignment of the title or custom widget inside the column header.
    /// The alignment determines its location inside the button -- 0.0 for left, 0.5
    /// for center, 1.0 for right.
    @inlinable func setAlignment(xalign: Double) {
        gtk_tree_view_column_set_alignment(tree_view_column_ptr, gfloat(xalign))
    
    }


    // *** setAttributes() is not available because it has a varargs (...) parameter!


    /// Sets the `GtkTreeCellDataFunc` to use for the column.  This
    /// function is used instead of the standard attributes mapping for
    /// setting the column value, and should set the value of `tree_column`'s
    /// cell renderer as appropriate.  `func` may be `nil` to remove an
    /// older one.
    @inlinable func setCellDataFunc<CellRendererT: CellRendererProtocol>(cellRenderer: CellRendererT, `func`: GtkTreeCellDataFunc? = nil, funcData: gpointer! = nil, destroy: GDestroyNotify?) {
        gtk_tree_view_column_set_cell_data_func(tree_view_column_ptr, cellRenderer.cell_renderer_ptr, `func`, funcData, destroy)
    
    }

    /// Sets the header to be active if `clickable` is `true`.  When the header is
    /// active, then it can take keyboard focus, and can be clicked.
    @inlinable func set(clickable: Bool) {
        gtk_tree_view_column_set_clickable(tree_view_column_ptr, gboolean((clickable) ? 1 : 0))
    
    }

    /// Sets the column to take available extra space.  This space is shared equally
    /// amongst all columns that have the expand set to `true`.  If no column has this
    /// option set, then the last column gets all extra space.  By default, every
    /// column is created with this `false`.
    /// 
    /// Along with “fixed-width”, the “expand” property changes when the column is
    /// resized by the user.
    @inlinable func set(expand: Bool) {
        gtk_tree_view_column_set_expand(tree_view_column_ptr, gboolean((expand) ? 1 : 0))
    
    }

    /// If `fixed_width` is not -1, sets the fixed width of `tree_column`; otherwise
    /// unsets it.  The effective value of `fixed_width` is clamped between the
    /// minimum and maximum width of the column; however, the value stored in the
    /// “fixed-width” property is not clamped.  If the column sizing is
    /// `GTK_TREE_VIEW_COLUMN_GROW_ONLY` or `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, setting
    /// a fixed width overrides the automatically calculated width.  Note that
    /// `fixed_width` is only a hint to GTK+; the width actually allocated to the
    /// column may be greater or less than requested.
    /// 
    /// Along with “expand”, the “fixed-width” property changes when the column is
    /// resized by the user.
    @inlinable func set(fixedWidth: Int) {
        gtk_tree_view_column_set_fixed_width(tree_view_column_ptr, gint(fixedWidth))
    
    }

    /// Sets the maximum width of the `tree_column`.  If `max_width` is -1, then the
    /// maximum width is unset.  Note, the column can actually be wider than max
    /// width if it’s the last column in a view.  In this case, the column expands to
    /// fill any extra space.
    @inlinable func set(maxWidth: Int) {
        gtk_tree_view_column_set_max_width(tree_view_column_ptr, gint(maxWidth))
    
    }

    /// Sets the minimum width of the `tree_column`.  If `min_width` is -1, then the
    /// minimum width is unset.
    @inlinable func set(minWidth: Int) {
        gtk_tree_view_column_set_min_width(tree_view_column_ptr, gint(minWidth))
    
    }

    /// If `reorderable` is `true`, then the column can be reordered by the end user
    /// dragging the header.
    @inlinable func set(reorderable: Bool) {
        gtk_tree_view_column_set_reorderable(tree_view_column_ptr, gboolean((reorderable) ? 1 : 0))
    
    }

    /// If `resizable` is `true`, then the user can explicitly resize the column by
    /// grabbing the outer edge of the column button.  If resizable is `true` and
    /// sizing mode of the column is `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, then the sizing
    /// mode is changed to `GTK_TREE_VIEW_COLUMN_GROW_ONLY`.
    @inlinable func set(resizable: Bool) {
        gtk_tree_view_column_set_resizable(tree_view_column_ptr, gboolean((resizable) ? 1 : 0))
    
    }

    /// Sets the growth behavior of `tree_column` to `type`.
    @inlinable func setSizing(type: GtkTreeViewColumnSizing) {
        gtk_tree_view_column_set_sizing(tree_view_column_ptr, type)
    
    }

    /// Sets the logical `sort_column_id` that this column sorts on when this column
    /// is selected for sorting.  Doing so makes the column header clickable.
    @inlinable func set(sortColumnID: Int) {
        gtk_tree_view_column_set_sort_column_id(tree_view_column_ptr, gint(sortColumnID))
    
    }

    /// Call this function with a `setting` of `true` to display an arrow in
    /// the header button indicating the column is sorted. Call
    /// `gtk_tree_view_column_set_sort_order()` to change the direction of
    /// the arrow.
    @inlinable func setSortIndicator(setting: Bool) {
        gtk_tree_view_column_set_sort_indicator(tree_view_column_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Changes the appearance of the sort indicator.
    /// 
    /// This does not actually sort the model.  Use
    /// `gtk_tree_view_column_set_sort_column_id()` if you want automatic sorting
    /// support.  This function is primarily for custom sorting behavior, and should
    /// be used in conjunction with `gtk_tree_sortable_set_sort_column_id()` to do
    /// that. For custom models, the mechanism will vary.
    /// 
    /// The sort indicator changes direction to indicate normal sort or reverse sort.
    /// Note that you must have the sort indicator enabled to see anything when
    /// calling this function; see `gtk_tree_view_column_set_sort_indicator()`.
    @inlinable func setSort(order: GtkSortType) {
        gtk_tree_view_column_set_sort_order(tree_view_column_ptr, order)
    
    }

    /// Sets the spacing field of `tree_column`, which is the number of pixels to
    /// place between cell renderers packed into it.
    @inlinable func set(spacing: Int) {
        gtk_tree_view_column_set_spacing(tree_view_column_ptr, gint(spacing))
    
    }

    /// Sets the title of the `tree_column`.  If a custom widget has been set, then
    /// this value is ignored.
    @inlinable func set(title: UnsafePointer<gchar>!) {
        gtk_tree_view_column_set_title(tree_view_column_ptr, title)
    
    }

    /// Sets the visibility of `tree_column`.
    @inlinable func set(visible: Bool) {
        gtk_tree_view_column_set_visible(tree_view_column_ptr, gboolean((visible) ? 1 : 0))
    
    }

    /// Sets the widget in the header to be `widget`.  If widget is `nil`, then the
    /// header button is set with a `GtkLabel` set to the title of `tree_column`.
    @inlinable func set(widget: WidgetRef? = nil) {
        gtk_tree_view_column_set_widget(tree_view_column_ptr, widget?.widget_ptr)
    
    }
    /// Sets the widget in the header to be `widget`.  If widget is `nil`, then the
    /// header button is set with a `GtkLabel` set to the title of `tree_column`.
    @inlinable func set<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        gtk_tree_view_column_set_widget(tree_view_column_ptr, widget?.widget_ptr)
    
    }
    @inlinable var alignment: Double {
        /// Returns the current x alignment of `tree_column`.  This value can range
        /// between 0.0 and 1.0.
        get {
            let rv = Double(gtk_tree_view_column_get_alignment(tree_view_column_ptr))
            return rv
        }
        /// Sets the alignment of the title or custom widget inside the column header.
        /// The alignment determines its location inside the button -- 0.0 for left, 0.5
        /// for center, 1.0 for right.
        nonmutating set {
            gtk_tree_view_column_set_alignment(tree_view_column_ptr, gfloat(newValue))
        }
    }

    /// Returns the button used in the treeview column header
    @inlinable var button: WidgetRef! {
        /// Returns the button used in the treeview column header
        get {
            let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tree_view_column_get_button(tree_view_column_ptr)))
            return rv
        }
    }

    @inlinable var clickable: Bool {
        /// Returns `true` if the user can click on the header for the column.
        get {
            let rv = ((gtk_tree_view_column_get_clickable(tree_view_column_ptr)) != 0)
            return rv
        }
        /// Sets the header to be active if `clickable` is `true`.  When the header is
        /// active, then it can take keyboard focus, and can be clicked.
        nonmutating set {
            gtk_tree_view_column_set_clickable(tree_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var expand: Bool {
        /// Returns `true` if the column expands to fill available space.
        get {
            let rv = ((gtk_tree_view_column_get_expand(tree_view_column_ptr)) != 0)
            return rv
        }
        /// Sets the column to take available extra space.  This space is shared equally
        /// amongst all columns that have the expand set to `true`.  If no column has this
        /// option set, then the last column gets all extra space.  By default, every
        /// column is created with this `false`.
        /// 
        /// Along with “fixed-width”, the “expand” property changes when the column is
        /// resized by the user.
        nonmutating set {
            gtk_tree_view_column_set_expand(tree_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the fixed width of the column.  This may not be the actual displayed
    /// width of the column; for that, use `gtk_tree_view_column_get_width()`.
    @inlinable var fixedWidth: Int {
        /// Gets the fixed width of the column.  This may not be the actual displayed
        /// width of the column; for that, use `gtk_tree_view_column_get_width()`.
        get {
            let rv = Int(gtk_tree_view_column_get_fixed_width(tree_view_column_ptr))
            return rv
        }
        /// If `fixed_width` is not -1, sets the fixed width of `tree_column`; otherwise
        /// unsets it.  The effective value of `fixed_width` is clamped between the
        /// minimum and maximum width of the column; however, the value stored in the
        /// “fixed-width” property is not clamped.  If the column sizing is
        /// `GTK_TREE_VIEW_COLUMN_GROW_ONLY` or `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, setting
        /// a fixed width overrides the automatically calculated width.  Note that
        /// `fixed_width` is only a hint to GTK+; the width actually allocated to the
        /// column may be greater or less than requested.
        /// 
        /// Along with “expand”, the “fixed-width” property changes when the column is
        /// resized by the user.
        nonmutating set {
            gtk_tree_view_column_set_fixed_width(tree_view_column_ptr, gint(newValue))
        }
    }

    /// Returns the maximum width in pixels of the `tree_column`, or -1 if no maximum
    /// width is set.
    @inlinable var maxWidth: Int {
        /// Returns the maximum width in pixels of the `tree_column`, or -1 if no maximum
        /// width is set.
        get {
            let rv = Int(gtk_tree_view_column_get_max_width(tree_view_column_ptr))
            return rv
        }
        /// Sets the maximum width of the `tree_column`.  If `max_width` is -1, then the
        /// maximum width is unset.  Note, the column can actually be wider than max
        /// width if it’s the last column in a view.  In this case, the column expands to
        /// fill any extra space.
        nonmutating set {
            gtk_tree_view_column_set_max_width(tree_view_column_ptr, gint(newValue))
        }
    }

    /// Returns the minimum width in pixels of the `tree_column`, or -1 if no minimum
    /// width is set.
    @inlinable var minWidth: Int {
        /// Returns the minimum width in pixels of the `tree_column`, or -1 if no minimum
        /// width is set.
        get {
            let rv = Int(gtk_tree_view_column_get_min_width(tree_view_column_ptr))
            return rv
        }
        /// Sets the minimum width of the `tree_column`.  If `min_width` is -1, then the
        /// minimum width is unset.
        nonmutating set {
            gtk_tree_view_column_set_min_width(tree_view_column_ptr, gint(newValue))
        }
    }

    @inlinable var reorderable: Bool {
        /// Returns `true` if the `tree_column` can be reordered by the user.
        get {
            let rv = ((gtk_tree_view_column_get_reorderable(tree_view_column_ptr)) != 0)
            return rv
        }
        /// If `reorderable` is `true`, then the column can be reordered by the end user
        /// dragging the header.
        nonmutating set {
            gtk_tree_view_column_set_reorderable(tree_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var resizable: Bool {
        /// Returns `true` if the `tree_column` can be resized by the end user.
        get {
            let rv = ((gtk_tree_view_column_get_resizable(tree_view_column_ptr)) != 0)
            return rv
        }
        /// If `resizable` is `true`, then the user can explicitly resize the column by
        /// grabbing the outer edge of the column button.  If resizable is `true` and
        /// sizing mode of the column is `GTK_TREE_VIEW_COLUMN_AUTOSIZE`, then the sizing
        /// mode is changed to `GTK_TREE_VIEW_COLUMN_GROW_ONLY`.
        nonmutating set {
            gtk_tree_view_column_set_resizable(tree_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var sizing: GtkTreeViewColumnSizing {
        /// Returns the current type of `tree_column`.
        get {
            let rv = gtk_tree_view_column_get_sizing(tree_view_column_ptr)
            return rv
        }
        /// Sets the growth behavior of `tree_column` to `type`.
        nonmutating set {
            gtk_tree_view_column_set_sizing(tree_view_column_ptr, newValue)
        }
    }

    /// Gets the logical `sort_column_id` that the model sorts on when this
    /// column is selected for sorting.
    /// See `gtk_tree_view_column_set_sort_column_id()`.
    @inlinable var sortColumnID: Int {
        /// Gets the logical `sort_column_id` that the model sorts on when this
        /// column is selected for sorting.
        /// See `gtk_tree_view_column_set_sort_column_id()`.
        get {
            let rv = Int(gtk_tree_view_column_get_sort_column_id(tree_view_column_ptr))
            return rv
        }
        /// Sets the logical `sort_column_id` that this column sorts on when this column
        /// is selected for sorting.  Doing so makes the column header clickable.
        nonmutating set {
            gtk_tree_view_column_set_sort_column_id(tree_view_column_ptr, gint(newValue))
        }
    }

    /// Gets the value set by `gtk_tree_view_column_set_sort_indicator()`.
    @inlinable var sortIndicator: Bool {
        /// Gets the value set by `gtk_tree_view_column_set_sort_indicator()`.
        get {
            let rv = ((gtk_tree_view_column_get_sort_indicator(tree_view_column_ptr)) != 0)
            return rv
        }
        /// Call this function with a `setting` of `true` to display an arrow in
        /// the header button indicating the column is sorted. Call
        /// `gtk_tree_view_column_set_sort_order()` to change the direction of
        /// the arrow.
        nonmutating set {
            gtk_tree_view_column_set_sort_indicator(tree_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets the value set by `gtk_tree_view_column_set_sort_order()`.
    @inlinable var sortOrder: GtkSortType {
        /// Gets the value set by `gtk_tree_view_column_set_sort_order()`.
        get {
            let rv = gtk_tree_view_column_get_sort_order(tree_view_column_ptr)
            return rv
        }
        /// Changes the appearance of the sort indicator.
        /// 
        /// This does not actually sort the model.  Use
        /// `gtk_tree_view_column_set_sort_column_id()` if you want automatic sorting
        /// support.  This function is primarily for custom sorting behavior, and should
        /// be used in conjunction with `gtk_tree_sortable_set_sort_column_id()` to do
        /// that. For custom models, the mechanism will vary.
        /// 
        /// The sort indicator changes direction to indicate normal sort or reverse sort.
        /// Note that you must have the sort indicator enabled to see anything when
        /// calling this function; see `gtk_tree_view_column_set_sort_indicator()`.
        nonmutating set {
            gtk_tree_view_column_set_sort_order(tree_view_column_ptr, newValue)
        }
    }

    @inlinable var spacing: Int {
        /// Returns the spacing of `tree_column`.
        get {
            let rv = Int(gtk_tree_view_column_get_spacing(tree_view_column_ptr))
            return rv
        }
        /// Sets the spacing field of `tree_column`, which is the number of pixels to
        /// place between cell renderers packed into it.
        nonmutating set {
            gtk_tree_view_column_set_spacing(tree_view_column_ptr, gint(newValue))
        }
    }

    @inlinable var title: String! {
        /// Returns the title of the widget.
        get {
            let rv = gtk_tree_view_column_get_title(tree_view_column_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the title of the `tree_column`.  If a custom widget has been set, then
        /// this value is ignored.
        nonmutating set {
            gtk_tree_view_column_set_title(tree_view_column_ptr, newValue)
        }
    }

    /// Returns the `GtkTreeView` wherein `tree_column` has been inserted.
    /// If `column` is currently not inserted in any tree view, `nil` is
    /// returned.
    @inlinable var treeView: WidgetRef! {
        /// Returns the `GtkTreeView` wherein `tree_column` has been inserted.
        /// If `column` is currently not inserted in any tree view, `nil` is
        /// returned.
        get {
            let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tree_view_column_get_tree_view(tree_view_column_ptr)))
            return rv
        }
    }

    @inlinable var visible: Bool {
        /// Returns `true` if `tree_column` is visible.
        get {
            let rv = ((gtk_tree_view_column_get_visible(tree_view_column_ptr)) != 0)
            return rv
        }
        /// Sets the visibility of `tree_column`.
        nonmutating set {
            gtk_tree_view_column_set_visible(tree_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var widget: WidgetRef! {
        /// Returns the `GtkWidget` in the button on the column header.
        /// If a custom widget has not been set then `nil` is returned.
        get {
            let rv = WidgetRef(gconstpointer: gconstpointer(gtk_tree_view_column_get_widget(tree_view_column_ptr)))
            return rv
        }
        /// Sets the widget in the header to be `widget`.  If widget is `nil`, then the
        /// header button is set with a `GtkLabel` set to the title of `tree_column`.
        nonmutating set {
            gtk_tree_view_column_set_widget(tree_view_column_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    @inlinable var width: Int {
        /// Returns the current size of `tree_column` in pixels.
        get {
            let rv = Int(gtk_tree_view_column_get_width(tree_view_column_ptr))
            return rv
        }
    }

    /// Returns the current X offset of `tree_column` in pixels.
    @inlinable var xOffset: Int {
        /// Returns the current X offset of `tree_column` in pixels.
        get {
            let rv = Int(gtk_tree_view_column_get_x_offset(tree_view_column_ptr))
            return rv
        }
    }

    @inlinable var parentInstance: GInitiallyUnowned {
        get {
            let rv = tree_view_column_ptr.pointee.parent_instance
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - UIManager Class

/// >&gt; GtkUIManager is deprecated since GTK+ 3.10. To construct user interfaces
/// &gt; from XML definitions, you should use `GtkBuilder`, `GMenuModel`, et al. To
/// &gt; work with actions, use `GAction`, `GtkActionable` et al. These newer classes
/// &gt; support richer functionality and integration with various desktop shells.
/// &gt; It should be possible to migrate most/all functionality from GtkUIManager.
/// 
/// A `GtkUIManager` constructs a user interface (menus and toolbars) from
/// one or more UI definitions, which reference actions from one or more
/// action groups.
/// 
/// # UI Definitions # <a name="XML-UI"></a>
/// 
/// The UI definitions are specified in an XML format which can be
/// roughly described by the following DTD.
/// 
/// &gt; Do not confuse the GtkUIManager UI Definitions described here with
/// &gt; the similarly named [GtkBuilder UI Definitions](#BUILDER-UI).
/// 
/// ```
/// <!ELEMENT menubar     (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT menu        (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT popup       (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT toolbar     (toolitem|separator|placeholder)* >
/// <!ELEMENT placeholder (menuitem|toolitem|separator|placeholder|menu)* >
/// <!ELEMENT menuitem     EMPTY >
/// <!ELEMENT toolitem     (menu?) >
/// <!ELEMENT separator    EMPTY >
/// <!ELEMENT accelerator  EMPTY >
/// <!ATTLIST menubar      name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST toolbar      name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST popup        name                      #IMPLIED
///                        action                    #IMPLIED
///                        accelerators (true|false) #IMPLIED >
/// <!ATTLIST placeholder  name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST separator    name                      #IMPLIED
///                        action                    #IMPLIED
///                        expand       (true|false) #IMPLIED >
/// <!ATTLIST menu         name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED >
/// <!ATTLIST menuitem     name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED
///                        always-show-image (true|false) #IMPLIED >
/// <!ATTLIST toolitem     name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED >
/// <!ATTLIST accelerator  name                      #IMPLIED
///                        action                    #REQUIRED >
/// ```
/// 
/// There are some additional restrictions beyond those specified in the
/// DTD, e.g. every toolitem must have a toolbar in its anchestry and
/// every menuitem must have a menubar or popup in its anchestry. Since
/// a `GMarkupParser` is used to parse the UI description, it must not only
/// be valid XML, but valid markup.
/// 
/// If a name is not specified, it defaults to the action. If an action is
/// not specified either, the element name is used. The name and action
/// attributes must not contain “/” characters after parsing (since that
/// would mess up path lookup) and must be usable as XML attributes when
/// enclosed in doublequotes, thus they must not “"” characters or references
/// to the &quot; entity.
/// 
/// # A UI definition #
/// 
/// ```
/// <ui>
///   <menubar>
///     <menu name="FileMenu" action="FileMenuAction">
///       <menuitem name="New" action="New2Action" />
///       <placeholder name="FileMenuAdditions" />
///     </menu>
///     <menu name="JustifyMenu" action="JustifyMenuAction">
///       <menuitem name="Left" action="justify-left"/>
///       <menuitem name="Centre" action="justify-center"/>
///       <menuitem name="Right" action="justify-right"/>
///       <menuitem name="Fill" action="justify-fill"/>
///     </menu>
///   </menubar>
///   <toolbar action="toolbar1">
///     <placeholder name="JustifyToolItems">
///       <separator/>
///       <toolitem name="Left" action="justify-left"/>
///       <toolitem name="Centre" action="justify-center"/>
///       <toolitem name="Right" action="justify-right"/>
///       <toolitem name="Fill" action="justify-fill"/>
///       <separator/>
///     </placeholder>
///   </toolbar>
/// </ui>
/// ```
/// 
/// The constructed widget hierarchy is very similar to the element tree
/// of the XML, with the exception that placeholders are merged into their
/// parents. The correspondence of XML elements to widgets should be
/// almost obvious:
/// 
/// - menubar
/// 
///    a `GtkMenuBar`
/// 
/// - toolbar
/// 
///    a `GtkToolbar`
/// 
/// - popup
/// 
///    a toplevel `GtkMenu`
/// 
/// - menu
/// 
///    a `GtkMenu` attached to a menuitem
/// 
/// - menuitem
/// 
///    a `GtkMenuItem` subclass, the exact type depends on the action
/// 
/// - toolitem
/// 
///    a `GtkToolItem` subclass, the exact type depends on the
///    action. Note that toolitem elements may contain a menu element,
///    but only if their associated action specifies a
///    `GtkMenuToolButton` as proxy.
/// 
/// - separator
/// 
///    a `GtkSeparatorMenuItem` or `GtkSeparatorToolItem`
/// 
/// - accelerator
/// 
///    a keyboard accelerator
/// 
/// The “position” attribute determines where a constructed widget is positioned
/// wrt. to its siblings in the partially constructed tree. If it is
/// “top”, the widget is prepended, otherwise it is appended.
/// 
/// # UI Merging # <a name="UI-Merging"></a>
/// 
/// The most remarkable feature of `GtkUIManager` is that it can overlay a set
/// of menuitems and toolitems over another one, and demerge them later.
/// 
/// Merging is done based on the names of the XML elements. Each element is
/// identified by a path which consists of the names of its anchestors, separated
/// by slashes. For example, the menuitem named “Left” in the example above
/// has the path `/ui/menubar/JustifyMenu/Left` and the
/// toolitem with the same name has path
/// `/ui/toolbar1/JustifyToolItems/Left`.
/// 
/// # Accelerators #
/// 
/// Every action has an accelerator path. Accelerators are installed together
/// with menuitem proxies, but they can also be explicitly added with
/// &lt;accelerator&gt; elements in the UI definition. This makes it possible to
/// have accelerators for actions even if they have no visible proxies.
/// 
/// # Smart Separators # <a name="Smart-Separators"></a>
/// 
/// The separators created by `GtkUIManager` are “smart”, i.e. they do not show up
/// in the UI unless they end up between two visible menu or tool items. Separators
/// which are located at the very beginning or end of the menu or toolbar
/// containing them, or multiple separators next to each other, are hidden. This
/// is a useful feature, since the merging of UI elements from multiple sources
/// can make it hard or impossible to determine in advance whether a separator
/// will end up in such an unfortunate position.
/// 
/// For separators in toolbars, you can set `expand="true"` to
/// turn them from a small, visible separator to an expanding, invisible one.
/// Toolitems following an expanding separator are effectively right-aligned.
/// 
/// # Empty Menus
/// 
/// Submenus pose similar problems to separators inconnection with merging. It is
/// impossible to know in advance whether they will end up empty after merging.
/// `GtkUIManager` offers two ways to treat empty submenus:
/// 
/// - make them disappear by hiding the menu item they’re attached to
/// 
/// - add an insensitive “Empty” item
/// 
/// The behaviour is chosen based on the “hide_if_empty” property of the action
/// to which the submenu is associated.
/// 
/// # GtkUIManager as GtkBuildable # <a name="GtkUIManager-BUILDER-UI"></a>
/// 
/// The GtkUIManager implementation of the GtkBuildable interface accepts
/// GtkActionGroup objects as &lt;child&gt; elements in UI definitions.
/// 
/// A GtkUIManager UI definition as described above can be embedded in
/// an GtkUIManager &lt;object&gt; element in a GtkBuilder UI definition.
/// 
/// The widgets that are constructed by a GtkUIManager can be embedded in
/// other parts of the constructed user interface with the help of the
/// “constructor” attribute. See the example below.
/// 
/// ## An embedded GtkUIManager UI definition
/// 
/// ```
/// <object class="GtkUIManager" id="uiman">
///   <child>
///     <object class="GtkActionGroup" id="actiongroup">
///       <child>
///         <object class="GtkAction" id="file">
///           <property name="label">_File</property>
///         </object>
///       </child>
///     </object>
///   </child>
///   <ui>
///     <menubar name="menubar1">
///       <menu action="file">
///       </menu>
///     </menubar>
///   </ui>
/// </object>
/// <object class="GtkWindow" id="main-window">
///   <child>
///     <object class="GtkMenuBar" id="menubar1" constructor="uiman"/>
///   </child>
/// </object>
/// ```
/// 
///
/// The `UIManagerProtocol` protocol exposes the methods and properties of an underlying `GtkUIManager` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `UIManager`.
/// Alternatively, use `UIManagerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol UIManagerProtocol: GLibObject.ObjectProtocol, BuildableProtocol {
        /// Untyped pointer to the underlying `GtkUIManager` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkUIManager` instance.
    var ui_manager_ptr: UnsafeMutablePointer<GtkUIManager>! { get }

    /// Required Initialiser for types conforming to `UIManagerProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// >&gt; GtkUIManager is deprecated since GTK+ 3.10. To construct user interfaces
/// &gt; from XML definitions, you should use `GtkBuilder`, `GMenuModel`, et al. To
/// &gt; work with actions, use `GAction`, `GtkActionable` et al. These newer classes
/// &gt; support richer functionality and integration with various desktop shells.
/// &gt; It should be possible to migrate most/all functionality from GtkUIManager.
/// 
/// A `GtkUIManager` constructs a user interface (menus and toolbars) from
/// one or more UI definitions, which reference actions from one or more
/// action groups.
/// 
/// # UI Definitions # <a name="XML-UI"></a>
/// 
/// The UI definitions are specified in an XML format which can be
/// roughly described by the following DTD.
/// 
/// &gt; Do not confuse the GtkUIManager UI Definitions described here with
/// &gt; the similarly named [GtkBuilder UI Definitions](#BUILDER-UI).
/// 
/// ```
/// <!ELEMENT menubar     (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT menu        (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT popup       (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT toolbar     (toolitem|separator|placeholder)* >
/// <!ELEMENT placeholder (menuitem|toolitem|separator|placeholder|menu)* >
/// <!ELEMENT menuitem     EMPTY >
/// <!ELEMENT toolitem     (menu?) >
/// <!ELEMENT separator    EMPTY >
/// <!ELEMENT accelerator  EMPTY >
/// <!ATTLIST menubar      name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST toolbar      name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST popup        name                      #IMPLIED
///                        action                    #IMPLIED
///                        accelerators (true|false) #IMPLIED >
/// <!ATTLIST placeholder  name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST separator    name                      #IMPLIED
///                        action                    #IMPLIED
///                        expand       (true|false) #IMPLIED >
/// <!ATTLIST menu         name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED >
/// <!ATTLIST menuitem     name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED
///                        always-show-image (true|false) #IMPLIED >
/// <!ATTLIST toolitem     name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED >
/// <!ATTLIST accelerator  name                      #IMPLIED
///                        action                    #REQUIRED >
/// ```
/// 
/// There are some additional restrictions beyond those specified in the
/// DTD, e.g. every toolitem must have a toolbar in its anchestry and
/// every menuitem must have a menubar or popup in its anchestry. Since
/// a `GMarkupParser` is used to parse the UI description, it must not only
/// be valid XML, but valid markup.
/// 
/// If a name is not specified, it defaults to the action. If an action is
/// not specified either, the element name is used. The name and action
/// attributes must not contain “/” characters after parsing (since that
/// would mess up path lookup) and must be usable as XML attributes when
/// enclosed in doublequotes, thus they must not “"” characters or references
/// to the &quot; entity.
/// 
/// # A UI definition #
/// 
/// ```
/// <ui>
///   <menubar>
///     <menu name="FileMenu" action="FileMenuAction">
///       <menuitem name="New" action="New2Action" />
///       <placeholder name="FileMenuAdditions" />
///     </menu>
///     <menu name="JustifyMenu" action="JustifyMenuAction">
///       <menuitem name="Left" action="justify-left"/>
///       <menuitem name="Centre" action="justify-center"/>
///       <menuitem name="Right" action="justify-right"/>
///       <menuitem name="Fill" action="justify-fill"/>
///     </menu>
///   </menubar>
///   <toolbar action="toolbar1">
///     <placeholder name="JustifyToolItems">
///       <separator/>
///       <toolitem name="Left" action="justify-left"/>
///       <toolitem name="Centre" action="justify-center"/>
///       <toolitem name="Right" action="justify-right"/>
///       <toolitem name="Fill" action="justify-fill"/>
///       <separator/>
///     </placeholder>
///   </toolbar>
/// </ui>
/// ```
/// 
/// The constructed widget hierarchy is very similar to the element tree
/// of the XML, with the exception that placeholders are merged into their
/// parents. The correspondence of XML elements to widgets should be
/// almost obvious:
/// 
/// - menubar
/// 
///    a `GtkMenuBar`
/// 
/// - toolbar
/// 
///    a `GtkToolbar`
/// 
/// - popup
/// 
///    a toplevel `GtkMenu`
/// 
/// - menu
/// 
///    a `GtkMenu` attached to a menuitem
/// 
/// - menuitem
/// 
///    a `GtkMenuItem` subclass, the exact type depends on the action
/// 
/// - toolitem
/// 
///    a `GtkToolItem` subclass, the exact type depends on the
///    action. Note that toolitem elements may contain a menu element,
///    but only if their associated action specifies a
///    `GtkMenuToolButton` as proxy.
/// 
/// - separator
/// 
///    a `GtkSeparatorMenuItem` or `GtkSeparatorToolItem`
/// 
/// - accelerator
/// 
///    a keyboard accelerator
/// 
/// The “position” attribute determines where a constructed widget is positioned
/// wrt. to its siblings in the partially constructed tree. If it is
/// “top”, the widget is prepended, otherwise it is appended.
/// 
/// # UI Merging # <a name="UI-Merging"></a>
/// 
/// The most remarkable feature of `GtkUIManager` is that it can overlay a set
/// of menuitems and toolitems over another one, and demerge them later.
/// 
/// Merging is done based on the names of the XML elements. Each element is
/// identified by a path which consists of the names of its anchestors, separated
/// by slashes. For example, the menuitem named “Left” in the example above
/// has the path `/ui/menubar/JustifyMenu/Left` and the
/// toolitem with the same name has path
/// `/ui/toolbar1/JustifyToolItems/Left`.
/// 
/// # Accelerators #
/// 
/// Every action has an accelerator path. Accelerators are installed together
/// with menuitem proxies, but they can also be explicitly added with
/// &lt;accelerator&gt; elements in the UI definition. This makes it possible to
/// have accelerators for actions even if they have no visible proxies.
/// 
/// # Smart Separators # <a name="Smart-Separators"></a>
/// 
/// The separators created by `GtkUIManager` are “smart”, i.e. they do not show up
/// in the UI unless they end up between two visible menu or tool items. Separators
/// which are located at the very beginning or end of the menu or toolbar
/// containing them, or multiple separators next to each other, are hidden. This
/// is a useful feature, since the merging of UI elements from multiple sources
/// can make it hard or impossible to determine in advance whether a separator
/// will end up in such an unfortunate position.
/// 
/// For separators in toolbars, you can set `expand="true"` to
/// turn them from a small, visible separator to an expanding, invisible one.
/// Toolitems following an expanding separator are effectively right-aligned.
/// 
/// # Empty Menus
/// 
/// Submenus pose similar problems to separators inconnection with merging. It is
/// impossible to know in advance whether they will end up empty after merging.
/// `GtkUIManager` offers two ways to treat empty submenus:
/// 
/// - make them disappear by hiding the menu item they’re attached to
/// 
/// - add an insensitive “Empty” item
/// 
/// The behaviour is chosen based on the “hide_if_empty” property of the action
/// to which the submenu is associated.
/// 
/// # GtkUIManager as GtkBuildable # <a name="GtkUIManager-BUILDER-UI"></a>
/// 
/// The GtkUIManager implementation of the GtkBuildable interface accepts
/// GtkActionGroup objects as &lt;child&gt; elements in UI definitions.
/// 
/// A GtkUIManager UI definition as described above can be embedded in
/// an GtkUIManager &lt;object&gt; element in a GtkBuilder UI definition.
/// 
/// The widgets that are constructed by a GtkUIManager can be embedded in
/// other parts of the constructed user interface with the help of the
/// “constructor” attribute. See the example below.
/// 
/// ## An embedded GtkUIManager UI definition
/// 
/// ```
/// <object class="GtkUIManager" id="uiman">
///   <child>
///     <object class="GtkActionGroup" id="actiongroup">
///       <child>
///         <object class="GtkAction" id="file">
///           <property name="label">_File</property>
///         </object>
///       </child>
///     </object>
///   </child>
///   <ui>
///     <menubar name="menubar1">
///       <menu action="file">
///       </menu>
///     </menubar>
///   </ui>
/// </object>
/// <object class="GtkWindow" id="main-window">
///   <child>
///     <object class="GtkMenuBar" id="menubar1" constructor="uiman"/>
///   </child>
/// </object>
/// ```
/// 
///
/// The `UIManagerRef` type acts as a lightweight Swift reference to an underlying `GtkUIManager` instance.
/// It exposes methods that can operate on this data type through `UIManagerProtocol` conformance.
/// Use `UIManagerRef` only as an `unowned` reference to an existing `GtkUIManager` instance.
///
public struct UIManagerRef: UIManagerProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkUIManager` instance.
    /// For type-safe access, use the generated, typed pointer `ui_manager_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension UIManagerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkUIManager>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkUIManager>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkUIManager>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkUIManager>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `UIManagerProtocol`
    @inlinable init<T: UIManagerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: UIManagerProtocol>(_ other: T) -> UIManagerRef { UIManagerRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new ui manager object.
    ///
    /// **new is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable init() {
        let rv = gtk_ui_manager_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// >&gt; GtkUIManager is deprecated since GTK+ 3.10. To construct user interfaces
/// &gt; from XML definitions, you should use `GtkBuilder`, `GMenuModel`, et al. To
/// &gt; work with actions, use `GAction`, `GtkActionable` et al. These newer classes
/// &gt; support richer functionality and integration with various desktop shells.
/// &gt; It should be possible to migrate most/all functionality from GtkUIManager.
/// 
/// A `GtkUIManager` constructs a user interface (menus and toolbars) from
/// one or more UI definitions, which reference actions from one or more
/// action groups.
/// 
/// # UI Definitions # <a name="XML-UI"></a>
/// 
/// The UI definitions are specified in an XML format which can be
/// roughly described by the following DTD.
/// 
/// &gt; Do not confuse the GtkUIManager UI Definitions described here with
/// &gt; the similarly named [GtkBuilder UI Definitions](#BUILDER-UI).
/// 
/// ```
/// <!ELEMENT menubar     (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT menu        (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT popup       (menuitem|separator|placeholder|menu)* >
/// <!ELEMENT toolbar     (toolitem|separator|placeholder)* >
/// <!ELEMENT placeholder (menuitem|toolitem|separator|placeholder|menu)* >
/// <!ELEMENT menuitem     EMPTY >
/// <!ELEMENT toolitem     (menu?) >
/// <!ELEMENT separator    EMPTY >
/// <!ELEMENT accelerator  EMPTY >
/// <!ATTLIST menubar      name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST toolbar      name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST popup        name                      #IMPLIED
///                        action                    #IMPLIED
///                        accelerators (true|false) #IMPLIED >
/// <!ATTLIST placeholder  name                      #IMPLIED
///                        action                    #IMPLIED >
/// <!ATTLIST separator    name                      #IMPLIED
///                        action                    #IMPLIED
///                        expand       (true|false) #IMPLIED >
/// <!ATTLIST menu         name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED >
/// <!ATTLIST menuitem     name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED
///                        always-show-image (true|false) #IMPLIED >
/// <!ATTLIST toolitem     name                      #IMPLIED
///                        action                    #REQUIRED
///                        position     (top|bot)    #IMPLIED >
/// <!ATTLIST accelerator  name                      #IMPLIED
///                        action                    #REQUIRED >
/// ```
/// 
/// There are some additional restrictions beyond those specified in the
/// DTD, e.g. every toolitem must have a toolbar in its anchestry and
/// every menuitem must have a menubar or popup in its anchestry. Since
/// a `GMarkupParser` is used to parse the UI description, it must not only
/// be valid XML, but valid markup.
/// 
/// If a name is not specified, it defaults to the action. If an action is
/// not specified either, the element name is used. The name and action
/// attributes must not contain “/” characters after parsing (since that
/// would mess up path lookup) and must be usable as XML attributes when
/// enclosed in doublequotes, thus they must not “"” characters or references
/// to the &quot; entity.
/// 
/// # A UI definition #
/// 
/// ```
/// <ui>
///   <menubar>
///     <menu name="FileMenu" action="FileMenuAction">
///       <menuitem name="New" action="New2Action" />
///       <placeholder name="FileMenuAdditions" />
///     </menu>
///     <menu name="JustifyMenu" action="JustifyMenuAction">
///       <menuitem name="Left" action="justify-left"/>
///       <menuitem name="Centre" action="justify-center"/>
///       <menuitem name="Right" action="justify-right"/>
///       <menuitem name="Fill" action="justify-fill"/>
///     </menu>
///   </menubar>
///   <toolbar action="toolbar1">
///     <placeholder name="JustifyToolItems">
///       <separator/>
///       <toolitem name="Left" action="justify-left"/>
///       <toolitem name="Centre" action="justify-center"/>
///       <toolitem name="Right" action="justify-right"/>
///       <toolitem name="Fill" action="justify-fill"/>
///       <separator/>
///     </placeholder>
///   </toolbar>
/// </ui>
/// ```
/// 
/// The constructed widget hierarchy is very similar to the element tree
/// of the XML, with the exception that placeholders are merged into their
/// parents. The correspondence of XML elements to widgets should be
/// almost obvious:
/// 
/// - menubar
/// 
///    a `GtkMenuBar`
/// 
/// - toolbar
/// 
///    a `GtkToolbar`
/// 
/// - popup
/// 
///    a toplevel `GtkMenu`
/// 
/// - menu
/// 
///    a `GtkMenu` attached to a menuitem
/// 
/// - menuitem
/// 
///    a `GtkMenuItem` subclass, the exact type depends on the action
/// 
/// - toolitem
/// 
///    a `GtkToolItem` subclass, the exact type depends on the
///    action. Note that toolitem elements may contain a menu element,
///    but only if their associated action specifies a
///    `GtkMenuToolButton` as proxy.
/// 
/// - separator
/// 
///    a `GtkSeparatorMenuItem` or `GtkSeparatorToolItem`
/// 
/// - accelerator
/// 
///    a keyboard accelerator
/// 
/// The “position” attribute determines where a constructed widget is positioned
/// wrt. to its siblings in the partially constructed tree. If it is
/// “top”, the widget is prepended, otherwise it is appended.
/// 
/// # UI Merging # <a name="UI-Merging"></a>
/// 
/// The most remarkable feature of `GtkUIManager` is that it can overlay a set
/// of menuitems and toolitems over another one, and demerge them later.
/// 
/// Merging is done based on the names of the XML elements. Each element is
/// identified by a path which consists of the names of its anchestors, separated
/// by slashes. For example, the menuitem named “Left” in the example above
/// has the path `/ui/menubar/JustifyMenu/Left` and the
/// toolitem with the same name has path
/// `/ui/toolbar1/JustifyToolItems/Left`.
/// 
/// # Accelerators #
/// 
/// Every action has an accelerator path. Accelerators are installed together
/// with menuitem proxies, but they can also be explicitly added with
/// &lt;accelerator&gt; elements in the UI definition. This makes it possible to
/// have accelerators for actions even if they have no visible proxies.
/// 
/// # Smart Separators # <a name="Smart-Separators"></a>
/// 
/// The separators created by `GtkUIManager` are “smart”, i.e. they do not show up
/// in the UI unless they end up between two visible menu or tool items. Separators
/// which are located at the very beginning or end of the menu or toolbar
/// containing them, or multiple separators next to each other, are hidden. This
/// is a useful feature, since the merging of UI elements from multiple sources
/// can make it hard or impossible to determine in advance whether a separator
/// will end up in such an unfortunate position.
/// 
/// For separators in toolbars, you can set `expand="true"` to
/// turn them from a small, visible separator to an expanding, invisible one.
/// Toolitems following an expanding separator are effectively right-aligned.
/// 
/// # Empty Menus
/// 
/// Submenus pose similar problems to separators inconnection with merging. It is
/// impossible to know in advance whether they will end up empty after merging.
/// `GtkUIManager` offers two ways to treat empty submenus:
/// 
/// - make them disappear by hiding the menu item they’re attached to
/// 
/// - add an insensitive “Empty” item
/// 
/// The behaviour is chosen based on the “hide_if_empty” property of the action
/// to which the submenu is associated.
/// 
/// # GtkUIManager as GtkBuildable # <a name="GtkUIManager-BUILDER-UI"></a>
/// 
/// The GtkUIManager implementation of the GtkBuildable interface accepts
/// GtkActionGroup objects as &lt;child&gt; elements in UI definitions.
/// 
/// A GtkUIManager UI definition as described above can be embedded in
/// an GtkUIManager &lt;object&gt; element in a GtkBuilder UI definition.
/// 
/// The widgets that are constructed by a GtkUIManager can be embedded in
/// other parts of the constructed user interface with the help of the
/// “constructor” attribute. See the example below.
/// 
/// ## An embedded GtkUIManager UI definition
/// 
/// ```
/// <object class="GtkUIManager" id="uiman">
///   <child>
///     <object class="GtkActionGroup" id="actiongroup">
///       <child>
///         <object class="GtkAction" id="file">
///           <property name="label">_File</property>
///         </object>
///       </child>
///     </object>
///   </child>
///   <ui>
///     <menubar name="menubar1">
///       <menu action="file">
///       </menu>
///     </menubar>
///   </ui>
/// </object>
/// <object class="GtkWindow" id="main-window">
///   <child>
///     <object class="GtkMenuBar" id="menubar1" constructor="uiman"/>
///   </child>
/// </object>
/// ```
/// 
///
/// The `UIManager` type acts as a reference-counted owner of an underlying `GtkUIManager` instance.
/// It provides the methods that can operate on this data type through `UIManagerProtocol` conformance.
/// Use `UIManager` as a strong reference or owner of a `GtkUIManager` instance.
///
open class UIManager: GLibObject.Object, UIManagerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `UIManager` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkUIManager>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `UIManager` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkUIManager>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `UIManager` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `UIManager` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `UIManager` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkUIManager>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `UIManager` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkUIManager>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkUIManager`.
    /// i.e., ownership is transferred to the `UIManager` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkUIManager>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `UIManagerProtocol`
    /// Will retain `GtkUIManager`.
    /// - Parameter other: an instance of a related type that implements `UIManagerProtocol`
    @inlinable public init<T: UIManagerProtocol>(uIManager other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `UIManagerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new ui manager object.
    ///
    /// **new is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable public init() {
        let rv = gtk_ui_manager_new()
        super.init(gpointer: (rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum UIManagerPropertyName: String, PropertyNameProtocol {
    /// The "add-tearoffs" property controls whether generated menus
    /// have tearoff menu items.
    /// 
    /// Note that this only affects regular menus. Generated popup
    /// menus never have tearoff menu items.
    ///
    /// **add-tearoffs is deprecated:**
    /// Tearoff menus are deprecated and should not
    ///     be used in newly written code.
    case addTearoffs = "add-tearoffs"
    case ui = "ui"
}

public extension UIManagerProtocol {
    /// Bind a `UIManagerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: UIManagerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a UIManager property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: UIManagerPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a UIManager property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: UIManagerPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum UIManagerSignalName: String, SignalNameProtocol {
    /// The `actions-changed` signal is emitted whenever the set of actions
    /// changes.
    ///
    /// **actions-changed is deprecated:**
    /// This method is deprecated.
    case actionsChanged = "actions-changed"
    /// The `add-widget` signal is emitted for each generated menubar and toolbar.
    /// It is not emitted for generated popup menus, which can be obtained by
    /// `gtk_ui_manager_get_widget()`.
    ///
    /// **add-widget is deprecated:**
    /// This method is deprecated.
    case addWidget = "add-widget"
    /// The `connect-proxy` signal is emitted after connecting a proxy to
    /// an action in the group.
    /// 
    /// This is intended for simple customizations for which a custom action
    /// class would be too clumsy, e.g. showing tooltips for menuitems in the
    /// statusbar.
    ///
    /// **connect-proxy is deprecated:**
    /// This method is deprecated.
    case connectProxy = "connect-proxy"
    /// The `disconnect-proxy` signal is emitted after disconnecting a proxy
    /// from an action in the group.
    ///
    /// **disconnect-proxy is deprecated:**
    /// This method is deprecated.
    case disconnectProxy = "disconnect-proxy"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `post-activate` signal is emitted just after the `action`
    /// is activated.
    /// 
    /// This is intended for applications to get notification
    /// just after any action is activated.
    ///
    /// **post-activate is deprecated:**
    /// This method is deprecated.
    case postActivate = "post-activate"
    /// The `pre-activate` signal is emitted just before the `action`
    /// is activated.
    /// 
    /// This is intended for applications to get notification
    /// just before any action is activated.
    ///
    /// **pre-activate is deprecated:**
    /// This method is deprecated.
    case preActivate = "pre-activate"
    /// The "add-tearoffs" property controls whether generated menus
    /// have tearoff menu items.
    /// 
    /// Note that this only affects regular menus. Generated popup
    /// menus never have tearoff menu items.
    ///
    /// **add-tearoffs is deprecated:**
    /// Tearoff menus are deprecated and should not
    ///     be used in newly written code.
    case notifyAddTearoffs = "notify::add-tearoffs"
    case notifyUi = "notify::ui"
}

// MARK: UIManager signals
public extension UIManagerProtocol {
    /// Connect a Swift signal handler to the given, typed `UIManagerSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: UIManagerSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `UIManagerSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: UIManagerSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// The `actions-changed` signal is emitted whenever the set of actions
    /// changes.
    /// - Note: This represents the underlying `actions-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `actionsChanged` signal is emitted
    @discardableResult @inlinable func onActionsChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: UIManagerRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<UIManagerRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(UIManagerRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .actionsChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `actions-changed` signal for using the `connect(signal:)` methods
    static var actionsChangedSignal: UIManagerSignalName { .actionsChanged }
    
    /// The `add-widget` signal is emitted for each generated menubar and toolbar.
    /// It is not emitted for generated popup menus, which can be obtained by
    /// `gtk_ui_manager_get_widget()`.
    /// - Note: This represents the underlying `add-widget` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter widget: the added widget
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `addWidget` signal is emitted
    @discardableResult @inlinable func onAddWidget(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: UIManagerRef, _ widget: WidgetRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<UIManagerRef, WidgetRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(UIManagerRef(raw: unownedSelf), WidgetRef(raw: arg1))
            return output
        }
        return connect(
            signal: .addWidget,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `add-widget` signal for using the `connect(signal:)` methods
    static var addWidgetSignal: UIManagerSignalName { .addWidget }
    
    /// The `connect-proxy` signal is emitted after connecting a proxy to
    /// an action in the group.
    /// 
    /// This is intended for simple customizations for which a custom action
    /// class would be too clumsy, e.g. showing tooltips for menuitems in the
    /// statusbar.
    /// - Note: This represents the underlying `connect-proxy` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter action: the action
    /// - Parameter proxy: the proxy
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `connectProxy` signal is emitted
    @discardableResult @inlinable func onConnectProxy(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: UIManagerRef, _ action: ActionRef, _ proxy: WidgetRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<UIManagerRef, ActionRef, WidgetRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(UIManagerRef(raw: unownedSelf), ActionRef(raw: arg1), WidgetRef(raw: arg2))
            return output
        }
        return connect(
            signal: .connectProxy,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `connect-proxy` signal for using the `connect(signal:)` methods
    static var connectProxySignal: UIManagerSignalName { .connectProxy }
    
    /// The `disconnect-proxy` signal is emitted after disconnecting a proxy
    /// from an action in the group.
    /// - Note: This represents the underlying `disconnect-proxy` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter action: the action
    /// - Parameter proxy: the proxy
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `disconnectProxy` signal is emitted
    @discardableResult @inlinable func onDisconnectProxy(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: UIManagerRef, _ action: ActionRef, _ proxy: WidgetRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<UIManagerRef, ActionRef, WidgetRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(UIManagerRef(raw: unownedSelf), ActionRef(raw: arg1), WidgetRef(raw: arg2))
            return output
        }
        return connect(
            signal: .disconnectProxy,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `disconnect-proxy` signal for using the `connect(signal:)` methods
    static var disconnectProxySignal: UIManagerSignalName { .disconnectProxy }
    
    /// The `post-activate` signal is emitted just after the `action`
    /// is activated.
    /// 
    /// This is intended for applications to get notification
    /// just after any action is activated.
    /// - Note: This represents the underlying `post-activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter action: the action
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `postActivate` signal is emitted
    @discardableResult @inlinable func onPostActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: UIManagerRef, _ action: ActionRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<UIManagerRef, ActionRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(UIManagerRef(raw: unownedSelf), ActionRef(raw: arg1))
            return output
        }
        return connect(
            signal: .postActivate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `post-activate` signal for using the `connect(signal:)` methods
    static var postActivateSignal: UIManagerSignalName { .postActivate }
    
    /// The `pre-activate` signal is emitted just before the `action`
    /// is activated.
    /// 
    /// This is intended for applications to get notification
    /// just before any action is activated.
    /// - Note: This represents the underlying `pre-activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter action: the action
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `preActivate` signal is emitted
    @discardableResult @inlinable func onPreActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: UIManagerRef, _ action: ActionRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<UIManagerRef, ActionRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(UIManagerRef(raw: unownedSelf), ActionRef(raw: arg1))
            return output
        }
        return connect(
            signal: .preActivate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `pre-activate` signal for using the `connect(signal:)` methods
    static var preActivateSignal: UIManagerSignalName { .preActivate }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::add-tearoffs` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAddTearoffs` signal is emitted
    @discardableResult @inlinable func onNotifyAddTearoffs(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: UIManagerRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<UIManagerRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(UIManagerRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAddTearoffs,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::add-tearoffs` signal for using the `connect(signal:)` methods
    static var notifyAddTearoffsSignal: UIManagerSignalName { .notifyAddTearoffs }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::ui` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUi` signal is emitted
    @discardableResult @inlinable func onNotifyUi(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: UIManagerRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<UIManagerRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(UIManagerRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyUi,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::ui` signal for using the `connect(signal:)` methods
    static var notifyUiSignal: UIManagerSignalName { .notifyUi }
    
}

// MARK: UIManager Class: UIManagerProtocol extension (methods and fields)
public extension UIManagerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkUIManager` instance.
    @inlinable var ui_manager_ptr: UnsafeMutablePointer<GtkUIManager>! { return ptr?.assumingMemoryBound(to: GtkUIManager.self) }

    /// Adds a UI element to the current contents of `manager`.
    /// 
    /// If `type` is `GTK_UI_MANAGER_AUTO`, GTK+ inserts a menuitem, toolitem or
    /// separator if such an element can be inserted at the place determined by
    /// `path`. Otherwise `type` must indicate an element that can be inserted at
    /// the place determined by `path`.
    /// 
    /// If `path` points to a menuitem or toolitem, the new element will be inserted
    /// before or after this item, depending on `top`.
    ///
    /// **add_ui is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func addUi(mergeID: Int, path: UnsafePointer<gchar>!, name: UnsafePointer<gchar>!, action: UnsafePointer<gchar>? = nil, type: UIManagerItemType, top: Bool) {
        gtk_ui_manager_add_ui(ui_manager_ptr, guint(mergeID), path, name, action, type.value, gboolean((top) ? 1 : 0))
    
    }

    /// Parses a file containing a [UI definition](#XML-UI) and
    /// merges it with the current contents of `manager`.
    ///
    /// **add_ui_from_file is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func addUiFromFile(filename: UnsafePointer<gchar>!) throws -> Int {
        var error: UnsafeMutablePointer<GError>?
        let rv = Int(gtk_ui_manager_add_ui_from_file(ui_manager_ptr, filename, &error))
        if let error = error { throw GLibError(error) }
        return rv
    }

    /// Parses a resource file containing a [UI definition](#XML-UI) and
    /// merges it with the current contents of `manager`.
    ///
    /// **add_ui_from_resource is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func addUiFrom(resourcePath: UnsafePointer<gchar>!) throws -> Int {
        var error: UnsafeMutablePointer<GError>?
        let rv = Int(gtk_ui_manager_add_ui_from_resource(ui_manager_ptr, resourcePath, &error))
        if let error = error { throw GLibError(error) }
        return rv
    }

    /// Parses a string containing a [UI definition](#XML-UI) and merges it with
    /// the current contents of `manager`. An enclosing &lt;ui&gt; element is added if
    /// it is missing.
    ///
    /// **add_ui_from_string is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func addUiFrom(stringBuffer buffer: UnsafePointer<gchar>!, length: gssize) throws -> Int {
        var error: UnsafeMutablePointer<GError>?
        let rv = Int(gtk_ui_manager_add_ui_from_string(ui_manager_ptr, buffer, length, &error))
        if let error = error { throw GLibError(error) }
        return rv
    }

    /// Makes sure that all pending updates to the UI have been completed.
    /// 
    /// This may occasionally be necessary, since `GtkUIManager` updates the
    /// UI in an idle function. A typical example where this function is
    /// useful is to enforce that the menubar and toolbar have been added to
    /// the main window before showing it:
    /// (C Language Example):
    /// ```C
    /// gtk_container_add (GTK_CONTAINER (window), vbox);
    /// g_signal_connect (merge, "add-widget",
    ///                   G_CALLBACK (add_widget), vbox);
    /// gtk_ui_manager_add_ui_from_file (merge, "my-menus");
    /// gtk_ui_manager_add_ui_from_file (merge, "my-toolbars");
    /// gtk_ui_manager_ensure_update (merge);
    /// gtk_widget_show (window);
    /// ```
    /// 
    ///
    /// **ensure_update is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func ensureUpdate() {
        gtk_ui_manager_ensure_update(ui_manager_ptr)
    
    }

    /// Returns the `GtkAccelGroup` associated with `manager`.
    ///
    /// **get_accel_group is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getAccelGroup() -> AccelGroupRef! {
        let rv = AccelGroupRef(gconstpointer: gconstpointer(gtk_ui_manager_get_accel_group(ui_manager_ptr)))
        return rv
    }

    /// Looks up an action by following a path. See `gtk_ui_manager_get_widget()`
    /// for more information about paths.
    ///
    /// **get_action is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getAction(path: UnsafePointer<gchar>!) -> ActionRef! {
        let rv = ActionRef(gconstpointer: gconstpointer(gtk_ui_manager_get_action(ui_manager_ptr, path)))
        return rv
    }

    /// Returns the list of action groups associated with `manager`.
    ///
    /// **get_action_groups is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getActionGroups() -> GLib.ListRef! {
        let rv = GLib.ListRef(gtk_ui_manager_get_action_groups(ui_manager_ptr))
        return rv
    }

    /// Returns whether menus generated by this `GtkUIManager`
    /// will have tearoff menu items.
    ///
    /// **get_add_tearoffs is deprecated:**
    /// Tearoff menus are deprecated and should not
    ///     be used in newly written code.
    @available(*, deprecated)
    @inlinable func getAddTearoffs() -> Bool {
        let rv = ((gtk_ui_manager_get_add_tearoffs(ui_manager_ptr)) != 0)
        return rv
    }

    /// Obtains a list of all toplevel widgets of the requested types.
    ///
    /// **get_toplevels is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getToplevels(types: UIManagerItemType) -> GLib.SListRef! {
        let rv = GLib.SListRef(gtk_ui_manager_get_toplevels(ui_manager_ptr, types.value))
        return rv
    }

    /// Creates a [UI definition](#XML-UI) of the merged UI.
    ///
    /// **get_ui is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getUi() -> String! {
        let rv = gtk_ui_manager_get_ui(ui_manager_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Looks up a widget by following a path.
    /// The path consists of the names specified in the XML description of the UI.
    /// separated by “/”. Elements which don’t have a name or action attribute in
    /// the XML (e.g. &lt;popup&gt;) can be addressed by their XML element name
    /// (e.g. "popup"). The root element ("/ui") can be omitted in the path.
    /// 
    /// Note that the widget found by following a path that ends in a &lt;menu&gt;;
    /// element is the menuitem to which the menu is attached, not the menu it
    /// manages.
    /// 
    /// Also note that the widgets constructed by a ui manager are not tied to
    /// the lifecycle of the ui manager. If you add the widgets returned by this
    /// function to some container or explicitly ref them, they will survive the
    /// destruction of the ui manager.
    ///
    /// **get_widget is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func getWidget(path: UnsafePointer<gchar>!) -> WidgetRef! {
        let rv = WidgetRef(gconstpointer: gconstpointer(gtk_ui_manager_get_widget(ui_manager_ptr, path)))
        return rv
    }

    /// Inserts an action group into the list of action groups associated
    /// with `manager`. Actions in earlier groups hide actions with the same
    /// name in later groups.
    /// 
    /// If `pos` is larger than the number of action groups in `manager`, or
    /// negative, `action_group` will be inserted at the end of the internal
    /// list.
    ///
    /// **insert_action_group is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func insert<ActionGroupT: ActionGroupProtocol>(actionGroup: ActionGroupT, pos: Int) {
        gtk_ui_manager_insert_action_group(ui_manager_ptr, actionGroup.action_group_ptr, gint(pos))
    
    }

    /// Returns an unused merge id, suitable for use with
    /// `gtk_ui_manager_add_ui()`.
    ///
    /// **new_merge_id is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func newMergeID() -> Int {
        let rv = Int(gtk_ui_manager_new_merge_id(ui_manager_ptr))
        return rv
    }

    /// Removes an action group from the list of action groups associated
    /// with `manager`.
    ///
    /// **remove_action_group is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func remove<ActionGroupT: ActionGroupProtocol>(actionGroup: ActionGroupT) {
        gtk_ui_manager_remove_action_group(ui_manager_ptr, actionGroup.action_group_ptr)
    
    }

    /// Unmerges the part of `manager`'s content identified by `merge_id`.
    ///
    /// **remove_ui is deprecated:**
    /// This method is deprecated.
    @available(*, deprecated)
    @inlinable func removeUi(mergeID: Int) {
        gtk_ui_manager_remove_ui(ui_manager_ptr, guint(mergeID))
    
    }

    /// Sets the “add_tearoffs” property, which controls whether menus
    /// generated by this `GtkUIManager` will have tearoff menu items.
    /// 
    /// Note that this only affects regular menus. Generated popup
    /// menus never have tearoff menu items.
    ///
    /// **set_add_tearoffs is deprecated:**
    /// Tearoff menus are deprecated and should not
    ///     be used in newly written code.
    @available(*, deprecated)
    @inlinable func set(addTearoffs: Bool) {
        gtk_ui_manager_set_add_tearoffs(ui_manager_ptr, gboolean((addTearoffs) ? 1 : 0))
    
    }
    /// Returns the `GtkAccelGroup` associated with `manager`.
    ///
    /// **get_accel_group is deprecated:**
    /// This method is deprecated.
    @inlinable var accelGroup: AccelGroupRef! {
        /// Returns the `GtkAccelGroup` associated with `manager`.
        ///
        /// **get_accel_group is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    get {
            let rv = AccelGroupRef(gconstpointer: gconstpointer(gtk_ui_manager_get_accel_group(ui_manager_ptr)))
            return rv
        }
    }

    /// Returns the list of action groups associated with `manager`.
    ///
    /// **get_action_groups is deprecated:**
    /// This method is deprecated.
    @inlinable var actionGroups: GLib.ListRef! {
        /// Returns the list of action groups associated with `manager`.
        ///
        /// **get_action_groups is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    get {
            let rv = GLib.ListRef(gtk_ui_manager_get_action_groups(ui_manager_ptr))
            return rv
        }
    }

    /// Returns whether menus generated by this `GtkUIManager`
    /// will have tearoff menu items.
    ///
    /// **get_add_tearoffs is deprecated:**
    /// Tearoff menus are deprecated and should not
    ///     be used in newly written code.
    @inlinable var addTearoffs: Bool {
        /// Returns whether menus generated by this `GtkUIManager`
        /// will have tearoff menu items.
        ///
        /// **get_add_tearoffs is deprecated:**
        /// Tearoff menus are deprecated and should not
        ///     be used in newly written code.
        @available(*, deprecated)
    get {
            let rv = ((gtk_ui_manager_get_add_tearoffs(ui_manager_ptr)) != 0)
            return rv
        }
        /// Sets the “add_tearoffs” property, which controls whether menus
        /// generated by this `GtkUIManager` will have tearoff menu items.
        /// 
        /// Note that this only affects regular menus. Generated popup
        /// menus never have tearoff menu items.
        ///
        /// **set_add_tearoffs is deprecated:**
        /// Tearoff menus are deprecated and should not
        ///     be used in newly written code.
        @available(*, deprecated)
    nonmutating set {
            gtk_ui_manager_set_add_tearoffs(ui_manager_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var ui: String! {
        /// Creates a [UI definition](#XML-UI) of the merged UI.
        ///
        /// **get_ui is deprecated:**
        /// This method is deprecated.
        @available(*, deprecated)
    get {
            let rv = gtk_ui_manager_get_ui(ui_manager_ptr).map({ String(cString: $0) })
            return rv
        }
    }

    @inlinable var parent: GObject {
        get {
            let rv = ui_manager_ptr.pointee.parent
            return rv
        }
    }

    // var privateData is unavailable because private_data is private

}



