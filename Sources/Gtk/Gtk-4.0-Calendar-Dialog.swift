import CGLib
import CCairo
import CPango
import CGdkPixbuf
import CGdk
import CGtk
import GLib
import GLibObject
import GIO
import Pango
import Cairo
import PangoCairo
import GdkPixbuf
import Gdk

// MARK: - Calendar Class

/// `GtkCalendar` is a widget that displays a Gregorian calendar, one month
/// at a time.
/// 
/// ![An example GtkCalendar](calendar.png)
/// 
/// A `GtkCalendar` can be created with [ctor`Gtk.Calendar.new`].
/// 
/// The date that is currently displayed can be altered with
/// [method`Gtk.Calendar.select_day`].
/// 
/// To place a visual marker on a particular day, use
/// [method`Gtk.Calendar.mark_day`] and to remove the marker,
/// [method`Gtk.Calendar.unmark_day`]. Alternative, all
/// marks can be cleared with [method`Gtk.Calendar.clear_marks`].
/// 
/// The selected date can be retrieved from a `GtkCalendar` using
/// [method`Gtk.Calendar.get_date`].
/// 
/// Users should be aware that, although the Gregorian calendar is the
/// legal calendar in most countries, it was adopted progressively
/// between 1582 and 1929. Display before these dates is likely to be
/// historically incorrect.
/// 
/// # CSS nodes
/// 
/// ```
/// calendar.view
/// ├── header
/// │   ├── button
/// │   ├── stack.month
/// │   ├── button
/// │   ├── button
/// │   ├── label.year
/// │   ╰── button
/// ╰── grid
///     ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
/// ```
/// 
/// `GtkCalendar` has a main node with name calendar. It contains a subnode
/// called header containing the widgets for switching between years and months.
/// 
/// The grid subnode contains all day labels, including week numbers on the left
/// (marked with the .week-number css class) and day names on top (marked with the
/// .day-name css class).
/// 
/// Day labels that belong to the previous or next month get the .other-month
/// style class. The label of the current day get the .today style class.
/// 
/// Marked day labels get the :selected state assigned.
///
/// The `CalendarProtocol` protocol exposes the methods and properties of an underlying `GtkCalendar` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Calendar`.
/// Alternatively, use `CalendarRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CalendarProtocol: WidgetProtocol {
        /// Untyped pointer to the underlying `GtkCalendar` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCalendar` instance.
    var calendar_ptr: UnsafeMutablePointer<GtkCalendar>! { get }

    /// Required Initialiser for types conforming to `CalendarProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCalendar` is a widget that displays a Gregorian calendar, one month
/// at a time.
/// 
/// ![An example GtkCalendar](calendar.png)
/// 
/// A `GtkCalendar` can be created with [ctor`Gtk.Calendar.new`].
/// 
/// The date that is currently displayed can be altered with
/// [method`Gtk.Calendar.select_day`].
/// 
/// To place a visual marker on a particular day, use
/// [method`Gtk.Calendar.mark_day`] and to remove the marker,
/// [method`Gtk.Calendar.unmark_day`]. Alternative, all
/// marks can be cleared with [method`Gtk.Calendar.clear_marks`].
/// 
/// The selected date can be retrieved from a `GtkCalendar` using
/// [method`Gtk.Calendar.get_date`].
/// 
/// Users should be aware that, although the Gregorian calendar is the
/// legal calendar in most countries, it was adopted progressively
/// between 1582 and 1929. Display before these dates is likely to be
/// historically incorrect.
/// 
/// # CSS nodes
/// 
/// ```
/// calendar.view
/// ├── header
/// │   ├── button
/// │   ├── stack.month
/// │   ├── button
/// │   ├── button
/// │   ├── label.year
/// │   ╰── button
/// ╰── grid
///     ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
/// ```
/// 
/// `GtkCalendar` has a main node with name calendar. It contains a subnode
/// called header containing the widgets for switching between years and months.
/// 
/// The grid subnode contains all day labels, including week numbers on the left
/// (marked with the .week-number css class) and day names on top (marked with the
/// .day-name css class).
/// 
/// Day labels that belong to the previous or next month get the .other-month
/// style class. The label of the current day get the .today style class.
/// 
/// Marked day labels get the :selected state assigned.
///
/// The `CalendarRef` type acts as a lightweight Swift reference to an underlying `GtkCalendar` instance.
/// It exposes methods that can operate on this data type through `CalendarProtocol` conformance.
/// Use `CalendarRef` only as an `unowned` reference to an existing `GtkCalendar` instance.
///
public struct CalendarRef: CalendarProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCalendar` instance.
    /// For type-safe access, use the generated, typed pointer `calendar_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CalendarRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCalendar>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCalendar>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCalendar>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCalendar>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CalendarProtocol`
    @inlinable init<T: CalendarProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CalendarProtocol>(_ other: T) -> CalendarRef { CalendarRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new calendar, with the current date being selected.
    @inlinable init() {
        let rv = gtk_calendar_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCalendar` is a widget that displays a Gregorian calendar, one month
/// at a time.
/// 
/// ![An example GtkCalendar](calendar.png)
/// 
/// A `GtkCalendar` can be created with [ctor`Gtk.Calendar.new`].
/// 
/// The date that is currently displayed can be altered with
/// [method`Gtk.Calendar.select_day`].
/// 
/// To place a visual marker on a particular day, use
/// [method`Gtk.Calendar.mark_day`] and to remove the marker,
/// [method`Gtk.Calendar.unmark_day`]. Alternative, all
/// marks can be cleared with [method`Gtk.Calendar.clear_marks`].
/// 
/// The selected date can be retrieved from a `GtkCalendar` using
/// [method`Gtk.Calendar.get_date`].
/// 
/// Users should be aware that, although the Gregorian calendar is the
/// legal calendar in most countries, it was adopted progressively
/// between 1582 and 1929. Display before these dates is likely to be
/// historically incorrect.
/// 
/// # CSS nodes
/// 
/// ```
/// calendar.view
/// ├── header
/// │   ├── button
/// │   ├── stack.month
/// │   ├── button
/// │   ├── button
/// │   ├── label.year
/// │   ╰── button
/// ╰── grid
///     ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
/// ```
/// 
/// `GtkCalendar` has a main node with name calendar. It contains a subnode
/// called header containing the widgets for switching between years and months.
/// 
/// The grid subnode contains all day labels, including week numbers on the left
/// (marked with the .week-number css class) and day names on top (marked with the
/// .day-name css class).
/// 
/// Day labels that belong to the previous or next month get the .other-month
/// style class. The label of the current day get the .today style class.
/// 
/// Marked day labels get the :selected state assigned.
///
/// The `Calendar` type acts as a reference-counted owner of an underlying `GtkCalendar` instance.
/// It provides the methods that can operate on this data type through `CalendarProtocol` conformance.
/// Use `Calendar` as a strong reference or owner of a `GtkCalendar` instance.
///
open class Calendar: Widget, CalendarProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCalendar>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCalendar>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCalendar>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCalendar>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCalendar`.
    /// i.e., ownership is transferred to the `Calendar` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCalendar>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CalendarProtocol`
    /// Will retain `GtkCalendar`.
    /// - Parameter other: an instance of a related type that implements `CalendarProtocol`
    @inlinable public init<T: CalendarProtocol>(calendar other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CalendarProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new calendar, with the current date being selected.
    @inlinable public init() {
        let rv = gtk_calendar_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CalendarPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// The selected day (as a number between 1 and 31).
    case day = "day"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The selected month (as a number between 0 and 11).
    /// 
    /// This property gets initially set to the current month.
    case month = "month"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Determines whether day names are displayed.
    case showDayNames = "show-day-names"
    /// Determines whether a heading is displayed.
    case showHeading = "show-heading"
    /// Determines whether week numbers are displayed.
    case showWeekNumbers = "show-week-numbers"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
    /// The selected year.
    /// 
    /// This property gets initially set to the current year.
    case year = "year"
}

public extension CalendarProtocol {
    /// Bind a `CalendarPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CalendarPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Calendar property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CalendarPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Calendar property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CalendarPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CalendarSignalName: String, SignalNameProtocol {
    /// Emitted when the user selects a day.
    case daySelected = "day-selected"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// Emitted when the user switched to the next month.
    case nextMonth = "next-month"
    /// Emitted when user switched to the next year.
    case nextYear = "next-year"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the user switched to the previous month.
    case prevMonth = "prev-month"
    /// Emitted when user switched to the previous year.
    case prevYear = "prev-year"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// The selected day (as a number between 1 and 31).
    case notifyDay = "notify::day"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The selected month (as a number between 0 and 11).
    /// 
    /// This property gets initially set to the current month.
    case notifyMonth = "notify::month"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Determines whether day names are displayed.
    case notifyShowDayNames = "notify::show-day-names"
    /// Determines whether a heading is displayed.
    case notifyShowHeading = "notify::show-heading"
    /// Determines whether week numbers are displayed.
    case notifyShowWeekNumbers = "notify::show-week-numbers"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
    /// The selected year.
    /// 
    /// This property gets initially set to the current year.
    case notifyYear = "notify::year"
}

// MARK: Calendar signals
public extension CalendarProtocol {
    /// Connect a Swift signal handler to the given, typed `CalendarSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CalendarSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CalendarSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CalendarSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when the user selects a day.
    /// - Note: This represents the underlying `day-selected` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `daySelected` signal is emitted
    @discardableResult @inlinable func onDaySelected(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<CalendarRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CalendarRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .daySelected,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `day-selected` signal for using the `connect(signal:)` methods
    static var daySelectedSignal: CalendarSignalName { .daySelected }
    
    /// Emitted when the user switched to the next month.
    /// - Note: This represents the underlying `next-month` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `nextMonth` signal is emitted
    @discardableResult @inlinable func onNextMonth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<CalendarRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CalendarRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .nextMonth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `next-month` signal for using the `connect(signal:)` methods
    static var nextMonthSignal: CalendarSignalName { .nextMonth }
    
    /// Emitted when user switched to the next year.
    /// - Note: This represents the underlying `next-year` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `nextYear` signal is emitted
    @discardableResult @inlinable func onNextYear(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<CalendarRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CalendarRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .nextYear,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `next-year` signal for using the `connect(signal:)` methods
    static var nextYearSignal: CalendarSignalName { .nextYear }
    
    /// Emitted when the user switched to the previous month.
    /// - Note: This represents the underlying `prev-month` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `prevMonth` signal is emitted
    @discardableResult @inlinable func onPrevMonth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<CalendarRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CalendarRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .prevMonth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `prev-month` signal for using the `connect(signal:)` methods
    static var prevMonthSignal: CalendarSignalName { .prevMonth }
    
    /// Emitted when user switched to the previous year.
    /// - Note: This represents the underlying `prev-year` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `prevYear` signal is emitted
    @discardableResult @inlinable func onPrevYear(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<CalendarRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CalendarRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .prevYear,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `prev-year` signal for using the `connect(signal:)` methods
    static var prevYearSignal: CalendarSignalName { .prevYear }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::day` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyDay` signal is emitted
    @discardableResult @inlinable func onNotifyDay(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CalendarRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CalendarRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyDay,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::day` signal for using the `connect(signal:)` methods
    static var notifyDaySignal: CalendarSignalName { .notifyDay }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::month` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMonth` signal is emitted
    @discardableResult @inlinable func onNotifyMonth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CalendarRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CalendarRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMonth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::month` signal for using the `connect(signal:)` methods
    static var notifyMonthSignal: CalendarSignalName { .notifyMonth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-day-names` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowDayNames` signal is emitted
    @discardableResult @inlinable func onNotifyShowDayNames(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CalendarRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CalendarRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyShowDayNames,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-day-names` signal for using the `connect(signal:)` methods
    static var notifyShowDayNamesSignal: CalendarSignalName { .notifyShowDayNames }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-heading` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowHeading` signal is emitted
    @discardableResult @inlinable func onNotifyShowHeading(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CalendarRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CalendarRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyShowHeading,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-heading` signal for using the `connect(signal:)` methods
    static var notifyShowHeadingSignal: CalendarSignalName { .notifyShowHeading }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-week-numbers` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowWeekNumbers` signal is emitted
    @discardableResult @inlinable func onNotifyShowWeekNumbers(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CalendarRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CalendarRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyShowWeekNumbers,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-week-numbers` signal for using the `connect(signal:)` methods
    static var notifyShowWeekNumbersSignal: CalendarSignalName { .notifyShowWeekNumbers }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::year` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyYear` signal is emitted
    @discardableResult @inlinable func onNotifyYear(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CalendarRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CalendarRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CalendarRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyYear,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::year` signal for using the `connect(signal:)` methods
    static var notifyYearSignal: CalendarSignalName { .notifyYear }
    
}

// MARK: Calendar Class: CalendarProtocol extension (methods and fields)
public extension CalendarProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCalendar` instance.
    @inlinable var calendar_ptr: UnsafeMutablePointer<GtkCalendar>! { return ptr?.assumingMemoryBound(to: GtkCalendar.self) }

    /// Remove all visual markers.
    @inlinable func clearMarks() {
        gtk_calendar_clear_marks(calendar_ptr)
    
    }

    /// Returns a `GDateTime` representing the shown
    /// year, month and the selected day.
    /// 
    /// The returned date is in the local time zone.
    @inlinable func getDate() -> GLib.DateTimeRef! {
        let rv = GLib.DateTimeRef(gtk_calendar_get_date(calendar_ptr))
        return rv
    }

    /// Returns if the `day` of the `calendar` is already marked.
    @inlinable func getDayIsMarked(day: Int) -> Bool {
        let rv = ((gtk_calendar_get_day_is_marked(calendar_ptr, guint(day))) != 0)
        return rv
    }

    /// Returns whether `self` is currently showing the names
    /// of the week days.
    /// 
    /// This is the value of the [property`Gtk.Calendar:show-day-names`]
    /// property.
    @inlinable func getShowDayNames() -> Bool {
        let rv = ((gtk_calendar_get_show_day_names(calendar_ptr)) != 0)
        return rv
    }

    /// Returns whether `self` is currently showing the heading.
    /// 
    /// This is the value of the [property`Gtk.Calendar:show-heading`]
    /// property.
    @inlinable func getShowHeading() -> Bool {
        let rv = ((gtk_calendar_get_show_heading(calendar_ptr)) != 0)
        return rv
    }

    /// Returns whether `self` is showing week numbers right
    /// now.
    /// 
    /// This is the value of the [property`Gtk.Calendar:show-week-numbers`]
    /// property.
    @inlinable func getShowWeekNumbers() -> Bool {
        let rv = ((gtk_calendar_get_show_week_numbers(calendar_ptr)) != 0)
        return rv
    }

    /// Places a visual marker on a particular day.
    @inlinable func mark(day: Int) {
        gtk_calendar_mark_day(calendar_ptr, guint(day))
    
    }

    /// Switches to `date`'s year and month and select its day.
    @inlinable func selectDay<DateTimeT: GLib.DateTimeProtocol>(date: DateTimeT) {
        gtk_calendar_select_day(calendar_ptr, date.date_time_ptr)
    
    }

    /// Sets whether the calendar shows day names.
    @inlinable func setShowDayNames(value: Bool) {
        gtk_calendar_set_show_day_names(calendar_ptr, gboolean((value) ? 1 : 0))
    
    }

    /// Sets whether the calendar should show a heading.
    /// 
    /// The heading contains the current year and month as well as
    /// buttons for changing both.
    @inlinable func setShowHeading(value: Bool) {
        gtk_calendar_set_show_heading(calendar_ptr, gboolean((value) ? 1 : 0))
    
    }

    /// Sets whether week numbers are shown in the calendar.
    @inlinable func setShowWeekNumbers(value: Bool) {
        gtk_calendar_set_show_week_numbers(calendar_ptr, gboolean((value) ? 1 : 0))
    
    }

    /// Removes the visual marker from a particular day.
    @inlinable func unmark(day: Int) {
        gtk_calendar_unmark_day(calendar_ptr, guint(day))
    
    }
    /// Returns a `GDateTime` representing the shown
    /// year, month and the selected day.
    /// 
    /// The returned date is in the local time zone.
    @inlinable var date: GLib.DateTimeRef! {
        /// Returns a `GDateTime` representing the shown
        /// year, month and the selected day.
        /// 
        /// The returned date is in the local time zone.
        get {
            let rv = GLib.DateTimeRef(gtk_calendar_get_date(calendar_ptr))
            return rv
        }
    }

    /// Returns whether `self` is currently showing the names
    /// of the week days.
    /// 
    /// This is the value of the [property`Gtk.Calendar:show-day-names`]
    /// property.
    @inlinable var showDayNames: Bool {
        /// Returns whether `self` is currently showing the names
        /// of the week days.
        /// 
        /// This is the value of the [property`Gtk.Calendar:show-day-names`]
        /// property.
        get {
            let rv = ((gtk_calendar_get_show_day_names(calendar_ptr)) != 0)
            return rv
        }
        /// Sets whether the calendar shows day names.
        nonmutating set {
            gtk_calendar_set_show_day_names(calendar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether `self` is currently showing the heading.
    /// 
    /// This is the value of the [property`Gtk.Calendar:show-heading`]
    /// property.
    @inlinable var showHeading: Bool {
        /// Returns whether `self` is currently showing the heading.
        /// 
        /// This is the value of the [property`Gtk.Calendar:show-heading`]
        /// property.
        get {
            let rv = ((gtk_calendar_get_show_heading(calendar_ptr)) != 0)
            return rv
        }
        /// Sets whether the calendar should show a heading.
        /// 
        /// The heading contains the current year and month as well as
        /// buttons for changing both.
        nonmutating set {
            gtk_calendar_set_show_heading(calendar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether `self` is showing week numbers right
    /// now.
    /// 
    /// This is the value of the [property`Gtk.Calendar:show-week-numbers`]
    /// property.
    @inlinable var showWeekNumbers: Bool {
        /// Returns whether `self` is showing week numbers right
        /// now.
        /// 
        /// This is the value of the [property`Gtk.Calendar:show-week-numbers`]
        /// property.
        get {
            let rv = ((gtk_calendar_get_show_week_numbers(calendar_ptr)) != 0)
            return rv
        }
        /// Sets whether week numbers are shown in the calendar.
        nonmutating set {
            gtk_calendar_set_show_week_numbers(calendar_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - CallbackAction Class

/// A `GtkShortcutAction` that invokes a callback.
///
/// The `CallbackActionProtocol` protocol exposes the methods and properties of an underlying `GtkCallbackAction` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CallbackAction`.
/// Alternatively, use `CallbackActionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CallbackActionProtocol: ShortcutActionProtocol {
        /// Untyped pointer to the underlying `GtkCallbackAction` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCallbackAction` instance.
    var callback_action_ptr: UnsafeMutablePointer<GtkCallbackAction>! { get }

    /// Required Initialiser for types conforming to `CallbackActionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkShortcutAction` that invokes a callback.
///
/// The `CallbackActionRef` type acts as a lightweight Swift reference to an underlying `GtkCallbackAction` instance.
/// It exposes methods that can operate on this data type through `CallbackActionProtocol` conformance.
/// Use `CallbackActionRef` only as an `unowned` reference to an existing `GtkCallbackAction` instance.
///
public struct CallbackActionRef: CallbackActionProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCallbackAction` instance.
    /// For type-safe access, use the generated, typed pointer `callback_action_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CallbackActionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCallbackAction>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCallbackAction>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCallbackAction>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCallbackAction>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CallbackActionProtocol`
    @inlinable init<T: CallbackActionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CallbackActionProtocol>(_ other: T) -> CallbackActionRef { CallbackActionRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// A `GtkShortcutAction` that invokes a callback.
///
/// The `CallbackAction` type acts as a reference-counted owner of an underlying `GtkCallbackAction` instance.
/// It provides the methods that can operate on this data type through `CallbackActionProtocol` conformance.
/// Use `CallbackAction` as a strong reference or owner of a `GtkCallbackAction` instance.
///
open class CallbackAction: ShortcutAction, CallbackActionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCallbackAction>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCallbackAction>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCallbackAction>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCallbackAction>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCallbackAction`.
    /// i.e., ownership is transferred to the `CallbackAction` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCallbackAction>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CallbackActionProtocol`
    /// Will retain `GtkCallbackAction`.
    /// - Parameter other: an instance of a related type that implements `CallbackActionProtocol`
    @inlinable public init<T: CallbackActionProtocol>(callbackAction other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CallbackActionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no CallbackAction properties

public enum CallbackActionSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: CallbackAction has no signals
// MARK: CallbackAction Class: CallbackActionProtocol extension (methods and fields)
public extension CallbackActionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCallbackAction` instance.
    @inlinable var callback_action_ptr: UnsafeMutablePointer<GtkCallbackAction>! { return ptr?.assumingMemoryBound(to: GtkCallbackAction.self) }



}



// MARK: - CellArea Class

/// An abstract class for laying out GtkCellRenderers
/// 
/// The `GtkCellArea` is an abstract class for `GtkCellLayout` widgets
/// (also referred to as "layouting widgets") to interface with an
/// arbitrary number of `GtkCellRenderer`s and interact with the user
/// for a given `GtkTreeModel` row.
/// 
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
/// 
/// Usually users dont have to interact with the `GtkCellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
/// 
/// # Requesting area sizes
/// 
/// As outlined in
/// [GtkWidget’s geometry management section](#geometry-management),
/// GTK uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `GtkCellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `GtkTreeModel` rows.
/// 
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a `GtkTreeViewColumn`
/// always lines up the areas from top to bottom while a `GtkIconView`
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
/// 
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `GtkCellArea`
/// uses a `GtkCellArea`Context object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
/// 
/// The `GtkCellArea`Context is an opaque object specific to the
/// `GtkCellArea` which created it (see `gtk_cell_area_create_context()`).
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same `GtkCellArea`Context which
/// was used to request the sizes for a given `GtkTreeModel` row be
/// used when rendering or processing events for that row.
/// 
/// In order to request the width of all the rows at the root level
/// of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// int         minimum_width;
/// int         natural_width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
/// 
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `GtkCellArea`Context object and can be consulted
/// at any time.
/// 
/// This can be useful since `GtkCellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `GtkCellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see `g_timeout_add()`) and when the widget
/// is requested its actual width in [vfunc`Gtk.Widget.measure`]
/// it can simply consult the width accumulated so far in the
/// `GtkCellArea`Context object.
/// 
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_get_preferred_width (GtkWidget       *widget,
///                          int             *minimum_size,
///                          int             *natural_size)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
/// 
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (foo);
/// 
///   gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
/// }
/// ```
/// 
/// In the above example the Foo widget has to make sure that some
/// row sizes have been calculated (the amount of rows that Foo judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `GtkCellArea`Context.
/// 
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `GtkCellArea`Context does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `GtkCellArea`).
/// 
/// In order to request the height for width of all the rows at the
/// root level of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// int         minimum_height;
/// int         natural_height;
/// int         full_minimum_height = 0;
/// int         full_natural_height = 0;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
/// 
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
/// 
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
/// 
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to [vfunc`Gtk.Widget.measure`]. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
/// 
/// # Rendering Areas
/// 
/// Once area sizes have been acquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// [vfunc`Gtk.Widget.snapshot`] time.
/// 
/// A crude example of how to render all the rows at the root level
/// runs as follows:
/// 
/// (C Language Example):
/// ```C
/// GtkAllocation allocation;
/// GdkRectangle  cell_area = { 0, };
/// GtkTreeIter   iter;
/// int           minimum_width;
/// int           natural_width;
/// 
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
/// 
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
/// 
///     cell_area.y += cell_area.height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// the time the widget is allocated using `gtk_distribute_natural_allocation()`.
/// 
/// # Handling Events and Driving Keyboard Focus
/// 
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the `gtk_cell_area_event()`
/// API as they come in. Usually `GtkCellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the `GtkCellArea``focus-changed` signal to fire; as well as
/// `GtkCellArea``add-editable` in the case that an editable cell was
/// clicked and needs to start editing. You can call
/// `gtk_cell_area_stop_editing()` at any time to cancel any cell editing
/// that is currently in progress.
/// 
/// The `GtkCellArea` drives keyboard focus from cell to cell in a way
/// similar to `GtkWidget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
/// 
/// Layouting widgets that accept focus on cells should implement the
/// [vfunc`Gtk.Widget.focus`] virtual method. The layouting widget is always
/// responsible for knowing where `GtkTreeModel` rows are rendered inside
/// the widget, so at [vfunc`Gtk.Widget.focus`] time the layouting widget
/// should use the `GtkCellArea` methods to navigate focus inside the area
/// and then observe the GtkDirectionType to pass the focus to adjacent
/// rows and areas.
/// 
/// A basic example of how the [vfunc`Gtk.Widget.focus`] virtual method
/// should be implemented:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
///   int         focus_row;
///   gboolean    have_focus = FALSE;
/// 
///   focus_row = priv->focus_row;
/// 
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
/// 
///   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
/// 
///       if (gtk_cell_area_focus (priv->area, direction))
///         {
///            priv->focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv->model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
/// 
/// Note that the layouting widget is responsible for matching the
/// GtkDirectionType values to the way it lays out its cells.
/// 
/// # Cell Properties
/// 
/// The `GtkCellArea` introduces cell properties for `GtkCellRenderer`s.
/// This provides some general interfaces for defining the relationship
/// cell areas have with their cells. For instance in a `GtkCellArea`Box
/// a cell might “expand” and receive extra space when the area is allocated
/// more than its full natural request, or a cell might be configured to “align”
/// with adjacent rows which were requested and rendered with the same
/// `GtkCellArea`Context.
/// 
/// Use `gtk_cell_area_class_install_cell_property()` to install cell
/// properties for a cell area class and `gtk_cell_area_class_find_cell_property()`
/// or `gtk_cell_area_class_list_cell_properties()` to get information about
/// existing cell properties.
/// 
/// To set the value of a cell property, use `gtk_cell_area_cell_set_property()`,
/// `gtk_cell_area_cell_set()` or `gtk_cell_area_cell_set_valist()`. To obtain
/// the value of a cell property, use `gtk_cell_area_cell_get_property()`,
/// `gtk_cell_area_cell_get()` or `gtk_cell_area_cell_get_valist()`.
///
/// The `CellAreaProtocol` protocol exposes the methods and properties of an underlying `GtkCellArea` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellArea`.
/// Alternatively, use `CellAreaRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellAreaProtocol: GLibObject.InitiallyUnownedProtocol, BuildableProtocol, CellLayoutProtocol {
        /// Untyped pointer to the underlying `GtkCellArea` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellArea` instance.
    var cell_area_ptr: UnsafeMutablePointer<GtkCellArea>! { get }

    /// Required Initialiser for types conforming to `CellAreaProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// An abstract class for laying out GtkCellRenderers
/// 
/// The `GtkCellArea` is an abstract class for `GtkCellLayout` widgets
/// (also referred to as "layouting widgets") to interface with an
/// arbitrary number of `GtkCellRenderer`s and interact with the user
/// for a given `GtkTreeModel` row.
/// 
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
/// 
/// Usually users dont have to interact with the `GtkCellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
/// 
/// # Requesting area sizes
/// 
/// As outlined in
/// [GtkWidget’s geometry management section](#geometry-management),
/// GTK uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `GtkCellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `GtkTreeModel` rows.
/// 
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a `GtkTreeViewColumn`
/// always lines up the areas from top to bottom while a `GtkIconView`
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
/// 
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `GtkCellArea`
/// uses a `GtkCellArea`Context object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
/// 
/// The `GtkCellArea`Context is an opaque object specific to the
/// `GtkCellArea` which created it (see `gtk_cell_area_create_context()`).
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same `GtkCellArea`Context which
/// was used to request the sizes for a given `GtkTreeModel` row be
/// used when rendering or processing events for that row.
/// 
/// In order to request the width of all the rows at the root level
/// of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// int         minimum_width;
/// int         natural_width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
/// 
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `GtkCellArea`Context object and can be consulted
/// at any time.
/// 
/// This can be useful since `GtkCellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `GtkCellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see `g_timeout_add()`) and when the widget
/// is requested its actual width in [vfunc`Gtk.Widget.measure`]
/// it can simply consult the width accumulated so far in the
/// `GtkCellArea`Context object.
/// 
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_get_preferred_width (GtkWidget       *widget,
///                          int             *minimum_size,
///                          int             *natural_size)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
/// 
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (foo);
/// 
///   gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
/// }
/// ```
/// 
/// In the above example the Foo widget has to make sure that some
/// row sizes have been calculated (the amount of rows that Foo judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `GtkCellArea`Context.
/// 
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `GtkCellArea`Context does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `GtkCellArea`).
/// 
/// In order to request the height for width of all the rows at the
/// root level of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// int         minimum_height;
/// int         natural_height;
/// int         full_minimum_height = 0;
/// int         full_natural_height = 0;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
/// 
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
/// 
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
/// 
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to [vfunc`Gtk.Widget.measure`]. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
/// 
/// # Rendering Areas
/// 
/// Once area sizes have been acquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// [vfunc`Gtk.Widget.snapshot`] time.
/// 
/// A crude example of how to render all the rows at the root level
/// runs as follows:
/// 
/// (C Language Example):
/// ```C
/// GtkAllocation allocation;
/// GdkRectangle  cell_area = { 0, };
/// GtkTreeIter   iter;
/// int           minimum_width;
/// int           natural_width;
/// 
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
/// 
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
/// 
///     cell_area.y += cell_area.height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// the time the widget is allocated using `gtk_distribute_natural_allocation()`.
/// 
/// # Handling Events and Driving Keyboard Focus
/// 
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the `gtk_cell_area_event()`
/// API as they come in. Usually `GtkCellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the `GtkCellArea``focus-changed` signal to fire; as well as
/// `GtkCellArea``add-editable` in the case that an editable cell was
/// clicked and needs to start editing. You can call
/// `gtk_cell_area_stop_editing()` at any time to cancel any cell editing
/// that is currently in progress.
/// 
/// The `GtkCellArea` drives keyboard focus from cell to cell in a way
/// similar to `GtkWidget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
/// 
/// Layouting widgets that accept focus on cells should implement the
/// [vfunc`Gtk.Widget.focus`] virtual method. The layouting widget is always
/// responsible for knowing where `GtkTreeModel` rows are rendered inside
/// the widget, so at [vfunc`Gtk.Widget.focus`] time the layouting widget
/// should use the `GtkCellArea` methods to navigate focus inside the area
/// and then observe the GtkDirectionType to pass the focus to adjacent
/// rows and areas.
/// 
/// A basic example of how the [vfunc`Gtk.Widget.focus`] virtual method
/// should be implemented:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
///   int         focus_row;
///   gboolean    have_focus = FALSE;
/// 
///   focus_row = priv->focus_row;
/// 
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
/// 
///   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
/// 
///       if (gtk_cell_area_focus (priv->area, direction))
///         {
///            priv->focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv->model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
/// 
/// Note that the layouting widget is responsible for matching the
/// GtkDirectionType values to the way it lays out its cells.
/// 
/// # Cell Properties
/// 
/// The `GtkCellArea` introduces cell properties for `GtkCellRenderer`s.
/// This provides some general interfaces for defining the relationship
/// cell areas have with their cells. For instance in a `GtkCellArea`Box
/// a cell might “expand” and receive extra space when the area is allocated
/// more than its full natural request, or a cell might be configured to “align”
/// with adjacent rows which were requested and rendered with the same
/// `GtkCellArea`Context.
/// 
/// Use `gtk_cell_area_class_install_cell_property()` to install cell
/// properties for a cell area class and `gtk_cell_area_class_find_cell_property()`
/// or `gtk_cell_area_class_list_cell_properties()` to get information about
/// existing cell properties.
/// 
/// To set the value of a cell property, use `gtk_cell_area_cell_set_property()`,
/// `gtk_cell_area_cell_set()` or `gtk_cell_area_cell_set_valist()`. To obtain
/// the value of a cell property, use `gtk_cell_area_cell_get_property()`,
/// `gtk_cell_area_cell_get()` or `gtk_cell_area_cell_get_valist()`.
///
/// The `CellAreaRef` type acts as a lightweight Swift reference to an underlying `GtkCellArea` instance.
/// It exposes methods that can operate on this data type through `CellAreaProtocol` conformance.
/// Use `CellAreaRef` only as an `unowned` reference to an existing `GtkCellArea` instance.
///
public struct CellAreaRef: CellAreaProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellArea` instance.
    /// For type-safe access, use the generated, typed pointer `cell_area_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellAreaRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellArea>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellArea>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellArea>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellArea>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellAreaProtocol`
    @inlinable init<T: CellAreaProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellAreaProtocol>(_ other: T) -> CellAreaRef { CellAreaRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// An abstract class for laying out GtkCellRenderers
/// 
/// The `GtkCellArea` is an abstract class for `GtkCellLayout` widgets
/// (also referred to as "layouting widgets") to interface with an
/// arbitrary number of `GtkCellRenderer`s and interact with the user
/// for a given `GtkTreeModel` row.
/// 
/// The cell area handles events, focus navigation, drawing and
/// size requests and allocations for a given row of data.
/// 
/// Usually users dont have to interact with the `GtkCellArea` directly
/// unless they are implementing a cell-layouting widget themselves.
/// 
/// # Requesting area sizes
/// 
/// As outlined in
/// [GtkWidget’s geometry management section](#geometry-management),
/// GTK uses a height-for-width
/// geometry management system to compute the sizes of widgets and user
/// interfaces. `GtkCellArea` uses the same semantics to calculate the
/// size of an area for an arbitrary number of `GtkTreeModel` rows.
/// 
/// When requesting the size of a cell area one needs to calculate
/// the size for a handful of rows, and this will be done differently by
/// different layouting widgets. For instance a `GtkTreeViewColumn`
/// always lines up the areas from top to bottom while a `GtkIconView`
/// on the other hand might enforce that all areas received the same
/// width and wrap the areas around, requesting height for more cell
/// areas when allocated less width.
/// 
/// It’s also important for areas to maintain some cell
/// alignments with areas rendered for adjacent rows (cells can
/// appear “columnized” inside an area even when the size of
/// cells are different in each row). For this reason the `GtkCellArea`
/// uses a `GtkCellArea`Context object to store the alignments
/// and sizes along the way (as well as the overall largest minimum
/// and natural size for all the rows which have been calculated
/// with the said context).
/// 
/// The `GtkCellArea`Context is an opaque object specific to the
/// `GtkCellArea` which created it (see `gtk_cell_area_create_context()`).
/// The owning cell-layouting widget can create as many contexts as
/// it wishes to calculate sizes of rows which should receive the
/// same size in at least one orientation (horizontally or vertically),
/// However, it’s important that the same `GtkCellArea`Context which
/// was used to request the sizes for a given `GtkTreeModel` row be
/// used when rendering or processing events for that row.
/// 
/// In order to request the width of all the rows at the root level
/// of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// int         minimum_width;
/// int         natural_width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
/// ```
/// 
/// Note that in this example it’s not important to observe the
/// returned minimum and natural width of the area for each row
/// unless the cell-layouting object is actually interested in the
/// widths of individual rows. The overall width is however stored
/// in the accompanying `GtkCellArea`Context object and can be consulted
/// at any time.
/// 
/// This can be useful since `GtkCellLayout` widgets usually have to
/// support requesting and rendering rows in treemodels with an
/// exceedingly large amount of rows. The `GtkCellLayout` widget in
/// that case would calculate the required width of the rows in an
/// idle or timeout source (see `g_timeout_add()`) and when the widget
/// is requested its actual width in [vfunc`Gtk.Widget.measure`]
/// it can simply consult the width accumulated so far in the
/// `GtkCellArea`Context object.
/// 
/// A simple example where rows are rendered from top to bottom and
/// take up the full width of the layouting widget would look like:
/// 
/// (C Language Example):
/// ```C
/// static void
/// foo_get_preferred_width (GtkWidget       *widget,
///                          int             *minimum_size,
///                          int             *natural_size)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
/// 
///   foo_ensure_at_least_one_handfull_of_rows_have_been_requested (foo);
/// 
///   gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
/// }
/// ```
/// 
/// In the above example the Foo widget has to make sure that some
/// row sizes have been calculated (the amount of rows that Foo judged
/// was appropriate to request space for in a single timeout iteration)
/// before simply returning the amount of space required by the area via
/// the `GtkCellArea`Context.
/// 
/// Requesting the height for width (or width for height) of an area is
/// a similar task except in this case the `GtkCellArea`Context does not
/// store the data (actually, it does not know how much space the layouting
/// widget plans to allocate it for every row. It’s up to the layouting
/// widget to render each row of data with the appropriate height and
/// width which was requested by the `GtkCellArea`).
/// 
/// In order to request the height for width of all the rows at the
/// root level of a `GtkTreeModel` one would do the following:
/// 
/// (C Language Example):
/// ```C
/// GtkTreeIter iter;
/// int         minimum_height;
/// int         natural_height;
/// int         full_minimum_height = 0;
/// int         full_natural_height = 0;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_get_preferred_height_for_width (area, context, widget,
///                                                   width, &minimum_height, &natural_height);
/// 
///     if (width_is_for_allocation)
///        cache_row_height (&iter, minimum_height, natural_height);
/// 
///     full_minimum_height += minimum_height;
///     full_natural_height += natural_height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that in the above example we would need to cache the heights
/// returned for each row so that we would know what sizes to render the
/// areas for each row. However we would only want to really cache the
/// heights if the request is intended for the layouting widgets real
/// allocation.
/// 
/// In some cases the layouting widget is requested the height for an
/// arbitrary for_width, this is a special case for layouting widgets
/// who need to request size for tens of thousands  of rows. For this
/// case it’s only important that the layouting widget calculate
/// one reasonably sized chunk of rows and return that height
/// synchronously. The reasoning here is that any layouting widget is
/// at least capable of synchronously calculating enough height to fill
/// the screen height (or scrolled window height) in response to a single
/// call to [vfunc`Gtk.Widget.measure`]. Returning
/// a perfect height for width that is larger than the screen area is
/// inconsequential since after the layouting receives an allocation
/// from a scrolled window it simply continues to drive the scrollbar
/// values while more and more height is required for the row heights
/// that are calculated in the background.
/// 
/// # Rendering Areas
/// 
/// Once area sizes have been acquired at least for the rows in the
/// visible area of the layouting widget they can be rendered at
/// [vfunc`Gtk.Widget.snapshot`] time.
/// 
/// A crude example of how to render all the rows at the root level
/// runs as follows:
/// 
/// (C Language Example):
/// ```C
/// GtkAllocation allocation;
/// GdkRectangle  cell_area = { 0, };
/// GtkTreeIter   iter;
/// int           minimum_width;
/// int           natural_width;
/// 
/// gtk_widget_get_allocation (widget, &allocation);
/// cell_area.width = allocation.width;
/// 
/// valid = gtk_tree_model_get_iter_first (model, &iter);
/// while (valid)
///   {
///     cell_area.height = get_cached_height_for_row (&iter);
/// 
///     gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
///     gtk_cell_area_render (area, context, widget, cr,
///                           &cell_area, &cell_area, state_flags, FALSE);
/// 
///     cell_area.y += cell_area.height;
/// 
///     valid = gtk_tree_model_iter_next (model, &iter);
///   }
/// ```
/// 
/// Note that the cached height in this example really depends on how
/// the layouting widget works. The layouting widget might decide to
/// give every row its minimum or natural height or, if the model content
/// is expected to fit inside the layouting widget without scrolling, it
/// would make sense to calculate the allocation for each row at
/// the time the widget is allocated using `gtk_distribute_natural_allocation()`.
/// 
/// # Handling Events and Driving Keyboard Focus
/// 
/// Passing events to the area is as simple as handling events on any
/// normal widget and then passing them to the `gtk_cell_area_event()`
/// API as they come in. Usually `GtkCellArea` is only interested in
/// button events, however some customized derived areas can be implemented
/// who are interested in handling other events. Handling an event can
/// trigger the `GtkCellArea``focus-changed` signal to fire; as well as
/// `GtkCellArea``add-editable` in the case that an editable cell was
/// clicked and needs to start editing. You can call
/// `gtk_cell_area_stop_editing()` at any time to cancel any cell editing
/// that is currently in progress.
/// 
/// The `GtkCellArea` drives keyboard focus from cell to cell in a way
/// similar to `GtkWidget`. For layouting widgets that support giving
/// focus to cells it’s important to remember to pass `GTK_CELL_RENDERER_FOCUSED`
/// to the area functions for the row that has focus and to tell the
/// area to paint the focus at render time.
/// 
/// Layouting widgets that accept focus on cells should implement the
/// [vfunc`Gtk.Widget.focus`] virtual method. The layouting widget is always
/// responsible for knowing where `GtkTreeModel` rows are rendered inside
/// the widget, so at [vfunc`Gtk.Widget.focus`] time the layouting widget
/// should use the `GtkCellArea` methods to navigate focus inside the area
/// and then observe the GtkDirectionType to pass the focus to adjacent
/// rows and areas.
/// 
/// A basic example of how the [vfunc`Gtk.Widget.focus`] virtual method
/// should be implemented:
/// 
/// (C Language Example):
/// ```C
/// static gboolean
/// foo_focus (GtkWidget       *widget,
///            GtkDirectionType direction)
/// {
///   Foo        *foo  = FOO (widget);
///   FooPrivate *priv = foo->priv;
///   int         focus_row;
///   gboolean    have_focus = FALSE;
/// 
///   focus_row = priv->focus_row;
/// 
///   if (!gtk_widget_has_focus (widget))
///     gtk_widget_grab_focus (widget);
/// 
///   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
///   while (valid)
///     {
///       gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
/// 
///       if (gtk_cell_area_focus (priv->area, direction))
///         {
///            priv->focus_row = focus_row;
///            have_focus = TRUE;
///            break;
///         }
///       else
///         {
///           if (direction == GTK_DIR_RIGHT ||
///               direction == GTK_DIR_LEFT)
///             break;
///           else if (direction == GTK_DIR_UP ||
///                    direction == GTK_DIR_TAB_BACKWARD)
///            {
///               if (focus_row == 0)
///                 break;
///               else
///                {
///                   focus_row--;
///                   valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
///                }
///             }
///           else
///             {
///               if (focus_row == last_row)
///                 break;
///               else
///                 {
///                   focus_row++;
///                   valid = gtk_tree_model_iter_next (priv->model, &iter);
///                 }
///             }
///         }
///     }
///     return have_focus;
/// }
/// ```
/// 
/// Note that the layouting widget is responsible for matching the
/// GtkDirectionType values to the way it lays out its cells.
/// 
/// # Cell Properties
/// 
/// The `GtkCellArea` introduces cell properties for `GtkCellRenderer`s.
/// This provides some general interfaces for defining the relationship
/// cell areas have with their cells. For instance in a `GtkCellArea`Box
/// a cell might “expand” and receive extra space when the area is allocated
/// more than its full natural request, or a cell might be configured to “align”
/// with adjacent rows which were requested and rendered with the same
/// `GtkCellArea`Context.
/// 
/// Use `gtk_cell_area_class_install_cell_property()` to install cell
/// properties for a cell area class and `gtk_cell_area_class_find_cell_property()`
/// or `gtk_cell_area_class_list_cell_properties()` to get information about
/// existing cell properties.
/// 
/// To set the value of a cell property, use `gtk_cell_area_cell_set_property()`,
/// `gtk_cell_area_cell_set()` or `gtk_cell_area_cell_set_valist()`. To obtain
/// the value of a cell property, use `gtk_cell_area_cell_get_property()`,
/// `gtk_cell_area_cell_get()` or `gtk_cell_area_cell_get_valist()`.
///
/// The `CellArea` type acts as a reference-counted owner of an underlying `GtkCellArea` instance.
/// It provides the methods that can operate on this data type through `CellAreaProtocol` conformance.
/// Use `CellArea` as a strong reference or owner of a `GtkCellArea` instance.
///
open class CellArea: GLibObject.InitiallyUnowned, CellAreaProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellArea>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellArea>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellArea>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellArea>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellArea`.
    /// i.e., ownership is transferred to the `CellArea` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellArea>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellAreaProtocol`
    /// Will retain `GtkCellArea`.
    /// - Parameter other: an instance of a related type that implements `CellAreaProtocol`
    @inlinable public init<T: CellAreaProtocol>(cellArea other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum CellAreaPropertyName: String, PropertyNameProtocol {
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editWidget = "edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editedCell = "edited-cell"
    /// The cell in the area that currently has focus
    case focusCell = "focus-cell"
}

public extension CellAreaProtocol {
    /// Bind a `CellAreaPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAreaPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellArea property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellAreaPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellArea property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellAreaPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellAreaSignalName: String, SignalNameProtocol {
    /// Indicates that editing has started on `renderer` and that `editable`
    /// should be added to the owning cell-layouting widget at `cell_area`.
    case addEditable = "add-editable"
    /// This signal is emitted whenever applying attributes to `area` from `model`
    case applyAttributes = "apply-attributes"
    /// Indicates that focus changed on this `area`. This signal
    /// is emitted either as a result of focus handling or event
    /// handling.
    /// 
    /// It's possible that the signal is emitted even if the
    /// currently focused renderer did not change, this is
    /// because focus may change to the same renderer in the
    /// same cell area for a different row of data.
    case focusChanged = "focus-changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Indicates that editing finished on `renderer` and that `editable`
    /// should be removed from the owning cell-layouting widget.
    case removeEditable = "remove-editable"
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditWidget = "notify::edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditedCell = "notify::edited-cell"
    /// The cell in the area that currently has focus
    case notifyFocusCell = "notify::focus-cell"
}

// MARK: CellArea signals
public extension CellAreaProtocol {
    /// Connect a Swift signal handler to the given, typed `CellAreaSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellAreaSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellAreaSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellAreaSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Indicates that editing has started on `renderer` and that `editable`
    /// should be added to the owning cell-layouting widget at `cell_area`.
    /// - Note: This represents the underlying `add-editable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter renderer: the `GtkCellRenderer` that started the edited
    /// - Parameter editable: the `GtkCellEditable` widget to add
    /// - Parameter cellArea: the `GtkWidget` relative `GdkRectangle` coordinates             where `editable` should be added
    /// - Parameter path: the `GtkTreePath` string this edit was initiated for
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `addEditable` signal is emitted
    @discardableResult @inlinable func onAddEditable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ renderer: CellRendererRef, _ editable: CellEditableRef, _ cellArea: Gdk.RectangleRef, _ path: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder5<CellAreaRef, CellRendererRef, CellEditableRef, Gdk.RectangleRef, String, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, arg4, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellAreaRef(raw: unownedSelf), CellRendererRef(raw: arg1), CellEditableRef(raw: arg2), Gdk.RectangleRef(raw: arg3), arg4.map({ String(cString: $0) })!)
            return output
        }
        return connect(
            signal: .addEditable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `add-editable` signal for using the `connect(signal:)` methods
    static var addEditableSignal: CellAreaSignalName { .addEditable }
    
    /// This signal is emitted whenever applying attributes to `area` from `model`
    /// - Note: This represents the underlying `apply-attributes` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter model: the `GtkTreeModel` to apply the attributes from
    /// - Parameter iter: the `GtkTreeIter` indicating which row to apply the attributes of
    /// - Parameter isExpander: whether the view shows children for this row
    /// - Parameter isExpanded: whether the view is currently showing the children of this row
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `applyAttributes` signal is emitted
    @discardableResult @inlinable func onApplyAttributes(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ model: TreeModelRef, _ iter: TreeIterRef, _ isExpander: Bool, _ isExpanded: Bool) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder5<CellAreaRef, TreeModelRef, TreeIterRef, Bool, Bool, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gboolean, gboolean, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, arg4, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellAreaRef(raw: unownedSelf), TreeModelRef(raw: arg1), TreeIterRef(raw: arg2), ((arg3) != 0), ((arg4) != 0))
            return output
        }
        return connect(
            signal: .applyAttributes,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `apply-attributes` signal for using the `connect(signal:)` methods
    static var applyAttributesSignal: CellAreaSignalName { .applyAttributes }
    
    /// Indicates that focus changed on this `area`. This signal
    /// is emitted either as a result of focus handling or event
    /// handling.
    /// 
    /// It's possible that the signal is emitted even if the
    /// currently focused renderer did not change, this is
    /// because focus may change to the same renderer in the
    /// same cell area for a different row of data.
    /// - Note: This represents the underlying `focus-changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter renderer: the `GtkCellRenderer` that has focus
    /// - Parameter path: the current `GtkTreePath` string set for `area`
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `focusChanged` signal is emitted
    @discardableResult @inlinable func onFocusChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ renderer: CellRendererRef, _ path: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<CellAreaRef, CellRendererRef, String, Void>
        let cCallback: @convention(c) (gpointer, gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellAreaRef(raw: unownedSelf), CellRendererRef(raw: arg1), arg2.map({ String(cString: $0) })!)
            return output
        }
        return connect(
            signal: .focusChanged,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `focus-changed` signal for using the `connect(signal:)` methods
    static var focusChangedSignal: CellAreaSignalName { .focusChanged }
    
    /// Indicates that editing finished on `renderer` and that `editable`
    /// should be removed from the owning cell-layouting widget.
    /// - Note: This represents the underlying `remove-editable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter renderer: the `GtkCellRenderer` that finished editeding
    /// - Parameter editable: the `GtkCellEditable` widget to remove
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `removeEditable` signal is emitted
    @discardableResult @inlinable func onRemoveEditable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ renderer: CellRendererRef, _ editable: CellEditableRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<CellAreaRef, CellRendererRef, CellEditableRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellAreaRef(raw: unownedSelf), CellRendererRef(raw: arg1), CellEditableRef(raw: arg2))
            return output
        }
        return connect(
            signal: .removeEditable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `remove-editable` signal for using the `connect(signal:)` methods
    static var removeEditableSignal: CellAreaSignalName { .removeEditable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::edit-widget` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditWidget` signal is emitted
    @discardableResult @inlinable func onNotifyEditWidget(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellAreaRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellAreaRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEditWidget,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::edit-widget` signal for using the `connect(signal:)` methods
    static var notifyEditWidgetSignal: CellAreaSignalName { .notifyEditWidget }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::edited-cell` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditedCell` signal is emitted
    @discardableResult @inlinable func onNotifyEditedCell(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellAreaRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellAreaRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEditedCell,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::edited-cell` signal for using the `connect(signal:)` methods
    static var notifyEditedCellSignal: CellAreaSignalName { .notifyEditedCell }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::focus-cell` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFocusCell` signal is emitted
    @discardableResult @inlinable func onNotifyFocusCell(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellAreaRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellAreaRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellAreaRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFocusCell,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::focus-cell` signal for using the `connect(signal:)` methods
    static var notifyFocusCellSignal: CellAreaSignalName { .notifyFocusCell }
    
}

// MARK: CellArea Class: CellAreaProtocol extension (methods and fields)
public extension CellAreaProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellArea` instance.
    @inlinable var cell_area_ptr: UnsafeMutablePointer<GtkCellArea>! { return ptr?.assumingMemoryBound(to: GtkCellArea.self) }

    /// Activates `area`, usually by activating the currently focused
    /// cell, however some subclasses which embed widgets in the area
    /// can also activate a widget if it currently has the focus.
    @inlinable func activate<CellAreaContextT: CellAreaContextProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, cellArea: RectangleT, flags: CellRendererState, editOnly: Bool) -> Bool {
        let rv = ((gtk_cell_area_activate(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, cellArea.rectangle_ptr, flags.value, gboolean((editOnly) ? 1 : 0))) != 0)
        return rv
    }

    /// This is used by `GtkCellArea` subclasses when handling events
    /// to activate cells, the base `GtkCellArea` class activates cells
    /// for keyboard events for free in its own GtkCellArea-&gt;`activate()`
    /// implementation.
    @inlinable func activateCell<CellRendererT: CellRendererProtocol, EventT: Gdk.EventProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(widget: WidgetT, renderer: CellRendererT, event: EventT, cellArea: RectangleT, flags: CellRendererState) -> Bool {
        let rv = ((gtk_cell_area_activate_cell(cell_area_ptr, widget.widget_ptr, renderer.cell_renderer_ptr, event.event_ptr, cellArea.rectangle_ptr, flags.value)) != 0)
        return rv
    }

    /// Adds `renderer` to `area` with the default child cell properties.
    @inlinable func add<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) {
        gtk_cell_area_add(cell_area_ptr, renderer.cell_renderer_ptr)
    
    }

    /// Adds `sibling` to `renderer`’s focusable area, focus will be drawn
    /// around `renderer` and all of its siblings if `renderer` can
    /// focus for a given row.
    /// 
    /// Events handled by focus siblings can also activate the given
    /// focusable `renderer`.
    @inlinable func addFocusSibling<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, sibling: CellRendererT) {
        gtk_cell_area_add_focus_sibling(cell_area_ptr, renderer.cell_renderer_ptr, sibling.cell_renderer_ptr)
    
    }


    // *** addWithProperties() is not available because it has a varargs (...) parameter!


    /// Applies any connected attributes to the renderers in
    /// `area` by pulling the values from `tree_model`.
    @inlinable func applyAttributes<TreeIterT: TreeIterProtocol, TreeModelT: TreeModelProtocol>(treeModel: TreeModelT, iter: TreeIterT, isExpander: Bool, isExpanded: Bool) {
        gtk_cell_area_apply_attributes(cell_area_ptr, treeModel.tree_model_ptr, iter.tree_iter_ptr, gboolean((isExpander) ? 1 : 0), gboolean((isExpanded) ? 1 : 0))
    
    }

    /// Connects an `attribute` to apply values from `column` for the
    /// `GtkTreeModel` in use.
    @inlinable func attributeConnect<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, attribute: UnsafePointer<CChar>!, column: Int) {
        gtk_cell_area_attribute_connect(cell_area_ptr, renderer.cell_renderer_ptr, attribute, gint(column))
    
    }

    /// Disconnects `attribute` for the `renderer` in `area` so that
    /// attribute will no longer be updated with values from the
    /// model.
    @inlinable func attributeDisconnect<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, attribute: UnsafePointer<CChar>!) {
        gtk_cell_area_attribute_disconnect(cell_area_ptr, renderer.cell_renderer_ptr, attribute)
    
    }

    /// Returns the model column that an attribute has been mapped to,
    /// or -1 if the attribute is not mapped.
    @inlinable func attributeGetColumn<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, attribute: UnsafePointer<CChar>!) -> Int {
        let rv = Int(gtk_cell_area_attribute_get_column(cell_area_ptr, renderer.cell_renderer_ptr, attribute))
        return rv
    }


    // *** cellGet() is not available because it has a varargs (...) parameter!


    /// Gets the value of a cell property for `renderer` in `area`.
    @inlinable func cellGetProperty<CellRendererT: CellRendererProtocol, ValueT: GLibObject.ValueProtocol>(renderer: CellRendererT, propertyName: UnsafePointer<CChar>!, value: ValueT) {
        gtk_cell_area_cell_get_property(cell_area_ptr, renderer.cell_renderer_ptr, propertyName, value.value_ptr)
    
    }

    /// Gets the values of one or more cell properties for `renderer` in `area`.
    @inlinable func cellGetValist<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, firstPropertyName: UnsafePointer<CChar>!, varArgs: CVaListPointer) {
        gtk_cell_area_cell_get_valist(cell_area_ptr, renderer.cell_renderer_ptr, firstPropertyName, varArgs)
    
    }


    // *** cellSet() is not available because it has a varargs (...) parameter!


    /// Sets a cell property for `renderer` in `area`.
    @inlinable func cellSetProperty<CellRendererT: CellRendererProtocol, ValueT: GLibObject.ValueProtocol>(renderer: CellRendererT, propertyName: UnsafePointer<CChar>!, value: ValueT) {
        gtk_cell_area_cell_set_property(cell_area_ptr, renderer.cell_renderer_ptr, propertyName, value.value_ptr)
    
    }

    /// Sets one or more cell properties for `renderer` in `area`.
    @inlinable func cellSetValist<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, firstPropertyName: UnsafePointer<CChar>!, varArgs: CVaListPointer) {
        gtk_cell_area_cell_set_valist(cell_area_ptr, renderer.cell_renderer_ptr, firstPropertyName, varArgs)
    
    }

    /// This is sometimes needed for cases where rows need to share
    /// alignments in one orientation but may be separately grouped
    /// in the opposing orientation.
    /// 
    /// For instance, `GtkIconView` creates all icons (rows) to have
    /// the same width and the cells theirin to have the same
    /// horizontal alignments. However each row of icons may have
    /// a separate collective height. `GtkIconView` uses this to
    /// request the heights of each row based on a context which
    /// was already used to request all the row widths that are
    /// to be displayed.
    @inlinable func copy<CellAreaContextT: CellAreaContextProtocol>(context: CellAreaContextT) -> CellAreaContextRef! {
        let rv = CellAreaContextRef(gconstpointer: gconstpointer(gtk_cell_area_copy_context(cell_area_ptr, context.cell_area_context_ptr)))
        return rv
    }

    /// Creates a `GtkCellArea`Context to be used with `area` for
    /// all purposes. `GtkCellArea`Context stores geometry information
    /// for rows for which it was operated on, it is important to use
    /// the same context for the same row of data at all times (i.e.
    /// one should render and handle events with the same `GtkCellArea`Context
    /// which was used to request the size of those rows of data).
    @inlinable func createContext() -> CellAreaContextRef! {
        let rv = CellAreaContextRef(gconstpointer: gconstpointer(gtk_cell_area_create_context(cell_area_ptr)))
        return rv
    }

    /// Delegates event handling to a `GtkCellArea`.
    @inlinable func event<CellAreaContextT: CellAreaContextProtocol, EventT: Gdk.EventProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, event: EventT, cellArea: RectangleT, flags: CellRendererState) -> Int {
        let rv = Int(gtk_cell_area_event(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, event.event_ptr, cellArea.rectangle_ptr, flags.value))
        return rv
    }

    /// This should be called by the `area`’s owning layout widget
    /// when focus is to be passed to `area`, or moved within `area`
    /// for a given `direction` and row data.
    /// 
    /// Implementing `GtkCellArea` classes should implement this
    /// method to receive and navigate focus in its own way particular
    /// to how it lays out cells.
    @inlinable func focus(direction: GtkDirectionType) -> Bool {
        let rv = ((gtk_cell_area_focus(cell_area_ptr, direction)) != 0)
        return rv
    }

    /// Calls `callback` for every `GtkCellRenderer` in `area`.
    @inlinable func foreach(callback: GtkCellCallback?, callbackData: gpointer! = nil) {
        gtk_cell_area_foreach(cell_area_ptr, callback, callbackData)
    
    }

    /// Calls `callback` for every `GtkCellRenderer` in `area` with the
    /// allocated rectangle inside `cell_area`.
    @inlinable func foreachAlloc<CellAreaContextT: CellAreaContextProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, cellArea: RectangleT, backgroundArea: RectangleT, callback: GtkCellAllocCallback?, callbackData: gpointer! = nil) {
        gtk_cell_area_foreach_alloc(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, cellArea.rectangle_ptr, backgroundArea.rectangle_ptr, callback, callbackData)
    
    }

    /// Derives the allocation of `renderer` inside `area` if `area`
    /// were to be renderered in `cell_area`.
    @inlinable func getCellAllocation<CellAreaContextT: CellAreaContextProtocol, CellRendererT: CellRendererProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, renderer: CellRendererT, cellArea: RectangleT, allocation: RectangleT) {
        gtk_cell_area_get_cell_allocation(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, renderer.cell_renderer_ptr, cellArea.rectangle_ptr, allocation.rectangle_ptr)
    
    }

    /// Gets the `GtkCellRenderer` at `x` and `y` coordinates inside `area` and optionally
    /// returns the full cell allocation for it inside `cell_area`.
    @inlinable func getCellAtPosition<CellAreaContextT: CellAreaContextProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, cellArea: RectangleT, x: Int, y: Int, allocArea: RectangleT?) -> CellRendererRef! {
        let rv = CellRendererRef(gconstpointer: gconstpointer(gtk_cell_area_get_cell_at_position(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, cellArea.rectangle_ptr, gint(x), gint(y), allocArea?.rectangle_ptr)))
        return rv
    }

    /// Gets the current `GtkTreePath` string for the currently
    /// applied `GtkTreeIter`, this is implicitly updated when
    /// `gtk_cell_area_apply_attributes()` is called and can be
    /// used to interact with renderers from `GtkCellArea`
    /// subclasses.
    @inlinable func getCurrentPathString() -> String! {
        let rv = gtk_cell_area_get_current_path_string(cell_area_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Gets the `GtkCellEditable` widget currently used
    /// to edit the currently edited cell.
    @inlinable func getEditWidget() -> CellEditableRef! {
        let rv = CellEditableRef(gconstpointer: gconstpointer(gtk_cell_area_get_edit_widget(cell_area_ptr)))
        return rv
    }

    /// Gets the `GtkCellRenderer` in `area` that is currently
    /// being edited.
    @inlinable func getEditedCell() -> CellRendererRef! {
        let rv = CellRendererRef(gconstpointer: gconstpointer(gtk_cell_area_get_edited_cell(cell_area_ptr)))
        return rv
    }

    /// Retrieves the currently focused cell for `area`
    @inlinable func getFocusCell() -> CellRendererRef! {
        let rv = CellRendererRef(gconstpointer: gconstpointer(gtk_cell_area_get_focus_cell(cell_area_ptr)))
        return rv
    }

    /// Gets the `GtkCellRenderer` which is expected to be focusable
    /// for which `renderer` is, or may be a sibling.
    /// 
    /// This is handy for `GtkCellArea` subclasses when handling events,
    /// after determining the renderer at the event location it can
    /// then chose to activate the focus cell for which the event
    /// cell may have been a sibling.
    @inlinable func getFocusFromSibling<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) -> CellRendererRef! {
        let rv = CellRendererRef(gconstpointer: gconstpointer(gtk_cell_area_get_focus_from_sibling(cell_area_ptr, renderer.cell_renderer_ptr)))
        return rv
    }

    /// Gets the focus sibling cell renderers for `renderer`.
    @inlinable func getFocusSiblings<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) -> GLib.ListRef! {
        let rv = GLib.ListRef(gtk_cell_area_get_focus_siblings(cell_area_ptr, renderer.cell_renderer_ptr))
        return rv
    }

    /// Retrieves a cell area’s initial minimum and natural height.
    /// 
    /// `area` will store some geometrical information in `context` along the way;
    /// when requesting sizes over an arbitrary number of rows, it’s not important
    /// to check the `minimum_height` and `natural_height` of this call but rather to
    /// consult `gtk_cell_area_context_get_preferred_height()` after a series of
    /// requests.
    @inlinable func getPreferredHeight<CellAreaContextT: CellAreaContextProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_get_preferred_height(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, minimumHeight, naturalHeight)
    
    }

    /// Retrieves a cell area’s minimum and natural height if it would be given
    /// the specified `width`.
    /// 
    /// `area` stores some geometrical information in `context` along the way
    /// while calling `gtk_cell_area_get_preferred_width()`. It’s important to
    /// perform a series of `gtk_cell_area_get_preferred_width()` requests with
    /// `context` first and then call `gtk_cell_area_get_preferred_height_for_width()`
    /// on each cell area individually to get the height for width of each
    /// fully requested row.
    /// 
    /// If at some point, the width of a single row changes, it should be
    /// requested with `gtk_cell_area_get_preferred_width()` again and then
    /// the full width of the requested rows checked again with
    /// `gtk_cell_area_context_get_preferred_width()`.
    @inlinable func getPreferredHeightForWidth<CellAreaContextT: CellAreaContextProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, width: Int, minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_get_preferred_height_for_width(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, gint(width), minimumHeight, naturalHeight)
    
    }

    /// Retrieves a cell area’s initial minimum and natural width.
    /// 
    /// `area` will store some geometrical information in `context` along the way;
    /// when requesting sizes over an arbitrary number of rows, it’s not important
    /// to check the `minimum_width` and `natural_width` of this call but rather to
    /// consult `gtk_cell_area_context_get_preferred_width()` after a series of
    /// requests.
    @inlinable func getPreferredWidth<CellAreaContextT: CellAreaContextProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_get_preferred_width(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, minimumWidth, naturalWidth)
    
    }

    /// Retrieves a cell area’s minimum and natural width if it would be given
    /// the specified `height`.
    /// 
    /// `area` stores some geometrical information in `context` along the way
    /// while calling `gtk_cell_area_get_preferred_height()`. It’s important to
    /// perform a series of `gtk_cell_area_get_preferred_height()` requests with
    /// `context` first and then call `gtk_cell_area_get_preferred_width_for_height()`
    /// on each cell area individually to get the height for width of each
    /// fully requested row.
    /// 
    /// If at some point, the height of a single row changes, it should be
    /// requested with `gtk_cell_area_get_preferred_height()` again and then
    /// the full height of the requested rows checked again with
    /// `gtk_cell_area_context_get_preferred_height()`.
    @inlinable func getPreferredWidthForHeight<CellAreaContextT: CellAreaContextProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, height: Int, minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_get_preferred_width_for_height(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, gint(height), minimumWidth, naturalWidth)
    
    }

    /// Gets whether the area prefers a height-for-width layout
    /// or a width-for-height layout.
    @inlinable func getRequestMode() -> GtkSizeRequestMode {
        let rv = gtk_cell_area_get_request_mode(cell_area_ptr)
        return rv
    }

    /// Checks if `area` contains `renderer`.
    @inlinable func has<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) -> Bool {
        let rv = ((gtk_cell_area_has_renderer(cell_area_ptr, renderer.cell_renderer_ptr)) != 0)
        return rv
    }

    /// This is a convenience function for `GtkCellArea` implementations
    /// to get the inner area where a given `GtkCellRenderer` will be
    /// rendered. It removes any padding previously added by `gtk_cell_area_request_renderer()`.
    @inlinable func innerCellArea<RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(widget: WidgetT, cellArea: RectangleT, innerArea: RectangleT) {
        gtk_cell_area_inner_cell_area(cell_area_ptr, widget.widget_ptr, cellArea.rectangle_ptr, innerArea.rectangle_ptr)
    
    }

    /// Returns whether `sibling` is one of `renderer`’s focus siblings
    /// (see `gtk_cell_area_add_focus_sibling()`).
    @inlinable func isFocusSibling<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, sibling: CellRendererT) -> Bool {
        let rv = ((gtk_cell_area_is_focus_sibling(cell_area_ptr, renderer.cell_renderer_ptr, sibling.cell_renderer_ptr)) != 0)
        return rv
    }

    /// Removes `renderer` from `area`.
    @inlinable func remove<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) {
        gtk_cell_area_remove(cell_area_ptr, renderer.cell_renderer_ptr)
    
    }

    /// Removes `sibling` from `renderer`’s focus sibling list
    /// (see `gtk_cell_area_add_focus_sibling()`).
    @inlinable func removeFocusSibling<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, sibling: CellRendererT) {
        gtk_cell_area_remove_focus_sibling(cell_area_ptr, renderer.cell_renderer_ptr, sibling.cell_renderer_ptr)
    
    }

    /// This is a convenience function for `GtkCellArea` implementations
    /// to request size for cell renderers. It’s important to use this
    /// function to request size and then use `gtk_cell_area_inner_cell_area()`
    /// at render and event time since this function will add padding
    /// around the cell for focus painting.
    @inlinable func request<CellRendererT: CellRendererProtocol, WidgetT: WidgetProtocol>(renderer: CellRendererT, orientation: GtkOrientation, widget: WidgetT, `for` size: Int, minimumSize: UnsafeMutablePointer<gint>! = nil, naturalSize: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_request_renderer(cell_area_ptr, renderer.cell_renderer_ptr, orientation, widget.widget_ptr, gint(size), minimumSize, naturalSize)
    
    }

    /// Explicitly sets the currently focused cell to `renderer`.
    /// 
    /// This is generally called by implementations of
    /// ``GtkCellAreaClass.focus()`` or ``GtkCellAreaClass.event()``,
    /// however it can also be used to implement functions such
    /// as `gtk_tree_view_set_cursor_on_cell()`.
    @inlinable func setFocusCell<CellRendererT: CellRendererProtocol>(renderer: CellRendererT) {
        gtk_cell_area_set_focus_cell(cell_area_ptr, renderer.cell_renderer_ptr)
    
    }

    /// Snapshots `area`’s cells according to `area`’s layout onto at
    /// the given coordinates.
    @inlinable func snapshot<CellAreaContextT: CellAreaContextProtocol, RectangleT: Gdk.RectangleProtocol, SnapshotT: SnapshotProtocol, WidgetT: WidgetProtocol>(context: CellAreaContextT, widget: WidgetT, snapshot: SnapshotT, backgroundArea: RectangleT, cellArea: RectangleT, flags: CellRendererState, paintFocus: Bool) {
        gtk_cell_area_snapshot(cell_area_ptr, context.cell_area_context_ptr, widget.widget_ptr, snapshot.snapshot_ptr, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value, gboolean((paintFocus) ? 1 : 0))
    
    }

    /// Explicitly stops the editing of the currently edited cell.
    /// 
    /// If `canceled` is `true`, the currently edited cell renderer
    /// will emit the `editing-canceled` signal, otherwise the
    /// the `editing-done` signal will be emitted on the current
    /// edit widget.
    /// 
    /// See `gtk_cell_area_get_edited_cell()` and `gtk_cell_area_get_edit_widget()`.
    @inlinable func stopEditing(canceled: Bool) {
        gtk_cell_area_stop_editing(cell_area_ptr, gboolean((canceled) ? 1 : 0))
    
    }
    /// Gets the current `GtkTreePath` string for the currently
    /// applied `GtkTreeIter`, this is implicitly updated when
    /// `gtk_cell_area_apply_attributes()` is called and can be
    /// used to interact with renderers from `GtkCellArea`
    /// subclasses.
    @inlinable var currentPathString: String! {
        /// Gets the current `GtkTreePath` string for the currently
        /// applied `GtkTreeIter`, this is implicitly updated when
        /// `gtk_cell_area_apply_attributes()` is called and can be
        /// used to interact with renderers from `GtkCellArea`
        /// subclasses.
        get {
            let rv = gtk_cell_area_get_current_path_string(cell_area_ptr).map({ String(cString: $0) })
            return rv
        }
    }

    /// Gets the `GtkCellEditable` widget currently used
    /// to edit the currently edited cell.
    @inlinable var editWidget: CellEditableRef! {
        /// Gets the `GtkCellEditable` widget currently used
        /// to edit the currently edited cell.
        get {
            let rv = CellEditableRef(gconstpointer: gconstpointer(gtk_cell_area_get_edit_widget(cell_area_ptr)))
            return rv
        }
    }

    /// Gets the `GtkCellRenderer` in `area` that is currently
    /// being edited.
    @inlinable var editedCell: CellRendererRef! {
        /// Gets the `GtkCellRenderer` in `area` that is currently
        /// being edited.
        get {
            let rv = CellRendererRef(gconstpointer: gconstpointer(gtk_cell_area_get_edited_cell(cell_area_ptr)))
            return rv
        }
    }

    /// Retrieves the currently focused cell for `area`
    @inlinable var focusCell: CellRendererRef! {
        /// Retrieves the currently focused cell for `area`
        get {
            let rv = CellRendererRef(gconstpointer: gconstpointer(gtk_cell_area_get_focus_cell(cell_area_ptr)))
            return rv
        }
        /// Explicitly sets the currently focused cell to `renderer`.
        /// 
        /// This is generally called by implementations of
        /// ``GtkCellAreaClass.focus()`` or ``GtkCellAreaClass.event()``,
        /// however it can also be used to implement functions such
        /// as `gtk_tree_view_set_cursor_on_cell()`.
        nonmutating set {
            gtk_cell_area_set_focus_cell(cell_area_ptr, UnsafeMutablePointer<GtkCellRenderer>(newValue?.cell_renderer_ptr))
        }
    }

    /// Returns whether the area can do anything when activated,
    /// after applying new attributes to `area`.
    @inlinable var isActivatable: Bool {
        /// Returns whether the area can do anything when activated,
        /// after applying new attributes to `area`.
        get {
            let rv = ((gtk_cell_area_is_activatable(cell_area_ptr)) != 0)
            return rv
        }
    }

    /// Gets whether the area prefers a height-for-width layout
    /// or a width-for-height layout.
    @inlinable var requestMode: GtkSizeRequestMode {
        /// Gets whether the area prefers a height-for-width layout
        /// or a width-for-height layout.
        get {
            let rv = gtk_cell_area_get_request_mode(cell_area_ptr)
            return rv
        }
    }

    // var parentInstance is unavailable because parent_instance is private

}



// MARK: - CellAreaBox Class

/// A cell area that renders GtkCellRenderers into a row or a column
/// 
/// The `GtkCellAreaBox` renders cell renderers into a row or a column
/// depending on its `GtkOrientation`.
/// 
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `GtkCellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `GtkCellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
/// 
/// Alignments of `GtkCellRenderer`s rendered in adjacent rows can be
/// configured by configuring the `GtkCellAreaBox` align child cell property
/// with `gtk_cell_area_cell_set_property()` or by specifying the "align"
/// argument to `gtk_cell_area_box_pack_start()` and `gtk_cell_area_box_pack_end()`.
///
/// The `CellAreaBoxProtocol` protocol exposes the methods and properties of an underlying `GtkCellAreaBox` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellAreaBox`.
/// Alternatively, use `CellAreaBoxRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellAreaBoxProtocol: CellAreaProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkCellAreaBox` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellAreaBox` instance.
    var cell_area_box_ptr: UnsafeMutablePointer<GtkCellAreaBox>! { get }

    /// Required Initialiser for types conforming to `CellAreaBoxProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A cell area that renders GtkCellRenderers into a row or a column
/// 
/// The `GtkCellAreaBox` renders cell renderers into a row or a column
/// depending on its `GtkOrientation`.
/// 
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `GtkCellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `GtkCellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
/// 
/// Alignments of `GtkCellRenderer`s rendered in adjacent rows can be
/// configured by configuring the `GtkCellAreaBox` align child cell property
/// with `gtk_cell_area_cell_set_property()` or by specifying the "align"
/// argument to `gtk_cell_area_box_pack_start()` and `gtk_cell_area_box_pack_end()`.
///
/// The `CellAreaBoxRef` type acts as a lightweight Swift reference to an underlying `GtkCellAreaBox` instance.
/// It exposes methods that can operate on this data type through `CellAreaBoxProtocol` conformance.
/// Use `CellAreaBoxRef` only as an `unowned` reference to an existing `GtkCellAreaBox` instance.
///
public struct CellAreaBoxRef: CellAreaBoxProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellAreaBox` instance.
    /// For type-safe access, use the generated, typed pointer `cell_area_box_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellAreaBoxRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellAreaBox>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellAreaBox>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellAreaBox>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellAreaBox>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellAreaBoxProtocol`
    @inlinable init<T: CellAreaBoxProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellAreaBoxProtocol>(_ other: T) -> CellAreaBoxRef { CellAreaBoxRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellAreaBox`.
    @inlinable init() {
        let rv = gtk_cell_area_box_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A cell area that renders GtkCellRenderers into a row or a column
/// 
/// The `GtkCellAreaBox` renders cell renderers into a row or a column
/// depending on its `GtkOrientation`.
/// 
/// GtkCellAreaBox uses a notion of packing. Packing
/// refers to adding cell renderers with reference to a particular position
/// in a `GtkCellAreaBox`. There are two reference positions: the
/// start and the end of the box.
/// When the `GtkCellAreaBox` is oriented in the `GTK_ORIENTATION_VERTICAL`
/// orientation, the start is defined as the top of the box and the end is
/// defined as the bottom. In the `GTK_ORIENTATION_HORIZONTAL` orientation
/// start is defined as the left side and the end is defined as the right
/// side.
/// 
/// Alignments of `GtkCellRenderer`s rendered in adjacent rows can be
/// configured by configuring the `GtkCellAreaBox` align child cell property
/// with `gtk_cell_area_cell_set_property()` or by specifying the "align"
/// argument to `gtk_cell_area_box_pack_start()` and `gtk_cell_area_box_pack_end()`.
///
/// The `CellAreaBox` type acts as a reference-counted owner of an underlying `GtkCellAreaBox` instance.
/// It provides the methods that can operate on this data type through `CellAreaBoxProtocol` conformance.
/// Use `CellAreaBox` as a strong reference or owner of a `GtkCellAreaBox` instance.
///
open class CellAreaBox: CellArea, CellAreaBoxProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellAreaBox>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellAreaBox>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellAreaBox>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellAreaBox>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellAreaBox`.
    /// i.e., ownership is transferred to the `CellAreaBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellAreaBox>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellAreaBoxProtocol`
    /// Will retain `GtkCellAreaBox`.
    /// - Parameter other: an instance of a related type that implements `CellAreaBoxProtocol`
    @inlinable public init<T: CellAreaBoxProtocol>(cellAreaBox other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellAreaBox`.
    @inlinable public init() {
        let rv = gtk_cell_area_box_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellAreaBoxPropertyName: String, PropertyNameProtocol {
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editWidget = "edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case editedCell = "edited-cell"
    /// The cell in the area that currently has focus
    case focusCell = "focus-cell"
    /// The amount of space to reserve between cells.
    case spacing = "spacing"
}

public extension CellAreaBoxProtocol {
    /// Bind a `CellAreaBoxPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAreaBoxPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellAreaBox property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellAreaBoxPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellAreaBox property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellAreaBoxPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellAreaBoxSignalName: String, SignalNameProtocol {
    /// Indicates that editing has started on `renderer` and that `editable`
    /// should be added to the owning cell-layouting widget at `cell_area`.
    case addEditable = "add-editable"
    /// This signal is emitted whenever applying attributes to `area` from `model`
    case applyAttributes = "apply-attributes"
    /// Indicates that focus changed on this `area`. This signal
    /// is emitted either as a result of focus handling or event
    /// handling.
    /// 
    /// It's possible that the signal is emitted even if the
    /// currently focused renderer did not change, this is
    /// because focus may change to the same renderer in the
    /// same cell area for a different row of data.
    case focusChanged = "focus-changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Indicates that editing finished on `renderer` and that `editable`
    /// should be removed from the owning cell-layouting widget.
    case removeEditable = "remove-editable"
    /// The widget currently editing the edited cell
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditWidget = "notify::edit-widget"
    /// The cell in the area that is currently edited
    /// 
    /// This property is read-only and only changes as
    /// a result of a call `gtk_cell_area_activate_cell()`.
    case notifyEditedCell = "notify::edited-cell"
    /// The cell in the area that currently has focus
    case notifyFocusCell = "notify::focus-cell"
    /// The amount of space to reserve between cells.
    case notifySpacing = "notify::spacing"
}

// MARK: CellAreaBox has no signals
// MARK: CellAreaBox Class: CellAreaBoxProtocol extension (methods and fields)
public extension CellAreaBoxProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellAreaBox` instance.
    @inlinable var cell_area_box_ptr: UnsafeMutablePointer<GtkCellAreaBox>! { return ptr?.assumingMemoryBound(to: GtkCellAreaBox.self) }

    /// Gets the spacing added between cell renderers.
    @inlinable func getSpacing() -> Int {
        let rv = Int(gtk_cell_area_box_get_spacing(cell_area_box_ptr))
        return rv
    }

    /// Adds `renderer` to `box`, packed with reference to the end of `box`.
    /// 
    /// The `renderer` is packed after (away from end of) any other
    /// `GtkCellRenderer` packed with reference to the end of `box`.
    @inlinable func packEnd<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, expand: Bool, align: Bool, fixed: Bool) {
        gtk_cell_area_box_pack_end(cell_area_box_ptr, renderer.cell_renderer_ptr, gboolean((expand) ? 1 : 0), gboolean((align) ? 1 : 0), gboolean((fixed) ? 1 : 0))
    
    }

    /// Adds `renderer` to `box`, packed with reference to the start of `box`.
    /// 
    /// The `renderer` is packed after any other `GtkCellRenderer` packed
    /// with reference to the start of `box`.
    @inlinable func packStart<CellRendererT: CellRendererProtocol>(renderer: CellRendererT, expand: Bool, align: Bool, fixed: Bool) {
        gtk_cell_area_box_pack_start(cell_area_box_ptr, renderer.cell_renderer_ptr, gboolean((expand) ? 1 : 0), gboolean((align) ? 1 : 0), gboolean((fixed) ? 1 : 0))
    
    }

    /// Sets the spacing to add between cell renderers in `box`.
    @inlinable func set(spacing: Int) {
        gtk_cell_area_box_set_spacing(cell_area_box_ptr, gint(spacing))
    
    }
    /// The amount of space to reserve between cells.
    @inlinable var spacing: Int {
        /// Gets the spacing added between cell renderers.
        get {
            let rv = Int(gtk_cell_area_box_get_spacing(cell_area_box_ptr))
            return rv
        }
        /// Sets the spacing to add between cell renderers in `box`.
        nonmutating set {
            gtk_cell_area_box_set_spacing(cell_area_box_ptr, gint(newValue))
        }
    }


}



// MARK: - CellAreaContext Class

/// Stores geometrical information for a series of rows in a GtkCellArea
/// 
/// The `GtkCellAreaContext` object is created by a given `GtkCellArea`
/// implementation via its ``GtkCellAreaClass.create_context()`` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `GtkTreeModel` rows that are requested and rendered in the same context.
/// 
/// `GtkCellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `GtkTreeModel`
/// row also be used for the same row when calling other `GtkCellArea` APIs
/// such as `gtk_cell_area_render()` and `gtk_cell_area_event()`.
///
/// The `CellAreaContextProtocol` protocol exposes the methods and properties of an underlying `GtkCellAreaContext` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellAreaContext`.
/// Alternatively, use `CellAreaContextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellAreaContextProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkCellAreaContext` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellAreaContext` instance.
    var cell_area_context_ptr: UnsafeMutablePointer<GtkCellAreaContext>! { get }

    /// Required Initialiser for types conforming to `CellAreaContextProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Stores geometrical information for a series of rows in a GtkCellArea
/// 
/// The `GtkCellAreaContext` object is created by a given `GtkCellArea`
/// implementation via its ``GtkCellAreaClass.create_context()`` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `GtkTreeModel` rows that are requested and rendered in the same context.
/// 
/// `GtkCellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `GtkTreeModel`
/// row also be used for the same row when calling other `GtkCellArea` APIs
/// such as `gtk_cell_area_render()` and `gtk_cell_area_event()`.
///
/// The `CellAreaContextRef` type acts as a lightweight Swift reference to an underlying `GtkCellAreaContext` instance.
/// It exposes methods that can operate on this data type through `CellAreaContextProtocol` conformance.
/// Use `CellAreaContextRef` only as an `unowned` reference to an existing `GtkCellAreaContext` instance.
///
public struct CellAreaContextRef: CellAreaContextProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellAreaContext` instance.
    /// For type-safe access, use the generated, typed pointer `cell_area_context_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellAreaContextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellAreaContext>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellAreaContext>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellAreaContext>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellAreaContext>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellAreaContextProtocol`
    @inlinable init<T: CellAreaContextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellAreaContextProtocol>(_ other: T) -> CellAreaContextRef { CellAreaContextRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// Stores geometrical information for a series of rows in a GtkCellArea
/// 
/// The `GtkCellAreaContext` object is created by a given `GtkCellArea`
/// implementation via its ``GtkCellAreaClass.create_context()`` virtual
/// method and is used to store cell sizes and alignments for a series of
/// `GtkTreeModel` rows that are requested and rendered in the same context.
/// 
/// `GtkCellLayout` widgets can create any number of contexts in which to
/// request and render groups of data rows. However, it’s important that the
/// same context which was used to request sizes for a given `GtkTreeModel`
/// row also be used for the same row when calling other `GtkCellArea` APIs
/// such as `gtk_cell_area_render()` and `gtk_cell_area_event()`.
///
/// The `CellAreaContext` type acts as a reference-counted owner of an underlying `GtkCellAreaContext` instance.
/// It provides the methods that can operate on this data type through `CellAreaContextProtocol` conformance.
/// Use `CellAreaContext` as a strong reference or owner of a `GtkCellAreaContext` instance.
///
open class CellAreaContext: GLibObject.Object, CellAreaContextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellAreaContext>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellAreaContext>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellAreaContext>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellAreaContext>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellAreaContext`.
    /// i.e., ownership is transferred to the `CellAreaContext` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellAreaContext>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellAreaContextProtocol`
    /// Will retain `GtkCellAreaContext`.
    /// - Parameter other: an instance of a related type that implements `CellAreaContextProtocol`
    @inlinable public init<T: CellAreaContextProtocol>(cellAreaContext other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellAreaContextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum CellAreaContextPropertyName: String, PropertyNameProtocol {
    /// The `GtkCellArea` this context was created by
    case area = "area"
    /// The minimum height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case minimumHeight = "minimum-height"
    /// The minimum width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case minimumWidth = "minimum-width"
    /// The natural height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case naturalHeight = "natural-height"
    /// The natural width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case naturalWidth = "natural-width"
}

public extension CellAreaContextProtocol {
    /// Bind a `CellAreaContextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellAreaContextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellAreaContext property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellAreaContextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellAreaContext property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellAreaContextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellAreaContextSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `GtkCellArea` this context was created by
    case notifyArea = "notify::area"
    /// The minimum height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case notifyMinimumHeight = "notify::minimum-height"
    /// The minimum width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case notifyMinimumWidth = "notify::minimum-width"
    /// The natural height for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_height()`.
    case notifyNaturalHeight = "notify::natural-height"
    /// The natural width for the `GtkCellArea` in this context
    /// for all `GtkTreeModel` rows that this context was requested
    /// for using `gtk_cell_area_get_preferred_width()`.
    case notifyNaturalWidth = "notify::natural-width"
}

// MARK: CellAreaContext has no signals
// MARK: CellAreaContext Class: CellAreaContextProtocol extension (methods and fields)
public extension CellAreaContextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellAreaContext` instance.
    @inlinable var cell_area_context_ptr: UnsafeMutablePointer<GtkCellAreaContext>! { return ptr?.assumingMemoryBound(to: GtkCellAreaContext.self) }

    /// Allocates a width and/or a height for all rows which are to be
    /// rendered with `context`.
    /// 
    /// Usually allocation is performed only horizontally or sometimes
    /// vertically since a group of rows are usually rendered side by
    /// side vertically or horizontally and share either the same width
    /// or the same height. Sometimes they are allocated in both horizontal
    /// and vertical orientations producing a homogeneous effect of the
    /// rows. This is generally the case for `GtkTreeView` when
    /// `GtkTreeView:fixed-height-mode` is enabled.
    @inlinable func allocate(width: Int, height: Int) {
        gtk_cell_area_context_allocate(cell_area_context_ptr, gint(width), gint(height))
    
    }

    /// Fetches the current allocation size for `context`.
    /// 
    /// If the context was not allocated in width or height, or if the
    /// context was recently reset with `gtk_cell_area_context_reset()`,
    /// the returned value will be -1.
    @inlinable func getAllocation(width: UnsafeMutablePointer<gint>! = nil, height: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_context_get_allocation(cell_area_context_ptr, width, height)
    
    }

    /// Fetches the `GtkCellArea` this `context` was created by.
    /// 
    /// This is generally unneeded by layouting widgets; however,
    /// it is important for the context implementation itself to
    /// fetch information about the area it is being used for.
    /// 
    /// For instance at ``GtkCellAreaContextClass.allocate()`` time
    /// it’s important to know details about any cell spacing
    /// that the `GtkCellArea` is configured with in order to
    /// compute a proper allocation.
    @inlinable func getArea() -> CellAreaRef! {
        let rv = CellAreaRef(gconstpointer: gconstpointer(gtk_cell_area_context_get_area(cell_area_context_ptr)))
        return rv
    }

    /// Gets the accumulative preferred height for all rows which have been
    /// requested with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are 0.
    @inlinable func getPreferredHeight(minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_context_get_preferred_height(cell_area_context_ptr, minimumHeight, naturalHeight)
    
    }

    /// Gets the accumulative preferred height for `width` for all rows
    /// which have been requested for the same said `width` with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are -1.
    @inlinable func getPreferredHeightFor(width: Int, minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_context_get_preferred_height_for_width(cell_area_context_ptr, gint(width), minimumHeight, naturalHeight)
    
    }

    /// Gets the accumulative preferred width for all rows which have been
    /// requested with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are 0.
    @inlinable func getPreferredWidth(minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_context_get_preferred_width(cell_area_context_ptr, minimumWidth, naturalWidth)
    
    }

    /// Gets the accumulative preferred width for `height` for all rows which
    /// have been requested for the same said `height` with this context.
    /// 
    /// After `gtk_cell_area_context_reset()` is called and/or before ever
    /// requesting the size of a `GtkCellArea`, the returned values are -1.
    @inlinable func getPreferredWidthFor(height: Int, minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_area_context_get_preferred_width_for_height(cell_area_context_ptr, gint(height), minimumWidth, naturalWidth)
    
    }

    /// Causes the minimum and/or natural height to grow if the new
    /// proposed sizes exceed the current minimum and natural height.
    /// 
    /// This is used by `GtkCellAreaContext` implementations during
    /// the request process over a series of `GtkTreeModel` rows to
    /// progressively push the requested height over a series of
    /// `gtk_cell_area_get_preferred_height()` requests.
    @inlinable func pushPreferredHeight(minimumHeight: Int, naturalHeight: Int) {
        gtk_cell_area_context_push_preferred_height(cell_area_context_ptr, gint(minimumHeight), gint(naturalHeight))
    
    }

    /// Causes the minimum and/or natural width to grow if the new
    /// proposed sizes exceed the current minimum and natural width.
    /// 
    /// This is used by `GtkCellAreaContext` implementations during
    /// the request process over a series of `GtkTreeModel` rows to
    /// progressively push the requested width over a series of
    /// `gtk_cell_area_get_preferred_width()` requests.
    @inlinable func pushPreferredWidth(minimumWidth: Int, naturalWidth: Int) {
        gtk_cell_area_context_push_preferred_width(cell_area_context_ptr, gint(minimumWidth), gint(naturalWidth))
    
    }

    /// Resets any previously cached request and allocation
    /// data.
    /// 
    /// When underlying `GtkTreeModel` data changes its
    /// important to reset the context if the content
    /// size is allowed to shrink. If the content size
    /// is only allowed to grow (this is usually an option
    /// for views rendering large data stores as a measure
    /// of optimization), then only the row that changed
    /// or was inserted needs to be (re)requested with
    /// `gtk_cell_area_get_preferred_width()`.
    /// 
    /// When the new overall size of the context requires
    /// that the allocated size changes (or whenever this
    /// allocation changes at all), the variable row
    /// sizes need to be re-requested for every row.
    /// 
    /// For instance, if the rows are displayed all with
    /// the same width from top to bottom then a change
    /// in the allocated width necessitates a recalculation
    /// of all the displayed row heights using
    /// `gtk_cell_area_get_preferred_height_for_width()`.
    @inlinable func reset() {
        gtk_cell_area_context_reset(cell_area_context_ptr)
    
    }
    /// The `GtkCellArea` this context was created by
    @inlinable var area: CellAreaRef! {
        /// Fetches the `GtkCellArea` this `context` was created by.
        /// 
        /// This is generally unneeded by layouting widgets; however,
        /// it is important for the context implementation itself to
        /// fetch information about the area it is being used for.
        /// 
        /// For instance at ``GtkCellAreaContextClass.allocate()`` time
        /// it’s important to know details about any cell spacing
        /// that the `GtkCellArea` is configured with in order to
        /// compute a proper allocation.
        get {
            let rv = CellAreaRef(gconstpointer: gconstpointer(gtk_cell_area_context_get_area(cell_area_context_ptr)))
            return rv
        }
    }

    // var parentInstance is unavailable because parent_instance is private

}



// MARK: - CellRenderer Class

/// An object for rendering a single cell
/// 
/// The `GtkCellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo_t`.  These objects are used primarily by
/// the `GtkTreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `GtkCellRenderer` is not a
/// `GtkWidget` and cannot be treated as such.
/// 
/// The primary use of a `GtkCellRenderer` is for drawing a certain graphical
/// elements on a `cairo_t`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObject`s property system.  Then, the
/// cell is measured using `gtk_cell_renderer_get_preferred_size()`. Finally, the cell
/// is rendered in the correct location using `gtk_cell_renderer_snapshot()`.
/// 
/// There are a number of rules that must be followed when writing a new
/// `GtkCellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a style change. The `GtkCellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
/// 
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `GtkCellRenderer`Toggle,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `GtkCellRenderer`Text, which
/// allows the user to edit the text using a widget implementing the
/// `GtkCellEditable` interface, e.g. `GtkEntry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `GtkCellRenderer`Class.activate or
/// `GtkCellRenderer`Class.start_editing virtual functions, respectively.
/// 
/// Many properties of `GtkCellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
///
/// The `CellRendererProtocol` protocol exposes the methods and properties of an underlying `GtkCellRenderer` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRenderer`.
/// Alternatively, use `CellRendererRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererProtocol: GLibObject.InitiallyUnownedProtocol {
        /// Untyped pointer to the underlying `GtkCellRenderer` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRenderer` instance.
    var cell_renderer_ptr: UnsafeMutablePointer<GtkCellRenderer>! { get }

    /// Required Initialiser for types conforming to `CellRendererProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// An object for rendering a single cell
/// 
/// The `GtkCellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo_t`.  These objects are used primarily by
/// the `GtkTreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `GtkCellRenderer` is not a
/// `GtkWidget` and cannot be treated as such.
/// 
/// The primary use of a `GtkCellRenderer` is for drawing a certain graphical
/// elements on a `cairo_t`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObject`s property system.  Then, the
/// cell is measured using `gtk_cell_renderer_get_preferred_size()`. Finally, the cell
/// is rendered in the correct location using `gtk_cell_renderer_snapshot()`.
/// 
/// There are a number of rules that must be followed when writing a new
/// `GtkCellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a style change. The `GtkCellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
/// 
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `GtkCellRenderer`Toggle,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `GtkCellRenderer`Text, which
/// allows the user to edit the text using a widget implementing the
/// `GtkCellEditable` interface, e.g. `GtkEntry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `GtkCellRenderer`Class.activate or
/// `GtkCellRenderer`Class.start_editing virtual functions, respectively.
/// 
/// Many properties of `GtkCellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
///
/// The `CellRendererRef` type acts as a lightweight Swift reference to an underlying `GtkCellRenderer` instance.
/// It exposes methods that can operate on this data type through `CellRendererProtocol` conformance.
/// Use `CellRendererRef` only as an `unowned` reference to an existing `GtkCellRenderer` instance.
///
public struct CellRendererRef: CellRendererProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRenderer` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRenderer>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRenderer>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRenderer>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRenderer>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererProtocol`
    @inlinable init<T: CellRendererProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererProtocol>(_ other: T) -> CellRendererRef { CellRendererRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// An object for rendering a single cell
/// 
/// The `GtkCellRenderer` is a base class of a set of objects used for
/// rendering a cell to a `cairo_t`.  These objects are used primarily by
/// the `GtkTreeView` widget, though they aren’t tied to them in any
/// specific way.  It is worth noting that `GtkCellRenderer` is not a
/// `GtkWidget` and cannot be treated as such.
/// 
/// The primary use of a `GtkCellRenderer` is for drawing a certain graphical
/// elements on a `cairo_t`. Typically, one cell renderer is used to
/// draw many cells on the screen.  To this extent, it isn’t expected that a
/// CellRenderer keep any permanent state around.  Instead, any state is set
/// just prior to use using `GObject`s property system.  Then, the
/// cell is measured using `gtk_cell_renderer_get_preferred_size()`. Finally, the cell
/// is rendered in the correct location using `gtk_cell_renderer_snapshot()`.
/// 
/// There are a number of rules that must be followed when writing a new
/// `GtkCellRenderer`.  First and foremost, it’s important that a certain set
/// of properties will always yield a cell renderer of the same size,
/// barring a style change. The `GtkCellRenderer` also has a number of
/// generic properties that are expected to be honored by all children.
/// 
/// Beyond merely rendering a cell, cell renderers can optionally
/// provide active user interface elements. A cell renderer can be
/// “activatable” like `GtkCellRenderer`Toggle,
/// which toggles when it gets activated by a mouse click, or it can be
/// “editable” like `GtkCellRenderer`Text, which
/// allows the user to edit the text using a widget implementing the
/// `GtkCellEditable` interface, e.g. `GtkEntry`.
/// To make a cell renderer activatable or editable, you have to
/// implement the `GtkCellRenderer`Class.activate or
/// `GtkCellRenderer`Class.start_editing virtual functions, respectively.
/// 
/// Many properties of `GtkCellRenderer` and its subclasses have a
/// corresponding “set” property, e.g. “cell-background-set” corresponds
/// to “cell-background”. These “set” properties reflect whether a property
/// has been set or not. You should not set them independently.
///
/// The `CellRenderer` type acts as a reference-counted owner of an underlying `GtkCellRenderer` instance.
/// It provides the methods that can operate on this data type through `CellRendererProtocol` conformance.
/// Use `CellRenderer` as a strong reference or owner of a `GtkCellRenderer` instance.
///
open class CellRenderer: GLibObject.InitiallyUnowned, CellRendererProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRenderer>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRenderer>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRenderer>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRenderer>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRenderer`.
    /// i.e., ownership is transferred to the `CellRenderer` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRenderer>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererProtocol`
    /// Will retain `GtkCellRenderer`.
    /// - Parameter other: an instance of a related type that implements `CellRendererProtocol`
    @inlinable public init<T: CellRendererProtocol>(cellRenderer other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum CellRendererPropertyName: String, PropertyNameProtocol {
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    case sensitive = "sensitive"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererProtocol {
    /// Bind a `CellRendererPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRenderer property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRenderer property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererSignalName: String, SignalNameProtocol {
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    case notifySensitive = "notify::sensitive"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRenderer signals
public extension CellRendererProtocol {
    /// Connect a Swift signal handler to the given, typed `CellRendererSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellRendererSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    /// - Note: This represents the underlying `editing-canceled` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `editingCanceled` signal is emitted
    @discardableResult @inlinable func onEditingCanceled(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<CellRendererRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .editingCanceled,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `editing-canceled` signal for using the `connect(signal:)` methods
    static var editingCanceledSignal: CellRendererSignalName { .editingCanceled }
    
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    /// - Note: This represents the underlying `editing-started` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter editable: the `GtkCellEditable`
    /// - Parameter path: the path identifying the edited cell
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `editingStarted` signal is emitted
    @discardableResult @inlinable func onEditingStarted(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ editable: CellEditableRef, _ path: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<CellRendererRef, CellEditableRef, String, Void>
        let cCallback: @convention(c) (gpointer, gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), CellEditableRef(raw: arg1), arg2.map({ String(cString: $0) })!)
            return output
        }
        return connect(
            signal: .editingStarted,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `editing-started` signal for using the `connect(signal:)` methods
    static var editingStartedSignal: CellRendererSignalName { .editingStarted }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::cell-background` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCellBackground` signal is emitted
    @discardableResult @inlinable func onNotifyCellBackground(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyCellBackground,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::cell-background` signal for using the `connect(signal:)` methods
    static var notifyCellBackgroundSignal: CellRendererSignalName { .notifyCellBackground }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::cell-background-rgba` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCellBackgroundRgba` signal is emitted
    @discardableResult @inlinable func onNotifyCellBackgroundRgba(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyCellBackgroundRgba,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::cell-background-rgba` signal for using the `connect(signal:)` methods
    static var notifyCellBackgroundRgbaSignal: CellRendererSignalName { .notifyCellBackgroundRgba }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::cell-background-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyCellBackgroundSet` signal is emitted
    @discardableResult @inlinable func onNotifyCellBackgroundSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyCellBackgroundSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::cell-background-set` signal for using the `connect(signal:)` methods
    static var notifyCellBackgroundSetSignal: CellRendererSignalName { .notifyCellBackgroundSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::editing` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditing` signal is emitted
    @discardableResult @inlinable func onNotifyEditing(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEditing,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::editing` signal for using the `connect(signal:)` methods
    static var notifyEditingSignal: CellRendererSignalName { .notifyEditing }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::height` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHeight` signal is emitted
    @discardableResult @inlinable func onNotifyHeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyHeight,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::height` signal for using the `connect(signal:)` methods
    static var notifyHeightSignal: CellRendererSignalName { .notifyHeight }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::is-expanded` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIsExpanded` signal is emitted
    @discardableResult @inlinable func onNotifyIsExpanded(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyIsExpanded,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::is-expanded` signal for using the `connect(signal:)` methods
    static var notifyIsExpandedSignal: CellRendererSignalName { .notifyIsExpanded }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::is-expander` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIsExpander` signal is emitted
    @discardableResult @inlinable func onNotifyIsExpander(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyIsExpander,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::is-expander` signal for using the `connect(signal:)` methods
    static var notifyIsExpanderSignal: CellRendererSignalName { .notifyIsExpander }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMode` signal is emitted
    @discardableResult @inlinable func onNotifyMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::mode` signal for using the `connect(signal:)` methods
    static var notifyModeSignal: CellRendererSignalName { .notifyMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::sensitive` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySensitive` signal is emitted
    @discardableResult @inlinable func onNotifySensitive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySensitive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::sensitive` signal for using the `connect(signal:)` methods
    static var notifySensitiveSignal: CellRendererSignalName { .notifySensitive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::visible` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVisible` signal is emitted
    @discardableResult @inlinable func onNotifyVisible(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyVisible,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::visible` signal for using the `connect(signal:)` methods
    static var notifyVisibleSignal: CellRendererSignalName { .notifyVisible }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWidth` signal is emitted
    @discardableResult @inlinable func onNotifyWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::width` signal for using the `connect(signal:)` methods
    static var notifyWidthSignal: CellRendererSignalName { .notifyWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::xalign` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyXalign` signal is emitted
    @discardableResult @inlinable func onNotifyXalign(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyXalign,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::xalign` signal for using the `connect(signal:)` methods
    static var notifyXalignSignal: CellRendererSignalName { .notifyXalign }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::xpad` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyXpad` signal is emitted
    @discardableResult @inlinable func onNotifyXpad(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyXpad,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::xpad` signal for using the `connect(signal:)` methods
    static var notifyXpadSignal: CellRendererSignalName { .notifyXpad }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::yalign` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyYalign` signal is emitted
    @discardableResult @inlinable func onNotifyYalign(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyYalign,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::yalign` signal for using the `connect(signal:)` methods
    static var notifyYalignSignal: CellRendererSignalName { .notifyYalign }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::ypad` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyYpad` signal is emitted
    @discardableResult @inlinable func onNotifyYpad(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyYpad,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::ypad` signal for using the `connect(signal:)` methods
    static var notifyYpadSignal: CellRendererSignalName { .notifyYpad }
    
}

// MARK: CellRenderer Class: CellRendererProtocol extension (methods and fields)
public extension CellRendererProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRenderer` instance.
    @inlinable var cell_renderer_ptr: UnsafeMutablePointer<GtkCellRenderer>! { return ptr?.assumingMemoryBound(to: GtkCellRenderer.self) }

    /// Passes an activate event to the cell renderer for possible processing.
    /// Some cell renderers may use events; for example, `GtkCellRendererToggle`
    /// toggles when it gets a mouse click.
    @inlinable func activate<EventT: Gdk.EventProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(event: EventT, widget: WidgetT, path: UnsafePointer<CChar>!, backgroundArea: RectangleT, cellArea: RectangleT, flags: CellRendererState) -> Bool {
        let rv = ((gtk_cell_renderer_activate(cell_renderer_ptr, event.event_ptr, widget.widget_ptr, path, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value)) != 0)
        return rv
    }

    /// Gets the aligned area used by `cell` inside `cell_area`. Used for finding
    /// the appropriate edit and focus rectangle.
    @inlinable func getAlignedArea<RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(widget: WidgetT, flags: CellRendererState, cellArea: RectangleT, alignedArea: RectangleT) {
        gtk_cell_renderer_get_aligned_area(cell_renderer_ptr, widget.widget_ptr, flags.value, cellArea.rectangle_ptr, alignedArea.rectangle_ptr)
    
    }

    /// Fills in `xalign` and `yalign` with the appropriate values of `cell`.
    @inlinable func getAlignment(xalign: UnsafeMutablePointer<CFloat>! = nil, yalign: UnsafeMutablePointer<CFloat>! = nil) {
        gtk_cell_renderer_get_alignment(cell_renderer_ptr, xalign, yalign)
    
    }

    /// Fills in `width` and `height` with the appropriate size of `cell`.
    @inlinable func getFixedSize(width: UnsafeMutablePointer<gint>! = nil, height: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_renderer_get_fixed_size(cell_renderer_ptr, width, height)
    
    }

    /// Checks whether the given `GtkCellRenderer` is expanded.
    @inlinable func getIsExpanded() -> Bool {
        let rv = ((gtk_cell_renderer_get_is_expanded(cell_renderer_ptr)) != 0)
        return rv
    }

    /// Checks whether the given `GtkCellRenderer` is an expander.
    @inlinable func getIsExpander() -> Bool {
        let rv = ((gtk_cell_renderer_get_is_expander(cell_renderer_ptr)) != 0)
        return rv
    }

    /// Fills in `xpad` and `ypad` with the appropriate values of `cell`.
    @inlinable func getPadding(xpad: UnsafeMutablePointer<gint>! = nil, ypad: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_renderer_get_padding(cell_renderer_ptr, xpad, ypad)
    
    }

    /// Retrieves a renderer’s natural size when rendered to `widget`.
    @inlinable func getPreferredHeight<WidgetT: WidgetProtocol>(widget: WidgetT, minimumSize: UnsafeMutablePointer<gint>! = nil, naturalSize: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_renderer_get_preferred_height(cell_renderer_ptr, widget.widget_ptr, minimumSize, naturalSize)
    
    }

    /// Retrieves a cell renderers’s minimum and natural height if it were rendered to
    /// `widget` with the specified `width`.
    @inlinable func getPreferredHeightForWidth<WidgetT: WidgetProtocol>(widget: WidgetT, width: Int, minimumHeight: UnsafeMutablePointer<gint>! = nil, naturalHeight: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_renderer_get_preferred_height_for_width(cell_renderer_ptr, widget.widget_ptr, gint(width), minimumHeight, naturalHeight)
    
    }

    /// Retrieves the minimum and natural size of a cell taking
    /// into account the widget’s preference for height-for-width management.
    @inlinable func getPreferredSize<WidgetT: WidgetProtocol>(widget: WidgetT, minimumSize: RequisitionRef? = nil, naturalSize: RequisitionRef? = nil) {
        gtk_cell_renderer_get_preferred_size(cell_renderer_ptr, widget.widget_ptr, minimumSize?.requisition_ptr, naturalSize?.requisition_ptr)
    
    }
    /// Retrieves the minimum and natural size of a cell taking
    /// into account the widget’s preference for height-for-width management.
    @inlinable func getPreferredSize<RequisitionT: RequisitionProtocol, WidgetT: WidgetProtocol>(widget: WidgetT, minimumSize: RequisitionT?, naturalSize: RequisitionT?) {
        gtk_cell_renderer_get_preferred_size(cell_renderer_ptr, widget.widget_ptr, minimumSize?.requisition_ptr, naturalSize?.requisition_ptr)
    
    }

    /// Retrieves a renderer’s natural size when rendered to `widget`.
    @inlinable func getPreferredWidth<WidgetT: WidgetProtocol>(widget: WidgetT, minimumSize: UnsafeMutablePointer<gint>! = nil, naturalSize: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_renderer_get_preferred_width(cell_renderer_ptr, widget.widget_ptr, minimumSize, naturalSize)
    
    }

    /// Retrieves a cell renderers’s minimum and natural width if it were rendered to
    /// `widget` with the specified `height`.
    @inlinable func getPreferredWidthForHeight<WidgetT: WidgetProtocol>(widget: WidgetT, height: Int, minimumWidth: UnsafeMutablePointer<gint>! = nil, naturalWidth: UnsafeMutablePointer<gint>! = nil) {
        gtk_cell_renderer_get_preferred_width_for_height(cell_renderer_ptr, widget.widget_ptr, gint(height), minimumWidth, naturalWidth)
    
    }

    /// Gets whether the cell renderer prefers a height-for-width layout
    /// or a width-for-height layout.
    @inlinable func getRequestMode() -> GtkSizeRequestMode {
        let rv = gtk_cell_renderer_get_request_mode(cell_renderer_ptr)
        return rv
    }

    /// Returns the cell renderer’s sensitivity.
    @inlinable func getSensitive() -> Bool {
        let rv = ((gtk_cell_renderer_get_sensitive(cell_renderer_ptr)) != 0)
        return rv
    }

    /// Translates the cell renderer state to `GtkStateFlags`,
    /// based on the cell renderer and widget sensitivity, and
    /// the given `GtkCellRenderer`State.
    @inlinable func getState(widget: WidgetRef? = nil, cellState: CellRendererState) -> StateFlags {
        let rv = StateFlags(gtk_cell_renderer_get_state(cell_renderer_ptr, widget?.widget_ptr, cellState.value))
        return rv
    }
    /// Translates the cell renderer state to `GtkStateFlags`,
    /// based on the cell renderer and widget sensitivity, and
    /// the given `GtkCellRenderer`State.
    @inlinable func getState<WidgetT: WidgetProtocol>(widget: WidgetT?, cellState: CellRendererState) -> StateFlags {
        let rv = StateFlags(gtk_cell_renderer_get_state(cell_renderer_ptr, widget?.widget_ptr, cellState.value))
        return rv
    }

    /// Returns the cell renderer’s visibility.
    @inlinable func getVisible() -> Bool {
        let rv = ((gtk_cell_renderer_get_visible(cell_renderer_ptr)) != 0)
        return rv
    }

    /// Sets the renderer’s alignment within its available space.
    @inlinable func setAlignment(xalign: CFloat, yalign: CFloat) {
        gtk_cell_renderer_set_alignment(cell_renderer_ptr, xalign, yalign)
    
    }

    /// Sets the renderer size to be explicit, independent of the properties set.
    @inlinable func setFixedSize(width: Int, height: Int) {
        gtk_cell_renderer_set_fixed_size(cell_renderer_ptr, gint(width), gint(height))
    
    }

    /// Sets whether the given `GtkCellRenderer` is expanded.
    @inlinable func set(isExpanded: Bool) {
        gtk_cell_renderer_set_is_expanded(cell_renderer_ptr, gboolean((isExpanded) ? 1 : 0))
    
    }

    /// Sets whether the given `GtkCellRenderer` is an expander.
    @inlinable func set(isExpander: Bool) {
        gtk_cell_renderer_set_is_expander(cell_renderer_ptr, gboolean((isExpander) ? 1 : 0))
    
    }

    /// Sets the renderer’s padding.
    @inlinable func setPadding(xpad: Int, ypad: Int) {
        gtk_cell_renderer_set_padding(cell_renderer_ptr, gint(xpad), gint(ypad))
    
    }

    /// Sets the cell renderer’s sensitivity.
    @inlinable func set(sensitive: Bool) {
        gtk_cell_renderer_set_sensitive(cell_renderer_ptr, gboolean((sensitive) ? 1 : 0))
    
    }

    /// Sets the cell renderer’s visibility.
    @inlinable func set(visible: Bool) {
        gtk_cell_renderer_set_visible(cell_renderer_ptr, gboolean((visible) ? 1 : 0))
    
    }

    /// Invokes the virtual render function of the `GtkCellRenderer`. The three
    /// passed-in rectangles are areas in `cr`. Most renderers will draw within
    /// `cell_area`; the xalign, yalign, xpad, and ypad fields of the `GtkCellRenderer`
    /// should be honored with respect to `cell_area`. `background_area` includes the
    /// blank space around the cell, and also the area containing the tree expander;
    /// so the `background_area` rectangles for all cells tile to cover the entire
    /// `window`.
    @inlinable func snapshot<RectangleT: Gdk.RectangleProtocol, SnapshotT: SnapshotProtocol, WidgetT: WidgetProtocol>(snapshot: SnapshotT, widget: WidgetT, backgroundArea: RectangleT, cellArea: RectangleT, flags: CellRendererState) {
        gtk_cell_renderer_snapshot(cell_renderer_ptr, snapshot.snapshot_ptr, widget.widget_ptr, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value)
    
    }

    /// Starts editing the contents of this `cell`, through a new `GtkCellEditable`
    /// widget created by the `GtkCellRenderer`Class.start_editing virtual function.
    @inlinable func startEditing<RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(event: Gdk.EventRef? = nil, widget: WidgetT, path: UnsafePointer<CChar>!, backgroundArea: RectangleT, cellArea: RectangleT, flags: CellRendererState) -> CellEditableRef! {
        let rv = CellEditableRef(gconstpointer: gconstpointer(gtk_cell_renderer_start_editing(cell_renderer_ptr, event?.event_ptr, widget.widget_ptr, path, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value)))
        return rv
    }
    /// Starts editing the contents of this `cell`, through a new `GtkCellEditable`
    /// widget created by the `GtkCellRenderer`Class.start_editing virtual function.
    @inlinable func startEditing<EventT: Gdk.EventProtocol, RectangleT: Gdk.RectangleProtocol, WidgetT: WidgetProtocol>(event: EventT?, widget: WidgetT, path: UnsafePointer<CChar>!, backgroundArea: RectangleT, cellArea: RectangleT, flags: CellRendererState) -> CellEditableRef! {
        let rv = CellEditableRef(gconstpointer: gconstpointer(gtk_cell_renderer_start_editing(cell_renderer_ptr, event?.event_ptr, widget.widget_ptr, path, backgroundArea.rectangle_ptr, cellArea.rectangle_ptr, flags.value)))
        return rv
    }

    /// Informs the cell renderer that the editing is stopped.
    /// If `canceled` is `true`, the cell renderer will emit the
    /// `GtkCellRenderer``editing-canceled` signal.
    /// 
    /// This function should be called by cell renderer implementations
    /// in response to the `GtkCellEditable`editing-done`` signal of
    /// `GtkCellEditable`.
    @inlinable func stopEditing(canceled: Bool) {
        gtk_cell_renderer_stop_editing(cell_renderer_ptr, gboolean((canceled) ? 1 : 0))
    
    }
    /// Checks whether the cell renderer can do something when activated.
    @inlinable var isActivatable: Bool {
        /// Checks whether the cell renderer can do something when activated.
        get {
            let rv = ((gtk_cell_renderer_is_activatable(cell_renderer_ptr)) != 0)
            return rv
        }
    }

    /// Checks whether the given `GtkCellRenderer` is expanded.
    @inlinable var isExpanded: Bool {
        /// Checks whether the given `GtkCellRenderer` is expanded.
        get {
            let rv = ((gtk_cell_renderer_get_is_expanded(cell_renderer_ptr)) != 0)
            return rv
        }
        /// Sets whether the given `GtkCellRenderer` is expanded.
        nonmutating set {
            gtk_cell_renderer_set_is_expanded(cell_renderer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Checks whether the given `GtkCellRenderer` is an expander.
    @inlinable var isExpander: Bool {
        /// Checks whether the given `GtkCellRenderer` is an expander.
        get {
            let rv = ((gtk_cell_renderer_get_is_expander(cell_renderer_ptr)) != 0)
            return rv
        }
        /// Sets whether the given `GtkCellRenderer` is an expander.
        nonmutating set {
            gtk_cell_renderer_set_is_expander(cell_renderer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets whether the cell renderer prefers a height-for-width layout
    /// or a width-for-height layout.
    @inlinable var requestMode: GtkSizeRequestMode {
        /// Gets whether the cell renderer prefers a height-for-width layout
        /// or a width-for-height layout.
        get {
            let rv = gtk_cell_renderer_get_request_mode(cell_renderer_ptr)
            return rv
        }
    }

    @inlinable var sensitive: Bool {
        /// Returns the cell renderer’s sensitivity.
        get {
            let rv = ((gtk_cell_renderer_get_sensitive(cell_renderer_ptr)) != 0)
            return rv
        }
        /// Sets the cell renderer’s sensitivity.
        nonmutating set {
            gtk_cell_renderer_set_sensitive(cell_renderer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var visible: Bool {
        /// Returns the cell renderer’s visibility.
        get {
            let rv = ((gtk_cell_renderer_get_visible(cell_renderer_ptr)) != 0)
            return rv
        }
        /// Sets the cell renderer’s visibility.
        nonmutating set {
            gtk_cell_renderer_set_visible(cell_renderer_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var parentInstance: GInitiallyUnowned {
        get {
            let rv = cell_renderer_ptr.pointee.parent_instance
            return rv
        }
    }

    // var priv is unavailable because priv is private

}



// MARK: - CellRendererAccel Class

/// Renders a keyboard accelerator in a cell
/// 
/// `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
///
/// The `CellRendererAccelProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererAccel` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererAccel`.
/// Alternatively, use `CellRendererAccelRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererAccelProtocol: CellRendererTextProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererAccel` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererAccel` instance.
    var cell_renderer_accel_ptr: UnsafeMutablePointer<GtkCellRendererAccel>! { get }

    /// Required Initialiser for types conforming to `CellRendererAccelProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders a keyboard accelerator in a cell
/// 
/// `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
///
/// The `CellRendererAccelRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererAccel` instance.
/// It exposes methods that can operate on this data type through `CellRendererAccelProtocol` conformance.
/// Use `CellRendererAccelRef` only as an `unowned` reference to an existing `GtkCellRendererAccel` instance.
///
public struct CellRendererAccelRef: CellRendererAccelProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererAccel` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_accel_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererAccelRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererAccel>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererAccel>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererAccel>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererAccel>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererAccelProtocol`
    @inlinable init<T: CellRendererAccelProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererAccelProtocol>(_ other: T) -> CellRendererAccelRef { CellRendererAccelRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererAccel`.
    @inlinable init() {
        let rv = gtk_cell_renderer_accel_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders a keyboard accelerator in a cell
/// 
/// `GtkCellRendererAccel` displays a keyboard accelerator (i.e. a key
/// combination like `Control + a`). If the cell renderer is editable,
/// the accelerator can be changed by simply typing the new combination.
///
/// The `CellRendererAccel` type acts as a reference-counted owner of an underlying `GtkCellRendererAccel` instance.
/// It provides the methods that can operate on this data type through `CellRendererAccelProtocol` conformance.
/// Use `CellRendererAccel` as a strong reference or owner of a `GtkCellRendererAccel` instance.
///
open class CellRendererAccel: CellRendererText, CellRendererAccelProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererAccel>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererAccel>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererAccel>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererAccel>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererAccel`.
    /// i.e., ownership is transferred to the `CellRendererAccel` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererAccel>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererAccelProtocol`
    /// Will retain `GtkCellRendererAccel`.
    /// - Parameter other: an instance of a related type that implements `CellRendererAccelProtocol`
    @inlinable public init<T: CellRendererAccelProtocol>(cellRendererAccel other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererAccelProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererAccel`.
    @inlinable override public init() {
        let rv = gtk_cell_renderer_accel_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererAccelPropertyName: String, PropertyNameProtocol {
    /// The keyval of the accelerator.
    case accelKey = "accel-key"
    /// Determines if the edited accelerators are GTK accelerators. If
    /// they are, consumed modifiers are suppressed, only accelerators
    /// accepted by GTK are allowed, and the accelerators are rendered
    /// in the same way as they are in menus.
    case accelMode = "accel-mode"
    /// The modifier mask of the accelerator.
    case accelMods = "accel-mods"
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkRGBA`
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    /// The hardware keycode of the accelerator. Note that the hardware keycode is
    /// only relevant if the key does not have a keyval. Normally, the keyboard
    /// configuration should assign keyvals to all keys.
    case keycode = "keycode"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererAccelProtocol {
    /// Bind a `CellRendererAccelPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererAccelPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererAccel property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererAccelPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererAccel property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererAccelPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererAccelSignalName: String, SignalNameProtocol {
    /// Gets emitted when the user has removed the accelerator.
    case accelCleared = "accel-cleared"
    /// Gets emitted when the user has selected a new accelerator.
    case accelEdited = "accel-edited"
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The keyval of the accelerator.
    case notifyAccelKey = "notify::accel-key"
    /// Determines if the edited accelerators are GTK accelerators. If
    /// they are, consumed modifiers are suppressed, only accelerators
    /// accepted by GTK are allowed, and the accelerators are rendered
    /// in the same way as they are in menus.
    case notifyAccelMode = "notify::accel-mode"
    /// The modifier mask of the accelerator.
    case notifyAccelMods = "notify::accel-mods"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    /// The hardware keycode of the accelerator. Note that the hardware keycode is
    /// only relevant if the key does not have a keyval. Normally, the keyboard
    /// configuration should assign keyvals to all keys.
    case notifyKeycode = "notify::keycode"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererAccel signals
public extension CellRendererAccelProtocol {
    /// Connect a Swift signal handler to the given, typed `CellRendererAccelSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererAccelSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellRendererAccelSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererAccelSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Gets emitted when the user has removed the accelerator.
    /// - Note: This represents the underlying `accel-cleared` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pathString: the path identifying the row of the edited cell
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `accelCleared` signal is emitted
    @discardableResult @inlinable func onAccelCleared(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererAccelRef, _ pathString: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererAccelRef, String, Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererAccelRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!)
            return output
        }
        return connect(
            signal: .accelCleared,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `accel-cleared` signal for using the `connect(signal:)` methods
    static var accelClearedSignal: CellRendererAccelSignalName { .accelCleared }
    
    /// Gets emitted when the user has selected a new accelerator.
    /// - Note: This represents the underlying `accel-edited` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pathString: the path identifying the row of the edited cell
    /// - Parameter accelKey: the new accelerator keyval
    /// - Parameter accelMods: the new acclerator modifier mask
    /// - Parameter hardwareKeycode: the keycode of the new accelerator
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `accelEdited` signal is emitted
    @discardableResult @inlinable func onAccelEdited(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererAccelRef, _ pathString: String, _ accelKey: UInt, _ accelMods: Gdk.ModifierType, _ hardwareKeycode: UInt) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder5<CellRendererAccelRef, String, UInt, Gdk.ModifierType, UInt, Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, guint, UInt32, guint, gpointer) -> Void = { unownedSelf, arg1, arg2, arg3, arg4, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererAccelRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!, UInt(arg2), Gdk.ModifierType(arg3), UInt(arg4))
            return output
        }
        return connect(
            signal: .accelEdited,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `accel-edited` signal for using the `connect(signal:)` methods
    static var accelEditedSignal: CellRendererAccelSignalName { .accelEdited }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::accel-key` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAccelKey` signal is emitted
    @discardableResult @inlinable func onNotifyAccelKey(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererAccelRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererAccelRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererAccelRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAccelKey,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::accel-key` signal for using the `connect(signal:)` methods
    static var notifyAccelKeySignal: CellRendererAccelSignalName { .notifyAccelKey }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::accel-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAccelMode` signal is emitted
    @discardableResult @inlinable func onNotifyAccelMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererAccelRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererAccelRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererAccelRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAccelMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::accel-mode` signal for using the `connect(signal:)` methods
    static var notifyAccelModeSignal: CellRendererAccelSignalName { .notifyAccelMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::accel-mods` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAccelMods` signal is emitted
    @discardableResult @inlinable func onNotifyAccelMods(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererAccelRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererAccelRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererAccelRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAccelMods,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::accel-mods` signal for using the `connect(signal:)` methods
    static var notifyAccelModsSignal: CellRendererAccelSignalName { .notifyAccelMods }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::keycode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyKeycode` signal is emitted
    @discardableResult @inlinable func onNotifyKeycode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererAccelRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererAccelRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererAccelRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyKeycode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::keycode` signal for using the `connect(signal:)` methods
    static var notifyKeycodeSignal: CellRendererAccelSignalName { .notifyKeycode }
    
}

// MARK: CellRendererAccel Class: CellRendererAccelProtocol extension (methods and fields)
public extension CellRendererAccelProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererAccel` instance.
    @inlinable var cell_renderer_accel_ptr: UnsafeMutablePointer<GtkCellRendererAccel>! { return ptr?.assumingMemoryBound(to: GtkCellRendererAccel.self) }



}



// MARK: - CellRendererCombo Class

/// Renders a combobox in a cell
/// 
/// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `GtkCellRendererCombo`:model property.
/// 
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `GtkCellRendererCombo`:text-column property. Further properties of the combo box
/// can be set in a handler for the `GtkCellRenderer`editing-started`` signal.
///
/// The `CellRendererComboProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererCombo` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererCombo`.
/// Alternatively, use `CellRendererComboRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererComboProtocol: CellRendererTextProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererCombo` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererCombo` instance.
    var cell_renderer_combo_ptr: UnsafeMutablePointer<GtkCellRendererCombo>! { get }

    /// Required Initialiser for types conforming to `CellRendererComboProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders a combobox in a cell
/// 
/// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `GtkCellRendererCombo`:model property.
/// 
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `GtkCellRendererCombo`:text-column property. Further properties of the combo box
/// can be set in a handler for the `GtkCellRenderer`editing-started`` signal.
///
/// The `CellRendererComboRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererCombo` instance.
/// It exposes methods that can operate on this data type through `CellRendererComboProtocol` conformance.
/// Use `CellRendererComboRef` only as an `unowned` reference to an existing `GtkCellRendererCombo` instance.
///
public struct CellRendererComboRef: CellRendererComboProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererCombo` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_combo_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererComboRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererCombo>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererCombo>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererCombo>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererCombo>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererComboProtocol`
    @inlinable init<T: CellRendererComboProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererComboProtocol>(_ other: T) -> CellRendererComboRef { CellRendererComboRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererCombo`.
    /// Adjust how text is drawn using object properties.
    /// Object properties can be set globally (with `g_object_set()`).
    /// Also, with `GtkTreeViewColumn`, you can bind a property to a value
    /// in a `GtkTreeModel`. For example, you can bind the “text” property
    /// on the cell renderer to a string value in the model, thus rendering
    /// a different string in each row of the `GtkTreeView`.
    @inlinable init() {
        let rv = gtk_cell_renderer_combo_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders a combobox in a cell
/// 
/// `GtkCellRendererCombo` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererCombo` offers a `GtkComboBox`
/// widget to edit the text. The values to display in the combo box are taken from
/// the tree model specified in the `GtkCellRendererCombo`:model property.
/// 
/// The combo cell renderer takes care of adding a text cell renderer to the combo
/// box and sets it to display the column specified by its
/// `GtkCellRendererCombo`:text-column property. Further properties of the combo box
/// can be set in a handler for the `GtkCellRenderer`editing-started`` signal.
///
/// The `CellRendererCombo` type acts as a reference-counted owner of an underlying `GtkCellRendererCombo` instance.
/// It provides the methods that can operate on this data type through `CellRendererComboProtocol` conformance.
/// Use `CellRendererCombo` as a strong reference or owner of a `GtkCellRendererCombo` instance.
///
open class CellRendererCombo: CellRendererText, CellRendererComboProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererCombo>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererCombo>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererCombo>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererCombo>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererCombo`.
    /// i.e., ownership is transferred to the `CellRendererCombo` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererCombo>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererComboProtocol`
    /// Will retain `GtkCellRendererCombo`.
    /// - Parameter other: an instance of a related type that implements `CellRendererComboProtocol`
    @inlinable public init<T: CellRendererComboProtocol>(cellRendererCombo other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererComboProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererCombo`.
    /// Adjust how text is drawn using object properties.
    /// Object properties can be set globally (with `g_object_set()`).
    /// Also, with `GtkTreeViewColumn`, you can bind a property to a value
    /// in a `GtkTreeModel`. For example, you can bind the “text” property
    /// on the cell renderer to a string value in the model, thus rendering
    /// a different string in each row of the `GtkTreeView`.
    @inlinable override public init() {
        let rv = gtk_cell_renderer_combo_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererComboPropertyName: String, PropertyNameProtocol {
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkRGBA`
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    /// If `true`, the cell renderer will include an entry and allow to enter
    /// values other than the ones in the popup list.
    case hasEntry = "has-entry"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// Holds a tree model containing the possible values for the combo box.
    /// Use the text_column property to specify the column holding the values.
    case model = "model"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    /// Specifies the model column which holds the possible values for the
    /// combo box.
    /// 
    /// Note that this refers to the model specified in the model property,
    /// not the model backing the tree view to which
    /// this cell renderer is attached.
    /// 
    /// `GtkCellRendererCombo` automatically adds a text cell renderer for
    /// this column to its combo box.
    case textColumn = "text-column"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererComboProtocol {
    /// Bind a `CellRendererComboPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererComboPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererCombo property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererComboPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererCombo property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererComboPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererComboSignalName: String, SignalNameProtocol {
    /// This signal is emitted each time after the user selected an item in
    /// the combo box, either by using the mouse or the arrow keys.  Contrary
    /// to GtkComboBox, GtkCellRendererCombo`changed` is not emitted for
    /// changes made to a selected item in the entry.  The argument `new_iter`
    /// corresponds to the newly selected item in the combo box and it is relative
    /// to the GtkTreeModel set via the model property on GtkCellRendererCombo.
    /// 
    /// Note that as soon as you change the model displayed in the tree view,
    /// the tree view will immediately cease the editing operating.  This
    /// means that you most probably want to refrain from changing the model
    /// until the combo cell renderer emits the edited or editing_canceled signal.
    case changed = "changed"
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    /// If `true`, the cell renderer will include an entry and allow to enter
    /// values other than the ones in the popup list.
    case notifyHasEntry = "notify::has-entry"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// Holds a tree model containing the possible values for the combo box.
    /// Use the text_column property to specify the column holding the values.
    case notifyModel = "notify::model"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    /// Specifies the model column which holds the possible values for the
    /// combo box.
    /// 
    /// Note that this refers to the model specified in the model property,
    /// not the model backing the tree view to which
    /// this cell renderer is attached.
    /// 
    /// `GtkCellRendererCombo` automatically adds a text cell renderer for
    /// this column to its combo box.
    case notifyTextColumn = "notify::text-column"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererCombo signals
public extension CellRendererComboProtocol {
    /// Connect a Swift signal handler to the given, typed `CellRendererComboSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererComboSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellRendererComboSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererComboSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// This signal is emitted each time after the user selected an item in
    /// the combo box, either by using the mouse or the arrow keys.  Contrary
    /// to GtkComboBox, GtkCellRendererCombo`changed` is not emitted for
    /// changes made to a selected item in the entry.  The argument `new_iter`
    /// corresponds to the newly selected item in the combo box and it is relative
    /// to the GtkTreeModel set via the model property on GtkCellRendererCombo.
    /// 
    /// Note that as soon as you change the model displayed in the tree view,
    /// the tree view will immediately cease the editing operating.  This
    /// means that you most probably want to refrain from changing the model
    /// until the combo cell renderer emits the edited or editing_canceled signal.
    /// - Note: This represents the underlying `changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pathString: a string of the path identifying the edited cell               (relative to the tree view model)
    /// - Parameter newIter: the new iter selected in the combo box            (relative to the combo box model)
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `changed` signal is emitted
    @discardableResult @inlinable func onChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererComboRef, _ pathString: String, _ newIter: TreeIterRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<CellRendererComboRef, String, TreeIterRef, Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererComboRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!, TreeIterRef(raw: arg2))
            return output
        }
        return connect(
            signal: .changed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `changed` signal for using the `connect(signal:)` methods
    static var changedSignal: CellRendererComboSignalName { .changed }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::has-entry` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHasEntry` signal is emitted
    @discardableResult @inlinable func onNotifyHasEntry(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererComboRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererComboRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererComboRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyHasEntry,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::has-entry` signal for using the `connect(signal:)` methods
    static var notifyHasEntrySignal: CellRendererComboSignalName { .notifyHasEntry }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::model` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyModel` signal is emitted
    @discardableResult @inlinable func onNotifyModel(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererComboRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererComboRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererComboRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyModel,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::model` signal for using the `connect(signal:)` methods
    static var notifyModelSignal: CellRendererComboSignalName { .notifyModel }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::text-column` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTextColumn` signal is emitted
    @discardableResult @inlinable func onNotifyTextColumn(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererComboRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererComboRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererComboRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyTextColumn,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::text-column` signal for using the `connect(signal:)` methods
    static var notifyTextColumnSignal: CellRendererComboSignalName { .notifyTextColumn }
    
}

// MARK: CellRendererCombo Class: CellRendererComboProtocol extension (methods and fields)
public extension CellRendererComboProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererCombo` instance.
    @inlinable var cell_renderer_combo_ptr: UnsafeMutablePointer<GtkCellRendererCombo>! { return ptr?.assumingMemoryBound(to: GtkCellRendererCombo.self) }



}



// MARK: - CellRendererPixbuf Class

/// Renders a pixbuf in a cell
/// 
/// A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `GdkPixbuf` (set via the
/// `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
/// `GtkCellRendererPixbuf:icon-name` property).
/// 
/// To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `GtkCellRenderer:is-expander` property is `true`.
/// If the `GtkCellRenderer:is-expanded property` is `true` and the
/// `GtkCellRendererPixbuf:pixbuf-expander-open` property is set to a pixbuf, it
/// renders that pixbuf, if the `GtkCellRenderer:is-expanded` property is `false`
/// and the `GtkCellRendererPixbuf:pixbuf-expander-closed` property is set to a
/// pixbuf, it renders that one.
///
/// The `CellRendererPixbufProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererPixbuf` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererPixbuf`.
/// Alternatively, use `CellRendererPixbufRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererPixbufProtocol: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererPixbuf` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererPixbuf` instance.
    var cell_renderer_pixbuf_ptr: UnsafeMutablePointer<GtkCellRendererPixbuf>! { get }

    /// Required Initialiser for types conforming to `CellRendererPixbufProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders a pixbuf in a cell
/// 
/// A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `GdkPixbuf` (set via the
/// `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
/// `GtkCellRendererPixbuf:icon-name` property).
/// 
/// To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `GtkCellRenderer:is-expander` property is `true`.
/// If the `GtkCellRenderer:is-expanded property` is `true` and the
/// `GtkCellRendererPixbuf:pixbuf-expander-open` property is set to a pixbuf, it
/// renders that pixbuf, if the `GtkCellRenderer:is-expanded` property is `false`
/// and the `GtkCellRendererPixbuf:pixbuf-expander-closed` property is set to a
/// pixbuf, it renders that one.
///
/// The `CellRendererPixbufRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererPixbuf` instance.
/// It exposes methods that can operate on this data type through `CellRendererPixbufProtocol` conformance.
/// Use `CellRendererPixbufRef` only as an `unowned` reference to an existing `GtkCellRendererPixbuf` instance.
///
public struct CellRendererPixbufRef: CellRendererPixbufProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererPixbuf` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_pixbuf_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererPixbufRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererPixbuf>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererPixbuf>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererPixbuf>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererPixbuf>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererPixbufProtocol`
    @inlinable init<T: CellRendererPixbufProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererPixbufProtocol>(_ other: T) -> CellRendererPixbufRef { CellRendererPixbufRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererPixbuf`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “pixbuf” property on the cell renderer to a pixbuf value
    /// in the model, thus rendering a different image in each row of the
    /// `GtkTreeView`.
    @inlinable init() {
        let rv = gtk_cell_renderer_pixbuf_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders a pixbuf in a cell
/// 
/// A `GtkCellRendererPixbuf` can be used to render an image in a cell. It allows
/// to render either a given `GdkPixbuf` (set via the
/// `GtkCellRendererPixbuf:pixbuf` property) or a named icon (set via the
/// `GtkCellRendererPixbuf:icon-name` property).
/// 
/// To support the tree view, `GtkCellRendererPixbuf` also supports rendering two
/// alternative pixbufs, when the `GtkCellRenderer:is-expander` property is `true`.
/// If the `GtkCellRenderer:is-expanded property` is `true` and the
/// `GtkCellRendererPixbuf:pixbuf-expander-open` property is set to a pixbuf, it
/// renders that pixbuf, if the `GtkCellRenderer:is-expanded` property is `false`
/// and the `GtkCellRendererPixbuf:pixbuf-expander-closed` property is set to a
/// pixbuf, it renders that one.
///
/// The `CellRendererPixbuf` type acts as a reference-counted owner of an underlying `GtkCellRendererPixbuf` instance.
/// It provides the methods that can operate on this data type through `CellRendererPixbufProtocol` conformance.
/// Use `CellRendererPixbuf` as a strong reference or owner of a `GtkCellRendererPixbuf` instance.
///
open class CellRendererPixbuf: CellRenderer, CellRendererPixbufProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererPixbuf>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererPixbuf>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererPixbuf>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererPixbuf>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererPixbuf`.
    /// i.e., ownership is transferred to the `CellRendererPixbuf` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererPixbuf>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererPixbufProtocol`
    /// Will retain `GtkCellRendererPixbuf`.
    /// - Parameter other: an instance of a related type that implements `CellRendererPixbufProtocol`
    @inlinable public init<T: CellRendererPixbufProtocol>(cellRendererPixbuf other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererPixbufProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererPixbuf`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “pixbuf” property on the cell renderer to a pixbuf value
    /// in the model, thus rendering a different image in each row of the
    /// `GtkTreeView`.
    @inlinable public init() {
        let rv = gtk_cell_renderer_pixbuf_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererPixbufPropertyName: String, PropertyNameProtocol {
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    /// The GIcon representing the icon to display.
    /// If the icon theme is changed, the image will be updated
    /// automatically.
    case gicon = "gicon"
    case height = "height"
    /// The name of the themed icon to display.
    /// This property only has an effect if not overridden by the "pixbuf" property.
    case iconName = "icon-name"
    /// The `GtkIconSize` value that specifies the size of the rendered icon.
    case iconSize = "icon-size"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    case pixbuf = "pixbuf"
    case pixbufExpanderClosed = "pixbuf-expander-closed"
    case pixbufExpanderOpen = "pixbuf-expander-open"
    case sensitive = "sensitive"
    case texture = "texture"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererPixbufProtocol {
    /// Bind a `CellRendererPixbufPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererPixbufPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererPixbuf property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererPixbufPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererPixbuf property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererPixbufPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererPixbufSignalName: String, SignalNameProtocol {
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    /// The GIcon representing the icon to display.
    /// If the icon theme is changed, the image will be updated
    /// automatically.
    case notifyGicon = "notify::gicon"
    case notifyHeight = "notify::height"
    /// The name of the themed icon to display.
    /// This property only has an effect if not overridden by the "pixbuf" property.
    case notifyIconName = "notify::icon-name"
    /// The `GtkIconSize` value that specifies the size of the rendered icon.
    case notifyIconSize = "notify::icon-size"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    case notifyPixbuf = "notify::pixbuf"
    case notifyPixbufExpanderClosed = "notify::pixbuf-expander-closed"
    case notifyPixbufExpanderOpen = "notify::pixbuf-expander-open"
    case notifySensitive = "notify::sensitive"
    case notifyTexture = "notify::texture"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererPixbuf has no signals
// MARK: CellRendererPixbuf Class: CellRendererPixbufProtocol extension (methods and fields)
public extension CellRendererPixbufProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererPixbuf` instance.
    @inlinable var cell_renderer_pixbuf_ptr: UnsafeMutablePointer<GtkCellRendererPixbuf>! { return ptr?.assumingMemoryBound(to: GtkCellRendererPixbuf.self) }



}



// MARK: - CellRendererProgress Class

/// Renders numbers as progress bars
/// 
/// `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
///
/// The `CellRendererProgressProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererProgress` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererProgress`.
/// Alternatively, use `CellRendererProgressRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererProgressProtocol: CellRendererProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererProgress` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererProgress` instance.
    var cell_renderer_progress_ptr: UnsafeMutablePointer<GtkCellRendererProgress>! { get }

    /// Required Initialiser for types conforming to `CellRendererProgressProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders numbers as progress bars
/// 
/// `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
///
/// The `CellRendererProgressRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererProgress` instance.
/// It exposes methods that can operate on this data type through `CellRendererProgressProtocol` conformance.
/// Use `CellRendererProgressRef` only as an `unowned` reference to an existing `GtkCellRendererProgress` instance.
///
public struct CellRendererProgressRef: CellRendererProgressProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererProgress` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_progress_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererProgressRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererProgress>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererProgress>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererProgress>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererProgress>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererProgressProtocol`
    @inlinable init<T: CellRendererProgressProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererProgressProtocol>(_ other: T) -> CellRendererProgressRef { CellRendererProgressRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererProgress`.
    @inlinable init() {
        let rv = gtk_cell_renderer_progress_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders numbers as progress bars
/// 
/// `GtkCellRendererProgress` renders a numeric value as a progress par in a cell.
/// Additionally, it can display a text on top of the progress bar.
///
/// The `CellRendererProgress` type acts as a reference-counted owner of an underlying `GtkCellRendererProgress` instance.
/// It provides the methods that can operate on this data type through `CellRendererProgressProtocol` conformance.
/// Use `CellRendererProgress` as a strong reference or owner of a `GtkCellRendererProgress` instance.
///
open class CellRendererProgress: CellRenderer, CellRendererProgressProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererProgress>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererProgress>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererProgress>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererProgress>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererProgress`.
    /// i.e., ownership is transferred to the `CellRendererProgress` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererProgress>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererProgressProtocol`
    /// Will retain `GtkCellRendererProgress`.
    /// - Parameter other: an instance of a related type that implements `CellRendererProgressProtocol`
    @inlinable public init<T: CellRendererProgressProtocol>(cellRendererProgress other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererProgressProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererProgress`.
    @inlinable public init() {
        let rv = gtk_cell_renderer_progress_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererProgressPropertyName: String, PropertyNameProtocol {
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case inverted = "inverted"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    /// Setting this to a non-negative value causes the cell renderer to
    /// enter "activity mode", where a block bounces back and forth to
    /// indicate that some progress is made, without specifying exactly how
    /// much.
    /// 
    /// Each increment of the property causes the block to move by a little
    /// bit.
    /// 
    /// To indicate that the activity has not started yet, set the property
    /// to zero. To indicate completion, set the property to `G_MAXINT`.
    case pulse = "pulse"
    case sensitive = "sensitive"
    /// The "text" property determines the label which will be drawn
    /// over the progress bar. Setting this property to `nil` causes the default
    /// label to be displayed. Setting this property to an empty string causes
    /// no label to be displayed.
    case text = "text"
    /// The "text-xalign" property controls the horizontal alignment of the
    /// text in the progress bar.  Valid values range from 0 (left) to 1
    /// (right).  Reserved for RTL layouts.
    case textXalign = "text-xalign"
    /// The "text-yalign" property controls the vertical alignment of the
    /// text in the progress bar.  Valid values range from 0 (top) to 1
    /// (bottom).
    case textYalign = "text-yalign"
    /// The "value" property determines the percentage to which the
    /// progress bar will be "filled in".
    case value = "value"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererProgressProtocol {
    /// Bind a `CellRendererProgressPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererProgressPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererProgress property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererProgressPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererProgress property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererProgressPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererProgressSignalName: String, SignalNameProtocol {
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyInverted = "notify::inverted"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    /// Setting this to a non-negative value causes the cell renderer to
    /// enter "activity mode", where a block bounces back and forth to
    /// indicate that some progress is made, without specifying exactly how
    /// much.
    /// 
    /// Each increment of the property causes the block to move by a little
    /// bit.
    /// 
    /// To indicate that the activity has not started yet, set the property
    /// to zero. To indicate completion, set the property to `G_MAXINT`.
    case notifyPulse = "notify::pulse"
    case notifySensitive = "notify::sensitive"
    /// The "text" property determines the label which will be drawn
    /// over the progress bar. Setting this property to `nil` causes the default
    /// label to be displayed. Setting this property to an empty string causes
    /// no label to be displayed.
    case notifyText = "notify::text"
    /// The "text-xalign" property controls the horizontal alignment of the
    /// text in the progress bar.  Valid values range from 0 (left) to 1
    /// (right).  Reserved for RTL layouts.
    case notifyTextXalign = "notify::text-xalign"
    /// The "text-yalign" property controls the vertical alignment of the
    /// text in the progress bar.  Valid values range from 0 (top) to 1
    /// (bottom).
    case notifyTextYalign = "notify::text-yalign"
    /// The "value" property determines the percentage to which the
    /// progress bar will be "filled in".
    case notifyValue = "notify::value"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererProgress has no signals
// MARK: CellRendererProgress Class: CellRendererProgressProtocol extension (methods and fields)
public extension CellRendererProgressProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererProgress` instance.
    @inlinable var cell_renderer_progress_ptr: UnsafeMutablePointer<GtkCellRendererProgress>! { return ptr?.assumingMemoryBound(to: GtkCellRendererProgress.self) }



}



// MARK: - CellRendererSpin Class

/// Renders a spin button in a cell
/// 
/// `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
/// 
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `GtkCellRendererSpin`
/// also has properties for the `GtkCellRendererSpin:climb-rate` and the number
/// of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
/// can be set in a handler for the `GtkCellRenderer`editing-started`` signal.
/// 
/// The `GtkCellRendererSpin` cell renderer was added in GTK 2.10.
///
/// The `CellRendererSpinProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererSpin` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererSpin`.
/// Alternatively, use `CellRendererSpinRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererSpinProtocol: CellRendererTextProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererSpin` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererSpin` instance.
    var cell_renderer_spin_ptr: UnsafeMutablePointer<GtkCellRendererSpin>! { get }

    /// Required Initialiser for types conforming to `CellRendererSpinProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders a spin button in a cell
/// 
/// `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
/// 
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `GtkCellRendererSpin`
/// also has properties for the `GtkCellRendererSpin:climb-rate` and the number
/// of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
/// can be set in a handler for the `GtkCellRenderer`editing-started`` signal.
/// 
/// The `GtkCellRendererSpin` cell renderer was added in GTK 2.10.
///
/// The `CellRendererSpinRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererSpin` instance.
/// It exposes methods that can operate on this data type through `CellRendererSpinProtocol` conformance.
/// Use `CellRendererSpinRef` only as an `unowned` reference to an existing `GtkCellRendererSpin` instance.
///
public struct CellRendererSpinRef: CellRendererSpinProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererSpin` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_spin_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererSpinRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererSpin>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererSpin>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererSpin>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererSpin>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererSpinProtocol`
    @inlinable init<T: CellRendererSpinProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererSpinProtocol>(_ other: T) -> CellRendererSpinRef { CellRendererSpinRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererSpin`.
    @inlinable init() {
        let rv = gtk_cell_renderer_spin_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders a spin button in a cell
/// 
/// `GtkCellRendererSpin` renders text in a cell like `GtkCellRendererText` from
/// which it is derived. But while `GtkCellRendererText` offers a simple entry to
/// edit the text, `GtkCellRendererSpin` offers a `GtkSpinButton` widget. Of course,
/// that means that the text has to be parseable as a floating point number.
/// 
/// The range of the spinbutton is taken from the adjustment property of the
/// cell renderer, which can be set explicitly or mapped to a column in the
/// tree model, like all properties of cell renders. `GtkCellRendererSpin`
/// also has properties for the `GtkCellRendererSpin:climb-rate` and the number
/// of `GtkCellRendererSpin:digits` to display. Other `GtkSpinButton` properties
/// can be set in a handler for the `GtkCellRenderer`editing-started`` signal.
/// 
/// The `GtkCellRendererSpin` cell renderer was added in GTK 2.10.
///
/// The `CellRendererSpin` type acts as a reference-counted owner of an underlying `GtkCellRendererSpin` instance.
/// It provides the methods that can operate on this data type through `CellRendererSpinProtocol` conformance.
/// Use `CellRendererSpin` as a strong reference or owner of a `GtkCellRendererSpin` instance.
///
open class CellRendererSpin: CellRendererText, CellRendererSpinProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererSpin>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererSpin>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererSpin>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererSpin>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererSpin`.
    /// i.e., ownership is transferred to the `CellRendererSpin` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererSpin>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererSpinProtocol`
    /// Will retain `GtkCellRendererSpin`.
    /// - Parameter other: an instance of a related type that implements `CellRendererSpinProtocol`
    @inlinable public init<T: CellRendererSpinProtocol>(cellRendererSpin other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererSpin`.
    @inlinable override public init() {
        let rv = gtk_cell_renderer_spin_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererSpinPropertyName: String, PropertyNameProtocol {
    /// The adjustment that holds the value of the spinbutton.
    /// This must be non-`nil` for the cell renderer to be editable.
    case adjustment = "adjustment"
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkRGBA`
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    /// The acceleration rate when you hold down a button.
    case climbRate = "climb-rate"
    /// The number of decimal places to display.
    case digits = "digits"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererSpinProtocol {
    /// Bind a `CellRendererSpinPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererSpinPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererSpin property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererSpinPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererSpin property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererSpinPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererSpinSignalName: String, SignalNameProtocol {
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The adjustment that holds the value of the spinbutton.
    /// This must be non-`nil` for the cell renderer to be editable.
    case notifyAdjustment = "notify::adjustment"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    /// The acceleration rate when you hold down a button.
    case notifyClimbRate = "notify::climb-rate"
    /// The number of decimal places to display.
    case notifyDigits = "notify::digits"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererSpin has no signals
// MARK: CellRendererSpin Class: CellRendererSpinProtocol extension (methods and fields)
public extension CellRendererSpinProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererSpin` instance.
    @inlinable var cell_renderer_spin_ptr: UnsafeMutablePointer<GtkCellRendererSpin>! { return ptr?.assumingMemoryBound(to: GtkCellRendererSpin.self) }



}



// MARK: - CellRendererSpinner Class

/// Renders a spinning animation in a cell
/// 
/// `GtkCellRendererSpinner` renders a spinning animation in a cell, very
/// similar to `GtkSpinner`. It can often be used as an alternative
/// to a `GtkCellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
/// 
/// To start the animation in a cell, set the `GtkCellRendererSpinner:active`
/// property to `true` and increment the `GtkCellRendererSpinner:pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk_tree_view_column_add_attribute()`.
///
/// The `CellRendererSpinnerProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererSpinner` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererSpinner`.
/// Alternatively, use `CellRendererSpinnerRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererSpinnerProtocol: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererSpinner` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererSpinner` instance.
    var cell_renderer_spinner_ptr: UnsafeMutablePointer<GtkCellRendererSpinner>! { get }

    /// Required Initialiser for types conforming to `CellRendererSpinnerProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders a spinning animation in a cell
/// 
/// `GtkCellRendererSpinner` renders a spinning animation in a cell, very
/// similar to `GtkSpinner`. It can often be used as an alternative
/// to a `GtkCellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
/// 
/// To start the animation in a cell, set the `GtkCellRendererSpinner:active`
/// property to `true` and increment the `GtkCellRendererSpinner:pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk_tree_view_column_add_attribute()`.
///
/// The `CellRendererSpinnerRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererSpinner` instance.
/// It exposes methods that can operate on this data type through `CellRendererSpinnerProtocol` conformance.
/// Use `CellRendererSpinnerRef` only as an `unowned` reference to an existing `GtkCellRendererSpinner` instance.
///
public struct CellRendererSpinnerRef: CellRendererSpinnerProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererSpinner` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_spinner_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererSpinnerRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererSpinner>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererSpinner>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererSpinner>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererSpinner>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererSpinnerProtocol`
    @inlinable init<T: CellRendererSpinnerProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererSpinnerProtocol>(_ other: T) -> CellRendererSpinnerRef { CellRendererSpinnerRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Returns a new cell renderer which will show a spinner to indicate
    /// activity.
    @inlinable init() {
        let rv = gtk_cell_renderer_spinner_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders a spinning animation in a cell
/// 
/// `GtkCellRendererSpinner` renders a spinning animation in a cell, very
/// similar to `GtkSpinner`. It can often be used as an alternative
/// to a `GtkCellRendererProgress` for displaying indefinite activity,
/// instead of actual progress.
/// 
/// To start the animation in a cell, set the `GtkCellRendererSpinner:active`
/// property to `true` and increment the `GtkCellRendererSpinner:pulse` property
/// at regular intervals. The usual way to set the cell renderer properties
/// for each cell is to bind them to columns in your tree model using e.g.
/// `gtk_tree_view_column_add_attribute()`.
///
/// The `CellRendererSpinner` type acts as a reference-counted owner of an underlying `GtkCellRendererSpinner` instance.
/// It provides the methods that can operate on this data type through `CellRendererSpinnerProtocol` conformance.
/// Use `CellRendererSpinner` as a strong reference or owner of a `GtkCellRendererSpinner` instance.
///
open class CellRendererSpinner: CellRenderer, CellRendererSpinnerProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererSpinner>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererSpinner>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererSpinner>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererSpinner>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererSpinner`.
    /// i.e., ownership is transferred to the `CellRendererSpinner` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererSpinner>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererSpinnerProtocol`
    /// Will retain `GtkCellRendererSpinner`.
    /// - Parameter other: an instance of a related type that implements `CellRendererSpinnerProtocol`
    @inlinable public init<T: CellRendererSpinnerProtocol>(cellRendererSpinner other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererSpinnerProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Returns a new cell renderer which will show a spinner to indicate
    /// activity.
    @inlinable public init() {
        let rv = gtk_cell_renderer_spinner_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererSpinnerPropertyName: String, PropertyNameProtocol {
    case active = "active"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    /// Pulse of the spinner. Increment this value to draw the next frame of the
    /// spinner animation. Usually, you would update this value in a timeout.
    /// 
    /// By default, the `GtkSpinner` widget draws one full cycle of the animation,
    /// consisting of 12 frames, in 750 milliseconds.
    case pulse = "pulse"
    case sensitive = "sensitive"
    /// The `GtkIconSize` value that specifies the size of the rendered spinner.
    case size = "size"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererSpinnerProtocol {
    /// Bind a `CellRendererSpinnerPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererSpinnerPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererSpinner property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererSpinnerPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererSpinner property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererSpinnerPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererSpinnerSignalName: String, SignalNameProtocol {
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyActive = "notify::active"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    /// Pulse of the spinner. Increment this value to draw the next frame of the
    /// spinner animation. Usually, you would update this value in a timeout.
    /// 
    /// By default, the `GtkSpinner` widget draws one full cycle of the animation,
    /// consisting of 12 frames, in 750 milliseconds.
    case notifyPulse = "notify::pulse"
    case notifySensitive = "notify::sensitive"
    /// The `GtkIconSize` value that specifies the size of the rendered spinner.
    case notifySize = "notify::size"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererSpinner has no signals
// MARK: CellRendererSpinner Class: CellRendererSpinnerProtocol extension (methods and fields)
public extension CellRendererSpinnerProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererSpinner` instance.
    @inlinable var cell_renderer_spinner_ptr: UnsafeMutablePointer<GtkCellRendererSpinner>! { return ptr?.assumingMemoryBound(to: GtkCellRendererSpinner.self) }



}



// MARK: - CellRendererText Class

/// Renders text in a cell
/// 
/// A `GtkCellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `GtkCellRendererText:ellipsize` property allows it.
/// 
/// If the `GtkCellRenderer:mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `GtkCellRendererText` allows to edit its text using an entry.
///
/// The `CellRendererTextProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererText` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererText`.
/// Alternatively, use `CellRendererTextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererTextProtocol: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererText` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererText` instance.
    var cell_renderer_text_ptr: UnsafeMutablePointer<GtkCellRendererText>! { get }

    /// Required Initialiser for types conforming to `CellRendererTextProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders text in a cell
/// 
/// A `GtkCellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `GtkCellRendererText:ellipsize` property allows it.
/// 
/// If the `GtkCellRenderer:mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `GtkCellRendererText` allows to edit its text using an entry.
///
/// The `CellRendererTextRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererText` instance.
/// It exposes methods that can operate on this data type through `CellRendererTextProtocol` conformance.
/// Use `CellRendererTextRef` only as an `unowned` reference to an existing `GtkCellRendererText` instance.
///
public struct CellRendererTextRef: CellRendererTextProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererText` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_text_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererTextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererText>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererText>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererText>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererText>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererTextProtocol`
    @inlinable init<T: CellRendererTextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererTextProtocol>(_ other: T) -> CellRendererTextRef { CellRendererTextRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererText`. Adjust how text is drawn using
    /// object properties. Object properties can be
    /// set globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`,
    /// you can bind a property to a value in a `GtkTreeModel`. For example,
    /// you can bind the “text” property on the cell renderer to a string
    /// value in the model, thus rendering a different string in each row
    /// of the `GtkTreeView`.
    @inlinable init() {
        let rv = gtk_cell_renderer_text_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders text in a cell
/// 
/// A `GtkCellRendererText` renders a given text in its cell, using the font, color and
/// style information provided by its properties. The text will be ellipsized if it is
/// too long and the `GtkCellRendererText:ellipsize` property allows it.
/// 
/// If the `GtkCellRenderer:mode` is `GTK_CELL_RENDERER_MODE_EDITABLE`,
/// the `GtkCellRendererText` allows to edit its text using an entry.
///
/// The `CellRendererText` type acts as a reference-counted owner of an underlying `GtkCellRendererText` instance.
/// It provides the methods that can operate on this data type through `CellRendererTextProtocol` conformance.
/// Use `CellRendererText` as a strong reference or owner of a `GtkCellRendererText` instance.
///
open class CellRendererText: CellRenderer, CellRendererTextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererText>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererText>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererText>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererText>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererText`.
    /// i.e., ownership is transferred to the `CellRendererText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererText>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererTextProtocol`
    /// Will retain `GtkCellRendererText`.
    /// - Parameter other: an instance of a related type that implements `CellRendererTextProtocol`
    @inlinable public init<T: CellRendererTextProtocol>(cellRendererText other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererTextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererText`. Adjust how text is drawn using
    /// object properties. Object properties can be
    /// set globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`,
    /// you can bind a property to a value in a `GtkTreeModel`. For example,
    /// you can bind the “text” property on the cell renderer to a string
    /// value in the model, thus rendering a different string in each row
    /// of the `GtkTreeView`.
    @inlinable public init() {
        let rv = gtk_cell_renderer_text_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererTextPropertyName: String, PropertyNameProtocol {
    case alignSet = "align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case alignment = "alignment"
    case attributes = "attributes"
    case background = "background"
    /// Background color as a `GdkRGBA`
    case backgroundRgba = "background-rgba"
    case backgroundSet = "background-set"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editable = "editable"
    case editableSet = "editable-set"
    case editing = "editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case ellipsize = "ellipsize"
    case ellipsizeSet = "ellipsize-set"
    case family = "family"
    case familySet = "family-set"
    case font = "font"
    case fontDesc = "font-desc"
    case foreground = "foreground"
    /// Foreground color as a `GdkRGBA`
    case foregroundRgba = "foreground-rgba"
    case foregroundSet = "foreground-set"
    case height = "height"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case language = "language"
    case languageSet = "language-set"
    case markup = "markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case maxWidthChars = "max-width-chars"
    case mode = "mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case placeholderText = "placeholder-text"
    case rise = "rise"
    case riseSet = "rise-set"
    case scale = "scale"
    case scaleSet = "scale-set"
    case sensitive = "sensitive"
    case singleParagraphMode = "single-paragraph-mode"
    case size = "size"
    case sizePoints = "size-points"
    case sizeSet = "size-set"
    case stretch = "stretch"
    case stretchSet = "stretch-set"
    case strikethrough = "strikethrough"
    case strikethroughSet = "strikethrough-set"
    case style = "style"
    case styleSet = "style-set"
    case text = "text"
    case underline = "underline"
    case underlineSet = "underline-set"
    case variant = "variant"
    case variantSet = "variant-set"
    case visible = "visible"
    case weight = "weight"
    case weightSet = "weight-set"
    case width = "width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case widthChars = "width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case wrapMode = "wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case wrapWidth = "wrap-width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererTextProtocol {
    /// Bind a `CellRendererTextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererTextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererText property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererTextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererText property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererTextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererTextSignalName: String, SignalNameProtocol {
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    case edited = "edited"
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    case notifyAlignSet = "notify::align-set"
    /// Specifies how to align the lines of text with respect to each other.
    /// 
    /// Note that this property describes how to align the lines of text in
    /// case there are several of them. The "xalign" property of `GtkCellRenderer`,
    /// on the other hand, sets the horizontal alignment of the whole text.
    case notifyAlignment = "notify::alignment"
    case notifyAttributes = "notify::attributes"
    case notifyBackground = "notify::background"
    /// Background color as a `GdkRGBA`
    case notifyBackgroundRgba = "notify::background-rgba"
    case notifyBackgroundSet = "notify::background-set"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditable = "notify::editable"
    case notifyEditableSet = "notify::editable-set"
    case notifyEditing = "notify::editing"
    /// Specifies the preferred place to ellipsize the string, if the cell renderer
    /// does not have enough room to display the entire string. Setting it to
    /// `PANGO_ELLIPSIZE_NONE` turns off ellipsizing. See the wrap-width property
    /// for another way of making the text fit into a given width.
    case notifyEllipsize = "notify::ellipsize"
    case notifyEllipsizeSet = "notify::ellipsize-set"
    case notifyFamily = "notify::family"
    case notifyFamilySet = "notify::family-set"
    case notifyFont = "notify::font"
    case notifyFontDesc = "notify::font-desc"
    case notifyForeground = "notify::foreground"
    /// Foreground color as a `GdkRGBA`
    case notifyForegroundRgba = "notify::foreground-rgba"
    case notifyForegroundSet = "notify::foreground-set"
    case notifyHeight = "notify::height"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyLanguage = "notify::language"
    case notifyLanguageSet = "notify::language-set"
    case notifyMarkup = "notify::markup"
    /// The desired maximum width of the cell, in characters. If this property
    /// is set to -1, the width will be calculated automatically.
    /// 
    /// For cell renderers that ellipsize or wrap text; this property
    /// controls the maximum reported width of the cell. The
    /// cell should not receive any greater allocation unless it is
    /// set to expand in its `GtkCellLayout` and all of the cell's siblings
    /// have received their natural width.
    case notifyMaxWidthChars = "notify::max-width-chars"
    case notifyMode = "notify::mode"
    /// The text that will be displayed in the `GtkCellRenderer` if
    /// `GtkCellRendererText:editable` is `true` and the cell is empty.
    case notifyPlaceholderText = "notify::placeholder-text"
    case notifyRise = "notify::rise"
    case notifyRiseSet = "notify::rise-set"
    case notifyScale = "notify::scale"
    case notifyScaleSet = "notify::scale-set"
    case notifySensitive = "notify::sensitive"
    case notifySingleParagraphMode = "notify::single-paragraph-mode"
    case notifySize = "notify::size"
    case notifySizePoints = "notify::size-points"
    case notifySizeSet = "notify::size-set"
    case notifyStretch = "notify::stretch"
    case notifyStretchSet = "notify::stretch-set"
    case notifyStrikethrough = "notify::strikethrough"
    case notifyStrikethroughSet = "notify::strikethrough-set"
    case notifyStyle = "notify::style"
    case notifyStyleSet = "notify::style-set"
    case notifyText = "notify::text"
    case notifyUnderline = "notify::underline"
    case notifyUnderlineSet = "notify::underline-set"
    case notifyVariant = "notify::variant"
    case notifyVariantSet = "notify::variant-set"
    case notifyVisible = "notify::visible"
    case notifyWeight = "notify::weight"
    case notifyWeightSet = "notify::weight-set"
    case notifyWidth = "notify::width"
    /// The desired width of the cell, in characters. If this property is set to
    /// -1, the width will be calculated automatically, otherwise the cell will
    /// request either 3 characters or the property value, whichever is greater.
    case notifyWidthChars = "notify::width-chars"
    /// Specifies how to break the string into multiple lines, if the cell
    /// renderer does not have enough room to display the entire string.
    /// This property has no effect unless the wrap-width property is set.
    case notifyWrapMode = "notify::wrap-mode"
    /// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
    /// be used to influence at what character positions the line breaks can be placed.
    /// Setting wrap-width to -1 turns wrapping off.
    case notifyWrapWidth = "notify::wrap-width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererText signals
public extension CellRendererTextProtocol {
    /// Connect a Swift signal handler to the given, typed `CellRendererTextSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererTextSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellRendererTextSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererTextSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// This signal is emitted after `renderer` has been edited.
    /// 
    /// It is the responsibility of the application to update the model
    /// and store `new_text` at the position indicated by `path`.
    /// - Note: This represents the underlying `edited` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: the path identifying the edited cell
    /// - Parameter newText: the new text
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `edited` signal is emitted
    @discardableResult @inlinable func onEdited(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ path: String, _ newText: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<CellRendererTextRef, String, String, Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!, arg2.map({ String(cString: $0) })!)
            return output
        }
        return connect(
            signal: .edited,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `edited` signal for using the `connect(signal:)` methods
    static var editedSignal: CellRendererTextSignalName { .edited }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::align-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAlignSet` signal is emitted
    @discardableResult @inlinable func onNotifyAlignSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAlignSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::align-set` signal for using the `connect(signal:)` methods
    static var notifyAlignSetSignal: CellRendererTextSignalName { .notifyAlignSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::alignment` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAlignment` signal is emitted
    @discardableResult @inlinable func onNotifyAlignment(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAlignment,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::alignment` signal for using the `connect(signal:)` methods
    static var notifyAlignmentSignal: CellRendererTextSignalName { .notifyAlignment }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::attributes` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyAttributes` signal is emitted
    @discardableResult @inlinable func onNotifyAttributes(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyAttributes,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::attributes` signal for using the `connect(signal:)` methods
    static var notifyAttributesSignal: CellRendererTextSignalName { .notifyAttributes }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::background` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBackground` signal is emitted
    @discardableResult @inlinable func onNotifyBackground(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyBackground,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::background` signal for using the `connect(signal:)` methods
    static var notifyBackgroundSignal: CellRendererTextSignalName { .notifyBackground }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::background-rgba` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBackgroundRgba` signal is emitted
    @discardableResult @inlinable func onNotifyBackgroundRgba(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyBackgroundRgba,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::background-rgba` signal for using the `connect(signal:)` methods
    static var notifyBackgroundRgbaSignal: CellRendererTextSignalName { .notifyBackgroundRgba }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::background-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyBackgroundSet` signal is emitted
    @discardableResult @inlinable func onNotifyBackgroundSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyBackgroundSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::background-set` signal for using the `connect(signal:)` methods
    static var notifyBackgroundSetSignal: CellRendererTextSignalName { .notifyBackgroundSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::editable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditable` signal is emitted
    @discardableResult @inlinable func onNotifyEditable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEditable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::editable` signal for using the `connect(signal:)` methods
    static var notifyEditableSignal: CellRendererTextSignalName { .notifyEditable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::editable-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEditableSet` signal is emitted
    @discardableResult @inlinable func onNotifyEditableSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEditableSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::editable-set` signal for using the `connect(signal:)` methods
    static var notifyEditableSetSignal: CellRendererTextSignalName { .notifyEditableSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::ellipsize` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEllipsize` signal is emitted
    @discardableResult @inlinable func onNotifyEllipsize(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEllipsize,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::ellipsize` signal for using the `connect(signal:)` methods
    static var notifyEllipsizeSignal: CellRendererTextSignalName { .notifyEllipsize }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::ellipsize-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEllipsizeSet` signal is emitted
    @discardableResult @inlinable func onNotifyEllipsizeSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEllipsizeSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::ellipsize-set` signal for using the `connect(signal:)` methods
    static var notifyEllipsizeSetSignal: CellRendererTextSignalName { .notifyEllipsizeSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::family` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFamily` signal is emitted
    @discardableResult @inlinable func onNotifyFamily(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFamily,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::family` signal for using the `connect(signal:)` methods
    static var notifyFamilySignal: CellRendererTextSignalName { .notifyFamily }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::family-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFamilySet` signal is emitted
    @discardableResult @inlinable func onNotifyFamilySet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFamilySet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::family-set` signal for using the `connect(signal:)` methods
    static var notifyFamilySetSignal: CellRendererTextSignalName { .notifyFamilySet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::font` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFont` signal is emitted
    @discardableResult @inlinable func onNotifyFont(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFont,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::font` signal for using the `connect(signal:)` methods
    static var notifyFontSignal: CellRendererTextSignalName { .notifyFont }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::font-desc` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyFontDesc` signal is emitted
    @discardableResult @inlinable func onNotifyFontDesc(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyFontDesc,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::font-desc` signal for using the `connect(signal:)` methods
    static var notifyFontDescSignal: CellRendererTextSignalName { .notifyFontDesc }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::foreground` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyForeground` signal is emitted
    @discardableResult @inlinable func onNotifyForeground(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyForeground,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::foreground` signal for using the `connect(signal:)` methods
    static var notifyForegroundSignal: CellRendererTextSignalName { .notifyForeground }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::foreground-rgba` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyForegroundRgba` signal is emitted
    @discardableResult @inlinable func onNotifyForegroundRgba(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyForegroundRgba,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::foreground-rgba` signal for using the `connect(signal:)` methods
    static var notifyForegroundRgbaSignal: CellRendererTextSignalName { .notifyForegroundRgba }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::foreground-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyForegroundSet` signal is emitted
    @discardableResult @inlinable func onNotifyForegroundSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyForegroundSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::foreground-set` signal for using the `connect(signal:)` methods
    static var notifyForegroundSetSignal: CellRendererTextSignalName { .notifyForegroundSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::language` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLanguage` signal is emitted
    @discardableResult @inlinable func onNotifyLanguage(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLanguage,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::language` signal for using the `connect(signal:)` methods
    static var notifyLanguageSignal: CellRendererTextSignalName { .notifyLanguage }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::language-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLanguageSet` signal is emitted
    @discardableResult @inlinable func onNotifyLanguageSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLanguageSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::language-set` signal for using the `connect(signal:)` methods
    static var notifyLanguageSetSignal: CellRendererTextSignalName { .notifyLanguageSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::markup` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMarkup` signal is emitted
    @discardableResult @inlinable func onNotifyMarkup(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMarkup,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::markup` signal for using the `connect(signal:)` methods
    static var notifyMarkupSignal: CellRendererTextSignalName { .notifyMarkup }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::max-width-chars` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyMaxWidthChars` signal is emitted
    @discardableResult @inlinable func onNotifyMaxWidthChars(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyMaxWidthChars,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::max-width-chars` signal for using the `connect(signal:)` methods
    static var notifyMaxWidthCharsSignal: CellRendererTextSignalName { .notifyMaxWidthChars }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::placeholder-text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPlaceholderText` signal is emitted
    @discardableResult @inlinable func onNotifyPlaceholderText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPlaceholderText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::placeholder-text` signal for using the `connect(signal:)` methods
    static var notifyPlaceholderTextSignal: CellRendererTextSignalName { .notifyPlaceholderText }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::rise` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRise` signal is emitted
    @discardableResult @inlinable func onNotifyRise(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyRise,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::rise` signal for using the `connect(signal:)` methods
    static var notifyRiseSignal: CellRendererTextSignalName { .notifyRise }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::rise-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRiseSet` signal is emitted
    @discardableResult @inlinable func onNotifyRiseSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyRiseSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::rise-set` signal for using the `connect(signal:)` methods
    static var notifyRiseSetSignal: CellRendererTextSignalName { .notifyRiseSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::scale` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyScale` signal is emitted
    @discardableResult @inlinable func onNotifyScale(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyScale,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::scale` signal for using the `connect(signal:)` methods
    static var notifyScaleSignal: CellRendererTextSignalName { .notifyScale }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::scale-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyScaleSet` signal is emitted
    @discardableResult @inlinable func onNotifyScaleSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyScaleSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::scale-set` signal for using the `connect(signal:)` methods
    static var notifyScaleSetSignal: CellRendererTextSignalName { .notifyScaleSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::single-paragraph-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySingleParagraphMode` signal is emitted
    @discardableResult @inlinable func onNotifySingleParagraphMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySingleParagraphMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::single-paragraph-mode` signal for using the `connect(signal:)` methods
    static var notifySingleParagraphModeSignal: CellRendererTextSignalName { .notifySingleParagraphMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::size` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySize` signal is emitted
    @discardableResult @inlinable func onNotifySize(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySize,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::size` signal for using the `connect(signal:)` methods
    static var notifySizeSignal: CellRendererTextSignalName { .notifySize }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::size-points` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySizePoints` signal is emitted
    @discardableResult @inlinable func onNotifySizePoints(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySizePoints,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::size-points` signal for using the `connect(signal:)` methods
    static var notifySizePointsSignal: CellRendererTextSignalName { .notifySizePoints }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::size-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySizeSet` signal is emitted
    @discardableResult @inlinable func onNotifySizeSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySizeSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::size-set` signal for using the `connect(signal:)` methods
    static var notifySizeSetSignal: CellRendererTextSignalName { .notifySizeSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::stretch` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStretch` signal is emitted
    @discardableResult @inlinable func onNotifyStretch(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStretch,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::stretch` signal for using the `connect(signal:)` methods
    static var notifyStretchSignal: CellRendererTextSignalName { .notifyStretch }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::stretch-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStretchSet` signal is emitted
    @discardableResult @inlinable func onNotifyStretchSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStretchSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::stretch-set` signal for using the `connect(signal:)` methods
    static var notifyStretchSetSignal: CellRendererTextSignalName { .notifyStretchSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::strikethrough` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStrikethrough` signal is emitted
    @discardableResult @inlinable func onNotifyStrikethrough(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStrikethrough,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::strikethrough` signal for using the `connect(signal:)` methods
    static var notifyStrikethroughSignal: CellRendererTextSignalName { .notifyStrikethrough }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::strikethrough-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStrikethroughSet` signal is emitted
    @discardableResult @inlinable func onNotifyStrikethroughSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStrikethroughSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::strikethrough-set` signal for using the `connect(signal:)` methods
    static var notifyStrikethroughSetSignal: CellRendererTextSignalName { .notifyStrikethroughSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::style` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStyle` signal is emitted
    @discardableResult @inlinable func onNotifyStyle(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStyle,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::style` signal for using the `connect(signal:)` methods
    static var notifyStyleSignal: CellRendererTextSignalName { .notifyStyle }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::style-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyStyleSet` signal is emitted
    @discardableResult @inlinable func onNotifyStyleSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyStyleSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::style-set` signal for using the `connect(signal:)` methods
    static var notifyStyleSetSignal: CellRendererTextSignalName { .notifyStyleSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyText` signal is emitted
    @discardableResult @inlinable func onNotifyText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::text` signal for using the `connect(signal:)` methods
    static var notifyTextSignal: CellRendererTextSignalName { .notifyText }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::underline` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUnderline` signal is emitted
    @discardableResult @inlinable func onNotifyUnderline(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyUnderline,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::underline` signal for using the `connect(signal:)` methods
    static var notifyUnderlineSignal: CellRendererTextSignalName { .notifyUnderline }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::underline-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUnderlineSet` signal is emitted
    @discardableResult @inlinable func onNotifyUnderlineSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyUnderlineSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::underline-set` signal for using the `connect(signal:)` methods
    static var notifyUnderlineSetSignal: CellRendererTextSignalName { .notifyUnderlineSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::variant` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVariant` signal is emitted
    @discardableResult @inlinable func onNotifyVariant(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyVariant,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::variant` signal for using the `connect(signal:)` methods
    static var notifyVariantSignal: CellRendererTextSignalName { .notifyVariant }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::variant-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyVariantSet` signal is emitted
    @discardableResult @inlinable func onNotifyVariantSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyVariantSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::variant-set` signal for using the `connect(signal:)` methods
    static var notifyVariantSetSignal: CellRendererTextSignalName { .notifyVariantSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::weight` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWeight` signal is emitted
    @discardableResult @inlinable func onNotifyWeight(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWeight,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::weight` signal for using the `connect(signal:)` methods
    static var notifyWeightSignal: CellRendererTextSignalName { .notifyWeight }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::weight-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWeightSet` signal is emitted
    @discardableResult @inlinable func onNotifyWeightSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWeightSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::weight-set` signal for using the `connect(signal:)` methods
    static var notifyWeightSetSignal: CellRendererTextSignalName { .notifyWeightSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::width-chars` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWidthChars` signal is emitted
    @discardableResult @inlinable func onNotifyWidthChars(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWidthChars,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::width-chars` signal for using the `connect(signal:)` methods
    static var notifyWidthCharsSignal: CellRendererTextSignalName { .notifyWidthChars }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::wrap-mode` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWrapMode` signal is emitted
    @discardableResult @inlinable func onNotifyWrapMode(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWrapMode,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::wrap-mode` signal for using the `connect(signal:)` methods
    static var notifyWrapModeSignal: CellRendererTextSignalName { .notifyWrapMode }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::wrap-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyWrapWidth` signal is emitted
    @discardableResult @inlinable func onNotifyWrapWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererTextRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererTextRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererTextRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyWrapWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::wrap-width` signal for using the `connect(signal:)` methods
    static var notifyWrapWidthSignal: CellRendererTextSignalName { .notifyWrapWidth }
    
}

// MARK: CellRendererText Class: CellRendererTextProtocol extension (methods and fields)
public extension CellRendererTextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererText` instance.
    @inlinable var cell_renderer_text_ptr: UnsafeMutablePointer<GtkCellRendererText>! { return ptr?.assumingMemoryBound(to: GtkCellRendererText.self) }

    /// Sets the height of a renderer to explicitly be determined by the “font” and
    /// “y_pad” property set on it.  Further changes in these properties do not
    /// affect the height, so they must be accompanied by a subsequent call to this
    /// function.  Using this function is inflexible, and should really only be used
    /// if calculating the size of a cell is too slow (ie, a massive number of cells
    /// displayed).  If `number_of_rows` is -1, then the fixed height is unset, and
    /// the height is determined by the properties again.
    @inlinable func setFixedHeightFromFont(numberOfRows: Int) {
        gtk_cell_renderer_text_set_fixed_height_from_font(cell_renderer_text_ptr, gint(numberOfRows))
    
    }

    @inlinable var parent: GtkCellRenderer {
        get {
            let rv = cell_renderer_text_ptr.pointee.parent
            return rv
        }
    }

}



// MARK: - CellRendererToggle Class

/// Renders a toggle button in a cell
/// 
/// `GtkCellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `GtkCellRendererToggle:radio` property.
/// When activated, it emits the `GtkCellRendererToggle`toggled`` signal.
///
/// The `CellRendererToggleProtocol` protocol exposes the methods and properties of an underlying `GtkCellRendererToggle` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellRendererToggle`.
/// Alternatively, use `CellRendererToggleRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellRendererToggleProtocol: CellRendererProtocol {
        /// Untyped pointer to the underlying `GtkCellRendererToggle` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellRendererToggle` instance.
    var cell_renderer_toggle_ptr: UnsafeMutablePointer<GtkCellRendererToggle>! { get }

    /// Required Initialiser for types conforming to `CellRendererToggleProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Renders a toggle button in a cell
/// 
/// `GtkCellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `GtkCellRendererToggle:radio` property.
/// When activated, it emits the `GtkCellRendererToggle`toggled`` signal.
///
/// The `CellRendererToggleRef` type acts as a lightweight Swift reference to an underlying `GtkCellRendererToggle` instance.
/// It exposes methods that can operate on this data type through `CellRendererToggleProtocol` conformance.
/// Use `CellRendererToggleRef` only as an `unowned` reference to an existing `GtkCellRendererToggle` instance.
///
public struct CellRendererToggleRef: CellRendererToggleProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellRendererToggle` instance.
    /// For type-safe access, use the generated, typed pointer `cell_renderer_toggle_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellRendererToggleRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellRendererToggle>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellRendererToggle>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellRendererToggle>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellRendererToggle>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellRendererToggleProtocol`
    @inlinable init<T: CellRendererToggleProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellRendererToggleProtocol>(_ other: T) -> CellRendererToggleRef { CellRendererToggleRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellRendererToggle`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “active” property on the cell renderer to a boolean value
    /// in the model, thus causing the check button to reflect the state of
    /// the model.
    @inlinable init() {
        let rv = gtk_cell_renderer_toggle_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// Renders a toggle button in a cell
/// 
/// `GtkCellRendererToggle` renders a toggle button in a cell. The
/// button is drawn as a radio or a checkbutton, depending on the
/// `GtkCellRendererToggle:radio` property.
/// When activated, it emits the `GtkCellRendererToggle`toggled`` signal.
///
/// The `CellRendererToggle` type acts as a reference-counted owner of an underlying `GtkCellRendererToggle` instance.
/// It provides the methods that can operate on this data type through `CellRendererToggleProtocol` conformance.
/// Use `CellRendererToggle` as a strong reference or owner of a `GtkCellRendererToggle` instance.
///
open class CellRendererToggle: CellRenderer, CellRendererToggleProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellRendererToggle>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellRendererToggle>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellRendererToggle>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellRendererToggle>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellRendererToggle`.
    /// i.e., ownership is transferred to the `CellRendererToggle` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellRendererToggle>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellRendererToggleProtocol`
    /// Will retain `GtkCellRendererToggle`.
    /// - Parameter other: an instance of a related type that implements `CellRendererToggleProtocol`
    @inlinable public init<T: CellRendererToggleProtocol>(cellRendererToggle other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellRendererToggleProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellRendererToggle`. Adjust rendering
    /// parameters using object properties. Object properties can be set
    /// globally (with `g_object_set()`). Also, with `GtkTreeViewColumn`, you
    /// can bind a property to a value in a `GtkTreeModel`. For example, you
    /// can bind the “active” property on the cell renderer to a boolean value
    /// in the model, thus causing the check button to reflect the state of
    /// the model.
    @inlinable public init() {
        let rv = gtk_cell_renderer_toggle_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CellRendererTogglePropertyName: String, PropertyNameProtocol {
    case activatable = "activatable"
    case active = "active"
    case cellBackground = "cell-background"
    /// Cell background as a `GdkRGBA`
    case cellBackgroundRgba = "cell-background-rgba"
    case cellBackgroundSet = "cell-background-set"
    case editing = "editing"
    case height = "height"
    case inconsistent = "inconsistent"
    case isExpanded = "is-expanded"
    case isExpander = "is-expander"
    case mode = "mode"
    case radio = "radio"
    case sensitive = "sensitive"
    case visible = "visible"
    case width = "width"
    case xalign = "xalign"
    case xpad = "xpad"
    case yalign = "yalign"
    case ypad = "ypad"
}

public extension CellRendererToggleProtocol {
    /// Bind a `CellRendererTogglePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellRendererTogglePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellRendererToggle property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellRendererTogglePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellRendererToggle property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellRendererTogglePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellRendererToggleSignalName: String, SignalNameProtocol {
    /// This signal gets emitted when the user cancels the process of editing a
    /// cell.  For example, an editable cell renderer could be written to cancel
    /// editing when the user presses Escape.
    /// 
    /// See also: `gtk_cell_renderer_stop_editing()`.
    case editingCanceled = "editing-canceled"
    /// This signal gets emitted when a cell starts to be edited.
    /// The intended use of this signal is to do special setup
    /// on `editable`, e.g. adding a `GtkEntryCompletion` or setting
    /// up additional columns in a `GtkComboBox`.
    /// 
    /// See `gtk_cell_editable_start_editing()` for information on the lifecycle of
    /// the `editable` and a way to do setup that doesn’t depend on the `renderer`.
    /// 
    /// Note that GTK doesn't guarantee that cell renderers will
    /// continue to use the same kind of widget for editing in future
    /// releases, therefore you should check the type of `editable`
    /// before doing any specific setup, as in the following example:
    /// (C Language Example):
    /// ```C
    /// static void
    /// text_editing_started (GtkCellRenderer *cell,
    ///                       GtkCellEditable *editable,
    ///                       const char      *path,
    ///                       gpointer         data)
    /// {
    ///   if (GTK_IS_ENTRY (editable))
    ///     {
    ///       GtkEntry *entry = GTK_ENTRY (editable);
    ///       
    ///       // ... create a GtkEntryCompletion
    ///       
    ///       gtk_entry_set_completion (entry, completion);
    ///     }
    /// }
    /// ```
    /// 
    case editingStarted = "editing-started"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `toggled` signal is emitted when the cell is toggled.
    /// 
    /// It is the responsibility of the application to update the model
    /// with the correct value to store at `path`.  Often this is simply the
    /// opposite of the value currently stored at `path`.
    case toggled = "toggled"
    case notifyActivatable = "notify::activatable"
    case notifyActive = "notify::active"
    case notifyCellBackground = "notify::cell-background"
    /// Cell background as a `GdkRGBA`
    case notifyCellBackgroundRgba = "notify::cell-background-rgba"
    case notifyCellBackgroundSet = "notify::cell-background-set"
    case notifyEditing = "notify::editing"
    case notifyHeight = "notify::height"
    case notifyInconsistent = "notify::inconsistent"
    case notifyIsExpanded = "notify::is-expanded"
    case notifyIsExpander = "notify::is-expander"
    case notifyMode = "notify::mode"
    case notifyRadio = "notify::radio"
    case notifySensitive = "notify::sensitive"
    case notifyVisible = "notify::visible"
    case notifyWidth = "notify::width"
    case notifyXalign = "notify::xalign"
    case notifyXpad = "notify::xpad"
    case notifyYalign = "notify::yalign"
    case notifyYpad = "notify::ypad"
}

// MARK: CellRendererToggle signals
public extension CellRendererToggleProtocol {
    /// Connect a Swift signal handler to the given, typed `CellRendererToggleSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererToggleSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CellRendererToggleSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CellRendererToggleSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// The `toggled` signal is emitted when the cell is toggled.
    /// 
    /// It is the responsibility of the application to update the model
    /// with the correct value to store at `path`.  Often this is simply the
    /// opposite of the value currently stored at `path`.
    /// - Note: This represents the underlying `toggled` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: string representation of `GtkTreePath` describing the        event location
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggled` signal is emitted
    @discardableResult @inlinable func onToggled(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererToggleRef, _ path: String) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererToggleRef, String, Void>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererToggleRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!)
            return output
        }
        return connect(
            signal: .toggled,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggled` signal for using the `connect(signal:)` methods
    static var toggledSignal: CellRendererToggleSignalName { .toggled }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::activatable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActivatable` signal is emitted
    @discardableResult @inlinable func onNotifyActivatable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererToggleRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererToggleRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererToggleRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyActivatable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::activatable` signal for using the `connect(signal:)` methods
    static var notifyActivatableSignal: CellRendererToggleSignalName { .notifyActivatable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActive` signal is emitted
    @discardableResult @inlinable func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererToggleRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererToggleRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererToggleRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active` signal for using the `connect(signal:)` methods
    static var notifyActiveSignal: CellRendererToggleSignalName { .notifyActive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::inconsistent` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInconsistent` signal is emitted
    @discardableResult @inlinable func onNotifyInconsistent(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererToggleRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererToggleRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererToggleRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyInconsistent,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::inconsistent` signal for using the `connect(signal:)` methods
    static var notifyInconsistentSignal: CellRendererToggleSignalName { .notifyInconsistent }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::radio` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyRadio` signal is emitted
    @discardableResult @inlinable func onNotifyRadio(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CellRendererToggleRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CellRendererToggleRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CellRendererToggleRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyRadio,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::radio` signal for using the `connect(signal:)` methods
    static var notifyRadioSignal: CellRendererToggleSignalName { .notifyRadio }
    
}

// MARK: CellRendererToggle Class: CellRendererToggleProtocol extension (methods and fields)
public extension CellRendererToggleProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellRendererToggle` instance.
    @inlinable var cell_renderer_toggle_ptr: UnsafeMutablePointer<GtkCellRendererToggle>! { return ptr?.assumingMemoryBound(to: GtkCellRendererToggle.self) }

    /// Returns whether the cell renderer is activatable. See
    /// `gtk_cell_renderer_toggle_set_activatable()`.
    @inlinable func getActivatable() -> Bool {
        let rv = ((gtk_cell_renderer_toggle_get_activatable(cell_renderer_toggle_ptr)) != 0)
        return rv
    }

    /// Returns whether the cell renderer is active. See
    /// `gtk_cell_renderer_toggle_set_active()`.
    @inlinable func getActive() -> Bool {
        let rv = ((gtk_cell_renderer_toggle_get_active(cell_renderer_toggle_ptr)) != 0)
        return rv
    }

    /// Returns whether we’re rendering radio toggles rather than checkboxes.
    @inlinable func getRadio() -> Bool {
        let rv = ((gtk_cell_renderer_toggle_get_radio(cell_renderer_toggle_ptr)) != 0)
        return rv
    }

    /// Makes the cell renderer activatable.
    @inlinable func setActivatable(setting: Bool) {
        gtk_cell_renderer_toggle_set_activatable(cell_renderer_toggle_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Activates or deactivates a cell renderer.
    @inlinable func setActive(setting: Bool) {
        gtk_cell_renderer_toggle_set_active(cell_renderer_toggle_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// If `radio` is `true`, the cell renderer renders a radio toggle
    /// (i.e. a toggle in a group of mutually-exclusive toggles).
    /// If `false`, it renders a check toggle (a standalone boolean option).
    /// This can be set globally for the cell renderer, or changed just
    /// before rendering each cell in the model (for `GtkTreeView`, you set
    /// up a per-row setting using `GtkTreeViewColumn` to associate model
    /// columns with cell renderer properties).
    @inlinable func set(radio: Bool) {
        gtk_cell_renderer_toggle_set_radio(cell_renderer_toggle_ptr, gboolean((radio) ? 1 : 0))
    
    }
    @inlinable var activatable: Bool {
        /// Returns whether the cell renderer is activatable. See
        /// `gtk_cell_renderer_toggle_set_activatable()`.
        get {
            let rv = ((gtk_cell_renderer_toggle_get_activatable(cell_renderer_toggle_ptr)) != 0)
            return rv
        }
        /// Makes the cell renderer activatable.
        nonmutating set {
            gtk_cell_renderer_toggle_set_activatable(cell_renderer_toggle_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var active: Bool {
        /// Returns whether the cell renderer is active. See
        /// `gtk_cell_renderer_toggle_set_active()`.
        get {
            let rv = ((gtk_cell_renderer_toggle_get_active(cell_renderer_toggle_ptr)) != 0)
            return rv
        }
        /// Activates or deactivates a cell renderer.
        nonmutating set {
            gtk_cell_renderer_toggle_set_active(cell_renderer_toggle_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var radio: Bool {
        /// Returns whether we’re rendering radio toggles rather than checkboxes.
        get {
            let rv = ((gtk_cell_renderer_toggle_get_radio(cell_renderer_toggle_ptr)) != 0)
            return rv
        }
        /// If `radio` is `true`, the cell renderer renders a radio toggle
        /// (i.e. a toggle in a group of mutually-exclusive toggles).
        /// If `false`, it renders a check toggle (a standalone boolean option).
        /// This can be set globally for the cell renderer, or changed just
        /// before rendering each cell in the model (for `GtkTreeView`, you set
        /// up a per-row setting using `GtkTreeViewColumn` to associate model
        /// columns with cell renderer properties).
        nonmutating set {
            gtk_cell_renderer_toggle_set_radio(cell_renderer_toggle_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - CellView Class

/// A widget displaying a single row of a GtkTreeModel
/// 
/// A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
/// and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
/// `GtkCellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with each other (like the aligned cells in the menus
/// of `GtkComboBox`).
/// 
/// `GtkCellView` is `GtkOrientable` in order to decide in which orientation
/// the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
/// 
/// # CSS nodes
/// 
/// GtkCellView has a single CSS node with name cellview.
///
/// The `CellViewProtocol` protocol exposes the methods and properties of an underlying `GtkCellView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CellView`.
/// Alternatively, use `CellViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CellViewProtocol: WidgetProtocol, CellLayoutProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkCellView` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCellView` instance.
    var cell_view_ptr: UnsafeMutablePointer<GtkCellView>! { get }

    /// Required Initialiser for types conforming to `CellViewProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A widget displaying a single row of a GtkTreeModel
/// 
/// A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
/// and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
/// `GtkCellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with each other (like the aligned cells in the menus
/// of `GtkComboBox`).
/// 
/// `GtkCellView` is `GtkOrientable` in order to decide in which orientation
/// the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
/// 
/// # CSS nodes
/// 
/// GtkCellView has a single CSS node with name cellview.
///
/// The `CellViewRef` type acts as a lightweight Swift reference to an underlying `GtkCellView` instance.
/// It exposes methods that can operate on this data type through `CellViewProtocol` conformance.
/// Use `CellViewRef` only as an `unowned` reference to an existing `GtkCellView` instance.
///
public struct CellViewRef: CellViewProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCellView` instance.
    /// For type-safe access, use the generated, typed pointer `cell_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CellViewRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCellView>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCellView>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCellView>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCellView>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CellViewProtocol`
    @inlinable init<T: CellViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CellViewProtocol>(_ other: T) -> CellViewRef { CellViewRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCellView` widget.
    @inlinable init() {
        let rv = gtk_cell_view_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handful of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    @inlinable init<CellAreaContextT: CellAreaContextProtocol, CellAreaT: CellAreaProtocol>(context area: CellAreaT, context: CellAreaContextT) {
        let rv = gtk_cell_view_new_with_context(area.cell_area_ptr, context.cell_area_context_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be marked up with
    /// the [Pango text markup language](https://docs.gtk.org/Pango/pango_markup.html).
    @inlinable init(markup: UnsafePointer<CChar>!) {
        let rv = gtk_cell_view_new_with_markup(markup)
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    @inlinable init(text: UnsafePointer<CChar>!) {
        let rv = gtk_cell_view_new_with_text(text)
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `texture`.
    @inlinable init<TextureT: Gdk.TextureProtocol>(texture: TextureT) {
        let rv = gtk_cell_view_new_with_texture(texture.texture_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handful of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    @inlinable static func newWith<CellAreaContextT: CellAreaContextProtocol, CellAreaT: CellAreaProtocol>(context area: CellAreaT, context: CellAreaContextT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_cell_view_new_with_context(area.cell_area_ptr, context.cell_area_context_ptr))) else { return nil }
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be marked up with
    /// the [Pango text markup language](https://docs.gtk.org/Pango/pango_markup.html).
    @inlinable static func newWith(markup: UnsafePointer<CChar>!) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_cell_view_new_with_markup(markup))) else { return nil }
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    @inlinable static func newWith(text: UnsafePointer<CChar>!) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_cell_view_new_with_text(text))) else { return nil }
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `texture`.
    @inlinable static func newWith<TextureT: Gdk.TextureProtocol>(texture: TextureT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_cell_view_new_with_texture(texture.texture_ptr))) else { return nil }
        return rv
    }
}

/// A widget displaying a single row of a GtkTreeModel
/// 
/// A `GtkCellView` displays a single row of a `GtkTreeModel` using a `GtkCellArea`
/// and `GtkCellAreaContext`. A `GtkCellAreaContext` can be provided to the
/// `GtkCellView` at construction time in order to keep the cellview in context
/// of a group of cell views, this ensures that the renderers displayed will
/// be properly aligned with each other (like the aligned cells in the menus
/// of `GtkComboBox`).
/// 
/// `GtkCellView` is `GtkOrientable` in order to decide in which orientation
/// the underlying `GtkCellAreaContext` should be allocated. Taking the `GtkComboBox`
/// menu as an example, cellviews should be oriented horizontally if the menus are
/// listed top-to-bottom and thus all share the same width but may have separate
/// individual heights (left-to-right menus should be allocated vertically since
/// they all share the same height but may have variable widths).
/// 
/// # CSS nodes
/// 
/// GtkCellView has a single CSS node with name cellview.
///
/// The `CellView` type acts as a reference-counted owner of an underlying `GtkCellView` instance.
/// It provides the methods that can operate on this data type through `CellViewProtocol` conformance.
/// Use `CellView` as a strong reference or owner of a `GtkCellView` instance.
///
open class CellView: Widget, CellViewProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCellView>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCellView>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCellView>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCellView>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCellView`.
    /// i.e., ownership is transferred to the `CellView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCellView>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CellViewProtocol`
    /// Will retain `GtkCellView`.
    /// - Parameter other: an instance of a related type that implements `CellViewProtocol`
    @inlinable public init<T: CellViewProtocol>(cellView other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CellViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCellView` widget.
    @inlinable public init() {
        let rv = gtk_cell_view_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handful of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    @inlinable public init<CellAreaContextT: CellAreaContextProtocol, CellAreaT: CellAreaProtocol>(context area: CellAreaT, context: CellAreaContextT) {
        let rv = gtk_cell_view_new_with_context(area.cell_area_ptr, context.cell_area_context_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be marked up with
    /// the [Pango text markup language](https://docs.gtk.org/Pango/pango_markup.html).
    @inlinable public init(markup: UnsafePointer<CChar>!) {
        let rv = gtk_cell_view_new_with_markup(markup)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    @inlinable public init(text: UnsafePointer<CChar>!) {
        let rv = gtk_cell_view_new_with_text(text)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `texture`.
    @inlinable public init<TextureT: Gdk.TextureProtocol>(texture: TextureT) {
        let rv = gtk_cell_view_new_with_texture(texture.texture_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCellView` widget with a specific `GtkCellArea`
    /// to layout cells and a specific `GtkCellAreaContext`.
    /// 
    /// Specifying the same context for a handful of cells lets
    /// the underlying area synchronize the geometry for those cells,
    /// in this way alignments with cellviews for other rows are
    /// possible.
    @inlinable public static func newWith<CellAreaContextT: CellAreaContextProtocol, CellAreaT: CellAreaProtocol>(context area: CellAreaT, context: CellAreaContextT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_cell_view_new_with_context(area.cell_area_ptr, context.cell_area_context_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `markup`. The text can be marked up with
    /// the [Pango text markup language](https://docs.gtk.org/Pango/pango_markup.html).
    @inlinable public static func newWith(markup: UnsafePointer<CChar>!) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_cell_view_new_with_markup(markup))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererText`
    /// to it, and makes it show `text`.
    @inlinable public static func newWith(text: UnsafePointer<CChar>!) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_cell_view_new_with_text(text))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

    /// Creates a new `GtkCellView` widget, adds a `GtkCellRendererPixbuf`
    /// to it, and makes it show `texture`.
    @inlinable public static func newWith<TextureT: Gdk.TextureProtocol>(texture: TextureT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_cell_view_new_with_texture(texture.texture_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum CellViewPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The `GtkCellArea` rendering cells
    /// 
    /// If no area is specified when creating the cell view with `gtk_cell_view_new_with_context()`
    /// a horizontally oriented `GtkCellArea`Box will be used.
    /// 
    /// since 3.0
    case cellArea = "cell-area"
    /// The `GtkCellAreaContext` used to compute the geometry of the cell view.
    /// 
    /// A group of cell views can be assigned the same context in order to
    /// ensure the sizes and cell alignments match across all the views with
    /// the same context.
    /// 
    /// `GtkComboBox` menus uses this to assign the same context to all cell views
    /// in the menu items for a single menu (each submenu creates its own
    /// context since the size of each submenu does not depend on parent
    /// or sibling menus).
    /// 
    /// since 3.0
    case cellAreaContext = "cell-area-context"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether all cells should be draw as sensitive for this view regardless
    /// of the actual cell properties (used to make menus with submenus appear
    /// sensitive when the items in submenus might be insensitive).
    /// 
    /// since 3.0
    case drawSensitive = "draw-sensitive"
    /// Whether the view should request enough space to always fit
    /// the size of every row in the model (used by the combo box to
    /// ensure the combo box size doesn't change when different items
    /// are selected).
    /// 
    /// since 3.0
    case fitModel = "fit-model"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The model for cell view
    /// 
    /// since 2.10
    case model = "model"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension CellViewProtocol {
    /// Bind a `CellViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CellViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CellView property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CellViewPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CellView property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CellViewPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CellViewSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The `GtkCellArea` rendering cells
    /// 
    /// If no area is specified when creating the cell view with `gtk_cell_view_new_with_context()`
    /// a horizontally oriented `GtkCellArea`Box will be used.
    /// 
    /// since 3.0
    case notifyCellArea = "notify::cell-area"
    /// The `GtkCellAreaContext` used to compute the geometry of the cell view.
    /// 
    /// A group of cell views can be assigned the same context in order to
    /// ensure the sizes and cell alignments match across all the views with
    /// the same context.
    /// 
    /// `GtkComboBox` menus uses this to assign the same context to all cell views
    /// in the menu items for a single menu (each submenu creates its own
    /// context since the size of each submenu does not depend on parent
    /// or sibling menus).
    /// 
    /// since 3.0
    case notifyCellAreaContext = "notify::cell-area-context"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether all cells should be draw as sensitive for this view regardless
    /// of the actual cell properties (used to make menus with submenus appear
    /// sensitive when the items in submenus might be insensitive).
    /// 
    /// since 3.0
    case notifyDrawSensitive = "notify::draw-sensitive"
    /// Whether the view should request enough space to always fit
    /// the size of every row in the model (used by the combo box to
    /// ensure the combo box size doesn't change when different items
    /// are selected).
    /// 
    /// since 3.0
    case notifyFitModel = "notify::fit-model"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The model for cell view
    /// 
    /// since 2.10
    case notifyModel = "notify::model"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: CellView has no signals
// MARK: CellView Class: CellViewProtocol extension (methods and fields)
public extension CellViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCellView` instance.
    @inlinable var cell_view_ptr: UnsafeMutablePointer<GtkCellView>! { return ptr?.assumingMemoryBound(to: GtkCellView.self) }

    /// Returns a `GtkTreePath` referring to the currently
    /// displayed row. If no row is currently displayed,
    /// `nil` is returned.
    @inlinable func getDisplayedRow() -> TreePathRef! {
        let rv = TreePathRef(gconstpointer: gconstpointer(gtk_cell_view_get_displayed_row(cell_view_ptr)))
        return rv
    }

    /// Gets whether `cell_view` is configured to draw all of its
    /// cells in a sensitive state.
    @inlinable func getDrawSensitive() -> Bool {
        let rv = ((gtk_cell_view_get_draw_sensitive(cell_view_ptr)) != 0)
        return rv
    }

    /// Gets whether `cell_view` is configured to request space
    /// to fit the entire `GtkTreeModel`.
    @inlinable func getFitModel() -> Bool {
        let rv = ((gtk_cell_view_get_fit_model(cell_view_ptr)) != 0)
        return rv
    }

    /// Returns the model for `cell_view`. If no model is used `nil` is
    /// returned.
    @inlinable func getModel() -> TreeModelRef! {
        let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_cell_view_get_model(cell_view_ptr)))
        return rv
    }

    /// Sets the row of the model that is currently displayed
    /// by the `GtkCellView`. If the path is unset, then the
    /// contents of the cellview “stick” at their last value;
    /// this is not normally a desired result, but may be
    /// a needed intermediate state if say, the model for
    /// the `GtkCellView` becomes temporarily empty.
    @inlinable func setDisplayedRow(path: TreePathRef? = nil) {
        gtk_cell_view_set_displayed_row(cell_view_ptr, path?.tree_path_ptr)
    
    }
    /// Sets the row of the model that is currently displayed
    /// by the `GtkCellView`. If the path is unset, then the
    /// contents of the cellview “stick” at their last value;
    /// this is not normally a desired result, but may be
    /// a needed intermediate state if say, the model for
    /// the `GtkCellView` becomes temporarily empty.
    @inlinable func setDisplayedRow<TreePathT: TreePathProtocol>(path: TreePathT?) {
        gtk_cell_view_set_displayed_row(cell_view_ptr, path?.tree_path_ptr)
    
    }

    /// Sets whether `cell_view` should draw all of its
    /// cells in a sensitive state, this is used by `GtkComboBox` menus
    /// to ensure that rows with insensitive cells that contain
    /// children appear sensitive in the parent menu item.
    @inlinable func set(drawSensitive: Bool) {
        gtk_cell_view_set_draw_sensitive(cell_view_ptr, gboolean((drawSensitive) ? 1 : 0))
    
    }

    /// Sets whether `cell_view` should request space to fit the entire `GtkTreeModel`.
    /// 
    /// This is used by `GtkComboBox` to ensure that the cell view displayed on
    /// the combo box’s button always gets enough space and does not resize
    /// when selection changes.
    @inlinable func set(fitModel: Bool) {
        gtk_cell_view_set_fit_model(cell_view_ptr, gboolean((fitModel) ? 1 : 0))
    
    }

    /// Sets the model for `cell_view`.  If `cell_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is
    /// `nil`, then it will unset the old model.
    @inlinable func set(model: TreeModelRef? = nil) {
        gtk_cell_view_set_model(cell_view_ptr, model?.tree_model_ptr)
    
    }
    /// Sets the model for `cell_view`.  If `cell_view` already has a model
    /// set, it will remove it before setting the new model.  If `model` is
    /// `nil`, then it will unset the old model.
    @inlinable func set<TreeModelT: TreeModelProtocol>(model: TreeModelT?) {
        gtk_cell_view_set_model(cell_view_ptr, model?.tree_model_ptr)
    
    }
    /// Returns a `GtkTreePath` referring to the currently
    /// displayed row. If no row is currently displayed,
    /// `nil` is returned.
    @inlinable var displayedRow: TreePathRef! {
        /// Returns a `GtkTreePath` referring to the currently
        /// displayed row. If no row is currently displayed,
        /// `nil` is returned.
        get {
            let rv = TreePathRef(gconstpointer: gconstpointer(gtk_cell_view_get_displayed_row(cell_view_ptr)))
            return rv
        }
        /// Sets the row of the model that is currently displayed
        /// by the `GtkCellView`. If the path is unset, then the
        /// contents of the cellview “stick” at their last value;
        /// this is not normally a desired result, but may be
        /// a needed intermediate state if say, the model for
        /// the `GtkCellView` becomes temporarily empty.
        nonmutating set {
            gtk_cell_view_set_displayed_row(cell_view_ptr, UnsafeMutablePointer<GtkTreePath>(newValue?.tree_path_ptr))
        }
    }

    /// Gets whether `cell_view` is configured to draw all of its
    /// cells in a sensitive state.
    @inlinable var drawSensitive: Bool {
        /// Gets whether `cell_view` is configured to draw all of its
        /// cells in a sensitive state.
        get {
            let rv = ((gtk_cell_view_get_draw_sensitive(cell_view_ptr)) != 0)
            return rv
        }
        /// Sets whether `cell_view` should draw all of its
        /// cells in a sensitive state, this is used by `GtkComboBox` menus
        /// to ensure that rows with insensitive cells that contain
        /// children appear sensitive in the parent menu item.
        nonmutating set {
            gtk_cell_view_set_draw_sensitive(cell_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Gets whether `cell_view` is configured to request space
    /// to fit the entire `GtkTreeModel`.
    @inlinable var fitModel: Bool {
        /// Gets whether `cell_view` is configured to request space
        /// to fit the entire `GtkTreeModel`.
        get {
            let rv = ((gtk_cell_view_get_fit_model(cell_view_ptr)) != 0)
            return rv
        }
        /// Sets whether `cell_view` should request space to fit the entire `GtkTreeModel`.
        /// 
        /// This is used by `GtkComboBox` to ensure that the cell view displayed on
        /// the combo box’s button always gets enough space and does not resize
        /// when selection changes.
        nonmutating set {
            gtk_cell_view_set_fit_model(cell_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The model for cell view
    /// 
    /// since 2.10
    @inlinable var model: TreeModelRef! {
        /// Returns the model for `cell_view`. If no model is used `nil` is
        /// returned.
        get {
            let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_cell_view_get_model(cell_view_ptr)))
            return rv
        }
        /// Sets the model for `cell_view`.  If `cell_view` already has a model
        /// set, it will remove it before setting the new model.  If `model` is
        /// `nil`, then it will unset the old model.
        nonmutating set {
            gtk_cell_view_set_model(cell_view_ptr, UnsafeMutablePointer<GtkTreeModel>(newValue?.tree_model_ptr))
        }
    }


}



// MARK: - CenterBox Class

/// `GtkCenterBox` arranges three children in a row, keeping the middle child
/// centered as well as possible.
/// 
/// ![An example GtkCenterBox](centerbox.png)
/// 
/// To add children to `GtkCenterBox`, use [method`Gtk.CenterBox.set_start_widget`],
/// [method`Gtk.CenterBox.set_center_widget`] and
/// [method`Gtk.CenterBox.set_end_widget`].
/// 
/// The sizing and positioning of children can be influenced with the
/// align and expand properties of the children.
/// 
/// # GtkCenterBox as GtkBuildable
/// 
/// The `GtkCenterBox` implementation of the `GtkBuildable` interface
/// supports placing children in the 3 positions by specifying “start”, “center”
/// or “end” as the “type” attribute of a &lt;child&gt; element.
/// 
/// # CSS nodes
/// 
/// `GtkCenterBox` uses a single CSS node with the name “box”,
/// 
/// The first child of the `GtkCenterBox` will be allocated depending on the
/// text direction, i.e. in left-to-right layouts it will be allocated on the
/// left and in right-to-left layouts on the right.
/// 
/// In vertical orientation, the nodes of the children are arranged from top to
/// bottom.
/// 
/// # Accessibility
/// 
/// `GtkCenterBox` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
///
/// The `CenterBoxProtocol` protocol exposes the methods and properties of an underlying `GtkCenterBox` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CenterBox`.
/// Alternatively, use `CenterBoxRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CenterBoxProtocol: WidgetProtocol, OrientableProtocol {
        /// Untyped pointer to the underlying `GtkCenterBox` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCenterBox` instance.
    var center_box_ptr: UnsafeMutablePointer<GtkCenterBox>! { get }

    /// Required Initialiser for types conforming to `CenterBoxProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCenterBox` arranges three children in a row, keeping the middle child
/// centered as well as possible.
/// 
/// ![An example GtkCenterBox](centerbox.png)
/// 
/// To add children to `GtkCenterBox`, use [method`Gtk.CenterBox.set_start_widget`],
/// [method`Gtk.CenterBox.set_center_widget`] and
/// [method`Gtk.CenterBox.set_end_widget`].
/// 
/// The sizing and positioning of children can be influenced with the
/// align and expand properties of the children.
/// 
/// # GtkCenterBox as GtkBuildable
/// 
/// The `GtkCenterBox` implementation of the `GtkBuildable` interface
/// supports placing children in the 3 positions by specifying “start”, “center”
/// or “end” as the “type” attribute of a &lt;child&gt; element.
/// 
/// # CSS nodes
/// 
/// `GtkCenterBox` uses a single CSS node with the name “box”,
/// 
/// The first child of the `GtkCenterBox` will be allocated depending on the
/// text direction, i.e. in left-to-right layouts it will be allocated on the
/// left and in right-to-left layouts on the right.
/// 
/// In vertical orientation, the nodes of the children are arranged from top to
/// bottom.
/// 
/// # Accessibility
/// 
/// `GtkCenterBox` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
///
/// The `CenterBoxRef` type acts as a lightweight Swift reference to an underlying `GtkCenterBox` instance.
/// It exposes methods that can operate on this data type through `CenterBoxProtocol` conformance.
/// Use `CenterBoxRef` only as an `unowned` reference to an existing `GtkCenterBox` instance.
///
public struct CenterBoxRef: CenterBoxProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCenterBox` instance.
    /// For type-safe access, use the generated, typed pointer `center_box_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CenterBoxRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCenterBox>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCenterBox>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCenterBox>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCenterBox>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CenterBoxProtocol`
    @inlinable init<T: CenterBoxProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CenterBoxProtocol>(_ other: T) -> CenterBoxRef { CenterBoxRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCenterBox`.
    @inlinable init() {
        let rv = gtk_center_box_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCenterBox` arranges three children in a row, keeping the middle child
/// centered as well as possible.
/// 
/// ![An example GtkCenterBox](centerbox.png)
/// 
/// To add children to `GtkCenterBox`, use [method`Gtk.CenterBox.set_start_widget`],
/// [method`Gtk.CenterBox.set_center_widget`] and
/// [method`Gtk.CenterBox.set_end_widget`].
/// 
/// The sizing and positioning of children can be influenced with the
/// align and expand properties of the children.
/// 
/// # GtkCenterBox as GtkBuildable
/// 
/// The `GtkCenterBox` implementation of the `GtkBuildable` interface
/// supports placing children in the 3 positions by specifying “start”, “center”
/// or “end” as the “type” attribute of a &lt;child&gt; element.
/// 
/// # CSS nodes
/// 
/// `GtkCenterBox` uses a single CSS node with the name “box”,
/// 
/// The first child of the `GtkCenterBox` will be allocated depending on the
/// text direction, i.e. in left-to-right layouts it will be allocated on the
/// left and in right-to-left layouts on the right.
/// 
/// In vertical orientation, the nodes of the children are arranged from top to
/// bottom.
/// 
/// # Accessibility
/// 
/// `GtkCenterBox` uses the `GTK_ACCESSIBLE_ROLE_GROUP` role.
///
/// The `CenterBox` type acts as a reference-counted owner of an underlying `GtkCenterBox` instance.
/// It provides the methods that can operate on this data type through `CenterBoxProtocol` conformance.
/// Use `CenterBox` as a strong reference or owner of a `GtkCenterBox` instance.
///
open class CenterBox: Widget, CenterBoxProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCenterBox>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCenterBox>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCenterBox>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCenterBox>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCenterBox`.
    /// i.e., ownership is transferred to the `CenterBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCenterBox>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CenterBoxProtocol`
    /// Will retain `GtkCenterBox`.
    /// - Parameter other: an instance of a related type that implements `CenterBoxProtocol`
    @inlinable public init<T: CenterBoxProtocol>(centerBox other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCenterBox`.
    @inlinable public init() {
        let rv = gtk_center_box_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum CenterBoxPropertyName: String, PropertyNameProtocol {
    /// The position of the baseline aligned widget if extra space is available.
    case baselinePosition = "baseline-position"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension CenterBoxProtocol {
    /// Bind a `CenterBoxPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CenterBoxPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CenterBox property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CenterBoxPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CenterBox property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CenterBoxPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CenterBoxSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The position of the baseline aligned widget if extra space is available.
    case notifyBaselinePosition = "notify::baseline-position"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: CenterBox has no signals
// MARK: CenterBox Class: CenterBoxProtocol extension (methods and fields)
public extension CenterBoxProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCenterBox` instance.
    @inlinable var center_box_ptr: UnsafeMutablePointer<GtkCenterBox>! { return ptr?.assumingMemoryBound(to: GtkCenterBox.self) }

    /// Gets the value set by `gtk_center_box_set_baseline_position()`.
    @inlinable func getBaselinePosition() -> GtkBaselinePosition {
        let rv = gtk_center_box_get_baseline_position(center_box_ptr)
        return rv
    }

    /// Gets the center widget, or `nil` if there is none.
    @inlinable func getCenterWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_box_get_center_widget(center_box_ptr))) else { return nil }
        return rv
    }

    /// Gets the end widget, or `nil` if there is none.
    @inlinable func getEndWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_box_get_end_widget(center_box_ptr))) else { return nil }
        return rv
    }

    /// Gets the start widget, or `nil` if there is none.
    @inlinable func getStartWidget() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_box_get_start_widget(center_box_ptr))) else { return nil }
        return rv
    }

    /// Sets the baseline position of a center box.
    /// 
    /// This affects only horizontal boxes with at least one baseline
    /// aligned child. If there is more vertical space available than
    /// requested, and the baseline is not allocated by the parent then
    /// `position` is used to allocate the baseline wrt. the extra space
    /// available.
    @inlinable func setBaseline(position: GtkBaselinePosition) {
        gtk_center_box_set_baseline_position(center_box_ptr, position)
    
    }

    /// Sets the center widget.
    /// 
    /// To remove the existing center widget, pas `nil`.
    @inlinable func setCenterWidget(child: WidgetRef? = nil) {
        gtk_center_box_set_center_widget(center_box_ptr, child?.widget_ptr)
    
    }
    /// Sets the center widget.
    /// 
    /// To remove the existing center widget, pas `nil`.
    @inlinable func setCenterWidget<WidgetT: WidgetProtocol>(child: WidgetT?) {
        gtk_center_box_set_center_widget(center_box_ptr, child?.widget_ptr)
    
    }

    /// Sets the end widget.
    /// 
    /// To remove the existing end widget, pass `nil`.
    @inlinable func setEndWidget(child: WidgetRef? = nil) {
        gtk_center_box_set_end_widget(center_box_ptr, child?.widget_ptr)
    
    }
    /// Sets the end widget.
    /// 
    /// To remove the existing end widget, pass `nil`.
    @inlinable func setEndWidget<WidgetT: WidgetProtocol>(child: WidgetT?) {
        gtk_center_box_set_end_widget(center_box_ptr, child?.widget_ptr)
    
    }

    /// Sets the start widget.
    /// 
    /// To remove the existing start widget, pass `nil`.
    @inlinable func setStartWidget(child: WidgetRef? = nil) {
        gtk_center_box_set_start_widget(center_box_ptr, child?.widget_ptr)
    
    }
    /// Sets the start widget.
    /// 
    /// To remove the existing start widget, pass `nil`.
    @inlinable func setStartWidget<WidgetT: WidgetProtocol>(child: WidgetT?) {
        gtk_center_box_set_start_widget(center_box_ptr, child?.widget_ptr)
    
    }
    /// Gets the value set by `gtk_center_box_set_baseline_position()`.
    @inlinable var baselinePosition: GtkBaselinePosition {
        /// Gets the value set by `gtk_center_box_set_baseline_position()`.
        get {
            let rv = gtk_center_box_get_baseline_position(center_box_ptr)
            return rv
        }
        /// Sets the baseline position of a center box.
        /// 
        /// This affects only horizontal boxes with at least one baseline
        /// aligned child. If there is more vertical space available than
        /// requested, and the baseline is not allocated by the parent then
        /// `position` is used to allocate the baseline wrt. the extra space
        /// available.
        nonmutating set {
            gtk_center_box_set_baseline_position(center_box_ptr, newValue)
        }
    }

    /// Gets the center widget, or `nil` if there is none.
    @inlinable var centerWidget: WidgetRef! {
        /// Gets the center widget, or `nil` if there is none.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_box_get_center_widget(center_box_ptr))) else { return nil }
            return rv
        }
        /// Sets the center widget.
        /// 
        /// To remove the existing center widget, pas `nil`.
        nonmutating set {
            gtk_center_box_set_center_widget(center_box_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Gets the end widget, or `nil` if there is none.
    @inlinable var endWidget: WidgetRef! {
        /// Gets the end widget, or `nil` if there is none.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_box_get_end_widget(center_box_ptr))) else { return nil }
            return rv
        }
        /// Sets the end widget.
        /// 
        /// To remove the existing end widget, pass `nil`.
        nonmutating set {
            gtk_center_box_set_end_widget(center_box_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Gets the start widget, or `nil` if there is none.
    @inlinable var startWidget: WidgetRef! {
        /// Gets the start widget, or `nil` if there is none.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_box_get_start_widget(center_box_ptr))) else { return nil }
            return rv
        }
        /// Sets the start widget.
        /// 
        /// To remove the existing start widget, pass `nil`.
        nonmutating set {
            gtk_center_box_set_start_widget(center_box_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }


}



// MARK: - CenterLayout Class

/// `GtkCenterLayout` is a layout manager that manages up to three children.
/// 
/// The start widget is allocated at the start of the layout (left in
/// left-to-right locales and right in right-to-left ones), and the end
/// widget at the end.
/// 
/// The center widget is centered regarding the full width of the layout's.
///
/// The `CenterLayoutProtocol` protocol exposes the methods and properties of an underlying `GtkCenterLayout` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CenterLayout`.
/// Alternatively, use `CenterLayoutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CenterLayoutProtocol: LayoutManagerProtocol {
        /// Untyped pointer to the underlying `GtkCenterLayout` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCenterLayout` instance.
    var center_layout_ptr: UnsafeMutablePointer<GtkCenterLayout>! { get }

    /// Required Initialiser for types conforming to `CenterLayoutProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCenterLayout` is a layout manager that manages up to three children.
/// 
/// The start widget is allocated at the start of the layout (left in
/// left-to-right locales and right in right-to-left ones), and the end
/// widget at the end.
/// 
/// The center widget is centered regarding the full width of the layout's.
///
/// The `CenterLayoutRef` type acts as a lightweight Swift reference to an underlying `GtkCenterLayout` instance.
/// It exposes methods that can operate on this data type through `CenterLayoutProtocol` conformance.
/// Use `CenterLayoutRef` only as an `unowned` reference to an existing `GtkCenterLayout` instance.
///
public struct CenterLayoutRef: CenterLayoutProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCenterLayout` instance.
    /// For type-safe access, use the generated, typed pointer `center_layout_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CenterLayoutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCenterLayout>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCenterLayout>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCenterLayout>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCenterLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CenterLayoutProtocol`
    @inlinable init<T: CenterLayoutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CenterLayoutProtocol>(_ other: T) -> CenterLayoutRef { CenterLayoutRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCenterLayout`.
    @inlinable init() {
        let rv = gtk_center_layout_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCenterLayout` is a layout manager that manages up to three children.
/// 
/// The start widget is allocated at the start of the layout (left in
/// left-to-right locales and right in right-to-left ones), and the end
/// widget at the end.
/// 
/// The center widget is centered regarding the full width of the layout's.
///
/// The `CenterLayout` type acts as a reference-counted owner of an underlying `GtkCenterLayout` instance.
/// It provides the methods that can operate on this data type through `CenterLayoutProtocol` conformance.
/// Use `CenterLayout` as a strong reference or owner of a `GtkCenterLayout` instance.
///
open class CenterLayout: LayoutManager, CenterLayoutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCenterLayout>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCenterLayout>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCenterLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCenterLayout>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCenterLayout`.
    /// i.e., ownership is transferred to the `CenterLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCenterLayout>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CenterLayoutProtocol`
    /// Will retain `GtkCenterLayout`.
    /// - Parameter other: an instance of a related type that implements `CenterLayoutProtocol`
    @inlinable public init<T: CenterLayoutProtocol>(centerLayout other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CenterLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCenterLayout`.
    @inlinable public init() {
        let rv = gtk_center_layout_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no CenterLayout properties

public enum CenterLayoutSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: CenterLayout has no signals
// MARK: CenterLayout Class: CenterLayoutProtocol extension (methods and fields)
public extension CenterLayoutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCenterLayout` instance.
    @inlinable var center_layout_ptr: UnsafeMutablePointer<GtkCenterLayout>! { return ptr?.assumingMemoryBound(to: GtkCenterLayout.self) }

    /// Returns the baseline position of the layout.
    @inlinable func getBaselinePosition() -> GtkBaselinePosition {
        let rv = gtk_center_layout_get_baseline_position(center_layout_ptr)
        return rv
    }

    /// Returns the center widget of the layout.
    @inlinable func getCenterWidget() -> WidgetRef! {
        let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_layout_get_center_widget(center_layout_ptr)))
        return rv
    }

    /// Returns the end widget of the layout.
    @inlinable func getEndWidget() -> WidgetRef! {
        let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_layout_get_end_widget(center_layout_ptr)))
        return rv
    }

    /// Gets the current orienration of the layout manager.
    @inlinable func getOrientation() -> GtkOrientation {
        let rv = gtk_center_layout_get_orientation(center_layout_ptr)
        return rv
    }

    /// Returns the start widget fo the layout.
    @inlinable func getStartWidget() -> WidgetRef! {
        let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_layout_get_start_widget(center_layout_ptr)))
        return rv
    }

    /// Sets the new baseline position of `self`
    @inlinable func set(baselinePosition: GtkBaselinePosition) {
        gtk_center_layout_set_baseline_position(center_layout_ptr, baselinePosition)
    
    }

    /// Sets the new center widget of `self`.
    /// 
    /// To remove the existing center widget, pass `nil`.
    @inlinable func setCenter(widget: WidgetRef? = nil) {
        gtk_center_layout_set_center_widget(center_layout_ptr, widget?.widget_ptr)
    
    }
    /// Sets the new center widget of `self`.
    /// 
    /// To remove the existing center widget, pass `nil`.
    @inlinable func setCenter<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        gtk_center_layout_set_center_widget(center_layout_ptr, widget?.widget_ptr)
    
    }

    /// Sets the new end widget of `self`.
    /// 
    /// To remove the existing center widget, pass `nil`.
    @inlinable func setEnd(widget: WidgetRef? = nil) {
        gtk_center_layout_set_end_widget(center_layout_ptr, widget?.widget_ptr)
    
    }
    /// Sets the new end widget of `self`.
    /// 
    /// To remove the existing center widget, pass `nil`.
    @inlinable func setEnd<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        gtk_center_layout_set_end_widget(center_layout_ptr, widget?.widget_ptr)
    
    }

    /// Sets the orientation of `self`.
    @inlinable func set(orientation: GtkOrientation) {
        gtk_center_layout_set_orientation(center_layout_ptr, orientation)
    
    }

    /// Sets the new start widget of `self`.
    /// 
    /// To remove the existing start widget, pass `nil`.
    @inlinable func setStart(widget: WidgetRef? = nil) {
        gtk_center_layout_set_start_widget(center_layout_ptr, widget?.widget_ptr)
    
    }
    /// Sets the new start widget of `self`.
    /// 
    /// To remove the existing start widget, pass `nil`.
    @inlinable func setStart<WidgetT: WidgetProtocol>(widget: WidgetT?) {
        gtk_center_layout_set_start_widget(center_layout_ptr, widget?.widget_ptr)
    
    }
    /// Returns the baseline position of the layout.
    @inlinable var baselinePosition: GtkBaselinePosition {
        /// Returns the baseline position of the layout.
        get {
            let rv = gtk_center_layout_get_baseline_position(center_layout_ptr)
            return rv
        }
        /// Sets the new baseline position of `self`
        nonmutating set {
            gtk_center_layout_set_baseline_position(center_layout_ptr, newValue)
        }
    }

    /// Returns the center widget of the layout.
    @inlinable var centerWidget: WidgetRef! {
        /// Returns the center widget of the layout.
        get {
            let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_layout_get_center_widget(center_layout_ptr)))
            return rv
        }
        /// Sets the new center widget of `self`.
        /// 
        /// To remove the existing center widget, pass `nil`.
        nonmutating set {
            gtk_center_layout_set_center_widget(center_layout_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Returns the end widget of the layout.
    @inlinable var endWidget: WidgetRef! {
        /// Returns the end widget of the layout.
        get {
            let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_layout_get_end_widget(center_layout_ptr)))
            return rv
        }
        /// Sets the new end widget of `self`.
        /// 
        /// To remove the existing center widget, pass `nil`.
        nonmutating set {
            gtk_center_layout_set_end_widget(center_layout_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Gets the current orienration of the layout manager.
    @inlinable var orientation: GtkOrientation {
        /// Gets the current orienration of the layout manager.
        get {
            let rv = gtk_center_layout_get_orientation(center_layout_ptr)
            return rv
        }
        /// Sets the orientation of `self`.
        nonmutating set {
            gtk_center_layout_set_orientation(center_layout_ptr, newValue)
        }
    }

    /// Returns the start widget fo the layout.
    @inlinable var startWidget: WidgetRef! {
        /// Returns the start widget fo the layout.
        get {
            let rv = WidgetRef(gconstpointer: gconstpointer(gtk_center_layout_get_start_widget(center_layout_ptr)))
            return rv
        }
        /// Sets the new start widget of `self`.
        /// 
        /// To remove the existing start widget, pass `nil`.
        nonmutating set {
            gtk_center_layout_set_start_widget(center_layout_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }


}



// MARK: - CheckButton Class

/// A `GtkCheckButton` places a label next to an indicator.
/// 
/// ![Example GtkCheckButtons](check-button.png)
/// 
/// A `GtkCheckButton` is created by calling either [ctor`Gtk.CheckButton.new`]
/// or [ctor`Gtk.CheckButton.new_with_label`].
/// 
/// The state of a `GtkCheckButton` can be set specifically using
/// [method`Gtk.CheckButton.set_active`], and retrieved using
/// [method`Gtk.CheckButton.get_active`].
/// 
/// # Inconsistent state
/// 
/// In addition to "on" and "off", check buttons can be an
/// "in between" state that is neither on nor off. This can be used
/// e.g. when the user has selected a range of elements (such as some
/// text or spreadsheet cells) that are affected by a check button,
/// and the current values in that range are inconsistent.
/// 
/// To set a `GtkCheckButton` to inconsistent state, use
/// [method`Gtk.CheckButton.set_inconsistent`].
/// 
/// # Grouping
/// 
/// Check buttons can be grouped together, to form mutually exclusive
/// groups - only one of the buttons can be toggled at a time, and toggling
/// another one will switch the currently toggled one off.
/// 
/// Grouped check buttons use a different indicator, and are commonly referred
/// to as *radio buttons*.
/// 
/// ![Example GtkCheckButtons](radio-button.png)
/// 
/// To add a `GtkCheckButton` to a group, use [method`Gtk.CheckButton.set_group`].
/// 
/// # CSS nodes
/// 
/// ```
/// checkbutton[.text-button]
/// ├── check
/// ╰── [label]
/// ```
/// 
/// A `GtkCheckButton` has a main node with name checkbutton. If the
/// [property`Gtk.CheckButton:label`] property is set, it contains a label
/// child. The indicator node is named check when no group is set, and
/// radio if the checkbutton is grouped together with other checkbuttons.
/// 
/// # Accessibility
/// 
/// `GtkCheckButton` uses the `GTK_ACCESSIBLE_ROLE_CHECKBOX` role.
///
/// The `CheckButtonProtocol` protocol exposes the methods and properties of an underlying `GtkCheckButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CheckButton`.
/// Alternatively, use `CheckButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CheckButtonProtocol: WidgetProtocol, ActionableProtocol {
        /// Untyped pointer to the underlying `GtkCheckButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCheckButton` instance.
    var check_button_ptr: UnsafeMutablePointer<GtkCheckButton>! { get }

    /// Required Initialiser for types conforming to `CheckButtonProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkCheckButton` places a label next to an indicator.
/// 
/// ![Example GtkCheckButtons](check-button.png)
/// 
/// A `GtkCheckButton` is created by calling either [ctor`Gtk.CheckButton.new`]
/// or [ctor`Gtk.CheckButton.new_with_label`].
/// 
/// The state of a `GtkCheckButton` can be set specifically using
/// [method`Gtk.CheckButton.set_active`], and retrieved using
/// [method`Gtk.CheckButton.get_active`].
/// 
/// # Inconsistent state
/// 
/// In addition to "on" and "off", check buttons can be an
/// "in between" state that is neither on nor off. This can be used
/// e.g. when the user has selected a range of elements (such as some
/// text or spreadsheet cells) that are affected by a check button,
/// and the current values in that range are inconsistent.
/// 
/// To set a `GtkCheckButton` to inconsistent state, use
/// [method`Gtk.CheckButton.set_inconsistent`].
/// 
/// # Grouping
/// 
/// Check buttons can be grouped together, to form mutually exclusive
/// groups - only one of the buttons can be toggled at a time, and toggling
/// another one will switch the currently toggled one off.
/// 
/// Grouped check buttons use a different indicator, and are commonly referred
/// to as *radio buttons*.
/// 
/// ![Example GtkCheckButtons](radio-button.png)
/// 
/// To add a `GtkCheckButton` to a group, use [method`Gtk.CheckButton.set_group`].
/// 
/// # CSS nodes
/// 
/// ```
/// checkbutton[.text-button]
/// ├── check
/// ╰── [label]
/// ```
/// 
/// A `GtkCheckButton` has a main node with name checkbutton. If the
/// [property`Gtk.CheckButton:label`] property is set, it contains a label
/// child. The indicator node is named check when no group is set, and
/// radio if the checkbutton is grouped together with other checkbuttons.
/// 
/// # Accessibility
/// 
/// `GtkCheckButton` uses the `GTK_ACCESSIBLE_ROLE_CHECKBOX` role.
///
/// The `CheckButtonRef` type acts as a lightweight Swift reference to an underlying `GtkCheckButton` instance.
/// It exposes methods that can operate on this data type through `CheckButtonProtocol` conformance.
/// Use `CheckButtonRef` only as an `unowned` reference to an existing `GtkCheckButton` instance.
///
public struct CheckButtonRef: CheckButtonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCheckButton` instance.
    /// For type-safe access, use the generated, typed pointer `check_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CheckButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCheckButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCheckButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCheckButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCheckButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CheckButtonProtocol`
    @inlinable init<T: CheckButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CheckButtonProtocol>(_ other: T) -> CheckButtonRef { CheckButtonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkCheckButton`.
    @inlinable init() {
        let rv = gtk_check_button_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCheckButton` with the given text.
    @inlinable init(label: UnsafePointer<CChar>? = nil) {
        let rv = gtk_check_button_new_with_label(label)
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkCheckButton` with the given text and a mnemonic.
    @inlinable init(mnemonic label: UnsafePointer<CChar>? = nil) {
        let rv = gtk_check_button_new_with_mnemonic(label)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkCheckButton` with the given text.
    @inlinable static func newWith(label: UnsafePointer<CChar>? = nil) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_check_button_new_with_label(label))) else { return nil }
        return rv
    }

    /// Creates a new `GtkCheckButton` with the given text and a mnemonic.
    @inlinable static func newWith(mnemonic label: UnsafePointer<CChar>? = nil) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_check_button_new_with_mnemonic(label))) else { return nil }
        return rv
    }
}

/// A `GtkCheckButton` places a label next to an indicator.
/// 
/// ![Example GtkCheckButtons](check-button.png)
/// 
/// A `GtkCheckButton` is created by calling either [ctor`Gtk.CheckButton.new`]
/// or [ctor`Gtk.CheckButton.new_with_label`].
/// 
/// The state of a `GtkCheckButton` can be set specifically using
/// [method`Gtk.CheckButton.set_active`], and retrieved using
/// [method`Gtk.CheckButton.get_active`].
/// 
/// # Inconsistent state
/// 
/// In addition to "on" and "off", check buttons can be an
/// "in between" state that is neither on nor off. This can be used
/// e.g. when the user has selected a range of elements (such as some
/// text or spreadsheet cells) that are affected by a check button,
/// and the current values in that range are inconsistent.
/// 
/// To set a `GtkCheckButton` to inconsistent state, use
/// [method`Gtk.CheckButton.set_inconsistent`].
/// 
/// # Grouping
/// 
/// Check buttons can be grouped together, to form mutually exclusive
/// groups - only one of the buttons can be toggled at a time, and toggling
/// another one will switch the currently toggled one off.
/// 
/// Grouped check buttons use a different indicator, and are commonly referred
/// to as *radio buttons*.
/// 
/// ![Example GtkCheckButtons](radio-button.png)
/// 
/// To add a `GtkCheckButton` to a group, use [method`Gtk.CheckButton.set_group`].
/// 
/// # CSS nodes
/// 
/// ```
/// checkbutton[.text-button]
/// ├── check
/// ╰── [label]
/// ```
/// 
/// A `GtkCheckButton` has a main node with name checkbutton. If the
/// [property`Gtk.CheckButton:label`] property is set, it contains a label
/// child. The indicator node is named check when no group is set, and
/// radio if the checkbutton is grouped together with other checkbuttons.
/// 
/// # Accessibility
/// 
/// `GtkCheckButton` uses the `GTK_ACCESSIBLE_ROLE_CHECKBOX` role.
///
/// The `CheckButton` type acts as a reference-counted owner of an underlying `GtkCheckButton` instance.
/// It provides the methods that can operate on this data type through `CheckButtonProtocol` conformance.
/// Use `CheckButton` as a strong reference or owner of a `GtkCheckButton` instance.
///
open class CheckButton: Widget, CheckButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCheckButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCheckButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCheckButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCheckButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCheckButton`.
    /// i.e., ownership is transferred to the `CheckButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCheckButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CheckButtonProtocol`
    /// Will retain `GtkCheckButton`.
    /// - Parameter other: an instance of a related type that implements `CheckButtonProtocol`
    @inlinable public init<T: CheckButtonProtocol>(checkButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CheckButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkCheckButton`.
    @inlinable public init() {
        let rv = gtk_check_button_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCheckButton` with the given text.
    @inlinable public init(label: UnsafePointer<CChar>? = nil) {
        let rv = gtk_check_button_new_with_label(label)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCheckButton` with the given text and a mnemonic.
    @inlinable public init(mnemonic label: UnsafePointer<CChar>? = nil) {
        let rv = gtk_check_button_new_with_mnemonic(label)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkCheckButton` with the given text.
    @inlinable public static func newWith(label: UnsafePointer<CChar>? = nil) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_check_button_new_with_label(label))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

    /// Creates a new `GtkCheckButton` with the given text and a mnemonic.
    @inlinable public static func newWith(mnemonic label: UnsafePointer<CChar>? = nil) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_check_button_new_with_mnemonic(label))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum CheckButtonPropertyName: String, PropertyNameProtocol {
    /// If the check button is active.
    /// 
    /// Setting `active` to `true` will add the `:checked:` state to both
    /// the check button and the indicator CSS node.
    case active = "active"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// The check button whose group this widget belongs to.
    case group = "group"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// If the check button is in an “in between” state.
    /// 
    /// The inconsistent state only affects visual appearance,
    /// not the semantics of the button.
    case inconsistent = "inconsistent"
    /// Text of the label inside the check button, if it contains a label widget.
    case label = "label"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// If set, an underline in the text indicates that the following
    /// character is to be used as mnemonic.
    case useUnderline = "use-underline"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension CheckButtonProtocol {
    /// Bind a `CheckButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: CheckButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a CheckButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: CheckButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a CheckButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: CheckButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum CheckButtonSignalName: String, SignalNameProtocol {
    /// Emitted to when the check button is activated.
    /// 
    /// The ``activate`` signal on `GtkCheckButton` is an action signal and
    /// emitting it causes the button to animate press then release.
    /// 
    /// Applications should never connect to this signal, but use the
    /// [signal`Gtk.CheckButton::toggled`] signal.
    case activate = "activate"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when the buttons's [property`Gtk.CheckButton:active`]
    /// property changes.
    case toggled = "toggled"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// If the check button is active.
    /// 
    /// Setting `active` to `true` will add the `:checked:` state to both
    /// the check button and the indicator CSS node.
    case notifyActive = "notify::active"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// The check button whose group this widget belongs to.
    case notifyGroup = "notify::group"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// If the check button is in an “in between” state.
    /// 
    /// The inconsistent state only affects visual appearance,
    /// not the semantics of the button.
    case notifyInconsistent = "notify::inconsistent"
    /// Text of the label inside the check button, if it contains a label widget.
    case notifyLabel = "notify::label"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// If set, an underline in the text indicates that the following
    /// character is to be used as mnemonic.
    case notifyUseUnderline = "notify::use-underline"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: CheckButton signals
public extension CheckButtonProtocol {
    /// Connect a Swift signal handler to the given, typed `CheckButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CheckButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CheckButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CheckButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted to when the check button is activated.
    /// 
    /// The ``activate`` signal on `GtkCheckButton` is an action signal and
    /// emitting it causes the button to animate press then release.
    /// 
    /// Applications should never connect to this signal, but use the
    /// [signal`Gtk.CheckButton::toggled`] signal.
    /// - Note: This represents the underlying `activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `activate` signal is emitted
    @discardableResult @inlinable func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<CheckButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CheckButtonRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .activate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `activate` signal for using the `connect(signal:)` methods
    static var activateSignal: CheckButtonSignalName { .activate }
    
    /// Emitted when the buttons's [property`Gtk.CheckButton:active`]
    /// property changes.
    /// - Note: This represents the underlying `toggled` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `toggled` signal is emitted
    @discardableResult @inlinable func onToggled(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<CheckButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CheckButtonRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .toggled,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `toggled` signal for using the `connect(signal:)` methods
    static var toggledSignal: CheckButtonSignalName { .toggled }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActive` signal is emitted
    @discardableResult @inlinable func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CheckButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CheckButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active` signal for using the `connect(signal:)` methods
    static var notifyActiveSignal: CheckButtonSignalName { .notifyActive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::group` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyGroup` signal is emitted
    @discardableResult @inlinable func onNotifyGroup(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CheckButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CheckButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyGroup,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::group` signal for using the `connect(signal:)` methods
    static var notifyGroupSignal: CheckButtonSignalName { .notifyGroup }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::inconsistent` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyInconsistent` signal is emitted
    @discardableResult @inlinable func onNotifyInconsistent(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CheckButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CheckButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyInconsistent,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::inconsistent` signal for using the `connect(signal:)` methods
    static var notifyInconsistentSignal: CheckButtonSignalName { .notifyInconsistent }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::label` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyLabel` signal is emitted
    @discardableResult @inlinable func onNotifyLabel(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CheckButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CheckButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyLabel,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::label` signal for using the `connect(signal:)` methods
    static var notifyLabelSignal: CheckButtonSignalName { .notifyLabel }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::use-underline` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUseUnderline` signal is emitted
    @discardableResult @inlinable func onNotifyUseUnderline(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CheckButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<CheckButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CheckButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyUseUnderline,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::use-underline` signal for using the `connect(signal:)` methods
    static var notifyUseUnderlineSignal: CheckButtonSignalName { .notifyUseUnderline }
    
}

// MARK: CheckButton Class: CheckButtonProtocol extension (methods and fields)
public extension CheckButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCheckButton` instance.
    @inlinable var check_button_ptr: UnsafeMutablePointer<GtkCheckButton>! { return ptr?.assumingMemoryBound(to: GtkCheckButton.self) }

    /// Returns whether the check button is active.
    @inlinable func getActive() -> Bool {
        let rv = ((gtk_check_button_get_active(check_button_ptr)) != 0)
        return rv
    }

    /// Returns whether the check button is in an inconsistent state.
    @inlinable func getInconsistent() -> Bool {
        let rv = ((gtk_check_button_get_inconsistent(check_button_ptr)) != 0)
        return rv
    }

    /// Returns the label of the check button.
    @inlinable func getLabel() -> String! {
        let rv = gtk_check_button_get_label(check_button_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns whether underlines in the label indicate mnemonics.
    @inlinable func getUseUnderline() -> Bool {
        let rv = ((gtk_check_button_get_use_underline(check_button_ptr)) != 0)
        return rv
    }

    /// Changes the check buttons active state.
    @inlinable func setActive(setting: Bool) {
        gtk_check_button_set_active(check_button_ptr, gboolean((setting) ? 1 : 0))
    
    }

    /// Adds `self` to the group of `group`.
    /// 
    /// In a group of multiple check buttons, only one button can be active
    /// at a time. The behavior of a checkbutton in a group is also commonly
    /// known as a *radio button*.
    /// 
    /// Setting the group of a check button also changes the css name of the
    /// indicator widget's CSS node to 'radio'.
    /// 
    /// Setting up groups in a cycle leads to undefined behavior.
    /// 
    /// Note that the same effect can be achieved via the [iface`Gtk.Actionable`]
    /// API, by using the same action with parameter type and state type 's'
    /// for all buttons in the group, and giving each button its own target
    /// value.
    @inlinable func set(group: CheckButtonRef? = nil) {
        gtk_check_button_set_group(check_button_ptr, group?.check_button_ptr)
    
    }
    /// Adds `self` to the group of `group`.
    /// 
    /// In a group of multiple check buttons, only one button can be active
    /// at a time. The behavior of a checkbutton in a group is also commonly
    /// known as a *radio button*.
    /// 
    /// Setting the group of a check button also changes the css name of the
    /// indicator widget's CSS node to 'radio'.
    /// 
    /// Setting up groups in a cycle leads to undefined behavior.
    /// 
    /// Note that the same effect can be achieved via the [iface`Gtk.Actionable`]
    /// API, by using the same action with parameter type and state type 's'
    /// for all buttons in the group, and giving each button its own target
    /// value.
    @inlinable func set<CheckButtonT: CheckButtonProtocol>(group: CheckButtonT?) {
        gtk_check_button_set_group(check_button_ptr, group?.check_button_ptr)
    
    }

    /// Sets the `GtkCheckButton` to inconsistent state.
    /// 
    /// You shoud turn off the inconsistent state again if the user checks
    /// the check button. This has to be done manually.
    @inlinable func set(inconsistent: Bool) {
        gtk_check_button_set_inconsistent(check_button_ptr, gboolean((inconsistent) ? 1 : 0))
    
    }

    /// Sets the text of `self`.
    /// 
    /// If [property`Gtk.CheckButton:use-underline`] is `true`, an underscore
    /// in `label` is interpreted as mnemonic indicator, see
    /// [method`Gtk.CheckButton.set_use_underline`] for details on this behavior.
    @inlinable func set(label: UnsafePointer<CChar>? = nil) {
        gtk_check_button_set_label(check_button_ptr, label)
    
    }

    /// Sets whether underlines in the label indicate mnemonics.
    /// 
    /// If `setting` is `true`, an underscore character in `self`'s label
    /// indicates a mnemonic accelerator key. This behavior is similar
    /// to [property`Gtk.Label:use-underline`].
    @inlinable func setUseUnderline(setting: Bool) {
        gtk_check_button_set_use_underline(check_button_ptr, gboolean((setting) ? 1 : 0))
    
    }
    /// If the check button is active.
    /// 
    /// Setting `active` to `true` will add the `:checked:` state to both
    /// the check button and the indicator CSS node.
    @inlinable var active: Bool {
        /// Returns whether the check button is active.
        get {
            let rv = ((gtk_check_button_get_active(check_button_ptr)) != 0)
            return rv
        }
        /// Changes the check buttons active state.
        nonmutating set {
            gtk_check_button_set_active(check_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// If the check button is in an “in between” state.
    /// 
    /// The inconsistent state only affects visual appearance,
    /// not the semantics of the button.
    @inlinable var inconsistent: Bool {
        /// Returns whether the check button is in an inconsistent state.
        get {
            let rv = ((gtk_check_button_get_inconsistent(check_button_ptr)) != 0)
            return rv
        }
        /// Sets the `GtkCheckButton` to inconsistent state.
        /// 
        /// You shoud turn off the inconsistent state again if the user checks
        /// the check button. This has to be done manually.
        nonmutating set {
            gtk_check_button_set_inconsistent(check_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Text of the label inside the check button, if it contains a label widget.
    @inlinable var label: String! {
        /// Returns the label of the check button.
        get {
            let rv = gtk_check_button_get_label(check_button_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the text of `self`.
        /// 
        /// If [property`Gtk.CheckButton:use-underline`] is `true`, an underscore
        /// in `label` is interpreted as mnemonic indicator, see
        /// [method`Gtk.CheckButton.set_use_underline`] for details on this behavior.
        nonmutating set {
            gtk_check_button_set_label(check_button_ptr, newValue)
        }
    }

    /// Returns whether underlines in the label indicate mnemonics.
    @inlinable var useUnderline: Bool {
        /// Returns whether underlines in the label indicate mnemonics.
        get {
            let rv = ((gtk_check_button_get_use_underline(check_button_ptr)) != 0)
            return rv
        }
        /// Sets whether underlines in the label indicate mnemonics.
        /// 
        /// If `setting` is `true`, an underscore character in `self`'s label
        /// indicates a mnemonic accelerator key. This behavior is similar
        /// to [property`Gtk.Label:use-underline`].
        nonmutating set {
            gtk_check_button_set_use_underline(check_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    @inlinable var parentInstance: GtkWidget {
        get {
            let rv = check_button_ptr.pointee.parent_instance
            return rv
        }
    }

}



// MARK: - ClosureExpression Class

/// An expression using a custom `GClosure` to compute the value from
/// its parameters.
///
/// The `ClosureExpressionProtocol` protocol exposes the methods and properties of an underlying `GtkClosureExpression` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ClosureExpression`.
/// Alternatively, use `ClosureExpressionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ClosureExpressionProtocol: ExpressionProtocol {
        /// Untyped pointer to the underlying `GtkClosureExpression` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkClosureExpression` instance.
    var closure_expression_ptr: UnsafeMutablePointer<GtkClosureExpression>! { get }

    /// Required Initialiser for types conforming to `ClosureExpressionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// An expression using a custom `GClosure` to compute the value from
/// its parameters.
///
/// The `ClosureExpressionRef` type acts as a lightweight Swift reference to an underlying `GtkClosureExpression` instance.
/// It exposes methods that can operate on this data type through `ClosureExpressionProtocol` conformance.
/// Use `ClosureExpressionRef` only as an `unowned` reference to an existing `GtkClosureExpression` instance.
///
public struct ClosureExpressionRef: ClosureExpressionProtocol {
        /// Untyped pointer to the underlying `GtkClosureExpression` instance.
    /// For type-safe access, use the generated, typed pointer `closure_expression_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ClosureExpressionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkClosureExpression>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkClosureExpression>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkClosureExpression>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkClosureExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ClosureExpressionProtocol`
    @inlinable init<T: ClosureExpressionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// An expression using a custom `GClosure` to compute the value from
/// its parameters.
///
/// The `ClosureExpression` type acts as a reference-counted owner of an underlying `GtkClosureExpression` instance.
/// It provides the methods that can operate on this data type through `ClosureExpressionProtocol` conformance.
/// Use `ClosureExpression` as a strong reference or owner of a `GtkClosureExpression` instance.
///
open class ClosureExpression: Expression, ClosureExpressionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkClosureExpression>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkClosureExpression>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkClosureExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkClosureExpression>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkClosureExpression`.
    /// i.e., ownership is transferred to the `ClosureExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkClosureExpression>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ClosureExpressionProtocol`
    /// Will retain `GtkClosureExpression`.
    /// - Parameter other: an instance of a related type that implements `ClosureExpressionProtocol`
    @inlinable public init<T: ClosureExpressionProtocol>(closureExpression other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ClosureExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no ClosureExpression properties

// MARK: no ClosureExpression signals

// MARK: ClosureExpression has no signals
// MARK: ClosureExpression Class: ClosureExpressionProtocol extension (methods and fields)
public extension ClosureExpressionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkClosureExpression` instance.
    @inlinable var closure_expression_ptr: UnsafeMutablePointer<GtkClosureExpression>! { return ptr?.assumingMemoryBound(to: GtkClosureExpression.self) }



}



// MARK: - ColorButton Class

/// The `GtkColorButton` allows to open a color chooser dialog to change
/// the color.
/// 
/// ![An example GtkColorButton](color-button.png)
/// 
/// It is suitable widget for selecting a color in a preference dialog.
/// 
/// # CSS nodes
/// 
/// ```
/// colorbutton
/// ╰── button.color
///     ╰── [content]
/// ```
/// 
/// `GtkColorButton` has a single CSS node with name colorbutton which
/// contains a button node. To differentiate it from a plain `GtkButton`,
/// it gets the .color style class.
///
/// The `ColorButtonProtocol` protocol exposes the methods and properties of an underlying `GtkColorButton` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorButton`.
/// Alternatively, use `ColorButtonRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColorButtonProtocol: WidgetProtocol, ColorChooserProtocol {
        /// Untyped pointer to the underlying `GtkColorButton` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColorButton` instance.
    var color_button_ptr: UnsafeMutablePointer<GtkColorButton>! { get }

    /// Required Initialiser for types conforming to `ColorButtonProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GtkColorButton` allows to open a color chooser dialog to change
/// the color.
/// 
/// ![An example GtkColorButton](color-button.png)
/// 
/// It is suitable widget for selecting a color in a preference dialog.
/// 
/// # CSS nodes
/// 
/// ```
/// colorbutton
/// ╰── button.color
///     ╰── [content]
/// ```
/// 
/// `GtkColorButton` has a single CSS node with name colorbutton which
/// contains a button node. To differentiate it from a plain `GtkButton`,
/// it gets the .color style class.
///
/// The `ColorButtonRef` type acts as a lightweight Swift reference to an underlying `GtkColorButton` instance.
/// It exposes methods that can operate on this data type through `ColorButtonProtocol` conformance.
/// Use `ColorButtonRef` only as an `unowned` reference to an existing `GtkColorButton` instance.
///
public struct ColorButtonRef: ColorButtonProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkColorButton` instance.
    /// For type-safe access, use the generated, typed pointer `color_button_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColorButtonRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColorButton>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColorButton>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColorButton>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColorButton>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColorButtonProtocol`
    @inlinable init<T: ColorButtonProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ColorButtonProtocol>(_ other: T) -> ColorButtonRef { ColorButtonRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new color button.
    /// 
    /// This returns a widget in the form of a small button containing
    /// a swatch representing the current selected color. When the button
    /// is clicked, a color chooser dialog will open, allowing the user
    /// to select a color. The swatch will be updated to reflect the new
    /// color when the user finishes.
    @inlinable init() {
        let rv = gtk_color_button_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new color button showing the given color.
    @inlinable init<RGBAT: Gdk.RGBAProtocol>(rgba: RGBAT) {
        let rv = gtk_color_button_new_with_rgba(rgba.rgba_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new color button showing the given color.
    @inlinable static func newWith<RGBAT: Gdk.RGBAProtocol>(rgba: RGBAT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_color_button_new_with_rgba(rgba.rgba_ptr))) else { return nil }
        return rv
    }
}

/// The `GtkColorButton` allows to open a color chooser dialog to change
/// the color.
/// 
/// ![An example GtkColorButton](color-button.png)
/// 
/// It is suitable widget for selecting a color in a preference dialog.
/// 
/// # CSS nodes
/// 
/// ```
/// colorbutton
/// ╰── button.color
///     ╰── [content]
/// ```
/// 
/// `GtkColorButton` has a single CSS node with name colorbutton which
/// contains a button node. To differentiate it from a plain `GtkButton`,
/// it gets the .color style class.
///
/// The `ColorButton` type acts as a reference-counted owner of an underlying `GtkColorButton` instance.
/// It provides the methods that can operate on this data type through `ColorButtonProtocol` conformance.
/// Use `ColorButton` as a strong reference or owner of a `GtkColorButton` instance.
///
open class ColorButton: Widget, ColorButtonProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColorButton>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColorButton>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColorButton>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColorButton>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColorButton`.
    /// i.e., ownership is transferred to the `ColorButton` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColorButton>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColorButtonProtocol`
    /// Will retain `GtkColorButton`.
    /// - Parameter other: an instance of a related type that implements `ColorButtonProtocol`
    @inlinable public init<T: ColorButtonProtocol>(colorButton other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorButtonProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new color button.
    /// 
    /// This returns a widget in the form of a small button containing
    /// a swatch representing the current selected color. When the button
    /// is clicked, a color chooser dialog will open, allowing the user
    /// to select a color. The swatch will be updated to reflect the new
    /// color when the user finishes.
    @inlinable public init() {
        let rv = gtk_color_button_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new color button showing the given color.
    @inlinable public init<RGBAT: Gdk.RGBAProtocol>(rgba: RGBAT) {
        let rv = gtk_color_button_new_with_rgba(rgba.rgba_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new color button showing the given color.
    @inlinable public static func newWith<RGBAT: Gdk.RGBAProtocol>(rgba: RGBAT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_color_button_new_with_rgba(rgba.rgba_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum ColorButtonPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// Whether the color chooser dialog should be modal.
    case modal = "modal"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Whether the color chooser should open in editor mode.
    /// 
    /// This property should be used in cases where the palette
    /// in the editor would be redundant, such as when the color
    /// button is already part of a palette.
    case showEditor = "show-editor"
    /// The title of the color chooser dialog
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ColorButtonProtocol {
    /// Bind a `ColorButtonPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorButtonPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColorButton property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColorButtonPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColorButton property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColorButtonPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColorButtonSignalName: String, SignalNameProtocol {
    /// Emitted to when the color button is activated.
    /// 
    /// The ``activate`` signal on `GtkMenuButton` is an action signal and
    /// emitting it causes the button to pop up its dialog.
    case activate = "activate"
    /// Emitted when the user selects a color.
    /// 
    /// When handling this signal, use [method`Gtk.ColorChooser.get_rgba`]
    /// to find out which color was just selected.
    /// 
    /// Note that this signal is only emitted when the user changes the color.
    /// If you need to react to programmatic color changes as well, use
    /// the notify`rgba` signal.
    case colorSet = "color-set"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// Whether the color chooser dialog should be modal.
    case notifyModal = "notify::modal"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Whether the color chooser should open in editor mode.
    /// 
    /// This property should be used in cases where the palette
    /// in the editor would be redundant, such as when the color
    /// button is already part of a palette.
    case notifyShowEditor = "notify::show-editor"
    /// The title of the color chooser dialog
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ColorButton signals
public extension ColorButtonProtocol {
    /// Connect a Swift signal handler to the given, typed `ColorButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ColorButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ColorButtonSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ColorButtonSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted to when the color button is activated.
    /// 
    /// The ``activate`` signal on `GtkMenuButton` is an action signal and
    /// emitting it causes the button to pop up its dialog.
    /// - Note: This represents the underlying `activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `activate` signal is emitted
    @discardableResult @inlinable func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ColorButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColorButtonRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .activate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `activate` signal for using the `connect(signal:)` methods
    static var activateSignal: ColorButtonSignalName { .activate }
    
    /// Emitted when the user selects a color.
    /// 
    /// When handling this signal, use [method`Gtk.ColorChooser.get_rgba`]
    /// to find out which color was just selected.
    /// 
    /// Note that this signal is only emitted when the user changes the color.
    /// If you need to react to programmatic color changes as well, use
    /// the notify`rgba` signal.
    /// - Note: This represents the underlying `color-set` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `colorSet` signal is emitted
    @discardableResult @inlinable func onColorSet(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorButtonRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ColorButtonRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColorButtonRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .colorSet,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `color-set` signal for using the `connect(signal:)` methods
    static var colorSetSignal: ColorButtonSignalName { .colorSet }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::modal` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyModal` signal is emitted
    @discardableResult @inlinable func onNotifyModal(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ColorButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColorButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyModal,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::modal` signal for using the `connect(signal:)` methods
    static var notifyModalSignal: ColorButtonSignalName { .notifyModal }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-editor` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowEditor` signal is emitted
    @discardableResult @inlinable func onNotifyShowEditor(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ColorButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColorButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyShowEditor,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-editor` signal for using the `connect(signal:)` methods
    static var notifyShowEditorSignal: ColorButtonSignalName { .notifyShowEditor }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::title` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyTitle` signal is emitted
    @discardableResult @inlinable func onNotifyTitle(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColorButtonRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ColorButtonRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColorButtonRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyTitle,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::title` signal for using the `connect(signal:)` methods
    static var notifyTitleSignal: ColorButtonSignalName { .notifyTitle }
    
}

// MARK: ColorButton Class: ColorButtonProtocol extension (methods and fields)
public extension ColorButtonProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorButton` instance.
    @inlinable var color_button_ptr: UnsafeMutablePointer<GtkColorButton>! { return ptr?.assumingMemoryBound(to: GtkColorButton.self) }

    /// Gets whether the dialog is modal.
    @inlinable func getModal() -> Bool {
        let rv = ((gtk_color_button_get_modal(color_button_ptr)) != 0)
        return rv
    }

    /// Gets the title of the color chooser dialog.
    @inlinable func getTitle() -> String! {
        let rv = gtk_color_button_get_title(color_button_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Sets whether the dialog should be modal.
    @inlinable func set(modal: Bool) {
        gtk_color_button_set_modal(color_button_ptr, gboolean((modal) ? 1 : 0))
    
    }

    /// Sets the title for the color chooser dialog.
    @inlinable func set(title: UnsafePointer<CChar>!) {
        gtk_color_button_set_title(color_button_ptr, title)
    
    }
    /// Whether the color chooser dialog should be modal.
    @inlinable var modal: Bool {
        /// Gets whether the dialog is modal.
        get {
            let rv = ((gtk_color_button_get_modal(color_button_ptr)) != 0)
            return rv
        }
        /// Sets whether the dialog should be modal.
        nonmutating set {
            gtk_color_button_set_modal(color_button_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// The title of the color chooser dialog
    @inlinable var title: String! {
        /// Gets the title of the color chooser dialog.
        get {
            let rv = gtk_color_button_get_title(color_button_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the title for the color chooser dialog.
        nonmutating set {
            gtk_color_button_set_title(color_button_ptr, newValue)
        }
    }


}



// MARK: - ColorChooserDialog Class

/// A dialog for choosing a color.
/// 
/// ![An example GtkColorChooserDialog](colorchooser.png)
/// 
/// `GtkColorChooserDialog` implements the [iface`Gtk.ColorChooser`] interface
/// and does not provide much API of its own.
/// 
/// To create a `GtkColorChooserDialog`, use [ctor`Gtk.ColorChooserDialog.new`].
/// 
/// To change the initially selected color, use
/// [method`Gtk.ColorChooser.set_rgba`]. To get the selected color use
/// [method`Gtk.ColorChooser.get_rgba`].
///
/// The `ColorChooserDialogProtocol` protocol exposes the methods and properties of an underlying `GtkColorChooserDialog` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorChooserDialog`.
/// Alternatively, use `ColorChooserDialogRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColorChooserDialogProtocol: DialogProtocol, ColorChooserProtocol {
        /// Untyped pointer to the underlying `GtkColorChooserDialog` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColorChooserDialog` instance.
    var color_chooser_dialog_ptr: UnsafeMutablePointer<GtkColorChooserDialog>! { get }

    /// Required Initialiser for types conforming to `ColorChooserDialogProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A dialog for choosing a color.
/// 
/// ![An example GtkColorChooserDialog](colorchooser.png)
/// 
/// `GtkColorChooserDialog` implements the [iface`Gtk.ColorChooser`] interface
/// and does not provide much API of its own.
/// 
/// To create a `GtkColorChooserDialog`, use [ctor`Gtk.ColorChooserDialog.new`].
/// 
/// To change the initially selected color, use
/// [method`Gtk.ColorChooser.set_rgba`]. To get the selected color use
/// [method`Gtk.ColorChooser.get_rgba`].
///
/// The `ColorChooserDialogRef` type acts as a lightweight Swift reference to an underlying `GtkColorChooserDialog` instance.
/// It exposes methods that can operate on this data type through `ColorChooserDialogProtocol` conformance.
/// Use `ColorChooserDialogRef` only as an `unowned` reference to an existing `GtkColorChooserDialog` instance.
///
public struct ColorChooserDialogRef: ColorChooserDialogProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkColorChooserDialog` instance.
    /// For type-safe access, use the generated, typed pointer `color_chooser_dialog_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColorChooserDialogRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColorChooserDialog>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColorChooserDialog>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColorChooserDialog>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColorChooserDialog>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColorChooserDialogProtocol`
    @inlinable init<T: ColorChooserDialogProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ColorChooserDialogProtocol>(_ other: T) -> ColorChooserDialogRef { ColorChooserDialogRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColorChooserDialog`.
    @inlinable init<WindowT: WindowProtocol>( title: UnsafePointer<CChar>? = nil, parent: WindowT?) {
        let rv = gtk_color_chooser_dialog_new(title, parent?.window_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A dialog for choosing a color.
/// 
/// ![An example GtkColorChooserDialog](colorchooser.png)
/// 
/// `GtkColorChooserDialog` implements the [iface`Gtk.ColorChooser`] interface
/// and does not provide much API of its own.
/// 
/// To create a `GtkColorChooserDialog`, use [ctor`Gtk.ColorChooserDialog.new`].
/// 
/// To change the initially selected color, use
/// [method`Gtk.ColorChooser.set_rgba`]. To get the selected color use
/// [method`Gtk.ColorChooser.get_rgba`].
///
/// The `ColorChooserDialog` type acts as a reference-counted owner of an underlying `GtkColorChooserDialog` instance.
/// It provides the methods that can operate on this data type through `ColorChooserDialogProtocol` conformance.
/// Use `ColorChooserDialog` as a strong reference or owner of a `GtkColorChooserDialog` instance.
///
open class ColorChooserDialog: Dialog, ColorChooserDialogProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColorChooserDialog>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColorChooserDialog>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColorChooserDialog>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColorChooserDialog>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColorChooserDialog`.
    /// i.e., ownership is transferred to the `ColorChooserDialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColorChooserDialog>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColorChooserDialogProtocol`
    /// Will retain `GtkColorChooserDialog`.
    /// - Parameter other: an instance of a related type that implements `ColorChooserDialogProtocol`
    @inlinable public init<T: ColorChooserDialogProtocol>(colorChooserDialog other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserDialogProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkColorChooserDialog`.
    @inlinable public init<WindowT: WindowProtocol>( title: UnsafePointer<CChar>? = nil, parent: WindowT?) {
        let rv = gtk_color_chooser_dialog_new(title, parent?.window_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ColorChooserDialogPropertyName: String, PropertyNameProtocol {
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case application = "application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the window should have a frame (also known as *decorations*).
    case decorated = "decorated"
    /// The default height of the window.
    case defaultHeight = "default-height"
    /// The default widget.
    case defaultWidget = "default-widget"
    /// The default width of the window.
    case defaultWidth = "default-width"
    /// Whether the window frame should have a close button.
    case deletable = "deletable"
    /// If this window should be destroyed when the parent is destroyed.
    case destroyWithParent = "destroy-with-parent"
    /// The display that will display this window.
    case display = "display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case focusVisible = "focus-visible"
    /// The focus widget.
    case focusWidget = "focus-widget"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.fullscreen`] or [method`Gtk.Window.unfullscreen`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case fullscreened = "fullscreened"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the window frame should handle F10 for activating
    /// menubars.
    case handleMenubarAccel = "handle-menubar-accel"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// If this window should be hidden when the users clicks the close button.
    case hideOnClose = "hide-on-close"
    /// Specifies the name of the themed icon to use as the window icon.
    /// 
    /// See [class`Gtk.IconTheme`] for more details.
    case iconName = "icon-name"
    /// Whether the toplevel is the currently active window.
    case isActive = "is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.maximize`] or [method`Gtk.Window.unmaximize`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case maximized = "maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case mnemonicsVisible = "mnemonics-visible"
    /// If `true`, the window is modal.
    case modal = "modal"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// If `true`, users can resize the window.
    case resizable = "resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    case showEditor = "show-editor"
    /// A write-only property for setting window's startup notification identifier.
    case startupId = "startup-id"
    /// The title of the window.
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The transient parent of the window.
    case transientFor = "transient-for"
    /// `true` if the dialog uses a headerbar for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    /// 
    /// ## Creating a dialog with headerbar
    /// 
    /// Builtin `GtkDialog` subclasses such as [class`Gtk.ColorChooserDialog`]
    /// set this property according to platform conventions (using the
    /// [property`Gtk.Settings:gtk-dialogs-use-header`] setting).
    /// 
    /// Here is how you can achieve the same:
    /// 
    /// ```c
    /// g_object_get (settings, "gtk-dialogs-use-header", &header, NULL);
    /// dialog = g_object_new (GTK_TYPE_DIALOG, header, TRUE, NULL);
    /// ```
    case useHeaderBar = "use-header-bar"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ColorChooserDialogProtocol {
    /// Bind a `ColorChooserDialogPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorChooserDialogPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColorChooserDialog property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColorChooserDialogPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColorChooserDialog property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColorChooserDialogPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColorChooserDialogSignalName: String, SignalNameProtocol {
    /// Emitted when the user activates the default widget
    /// of `window`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    case activateDefault = "activate-default"
    /// Emitted when the user activates the currently focused
    /// widget of `window`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    case activateFocus = "activate-focus"
    /// Emitted when the user uses a keybinding to close the dialog.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is the Escape key.
    case close = "close"
    /// Emitted when the user clicks on the close button of the window.
    case closeRequest = "close-request"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when the user enables or disables interactive debugging.
    /// 
    /// When `toggle` is `true`, interactive debugging is toggled on or off,
    /// when it is `false`, the debugger will be pointed at the widget
    /// under the pointer.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are Ctrl-Shift-I
    /// and Ctrl-Shift-D.
    case enableDebugging = "enable-debugging"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// emitted when the set of accelerators or mnemonics that
    /// are associated with `window` changes.
    case keysChanged = "keys-changed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when an action widget is clicked.
    /// 
    /// The signal is also emitted when the dialog receives a
    /// delete event, and when [method`Gtk.Dialog.response`] is called.
    /// On a delete event, the response ID is `GTK_RESPONSE_DELETE_EVENT`.
    /// Otherwise, it depends on which action widget was clicked.
    case response = "response"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case notifyApplication = "notify::application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the window should have a frame (also known as *decorations*).
    case notifyDecorated = "notify::decorated"
    /// The default height of the window.
    case notifyDefaultHeight = "notify::default-height"
    /// The default widget.
    case notifyDefaultWidget = "notify::default-widget"
    /// The default width of the window.
    case notifyDefaultWidth = "notify::default-width"
    /// Whether the window frame should have a close button.
    case notifyDeletable = "notify::deletable"
    /// If this window should be destroyed when the parent is destroyed.
    case notifyDestroyWithParent = "notify::destroy-with-parent"
    /// The display that will display this window.
    case notifyDisplay = "notify::display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case notifyFocusVisible = "notify::focus-visible"
    /// The focus widget.
    case notifyFocusWidget = "notify::focus-widget"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.fullscreen`] or [method`Gtk.Window.unfullscreen`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case notifyFullscreened = "notify::fullscreened"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the window frame should handle F10 for activating
    /// menubars.
    case notifyHandleMenubarAccel = "notify::handle-menubar-accel"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// If this window should be hidden when the users clicks the close button.
    case notifyHideOnClose = "notify::hide-on-close"
    /// Specifies the name of the themed icon to use as the window icon.
    /// 
    /// See [class`Gtk.IconTheme`] for more details.
    case notifyIconName = "notify::icon-name"
    /// Whether the toplevel is the currently active window.
    case notifyIsActive = "notify::is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.maximize`] or [method`Gtk.Window.unmaximize`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case notifyMaximized = "notify::maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case notifyMnemonicsVisible = "notify::mnemonics-visible"
    /// If `true`, the window is modal.
    case notifyModal = "notify::modal"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// If `true`, users can resize the window.
    case notifyResizable = "notify::resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    case notifyShowEditor = "notify::show-editor"
    /// A write-only property for setting window's startup notification identifier.
    case notifyStartupId = "notify::startup-id"
    /// The title of the window.
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The transient parent of the window.
    case notifyTransientFor = "notify::transient-for"
    /// `true` if the dialog uses a headerbar for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    /// 
    /// ## Creating a dialog with headerbar
    /// 
    /// Builtin `GtkDialog` subclasses such as [class`Gtk.ColorChooserDialog`]
    /// set this property according to platform conventions (using the
    /// [property`Gtk.Settings:gtk-dialogs-use-header`] setting).
    /// 
    /// Here is how you can achieve the same:
    /// 
    /// ```c
    /// g_object_get (settings, "gtk-dialogs-use-header", &header, NULL);
    /// dialog = g_object_new (GTK_TYPE_DIALOG, header, TRUE, NULL);
    /// ```
    case notifyUseHeaderBar = "notify::use-header-bar"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ColorChooserDialog has no signals
// MARK: ColorChooserDialog Class: ColorChooserDialogProtocol extension (methods and fields)
public extension ColorChooserDialogProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorChooserDialog` instance.
    @inlinable var color_chooser_dialog_ptr: UnsafeMutablePointer<GtkColorChooserDialog>! { return ptr?.assumingMemoryBound(to: GtkColorChooserDialog.self) }



}



// MARK: - ColorChooserWidget Class

/// The `GtkColorChooserWidget` widget lets the user select a color.
/// 
/// By default, the chooser presents a predefined palette of colors,
/// plus a small number of settable custom colors. It is also possible
/// to select a different color with the single-color editor.
/// 
/// To enter the single-color editing mode, use the context menu of any
/// color of the palette, or use the '+' button to add a new custom color.
/// 
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
/// 
/// To create a `GtkColorChooserWidget`, use [ctor`Gtk.ColorChooserWidget.new`].
/// 
/// To change the initially selected color, use
/// [method`Gtk.ColorChooser.set_rgba`]. To get the selected color use
/// [method`Gtk.ColorChooser.get_rgba`].
/// 
/// The `GtkColorChooserWidget` is used in the [class`Gtk.ColorChooserDialog`]
/// to provide a dialog for selecting colors.
/// 
/// # CSS names
/// 
/// `GtkColorChooserWidget` has a single CSS node with name colorchooser.
///
/// The `ColorChooserWidgetProtocol` protocol exposes the methods and properties of an underlying `GtkColorChooserWidget` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColorChooserWidget`.
/// Alternatively, use `ColorChooserWidgetRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColorChooserWidgetProtocol: WidgetProtocol, ColorChooserProtocol {
        /// Untyped pointer to the underlying `GtkColorChooserWidget` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColorChooserWidget` instance.
    var color_chooser_widget_ptr: UnsafeMutablePointer<GtkColorChooserWidget>! { get }

    /// Required Initialiser for types conforming to `ColorChooserWidgetProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// The `GtkColorChooserWidget` widget lets the user select a color.
/// 
/// By default, the chooser presents a predefined palette of colors,
/// plus a small number of settable custom colors. It is also possible
/// to select a different color with the single-color editor.
/// 
/// To enter the single-color editing mode, use the context menu of any
/// color of the palette, or use the '+' button to add a new custom color.
/// 
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
/// 
/// To create a `GtkColorChooserWidget`, use [ctor`Gtk.ColorChooserWidget.new`].
/// 
/// To change the initially selected color, use
/// [method`Gtk.ColorChooser.set_rgba`]. To get the selected color use
/// [method`Gtk.ColorChooser.get_rgba`].
/// 
/// The `GtkColorChooserWidget` is used in the [class`Gtk.ColorChooserDialog`]
/// to provide a dialog for selecting colors.
/// 
/// # CSS names
/// 
/// `GtkColorChooserWidget` has a single CSS node with name colorchooser.
///
/// The `ColorChooserWidgetRef` type acts as a lightweight Swift reference to an underlying `GtkColorChooserWidget` instance.
/// It exposes methods that can operate on this data type through `ColorChooserWidgetProtocol` conformance.
/// Use `ColorChooserWidgetRef` only as an `unowned` reference to an existing `GtkColorChooserWidget` instance.
///
public struct ColorChooserWidgetRef: ColorChooserWidgetProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkColorChooserWidget` instance.
    /// For type-safe access, use the generated, typed pointer `color_chooser_widget_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColorChooserWidgetRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColorChooserWidget>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColorChooserWidget>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColorChooserWidget>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColorChooserWidget>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColorChooserWidgetProtocol`
    @inlinable init<T: ColorChooserWidgetProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ColorChooserWidgetProtocol>(_ other: T) -> ColorChooserWidgetRef { ColorChooserWidgetRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColorChooserWidget`.
    @inlinable init() {
        let rv = gtk_color_chooser_widget_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// The `GtkColorChooserWidget` widget lets the user select a color.
/// 
/// By default, the chooser presents a predefined palette of colors,
/// plus a small number of settable custom colors. It is also possible
/// to select a different color with the single-color editor.
/// 
/// To enter the single-color editing mode, use the context menu of any
/// color of the palette, or use the '+' button to add a new custom color.
/// 
/// The chooser automatically remembers the last selection, as well
/// as custom colors.
/// 
/// To create a `GtkColorChooserWidget`, use [ctor`Gtk.ColorChooserWidget.new`].
/// 
/// To change the initially selected color, use
/// [method`Gtk.ColorChooser.set_rgba`]. To get the selected color use
/// [method`Gtk.ColorChooser.get_rgba`].
/// 
/// The `GtkColorChooserWidget` is used in the [class`Gtk.ColorChooserDialog`]
/// to provide a dialog for selecting colors.
/// 
/// # CSS names
/// 
/// `GtkColorChooserWidget` has a single CSS node with name colorchooser.
///
/// The `ColorChooserWidget` type acts as a reference-counted owner of an underlying `GtkColorChooserWidget` instance.
/// It provides the methods that can operate on this data type through `ColorChooserWidgetProtocol` conformance.
/// Use `ColorChooserWidget` as a strong reference or owner of a `GtkColorChooserWidget` instance.
///
open class ColorChooserWidget: Widget, ColorChooserWidgetProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColorChooserWidget>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColorChooserWidget>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColorChooserWidget>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColorChooserWidget>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColorChooserWidget`.
    /// i.e., ownership is transferred to the `ColorChooserWidget` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColorChooserWidget>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColorChooserWidgetProtocol`
    /// Will retain `GtkColorChooserWidget`.
    /// - Parameter other: an instance of a related type that implements `ColorChooserWidgetProtocol`
    @inlinable public init<T: ColorChooserWidgetProtocol>(colorChooserWidget other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColorChooserWidgetProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkColorChooserWidget`.
    @inlinable public init() {
        let rv = gtk_color_chooser_widget_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ColorChooserWidgetPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// `true` when the color chooser is showing the single-color editor.
    /// 
    /// It can be set to switch the color chooser into single-color editing mode.
    case showEditor = "show-editor"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ColorChooserWidgetProtocol {
    /// Bind a `ColorChooserWidgetPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColorChooserWidgetPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColorChooserWidget property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColorChooserWidgetPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColorChooserWidget property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColorChooserWidgetPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColorChooserWidgetSignalName: String, SignalNameProtocol {
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// `true` when the color chooser is showing the single-color editor.
    /// 
    /// It can be set to switch the color chooser into single-color editing mode.
    case notifyShowEditor = "notify::show-editor"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ColorChooserWidget has no signals
// MARK: ColorChooserWidget Class: ColorChooserWidgetProtocol extension (methods and fields)
public extension ColorChooserWidgetProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColorChooserWidget` instance.
    @inlinable var color_chooser_widget_ptr: UnsafeMutablePointer<GtkColorChooserWidget>! { return ptr?.assumingMemoryBound(to: GtkColorChooserWidget.self) }



}



// MARK: - ColumnView Class

/// `GtkColumnView` presents a large dynamic list of items using multiple columns
/// with headers.
/// 
/// `GtkColumnView` uses the factories of its columns to generate a cell widget for
/// each column, for each visible item and displays them together as the row for
/// this item.
/// 
/// The [property`Gtk.ColumnView:show-row-separators`] and
/// [property`Gtk.ColumnView:show-column-separators`] properties offer a simple way
/// to display separators between the rows or columns.
/// 
/// `GtkColumnView` allows the user to select items according to the selection
/// characteristics of the model. For models that allow multiple selected items,
/// it is possible to turn on *rubberband selection*, using
/// [property`Gtk.ColumnView:enable-rubberband`].
/// 
/// The column view supports sorting that can be customized by the user by
/// clicking on column headers. To set this up, the `GtkSorter` returned by
/// [method`Gtk.ColumnView.get_sorter`] must be attached to a sort model for the
/// data that the view is showing, and the columns must have sorters attached to
/// them by calling [method`Gtk.ColumnViewColumn.set_sorter`]. The initial sort
/// order can be set with [method`Gtk.ColumnView.sort_by_column`].
/// 
/// The column view also supports interactive resizing and reordering of
/// columns, via Drag-and-Drop of the column headers. This can be enabled or
/// disabled with the [property`Gtk.ColumnView:reorderable`] and
/// [property`Gtk.ColumnViewColumn:resizable`] properties.
/// 
/// To learn more about the list widget framework, see the
/// [overview](section-list-widget.html).
/// 
/// # CSS nodes
/// 
/// ```
/// columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
/// ├── header
/// │   ├── &lt;column header&gt;
/// ┊   ┊
/// │   ╰── &lt;column header&gt;
/// │
/// ├── listview
/// │
/// ┊
/// ╰── [rubberband]
/// ```
/// 
/// `GtkColumnView` uses a single CSS node named columnview. It may carry the
/// .column-separators style class, when [property`Gtk.ColumnView:show-column-separators`]
/// property is set. Header widgets appear below a node with name header.
/// The rows are contained in a `GtkListView` widget, so there is a listview
/// node with the same structure as for a standalone `GtkListView` widget.
/// If [property`Gtk.ColumnView:show-row-separators`] is set, it will be passed
/// on to the list view, causing its CSS node to carry the .separators style class.
/// For rubberband selection, a node with name rubberband is used.
/// 
/// The main columnview node may also carry style classes to select
/// the style of [list presentation](section-list-widget.html`list-styles`):
/// .rich-list, .navigation-sidebar or .data-table.
/// 
/// # Accessibility
/// 
/// `GtkColumnView` uses the `GTK_ACCESSIBLE_ROLE_TREE_GRID` role, header title
/// widgets are using the `GTK_ACCESSIBLE_ROLE_COLUMN_HEADER` role. The row widgets
/// are using the `GTK_ACCESSIBLE_ROLE_ROW` role, and individual cells are using
/// the `GTK_ACCESSIBLE_ROLE_GRID_CELL` role
///
/// The `ColumnViewProtocol` protocol exposes the methods and properties of an underlying `GtkColumnView` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColumnView`.
/// Alternatively, use `ColumnViewRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColumnViewProtocol: WidgetProtocol, ScrollableProtocol {
        /// Untyped pointer to the underlying `GtkColumnView` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColumnView` instance.
    var column_view_ptr: UnsafeMutablePointer<GtkColumnView>! { get }

    /// Required Initialiser for types conforming to `ColumnViewProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkColumnView` presents a large dynamic list of items using multiple columns
/// with headers.
/// 
/// `GtkColumnView` uses the factories of its columns to generate a cell widget for
/// each column, for each visible item and displays them together as the row for
/// this item.
/// 
/// The [property`Gtk.ColumnView:show-row-separators`] and
/// [property`Gtk.ColumnView:show-column-separators`] properties offer a simple way
/// to display separators between the rows or columns.
/// 
/// `GtkColumnView` allows the user to select items according to the selection
/// characteristics of the model. For models that allow multiple selected items,
/// it is possible to turn on *rubberband selection*, using
/// [property`Gtk.ColumnView:enable-rubberband`].
/// 
/// The column view supports sorting that can be customized by the user by
/// clicking on column headers. To set this up, the `GtkSorter` returned by
/// [method`Gtk.ColumnView.get_sorter`] must be attached to a sort model for the
/// data that the view is showing, and the columns must have sorters attached to
/// them by calling [method`Gtk.ColumnViewColumn.set_sorter`]. The initial sort
/// order can be set with [method`Gtk.ColumnView.sort_by_column`].
/// 
/// The column view also supports interactive resizing and reordering of
/// columns, via Drag-and-Drop of the column headers. This can be enabled or
/// disabled with the [property`Gtk.ColumnView:reorderable`] and
/// [property`Gtk.ColumnViewColumn:resizable`] properties.
/// 
/// To learn more about the list widget framework, see the
/// [overview](section-list-widget.html).
/// 
/// # CSS nodes
/// 
/// ```
/// columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
/// ├── header
/// │   ├── &lt;column header&gt;
/// ┊   ┊
/// │   ╰── &lt;column header&gt;
/// │
/// ├── listview
/// │
/// ┊
/// ╰── [rubberband]
/// ```
/// 
/// `GtkColumnView` uses a single CSS node named columnview. It may carry the
/// .column-separators style class, when [property`Gtk.ColumnView:show-column-separators`]
/// property is set. Header widgets appear below a node with name header.
/// The rows are contained in a `GtkListView` widget, so there is a listview
/// node with the same structure as for a standalone `GtkListView` widget.
/// If [property`Gtk.ColumnView:show-row-separators`] is set, it will be passed
/// on to the list view, causing its CSS node to carry the .separators style class.
/// For rubberband selection, a node with name rubberband is used.
/// 
/// The main columnview node may also carry style classes to select
/// the style of [list presentation](section-list-widget.html`list-styles`):
/// .rich-list, .navigation-sidebar or .data-table.
/// 
/// # Accessibility
/// 
/// `GtkColumnView` uses the `GTK_ACCESSIBLE_ROLE_TREE_GRID` role, header title
/// widgets are using the `GTK_ACCESSIBLE_ROLE_COLUMN_HEADER` role. The row widgets
/// are using the `GTK_ACCESSIBLE_ROLE_ROW` role, and individual cells are using
/// the `GTK_ACCESSIBLE_ROLE_GRID_CELL` role
///
/// The `ColumnViewRef` type acts as a lightweight Swift reference to an underlying `GtkColumnView` instance.
/// It exposes methods that can operate on this data type through `ColumnViewProtocol` conformance.
/// Use `ColumnViewRef` only as an `unowned` reference to an existing `GtkColumnView` instance.
///
public struct ColumnViewRef: ColumnViewProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkColumnView` instance.
    /// For type-safe access, use the generated, typed pointer `column_view_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColumnViewRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColumnView>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColumnView>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColumnView>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColumnView>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColumnViewProtocol`
    @inlinable init<T: ColumnViewProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ColumnViewProtocol>(_ other: T) -> ColumnViewRef { ColumnViewRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColumnView`.
    /// 
    /// You most likely want to call [method`Gtk.ColumnView.append_column`]
    /// to add columns next.
    @inlinable init<SelectionModelT: SelectionModelProtocol>( model: SelectionModelT?) {
        let rv = gtk_column_view_new(model?.selection_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkColumnView` presents a large dynamic list of items using multiple columns
/// with headers.
/// 
/// `GtkColumnView` uses the factories of its columns to generate a cell widget for
/// each column, for each visible item and displays them together as the row for
/// this item.
/// 
/// The [property`Gtk.ColumnView:show-row-separators`] and
/// [property`Gtk.ColumnView:show-column-separators`] properties offer a simple way
/// to display separators between the rows or columns.
/// 
/// `GtkColumnView` allows the user to select items according to the selection
/// characteristics of the model. For models that allow multiple selected items,
/// it is possible to turn on *rubberband selection*, using
/// [property`Gtk.ColumnView:enable-rubberband`].
/// 
/// The column view supports sorting that can be customized by the user by
/// clicking on column headers. To set this up, the `GtkSorter` returned by
/// [method`Gtk.ColumnView.get_sorter`] must be attached to a sort model for the
/// data that the view is showing, and the columns must have sorters attached to
/// them by calling [method`Gtk.ColumnViewColumn.set_sorter`]. The initial sort
/// order can be set with [method`Gtk.ColumnView.sort_by_column`].
/// 
/// The column view also supports interactive resizing and reordering of
/// columns, via Drag-and-Drop of the column headers. This can be enabled or
/// disabled with the [property`Gtk.ColumnView:reorderable`] and
/// [property`Gtk.ColumnViewColumn:resizable`] properties.
/// 
/// To learn more about the list widget framework, see the
/// [overview](section-list-widget.html).
/// 
/// # CSS nodes
/// 
/// ```
/// columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
/// ├── header
/// │   ├── &lt;column header&gt;
/// ┊   ┊
/// │   ╰── &lt;column header&gt;
/// │
/// ├── listview
/// │
/// ┊
/// ╰── [rubberband]
/// ```
/// 
/// `GtkColumnView` uses a single CSS node named columnview. It may carry the
/// .column-separators style class, when [property`Gtk.ColumnView:show-column-separators`]
/// property is set. Header widgets appear below a node with name header.
/// The rows are contained in a `GtkListView` widget, so there is a listview
/// node with the same structure as for a standalone `GtkListView` widget.
/// If [property`Gtk.ColumnView:show-row-separators`] is set, it will be passed
/// on to the list view, causing its CSS node to carry the .separators style class.
/// For rubberband selection, a node with name rubberband is used.
/// 
/// The main columnview node may also carry style classes to select
/// the style of [list presentation](section-list-widget.html`list-styles`):
/// .rich-list, .navigation-sidebar or .data-table.
/// 
/// # Accessibility
/// 
/// `GtkColumnView` uses the `GTK_ACCESSIBLE_ROLE_TREE_GRID` role, header title
/// widgets are using the `GTK_ACCESSIBLE_ROLE_COLUMN_HEADER` role. The row widgets
/// are using the `GTK_ACCESSIBLE_ROLE_ROW` role, and individual cells are using
/// the `GTK_ACCESSIBLE_ROLE_GRID_CELL` role
///
/// The `ColumnView` type acts as a reference-counted owner of an underlying `GtkColumnView` instance.
/// It provides the methods that can operate on this data type through `ColumnViewProtocol` conformance.
/// Use `ColumnView` as a strong reference or owner of a `GtkColumnView` instance.
///
open class ColumnView: Widget, ColumnViewProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColumnView>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColumnView>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColumnView>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColumnView>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColumnView`.
    /// i.e., ownership is transferred to the `ColumnView` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColumnView>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColumnViewProtocol`
    /// Will retain `GtkColumnView`.
    /// - Parameter other: an instance of a related type that implements `ColumnViewProtocol`
    @inlinable public init<T: ColumnViewProtocol>(columnView other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkColumnView`.
    /// 
    /// You most likely want to call [method`Gtk.ColumnView.append_column`]
    /// to add columns next.
    @inlinable public init<SelectionModelT: SelectionModelProtocol>( model: SelectionModelT?) {
        let rv = gtk_column_view_new(model?.selection_model_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ColumnViewPropertyName: String, PropertyNameProtocol {
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The list of columns.
    case columns = "columns"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Allow rubberband selection.
    case enableRubberband = "enable-rubberband"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// Model for the items displayed.
    case model = "model"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// Whether columns are reorderable.
    case reorderable = "reorderable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Show separators between columns.
    case showColumnSeparators = "show-column-separators"
    /// Show separators between rows.
    case showRowSeparators = "show-row-separators"
    /// Activate rows on single click and select them on hover.
    case singleClickActivate = "single-click-activate"
    /// Sorter with the sorting choices of the user.
    case sorter = "sorter"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ColumnViewProtocol {
    /// Bind a `ColumnViewPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColumnViewPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColumnView property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColumnViewPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColumnView property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColumnViewPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColumnViewSignalName: String, SignalNameProtocol {
    /// Emitted when a row has been activated by the user, usually via activating
    /// the GtkListBase|list.activate-item action.
    /// 
    /// This allows for a convenient way to handle activation in a columnview.
    /// See [method`Gtk.ListItem.set_activatable`] for details on how to use this
    /// signal.
    case activate = "activate"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The list of columns.
    case notifyColumns = "notify::columns"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Allow rubberband selection.
    case notifyEnableRubberband = "notify::enable-rubberband"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// Model for the items displayed.
    case notifyModel = "notify::model"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// Whether columns are reorderable.
    case notifyReorderable = "notify::reorderable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Show separators between columns.
    case notifyShowColumnSeparators = "notify::show-column-separators"
    /// Show separators between rows.
    case notifyShowRowSeparators = "notify::show-row-separators"
    /// Activate rows on single click and select them on hover.
    case notifySingleClickActivate = "notify::single-click-activate"
    /// Sorter with the sorting choices of the user.
    case notifySorter = "notify::sorter"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ColumnView signals
public extension ColumnViewProtocol {
    /// Connect a Swift signal handler to the given, typed `ColumnViewSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ColumnViewSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ColumnViewSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ColumnViewSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when a row has been activated by the user, usually via activating
    /// the GtkListBase|list.activate-item action.
    /// 
    /// This allows for a convenient way to handle activation in a columnview.
    /// See [method`Gtk.ListItem.set_activatable`] for details on how to use this
    /// signal.
    /// - Note: This represents the underlying `activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter position: position of item to activate
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `activate` signal is emitted
    @discardableResult @inlinable func onActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ position: UInt) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ColumnViewRef, UInt, Void>
        let cCallback: @convention(c) (gpointer, guint, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColumnViewRef(raw: unownedSelf), UInt(arg1))
            return output
        }
        return connect(
            signal: .activate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `activate` signal for using the `connect(signal:)` methods
    static var activateSignal: ColumnViewSignalName { .activate }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::columns` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyColumns` signal is emitted
    @discardableResult @inlinable func onNotifyColumns(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ColumnViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColumnViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyColumns,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::columns` signal for using the `connect(signal:)` methods
    static var notifyColumnsSignal: ColumnViewSignalName { .notifyColumns }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::enable-rubberband` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEnableRubberband` signal is emitted
    @discardableResult @inlinable func onNotifyEnableRubberband(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ColumnViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColumnViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEnableRubberband,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::enable-rubberband` signal for using the `connect(signal:)` methods
    static var notifyEnableRubberbandSignal: ColumnViewSignalName { .notifyEnableRubberband }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::model` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyModel` signal is emitted
    @discardableResult @inlinable func onNotifyModel(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ColumnViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColumnViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyModel,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::model` signal for using the `connect(signal:)` methods
    static var notifyModelSignal: ColumnViewSignalName { .notifyModel }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::reorderable` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyReorderable` signal is emitted
    @discardableResult @inlinable func onNotifyReorderable(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ColumnViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColumnViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyReorderable,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::reorderable` signal for using the `connect(signal:)` methods
    static var notifyReorderableSignal: ColumnViewSignalName { .notifyReorderable }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-column-separators` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowColumnSeparators` signal is emitted
    @discardableResult @inlinable func onNotifyShowColumnSeparators(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ColumnViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColumnViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyShowColumnSeparators,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-column-separators` signal for using the `connect(signal:)` methods
    static var notifyShowColumnSeparatorsSignal: ColumnViewSignalName { .notifyShowColumnSeparators }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::show-row-separators` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyShowRowSeparators` signal is emitted
    @discardableResult @inlinable func onNotifyShowRowSeparators(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ColumnViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColumnViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyShowRowSeparators,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::show-row-separators` signal for using the `connect(signal:)` methods
    static var notifyShowRowSeparatorsSignal: ColumnViewSignalName { .notifyShowRowSeparators }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::single-click-activate` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySingleClickActivate` signal is emitted
    @discardableResult @inlinable func onNotifySingleClickActivate(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ColumnViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColumnViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySingleClickActivate,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::single-click-activate` signal for using the `connect(signal:)` methods
    static var notifySingleClickActivateSignal: ColumnViewSignalName { .notifySingleClickActivate }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::sorter` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifySorter` signal is emitted
    @discardableResult @inlinable func onNotifySorter(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ColumnViewRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ColumnViewRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ColumnViewRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifySorter,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::sorter` signal for using the `connect(signal:)` methods
    static var notifySorterSignal: ColumnViewSignalName { .notifySorter }
    
}

// MARK: ColumnView Class: ColumnViewProtocol extension (methods and fields)
public extension ColumnViewProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColumnView` instance.
    @inlinable var column_view_ptr: UnsafeMutablePointer<GtkColumnView>! { return ptr?.assumingMemoryBound(to: GtkColumnView.self) }

    /// Appends the `column` to the end of the columns in `self`.
    @inlinable func append<ColumnViewColumnT: ColumnViewColumnProtocol>(column: ColumnViewColumnT) {
        gtk_column_view_append_column(column_view_ptr, column.column_view_column_ptr)
    
    }

    /// Gets the list of columns in this column view.
    /// 
    /// This list is constant over the lifetime of `self` and can be used to
    /// monitor changes to the columns of `self` by connecting to the
    /// `items-changed` signal.
    @inlinable func getColumns() -> GIO.ListModelRef! {
        let rv = GIO.ListModelRef(gtk_column_view_get_columns(column_view_ptr))
        return rv
    }

    /// Returns whether rows can be selected by dragging with the mouse.
    @inlinable func getEnableRubberband() -> Bool {
        let rv = ((gtk_column_view_get_enable_rubberband(column_view_ptr)) != 0)
        return rv
    }

    /// Gets the model that's currently used to read the items displayed.
    @inlinable func getModel() -> SelectionModelRef! {
        let rv = SelectionModelRef(gconstpointer: gconstpointer(gtk_column_view_get_model(column_view_ptr)))
        return rv
    }

    /// Returns whether columns are reorderable.
    @inlinable func getReorderable() -> Bool {
        let rv = ((gtk_column_view_get_reorderable(column_view_ptr)) != 0)
        return rv
    }

    /// Returns whether the list should show separators
    /// between columns.
    @inlinable func getShowColumnSeparators() -> Bool {
        let rv = ((gtk_column_view_get_show_column_separators(column_view_ptr)) != 0)
        return rv
    }

    /// Returns whether the list should show separators
    /// between rows.
    @inlinable func getShowRowSeparators() -> Bool {
        let rv = ((gtk_column_view_get_show_row_separators(column_view_ptr)) != 0)
        return rv
    }

    /// Returns whether rows will be activated on single click and
    /// selected on hover.
    @inlinable func getSingleClickActivate() -> Bool {
        let rv = ((gtk_column_view_get_single_click_activate(column_view_ptr)) != 0)
        return rv
    }

    /// Returns a special sorter that reflects the users sorting
    /// choices in the column view.
    /// 
    /// To allow users to customizable sorting by clicking on column
    /// headers, this sorter needs to be set on the sort model underneath
    /// the model that is displayed by the view.
    /// 
    /// See [method`Gtk.ColumnViewColumn.set_sorter`] for setting up
    /// per-column sorting.
    /// 
    /// Here is an example:
    /// ```c
    /// gtk_column_view_column_set_sorter (column, sorter);
    /// gtk_column_view_append_column (view, column);
    /// sorter = g_object_ref (gtk_column_view_get_sorter (view)));
    /// model = gtk_sort_list_model_new (store, sorter);
    /// selection = gtk_no_selection_new (model);
    /// gtk_column_view_set_model (view, selection);
    /// ```
    @inlinable func getSorter() -> SorterRef! {
        let rv = SorterRef(gconstpointer: gconstpointer(gtk_column_view_get_sorter(column_view_ptr)))
        return rv
    }

    /// Inserts a column at the given position in the columns of `self`.
    /// 
    /// If `column` is already a column of `self`, it will be repositioned.
    @inlinable func insertColumn<ColumnViewColumnT: ColumnViewColumnProtocol>(position: Int, column: ColumnViewColumnT) {
        gtk_column_view_insert_column(column_view_ptr, guint(position), column.column_view_column_ptr)
    
    }

    /// Removes the `column` from the list of columns of `self`.
    @inlinable func remove<ColumnViewColumnT: ColumnViewColumnProtocol>(column: ColumnViewColumnT) {
        gtk_column_view_remove_column(column_view_ptr, column.column_view_column_ptr)
    
    }

    /// Sets whether selections can be changed by dragging with the mouse.
    @inlinable func set(enableRubberband: Bool) {
        gtk_column_view_set_enable_rubberband(column_view_ptr, gboolean((enableRubberband) ? 1 : 0))
    
    }

    /// Sets the model to use.
    /// 
    /// This must be a [iface`Gtk.SelectionModel`].
    @inlinable func set(model: SelectionModelRef? = nil) {
        gtk_column_view_set_model(column_view_ptr, model?.selection_model_ptr)
    
    }
    /// Sets the model to use.
    /// 
    /// This must be a [iface`Gtk.SelectionModel`].
    @inlinable func set<SelectionModelT: SelectionModelProtocol>(model: SelectionModelT?) {
        gtk_column_view_set_model(column_view_ptr, model?.selection_model_ptr)
    
    }

    /// Sets whether columns should be reorderable by dragging.
    @inlinable func set(reorderable: Bool) {
        gtk_column_view_set_reorderable(column_view_ptr, gboolean((reorderable) ? 1 : 0))
    
    }

    /// Sets whether the list should show separators
    /// between columns.
    @inlinable func set(showColumnSeparators: Bool) {
        gtk_column_view_set_show_column_separators(column_view_ptr, gboolean((showColumnSeparators) ? 1 : 0))
    
    }

    /// Sets whether the list should show separators
    /// between rows.
    @inlinable func set(showRowSeparators: Bool) {
        gtk_column_view_set_show_row_separators(column_view_ptr, gboolean((showRowSeparators) ? 1 : 0))
    
    }

    /// Sets whether rows should be activated on single click and
    /// selected on hover.
    @inlinable func set(singleClickActivate: Bool) {
        gtk_column_view_set_single_click_activate(column_view_ptr, gboolean((singleClickActivate) ? 1 : 0))
    
    }

    /// Sets the sorting of the view.
    /// 
    /// This function should be used to set up the initial sorting.
    /// At runtime, users can change the sorting of a column view
    /// by clicking on the list headers.
    /// 
    /// This call only has an effect if the sorter returned by
    /// [method`Gtk.ColumnView.get_sorter`] is set on a sort model,
    /// and [method`Gtk.ColumnViewColumn.set_sorter`] has been called
    /// on `column` to associate a sorter with the column.
    /// 
    /// If `column` is `nil`, the view will be unsorted.
    @inlinable func sortBy(column: ColumnViewColumnRef? = nil, direction: GtkSortType) {
        gtk_column_view_sort_by_column(column_view_ptr, column?.column_view_column_ptr, direction)
    
    }
    /// Sets the sorting of the view.
    /// 
    /// This function should be used to set up the initial sorting.
    /// At runtime, users can change the sorting of a column view
    /// by clicking on the list headers.
    /// 
    /// This call only has an effect if the sorter returned by
    /// [method`Gtk.ColumnView.get_sorter`] is set on a sort model,
    /// and [method`Gtk.ColumnViewColumn.set_sorter`] has been called
    /// on `column` to associate a sorter with the column.
    /// 
    /// If `column` is `nil`, the view will be unsorted.
    @inlinable func sortBy<ColumnViewColumnT: ColumnViewColumnProtocol>(column: ColumnViewColumnT?, direction: GtkSortType) {
        gtk_column_view_sort_by_column(column_view_ptr, column?.column_view_column_ptr, direction)
    
    }
    /// The list of columns.
    @inlinable var columns: GIO.ListModelRef! {
        /// Gets the list of columns in this column view.
        /// 
        /// This list is constant over the lifetime of `self` and can be used to
        /// monitor changes to the columns of `self` by connecting to the
        /// `items-changed` signal.
        get {
            let rv = GIO.ListModelRef(gtk_column_view_get_columns(column_view_ptr))
            return rv
        }
    }

    /// Returns whether rows can be selected by dragging with the mouse.
    @inlinable var enableRubberband: Bool {
        /// Returns whether rows can be selected by dragging with the mouse.
        get {
            let rv = ((gtk_column_view_get_enable_rubberband(column_view_ptr)) != 0)
            return rv
        }
        /// Sets whether selections can be changed by dragging with the mouse.
        nonmutating set {
            gtk_column_view_set_enable_rubberband(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Model for the items displayed.
    @inlinable var model: SelectionModelRef! {
        /// Gets the model that's currently used to read the items displayed.
        get {
            let rv = SelectionModelRef(gconstpointer: gconstpointer(gtk_column_view_get_model(column_view_ptr)))
            return rv
        }
        /// Sets the model to use.
        /// 
        /// This must be a [iface`Gtk.SelectionModel`].
        nonmutating set {
            gtk_column_view_set_model(column_view_ptr, UnsafeMutablePointer<GtkSelectionModel>(newValue?.selection_model_ptr))
        }
    }

    /// Whether columns are reorderable.
    @inlinable var reorderable: Bool {
        /// Returns whether columns are reorderable.
        get {
            let rv = ((gtk_column_view_get_reorderable(column_view_ptr)) != 0)
            return rv
        }
        /// Sets whether columns should be reorderable by dragging.
        nonmutating set {
            gtk_column_view_set_reorderable(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the list should show separators
    /// between columns.
    @inlinable var showColumnSeparators: Bool {
        /// Returns whether the list should show separators
        /// between columns.
        get {
            let rv = ((gtk_column_view_get_show_column_separators(column_view_ptr)) != 0)
            return rv
        }
        /// Sets whether the list should show separators
        /// between columns.
        nonmutating set {
            gtk_column_view_set_show_column_separators(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether the list should show separators
    /// between rows.
    @inlinable var showRowSeparators: Bool {
        /// Returns whether the list should show separators
        /// between rows.
        get {
            let rv = ((gtk_column_view_get_show_row_separators(column_view_ptr)) != 0)
            return rv
        }
        /// Sets whether the list should show separators
        /// between rows.
        nonmutating set {
            gtk_column_view_set_show_row_separators(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns whether rows will be activated on single click and
    /// selected on hover.
    @inlinable var singleClickActivate: Bool {
        /// Returns whether rows will be activated on single click and
        /// selected on hover.
        get {
            let rv = ((gtk_column_view_get_single_click_activate(column_view_ptr)) != 0)
            return rv
        }
        /// Sets whether rows should be activated on single click and
        /// selected on hover.
        nonmutating set {
            gtk_column_view_set_single_click_activate(column_view_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Sorter with the sorting choices of the user.
    @inlinable var sorter: SorterRef! {
        /// Returns a special sorter that reflects the users sorting
        /// choices in the column view.
        /// 
        /// To allow users to customizable sorting by clicking on column
        /// headers, this sorter needs to be set on the sort model underneath
        /// the model that is displayed by the view.
        /// 
        /// See [method`Gtk.ColumnViewColumn.set_sorter`] for setting up
        /// per-column sorting.
        /// 
        /// Here is an example:
        /// ```c
        /// gtk_column_view_column_set_sorter (column, sorter);
        /// gtk_column_view_append_column (view, column);
        /// sorter = g_object_ref (gtk_column_view_get_sorter (view)));
        /// model = gtk_sort_list_model_new (store, sorter);
        /// selection = gtk_no_selection_new (model);
        /// gtk_column_view_set_model (view, selection);
        /// ```
        get {
            let rv = SorterRef(gconstpointer: gconstpointer(gtk_column_view_get_sorter(column_view_ptr)))
            return rv
        }
    }


}



// MARK: - ColumnViewColumn Class

/// `GtkColumnViewColumn` represents the columns being added to `GtkColumnView`.
/// 
/// The main ingredient for a `GtkColumnViewColumn` is the `GtkListItemFactory`
/// that tells the columnview how to create cells for this column from items in
/// the model.
/// 
/// Columns have a title, and can optionally have a header menu set
/// with [method`Gtk.ColumnViewColumn.set_header_menu`].
/// 
/// A sorter can be associated with a column using
/// [method`Gtk.ColumnViewColumn.set_sorter`], to let users influence sorting
/// by clicking on the column header.
///
/// The `ColumnViewColumnProtocol` protocol exposes the methods and properties of an underlying `GtkColumnViewColumn` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ColumnViewColumn`.
/// Alternatively, use `ColumnViewColumnRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ColumnViewColumnProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkColumnViewColumn` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkColumnViewColumn` instance.
    var column_view_column_ptr: UnsafeMutablePointer<GtkColumnViewColumn>! { get }

    /// Required Initialiser for types conforming to `ColumnViewColumnProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkColumnViewColumn` represents the columns being added to `GtkColumnView`.
/// 
/// The main ingredient for a `GtkColumnViewColumn` is the `GtkListItemFactory`
/// that tells the columnview how to create cells for this column from items in
/// the model.
/// 
/// Columns have a title, and can optionally have a header menu set
/// with [method`Gtk.ColumnViewColumn.set_header_menu`].
/// 
/// A sorter can be associated with a column using
/// [method`Gtk.ColumnViewColumn.set_sorter`], to let users influence sorting
/// by clicking on the column header.
///
/// The `ColumnViewColumnRef` type acts as a lightweight Swift reference to an underlying `GtkColumnViewColumn` instance.
/// It exposes methods that can operate on this data type through `ColumnViewColumnProtocol` conformance.
/// Use `ColumnViewColumnRef` only as an `unowned` reference to an existing `GtkColumnViewColumn` instance.
///
public struct ColumnViewColumnRef: ColumnViewColumnProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkColumnViewColumn` instance.
    /// For type-safe access, use the generated, typed pointer `column_view_column_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ColumnViewColumnRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkColumnViewColumn>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkColumnViewColumn>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkColumnViewColumn>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkColumnViewColumn>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ColumnViewColumnProtocol`
    @inlinable init<T: ColumnViewColumnProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ColumnViewColumnProtocol>(_ other: T) -> ColumnViewColumnRef { ColumnViewColumnRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkColumnViewColumn` that uses the given `factory` for
    /// mapping items to widgets.
    /// 
    /// You most likely want to call [method`Gtk.ColumnView.append_column`] next.
    /// 
    /// The function takes ownership of the argument, so you can write code like:
    /// 
    /// ```c
    /// column = gtk_column_view_column_new (`_("Name")`,
    ///   gtk_builder_list_item_factory_new_from_resource ("/name.ui"));
    /// ```
    @inlinable init<ListItemFactoryT: ListItemFactoryProtocol>( title: UnsafePointer<CChar>? = nil, factory: ListItemFactoryT?) {
        let rv = gtk_column_view_column_new(title, factory?.list_item_factory_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkColumnViewColumn` represents the columns being added to `GtkColumnView`.
/// 
/// The main ingredient for a `GtkColumnViewColumn` is the `GtkListItemFactory`
/// that tells the columnview how to create cells for this column from items in
/// the model.
/// 
/// Columns have a title, and can optionally have a header menu set
/// with [method`Gtk.ColumnViewColumn.set_header_menu`].
/// 
/// A sorter can be associated with a column using
/// [method`Gtk.ColumnViewColumn.set_sorter`], to let users influence sorting
/// by clicking on the column header.
///
/// The `ColumnViewColumn` type acts as a reference-counted owner of an underlying `GtkColumnViewColumn` instance.
/// It provides the methods that can operate on this data type through `ColumnViewColumnProtocol` conformance.
/// Use `ColumnViewColumn` as a strong reference or owner of a `GtkColumnViewColumn` instance.
///
open class ColumnViewColumn: GLibObject.Object, ColumnViewColumnProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkColumnViewColumn>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkColumnViewColumn>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkColumnViewColumn>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkColumnViewColumn>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkColumnViewColumn`.
    /// i.e., ownership is transferred to the `ColumnViewColumn` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkColumnViewColumn>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ColumnViewColumnProtocol`
    /// Will retain `GtkColumnViewColumn`.
    /// - Parameter other: an instance of a related type that implements `ColumnViewColumnProtocol`
    @inlinable public init<T: ColumnViewColumnProtocol>(columnViewColumn other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ColumnViewColumnProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkColumnViewColumn` that uses the given `factory` for
    /// mapping items to widgets.
    /// 
    /// You most likely want to call [method`Gtk.ColumnView.append_column`] next.
    /// 
    /// The function takes ownership of the argument, so you can write code like:
    /// 
    /// ```c
    /// column = gtk_column_view_column_new (`_("Name")`,
    ///   gtk_builder_list_item_factory_new_from_resource ("/name.ui"));
    /// ```
    @inlinable public init<ListItemFactoryT: ListItemFactoryProtocol>( title: UnsafePointer<CChar>? = nil, factory: ListItemFactoryT?) {
        let rv = gtk_column_view_column_new(title, factory?.list_item_factory_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ColumnViewColumnPropertyName: String, PropertyNameProtocol {
    /// The `GtkColumnView` this column is a part of.
    case columnView = "column-view"
    /// Column gets share of extra width allocated to the view.
    case expand = "expand"
    /// Factory for populating list items.
    case factory = "factory"
    /// If not -1, this is the width that the column is allocated,
    /// regardless of the size of its content.
    case fixedWidth = "fixed-width"
    /// Menu model used to create the context menu for the column header.
    case headerMenu = "header-menu"
    /// Whether this column is resizable.
    case resizable = "resizable"
    /// Sorter for sorting items according to this column.
    case sorter = "sorter"
    /// Title displayed in the header.
    case title = "title"
    /// Whether this column is visible.
    case visible = "visible"
}

public extension ColumnViewColumnProtocol {
    /// Bind a `ColumnViewColumnPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ColumnViewColumnPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ColumnViewColumn property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ColumnViewColumnPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ColumnViewColumn property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ColumnViewColumnPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ColumnViewColumnSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The `GtkColumnView` this column is a part of.
    case notifyColumnView = "notify::column-view"
    /// Column gets share of extra width allocated to the view.
    case notifyExpand = "notify::expand"
    /// Factory for populating list items.
    case notifyFactory = "notify::factory"
    /// If not -1, this is the width that the column is allocated,
    /// regardless of the size of its content.
    case notifyFixedWidth = "notify::fixed-width"
    /// Menu model used to create the context menu for the column header.
    case notifyHeaderMenu = "notify::header-menu"
    /// Whether this column is resizable.
    case notifyResizable = "notify::resizable"
    /// Sorter for sorting items according to this column.
    case notifySorter = "notify::sorter"
    /// Title displayed in the header.
    case notifyTitle = "notify::title"
    /// Whether this column is visible.
    case notifyVisible = "notify::visible"
}

// MARK: ColumnViewColumn has no signals
// MARK: ColumnViewColumn Class: ColumnViewColumnProtocol extension (methods and fields)
public extension ColumnViewColumnProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkColumnViewColumn` instance.
    @inlinable var column_view_column_ptr: UnsafeMutablePointer<GtkColumnViewColumn>! { return ptr?.assumingMemoryBound(to: GtkColumnViewColumn.self) }

    /// Gets the column view that's currently displaying this column.
    /// 
    /// If `self` has not been added to a column view yet, `nil` is returned.
    @inlinable func getColumnView() -> ColumnViewRef! {
        let rv = ColumnViewRef(gconstpointer: gconstpointer(gtk_column_view_column_get_column_view(column_view_column_ptr)))
        return rv
    }

    /// Returns whether this column should expand.
    @inlinable func getExpand() -> Bool {
        let rv = ((gtk_column_view_column_get_expand(column_view_column_ptr)) != 0)
        return rv
    }

    /// Gets the factory that's currently used to populate list items for
    /// this column.
    @inlinable func getFactory() -> ListItemFactoryRef! {
        let rv = ListItemFactoryRef(gconstpointer: gconstpointer(gtk_column_view_column_get_factory(column_view_column_ptr)))
        return rv
    }

    /// Gets the fixed width of the column.
    @inlinable func getFixedWidth() -> Int {
        let rv = Int(gtk_column_view_column_get_fixed_width(column_view_column_ptr))
        return rv
    }

    /// Gets the menu model that is used to create the context menu
    /// for the column header.
    @inlinable func getHeaderMenu() -> GIO.MenuModelRef! {
        let rv = GIO.MenuModelRef(gtk_column_view_column_get_header_menu(column_view_column_ptr))
        return rv
    }

    /// Returns whether this column is resizable.
    @inlinable func getResizable() -> Bool {
        let rv = ((gtk_column_view_column_get_resizable(column_view_column_ptr)) != 0)
        return rv
    }

    /// Returns the sorter that is associated with the column.
    @inlinable func getSorter() -> SorterRef! {
        let rv = SorterRef(gconstpointer: gconstpointer(gtk_column_view_column_get_sorter(column_view_column_ptr)))
        return rv
    }

    /// Returns the title set with `gtk_column_view_column_set_title()`.
    @inlinable func getTitle() -> String! {
        let rv = gtk_column_view_column_get_title(column_view_column_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Returns whether this column is visible.
    @inlinable func getVisible() -> Bool {
        let rv = ((gtk_column_view_column_get_visible(column_view_column_ptr)) != 0)
        return rv
    }

    /// Sets the column to take available extra space.
    /// 
    /// The extra space is shared equally amongst all columns that
    /// have the expand set to `true`.
    @inlinable func set(expand: Bool) {
        gtk_column_view_column_set_expand(column_view_column_ptr, gboolean((expand) ? 1 : 0))
    
    }

    /// Sets the `GtkListItemFactory` to use for populating list items for this
    /// column.
    @inlinable func set(factory: ListItemFactoryRef? = nil) {
        gtk_column_view_column_set_factory(column_view_column_ptr, factory?.list_item_factory_ptr)
    
    }
    /// Sets the `GtkListItemFactory` to use for populating list items for this
    /// column.
    @inlinable func set<ListItemFactoryT: ListItemFactoryProtocol>(factory: ListItemFactoryT?) {
        gtk_column_view_column_set_factory(column_view_column_ptr, factory?.list_item_factory_ptr)
    
    }

    /// If `fixed_width` is not -1, sets the fixed width of `column`;
    /// otherwise unsets it.
    /// 
    /// Setting a fixed width overrides the automatically calculated
    /// width. Interactive resizing also sets the “fixed-width” property.
    @inlinable func set(fixedWidth: Int) {
        gtk_column_view_column_set_fixed_width(column_view_column_ptr, gint(fixedWidth))
    
    }

    /// Sets the menu model that is used to create the context menu
    /// for the column header.
    @inlinable func setHeader(menu: GIO.MenuModelRef? = nil) {
        gtk_column_view_column_set_header_menu(column_view_column_ptr, menu?.menu_model_ptr)
    
    }
    /// Sets the menu model that is used to create the context menu
    /// for the column header.
    @inlinable func setHeader<MenuModelT: GIO.MenuModelProtocol>(menu: MenuModelT?) {
        gtk_column_view_column_set_header_menu(column_view_column_ptr, menu?.menu_model_ptr)
    
    }

    /// Sets whether this column should be resizable by dragging.
    @inlinable func set(resizable: Bool) {
        gtk_column_view_column_set_resizable(column_view_column_ptr, gboolean((resizable) ? 1 : 0))
    
    }

    /// Associates a sorter with the column.
    /// 
    /// If `sorter` is `nil`, the column will not let users change
    /// the sorting by clicking on its header.
    /// 
    /// This sorter can be made active by clicking on the column
    /// header, or by calling [method`Gtk.ColumnView.sort_by_column`].
    /// 
    /// See [method`Gtk.ColumnView.get_sorter`] for the necessary steps
    /// for setting up customizable sorting for [class`Gtk.ColumnView`].
    @inlinable func set(sorter: SorterRef? = nil) {
        gtk_column_view_column_set_sorter(column_view_column_ptr, sorter?.sorter_ptr)
    
    }
    /// Associates a sorter with the column.
    /// 
    /// If `sorter` is `nil`, the column will not let users change
    /// the sorting by clicking on its header.
    /// 
    /// This sorter can be made active by clicking on the column
    /// header, or by calling [method`Gtk.ColumnView.sort_by_column`].
    /// 
    /// See [method`Gtk.ColumnView.get_sorter`] for the necessary steps
    /// for setting up customizable sorting for [class`Gtk.ColumnView`].
    @inlinable func set<SorterT: SorterProtocol>(sorter: SorterT?) {
        gtk_column_view_column_set_sorter(column_view_column_ptr, sorter?.sorter_ptr)
    
    }

    /// Sets the title of this column.
    /// 
    /// The title is displayed in the header of a `GtkColumnView`
    /// for this column and is therefore user-facing text that should
    /// be translated.
    @inlinable func set(title: UnsafePointer<CChar>? = nil) {
        gtk_column_view_column_set_title(column_view_column_ptr, title)
    
    }

    /// Sets whether this column should be visible in views.
    @inlinable func set(visible: Bool) {
        gtk_column_view_column_set_visible(column_view_column_ptr, gboolean((visible) ? 1 : 0))
    
    }
    /// Gets the column view that's currently displaying this column.
    /// 
    /// If `self` has not been added to a column view yet, `nil` is returned.
    @inlinable var columnView: ColumnViewRef! {
        /// Gets the column view that's currently displaying this column.
        /// 
        /// If `self` has not been added to a column view yet, `nil` is returned.
        get {
            let rv = ColumnViewRef(gconstpointer: gconstpointer(gtk_column_view_column_get_column_view(column_view_column_ptr)))
            return rv
        }
    }

    /// Column gets share of extra width allocated to the view.
    @inlinable var expand: Bool {
        /// Returns whether this column should expand.
        get {
            let rv = ((gtk_column_view_column_get_expand(column_view_column_ptr)) != 0)
            return rv
        }
        /// Sets the column to take available extra space.
        /// 
        /// The extra space is shared equally amongst all columns that
        /// have the expand set to `true`.
        nonmutating set {
            gtk_column_view_column_set_expand(column_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Factory for populating list items.
    @inlinable var factory: ListItemFactoryRef! {
        /// Gets the factory that's currently used to populate list items for
        /// this column.
        get {
            let rv = ListItemFactoryRef(gconstpointer: gconstpointer(gtk_column_view_column_get_factory(column_view_column_ptr)))
            return rv
        }
        /// Sets the `GtkListItemFactory` to use for populating list items for this
        /// column.
        nonmutating set {
            gtk_column_view_column_set_factory(column_view_column_ptr, UnsafeMutablePointer<GtkListItemFactory>(newValue?.list_item_factory_ptr))
        }
    }

    /// Gets the fixed width of the column.
    @inlinable var fixedWidth: Int {
        /// Gets the fixed width of the column.
        get {
            let rv = Int(gtk_column_view_column_get_fixed_width(column_view_column_ptr))
            return rv
        }
        /// If `fixed_width` is not -1, sets the fixed width of `column`;
        /// otherwise unsets it.
        /// 
        /// Setting a fixed width overrides the automatically calculated
        /// width. Interactive resizing also sets the “fixed-width” property.
        nonmutating set {
            gtk_column_view_column_set_fixed_width(column_view_column_ptr, gint(newValue))
        }
    }

    /// Gets the menu model that is used to create the context menu
    /// for the column header.
    @inlinable var headerMenu: GIO.MenuModelRef! {
        /// Gets the menu model that is used to create the context menu
        /// for the column header.
        get {
            let rv = GIO.MenuModelRef(gtk_column_view_column_get_header_menu(column_view_column_ptr))
            return rv
        }
        /// Sets the menu model that is used to create the context menu
        /// for the column header.
        nonmutating set {
            gtk_column_view_column_set_header_menu(column_view_column_ptr, UnsafeMutablePointer<GMenuModel>(newValue?.menu_model_ptr))
        }
    }

    /// Whether this column is resizable.
    @inlinable var resizable: Bool {
        /// Returns whether this column is resizable.
        get {
            let rv = ((gtk_column_view_column_get_resizable(column_view_column_ptr)) != 0)
            return rv
        }
        /// Sets whether this column should be resizable by dragging.
        nonmutating set {
            gtk_column_view_column_set_resizable(column_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Sorter for sorting items according to this column.
    @inlinable var sorter: SorterRef! {
        /// Returns the sorter that is associated with the column.
        get {
            let rv = SorterRef(gconstpointer: gconstpointer(gtk_column_view_column_get_sorter(column_view_column_ptr)))
            return rv
        }
        /// Associates a sorter with the column.
        /// 
        /// If `sorter` is `nil`, the column will not let users change
        /// the sorting by clicking on its header.
        /// 
        /// This sorter can be made active by clicking on the column
        /// header, or by calling [method`Gtk.ColumnView.sort_by_column`].
        /// 
        /// See [method`Gtk.ColumnView.get_sorter`] for the necessary steps
        /// for setting up customizable sorting for [class`Gtk.ColumnView`].
        nonmutating set {
            gtk_column_view_column_set_sorter(column_view_column_ptr, UnsafeMutablePointer<GtkSorter>(newValue?.sorter_ptr))
        }
    }

    /// Title displayed in the header.
    @inlinable var title: String! {
        /// Returns the title set with `gtk_column_view_column_set_title()`.
        get {
            let rv = gtk_column_view_column_get_title(column_view_column_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets the title of this column.
        /// 
        /// The title is displayed in the header of a `GtkColumnView`
        /// for this column and is therefore user-facing text that should
        /// be translated.
        nonmutating set {
            gtk_column_view_column_set_title(column_view_column_ptr, newValue)
        }
    }

    /// Whether this column is visible.
    @inlinable var visible: Bool {
        /// Returns whether this column is visible.
        get {
            let rv = ((gtk_column_view_column_get_visible(column_view_column_ptr)) != 0)
            return rv
        }
        /// Sets whether this column should be visible in views.
        nonmutating set {
            gtk_column_view_column_set_visible(column_view_column_ptr, gboolean((newValue) ? 1 : 0))
        }
    }


}



// MARK: - ComboBox Class

/// A `GtkComboBox` is a widget that allows the user to choose from a list of
/// valid choices.
/// 
/// ![An example GtkComboBox](combo-box.png)
/// 
/// The `GtkComboBox` displays the selected choice; when activated, the
/// `GtkComboBox` displays a popup which allows the user to make a new choice.
/// 
/// The `GtkComboBox` uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since `GtkComboBox` implements the
/// [iface`Gtk.CellLayout`] interface. The tree model holding the valid
/// choices is not restricted to a flat list, it can be a real tree, and the
/// popup will reflect the tree structure.
/// 
/// To allow the user to enter values not in the model, the
/// [property`Gtk.ComboBox:has-entry`] property allows the `GtkComboBox` to
/// contain a [class`Gtk.Entry`]. This entry can be accessed by calling
/// [method`Gtk.ComboBox.get_child`] on the combo box.
/// 
/// For a simple list of textual choices, the model-view API of `GtkComboBox`
/// can be a bit overwhelming. In this case, [class`Gtk.ComboBoxText`] offers
/// a simple alternative. Both `GtkComboBox` and `GtkComboBoxText` can contain
/// an entry.
/// 
/// ## CSS nodes
/// 
/// ```
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
/// 
/// ```
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A `GtkComboBox` with an entry has a single CSS node with name combobox.
/// It contains a box with the .linked class. That box contains an entry and
/// a button, both with the .combo class added. The button also contains another
/// node with name arrow.
/// 
/// # Accessibility
/// 
/// `GtkComboBox` uses the `GTK_ACCESSIBLE_ROLE_COMBO_BOX` role.
///
/// The `ComboBoxProtocol` protocol exposes the methods and properties of an underlying `GtkComboBox` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ComboBox`.
/// Alternatively, use `ComboBoxRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ComboBoxProtocol: WidgetProtocol, CellEditableProtocol, CellLayoutProtocol {
        /// Untyped pointer to the underlying `GtkComboBox` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkComboBox` instance.
    var combo_box_ptr: UnsafeMutablePointer<GtkComboBox>! { get }

    /// Required Initialiser for types conforming to `ComboBoxProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkComboBox` is a widget that allows the user to choose from a list of
/// valid choices.
/// 
/// ![An example GtkComboBox](combo-box.png)
/// 
/// The `GtkComboBox` displays the selected choice; when activated, the
/// `GtkComboBox` displays a popup which allows the user to make a new choice.
/// 
/// The `GtkComboBox` uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since `GtkComboBox` implements the
/// [iface`Gtk.CellLayout`] interface. The tree model holding the valid
/// choices is not restricted to a flat list, it can be a real tree, and the
/// popup will reflect the tree structure.
/// 
/// To allow the user to enter values not in the model, the
/// [property`Gtk.ComboBox:has-entry`] property allows the `GtkComboBox` to
/// contain a [class`Gtk.Entry`]. This entry can be accessed by calling
/// [method`Gtk.ComboBox.get_child`] on the combo box.
/// 
/// For a simple list of textual choices, the model-view API of `GtkComboBox`
/// can be a bit overwhelming. In this case, [class`Gtk.ComboBoxText`] offers
/// a simple alternative. Both `GtkComboBox` and `GtkComboBoxText` can contain
/// an entry.
/// 
/// ## CSS nodes
/// 
/// ```
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
/// 
/// ```
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A `GtkComboBox` with an entry has a single CSS node with name combobox.
/// It contains a box with the .linked class. That box contains an entry and
/// a button, both with the .combo class added. The button also contains another
/// node with name arrow.
/// 
/// # Accessibility
/// 
/// `GtkComboBox` uses the `GTK_ACCESSIBLE_ROLE_COMBO_BOX` role.
///
/// The `ComboBoxRef` type acts as a lightweight Swift reference to an underlying `GtkComboBox` instance.
/// It exposes methods that can operate on this data type through `ComboBoxProtocol` conformance.
/// Use `ComboBoxRef` only as an `unowned` reference to an existing `GtkComboBox` instance.
///
public struct ComboBoxRef: ComboBoxProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkComboBox` instance.
    /// For type-safe access, use the generated, typed pointer `combo_box_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ComboBoxRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkComboBox>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkComboBox>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkComboBox>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkComboBox>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ComboBoxProtocol`
    @inlinable init<T: ComboBoxProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ComboBoxProtocol>(_ other: T) -> ComboBoxRef { ComboBoxRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new empty `GtkComboBox`.
    @inlinable init() {
        let rv = gtk_combo_box_new()
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new `GtkComboBox` with a model.
    @inlinable init<TreeModelT: TreeModelProtocol>(model: TreeModelT) {
        let rv = gtk_combo_box_new_with_model(model.tree_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new empty `GtkComboBox` with an entry and a model.
    /// 
    /// See also [ctor`Gtk.ComboBox.new_with_entry`].
    @inlinable init<TreeModelT: TreeModelProtocol>(modelAndEntry model: TreeModelT) {
        let rv = gtk_combo_box_new_with_model_and_entry(model.tree_model_ptr)
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new empty `GtkComboBox` with an entry.
    /// 
    /// In order to use a combo box with entry, you need to tell it
    /// which column of the model contains the text for the entry
    /// by calling [method`Gtk.ComboBox.set_entry_text_column`].
    @inlinable static func newWithEntry() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_combo_box_new_with_entry())) else { return nil }
        return rv
    }

    /// Creates a new `GtkComboBox` with a model.
    @inlinable static func newWith<TreeModelT: TreeModelProtocol>(model: TreeModelT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_combo_box_new_with_model(model.tree_model_ptr))) else { return nil }
        return rv
    }

    /// Creates a new empty `GtkComboBox` with an entry and a model.
    /// 
    /// See also [ctor`Gtk.ComboBox.new_with_entry`].
    @inlinable static func newWith<TreeModelT: TreeModelProtocol>(modelAndEntry model: TreeModelT) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_combo_box_new_with_model_and_entry(model.tree_model_ptr))) else { return nil }
        return rv
    }
}

/// A `GtkComboBox` is a widget that allows the user to choose from a list of
/// valid choices.
/// 
/// ![An example GtkComboBox](combo-box.png)
/// 
/// The `GtkComboBox` displays the selected choice; when activated, the
/// `GtkComboBox` displays a popup which allows the user to make a new choice.
/// 
/// The `GtkComboBox` uses the model-view pattern; the list of valid choices
/// is specified in the form of a tree model, and the display of the choices
/// can be adapted to the data in the model by using cell renderers, as you
/// would in a tree view. This is possible since `GtkComboBox` implements the
/// [iface`Gtk.CellLayout`] interface. The tree model holding the valid
/// choices is not restricted to a flat list, it can be a real tree, and the
/// popup will reflect the tree structure.
/// 
/// To allow the user to enter values not in the model, the
/// [property`Gtk.ComboBox:has-entry`] property allows the `GtkComboBox` to
/// contain a [class`Gtk.Entry`]. This entry can be accessed by calling
/// [method`Gtk.ComboBox.get_child`] on the combo box.
/// 
/// For a simple list of textual choices, the model-view API of `GtkComboBox`
/// can be a bit overwhelming. In this case, [class`Gtk.ComboBoxText`] offers
/// a simple alternative. Both `GtkComboBox` and `GtkComboBoxText` can contain
/// an entry.
/// 
/// ## CSS nodes
/// 
/// ```
/// combobox
/// ├── box.linked
/// │   ╰── button.combo
/// │       ╰── box
/// │           ├── cellview
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A normal combobox contains a box with the .linked class, a button
/// with the .combo class and inside those buttons, there are a cellview and
/// an arrow.
/// 
/// ```
/// combobox
/// ├── box.linked
/// │   ├── entry.combo
/// │   ╰── button.combo
/// │       ╰── box
/// │           ╰── arrow
/// ╰── window.popup
/// ```
/// 
/// A `GtkComboBox` with an entry has a single CSS node with name combobox.
/// It contains a box with the .linked class. That box contains an entry and
/// a button, both with the .combo class added. The button also contains another
/// node with name arrow.
/// 
/// # Accessibility
/// 
/// `GtkComboBox` uses the `GTK_ACCESSIBLE_ROLE_COMBO_BOX` role.
///
/// The `ComboBox` type acts as a reference-counted owner of an underlying `GtkComboBox` instance.
/// It provides the methods that can operate on this data type through `ComboBoxProtocol` conformance.
/// Use `ComboBox` as a strong reference or owner of a `GtkComboBox` instance.
///
open class ComboBox: Widget, ComboBoxProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkComboBox>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkComboBox>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkComboBox>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkComboBox>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkComboBox`.
    /// i.e., ownership is transferred to the `ComboBox` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkComboBox>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ComboBoxProtocol`
    /// Will retain `GtkComboBox`.
    /// - Parameter other: an instance of a related type that implements `ComboBoxProtocol`
    @inlinable public init<T: ComboBoxProtocol>(comboBox other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new empty `GtkComboBox`.
    @inlinable public init() {
        let rv = gtk_combo_box_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkComboBox` with a model.
    @inlinable public init<TreeModelT: TreeModelProtocol>(model: TreeModelT) {
        let rv = gtk_combo_box_new_with_model(model.tree_model_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new empty `GtkComboBox` with an entry and a model.
    /// 
    /// See also [ctor`Gtk.ComboBox.new_with_entry`].
    @inlinable public init<TreeModelT: TreeModelProtocol>(modelAndEntry model: TreeModelT) {
        let rv = gtk_combo_box_new_with_model_and_entry(model.tree_model_ptr)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new empty `GtkComboBox` with an entry.
    /// 
    /// In order to use a combo box with entry, you need to tell it
    /// which column of the model contains the text for the entry
    /// by calling [method`Gtk.ComboBox.set_entry_text_column`].
    @inlinable public static func newWithEntry() -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_combo_box_new_with_entry())) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

    /// Creates a new `GtkComboBox` with a model.
    @inlinable public static func newWith<TreeModelT: TreeModelProtocol>(model: TreeModelT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_combo_box_new_with_model(model.tree_model_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

    /// Creates a new empty `GtkComboBox` with an entry and a model.
    /// 
    /// See also [ctor`Gtk.ComboBox.new_with_entry`].
    @inlinable public static func newWith<TreeModelT: TreeModelProtocol>(modelAndEntry model: TreeModelT) -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_combo_box_new_with_model_and_entry(model.tree_model_ptr))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum ComboBoxPropertyName: String, PropertyNameProtocol {
    /// The item which is currently active.
    /// 
    /// If the model is a non-flat treemodel, and the active item is not an
    /// immediate child of the root of the tree, this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
    /// [struct`Gtk.TreePath`] of the active item.
    case active = "active"
    /// The value of the ID column of the active row.
    case activeId = "active-id"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case buttonSensitivity = "button-sensitivity"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// The model column to associate with strings from the entry.
    /// 
    /// This is property only relevant if the combo was created with
    /// [property`Gtk.ComboBox:has-entry`] is `true`.
    case entryTextColumn = "entry-text-column"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the combo box has an entry.
    case hasEntry = "has-entry"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// The `has-frame` property controls whether a frame is drawn around the entry.
    case hasFrame = "has-frame"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The model column that provides string IDs for the values
    /// in the model, if != -1.
    case idColumn = "id-column"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The model from which the combo box takes its values.
    case model = "model"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case popupFixedWidth = "popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// 
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup-shown`.
    case popupShown = "popup-shown"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ComboBoxProtocol {
    /// Bind a `ComboBoxPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ComboBoxPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ComboBox property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ComboBoxPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ComboBox property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ComboBoxPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ComboBoxSignalName: String, SignalNameProtocol {
    /// Emitted when the active item is changed.
    /// 
    /// The can be due to the user selecting a different item from the list,
    /// or due to a call to [method`Gtk.ComboBox.set_active_iter`]. It will
    /// also be emitted while typing into the entry of a combo box with an entry.
    case changed = "changed"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted to allow changing how the text in a combo box's entry is displayed.
    /// 
    /// See [property`Gtk.ComboBox:has-entry`].
    /// 
    /// Connect a signal handler which returns an allocated string representing
    /// `path`. That string will then be used to set the text in the combo box's
    /// entry. The default signal handler uses the text from the
    /// [property`Gtk.ComboBox:entry-text-column`] model column.
    /// 
    /// Here's an example signal handler which fetches data from the model and
    /// displays it in the entry.
    /// ```c
    /// static char *
    /// format_entry_text_callback (GtkComboBox *combo,
    ///                             const char *path,
    ///                             gpointer     user_data)
    /// {
    ///   GtkTreeIter iter;
    ///   GtkTreeModel model;
    ///   double       value;
    /// 
    ///   model = gtk_combo_box_get_model (combo);
    /// 
    ///   gtk_tree_model_get_iter_from_string (model, &iter, path);
    ///   gtk_tree_model_get (model, &iter,
    ///                       THE_DOUBLE_VALUE_COLUMN, &value,
    ///                       -1);
    /// 
    ///   return g_strdup_printf ("`g`", value);
    /// }
    /// ```
    case formatEntryText = "format-entry-text"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted to move the active selection.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    case moveActive = "move-active"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted to popdown the combo box list.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are Alt+Up and Escape.
    case popdown = "popdown"
    /// Emitted to popup the combo box list.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is Alt+Down.
    case popup = "popup"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The item which is currently active.
    /// 
    /// If the model is a non-flat treemodel, and the active item is not an
    /// immediate child of the root of the tree, this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
    /// [struct`Gtk.TreePath`] of the active item.
    case notifyActive = "notify::active"
    /// The value of the ID column of the active row.
    case notifyActiveId = "notify::active-id"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case notifyButtonSensitivity = "notify::button-sensitivity"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// The model column to associate with strings from the entry.
    /// 
    /// This is property only relevant if the combo was created with
    /// [property`Gtk.ComboBox:has-entry`] is `true`.
    case notifyEntryTextColumn = "notify::entry-text-column"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the combo box has an entry.
    case notifyHasEntry = "notify::has-entry"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// The `has-frame` property controls whether a frame is drawn around the entry.
    case notifyHasFrame = "notify::has-frame"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The model column that provides string IDs for the values
    /// in the model, if != -1.
    case notifyIdColumn = "notify::id-column"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The model from which the combo box takes its values.
    case notifyModel = "notify::model"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case notifyPopupFixedWidth = "notify::popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// 
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup-shown`.
    case notifyPopupShown = "notify::popup-shown"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ComboBox signals
public extension ComboBoxProtocol {
    /// Connect a Swift signal handler to the given, typed `ComboBoxSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ComboBoxSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `ComboBoxSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: ComboBoxSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when the active item is changed.
    /// 
    /// The can be due to the user selecting a different item from the list,
    /// or due to a call to [method`Gtk.ComboBox.set_active_iter`]. It will
    /// also be emitted while typing into the entry of a combo box with an entry.
    /// - Note: This represents the underlying `changed` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `changed` signal is emitted
    @discardableResult @inlinable func onChanged(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ComboBoxRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .changed,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `changed` signal for using the `connect(signal:)` methods
    static var changedSignal: ComboBoxSignalName { .changed }
    
    /// Emitted to allow changing how the text in a combo box's entry is displayed.
    /// 
    /// See [property`Gtk.ComboBox:has-entry`].
    /// 
    /// Connect a signal handler which returns an allocated string representing
    /// `path`. That string will then be used to set the text in the combo box's
    /// entry. The default signal handler uses the text from the
    /// [property`Gtk.ComboBox:entry-text-column`] model column.
    /// 
    /// Here's an example signal handler which fetches data from the model and
    /// displays it in the entry.
    /// ```c
    /// static char *
    /// format_entry_text_callback (GtkComboBox *combo,
    ///                             const char *path,
    ///                             gpointer     user_data)
    /// {
    ///   GtkTreeIter iter;
    ///   GtkTreeModel model;
    ///   double       value;
    /// 
    ///   model = gtk_combo_box_get_model (combo);
    /// 
    ///   gtk_tree_model_get_iter_from_string (model, &iter, path);
    ///   gtk_tree_model_get (model, &iter,
    ///                       THE_DOUBLE_VALUE_COLUMN, &value,
    ///                       -1);
    /// 
    ///   return g_strdup_printf ("`g`", value);
    /// }
    /// ```
    /// - Note: This represents the underlying `format-entry-text` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter path: the [struct`Gtk.TreePath`] string from the combo box's current model   to format text for
    /// - Parameter handler: a newly allocated string representing `path`   for the current `GtkComboBox` model.
    /// Run the given callback whenever the `formatEntryText` signal is emitted
    @discardableResult @inlinable func onFormatEntryText(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ path: String) -> String ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, String, String>
        let cCallback: @convention(c) (gpointer, UnsafeMutablePointer<gchar>?, gpointer) -> UnsafeMutablePointer<gchar>? = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(ComboBoxRef(raw: unownedSelf), arg1.map({ String(cString: $0) })!)
                let length = output.utf8CString.count
                let buffer = UnsafeMutablePointer<gchar>.allocate(capacity: length)
                buffer.initialize(from: output, count: length)
                return buffer
        }
        return connect(
            signal: .formatEntryText,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `format-entry-text` signal for using the `connect(signal:)` methods
    static var formatEntryTextSignal: ComboBoxSignalName { .formatEntryText }
    
    /// Emitted to move the active selection.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// - Note: This represents the underlying `move-active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter scrollType: a `GtkScrollType`
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `moveActive` signal is emitted
    @discardableResult @inlinable func onMoveActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ scrollType: ScrollType) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, ScrollType, Void>
        let cCallback: @convention(c) (gpointer, UInt32, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf), ScrollType(arg1))
            return output
        }
        return connect(
            signal: .moveActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `move-active` signal for using the `connect(signal:)` methods
    static var moveActiveSignal: ComboBoxSignalName { .moveActive }
    
    /// Emitted to popdown the combo box list.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are Alt+Up and Escape.
    /// - Note: This represents the underlying `popdown` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `popdown` signal is emitted
    @discardableResult @inlinable func onPopdown(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef) -> Bool ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ComboBoxRef, Bool>
        let cCallback: @convention(c) (gpointer, gpointer) -> gboolean = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output = holder.call(ComboBoxRef(raw: unownedSelf))
            return gboolean((output) ? 1 : 0)
        }
        return connect(
            signal: .popdown,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `popdown` signal for using the `connect(signal:)` methods
    static var popdownSignal: ComboBoxSignalName { .popdown }
    
    /// Emitted to popup the combo box list.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is Alt+Down.
    /// - Note: This represents the underlying `popup` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `popup` signal is emitted
    @discardableResult @inlinable func onPopup(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<ComboBoxRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .popup,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `popup` signal for using the `connect(signal:)` methods
    static var popupSignal: ComboBoxSignalName { .popup }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActive` signal is emitted
    @discardableResult @inlinable func onNotifyActive(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyActive,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active` signal for using the `connect(signal:)` methods
    static var notifyActiveSignal: ComboBoxSignalName { .notifyActive }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::active-id` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyActiveId` signal is emitted
    @discardableResult @inlinable func onNotifyActiveId(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyActiveId,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::active-id` signal for using the `connect(signal:)` methods
    static var notifyActiveIdSignal: ComboBoxSignalName { .notifyActiveId }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::button-sensitivity` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyButtonSensitivity` signal is emitted
    @discardableResult @inlinable func onNotifyButtonSensitivity(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyButtonSensitivity,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::button-sensitivity` signal for using the `connect(signal:)` methods
    static var notifyButtonSensitivitySignal: ComboBoxSignalName { .notifyButtonSensitivity }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::child` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyChild` signal is emitted
    @discardableResult @inlinable func onNotifyChild(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyChild,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::child` signal for using the `connect(signal:)` methods
    static var notifyChildSignal: ComboBoxSignalName { .notifyChild }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::entry-text-column` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyEntryTextColumn` signal is emitted
    @discardableResult @inlinable func onNotifyEntryTextColumn(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyEntryTextColumn,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::entry-text-column` signal for using the `connect(signal:)` methods
    static var notifyEntryTextColumnSignal: ComboBoxSignalName { .notifyEntryTextColumn }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::has-entry` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHasEntry` signal is emitted
    @discardableResult @inlinable func onNotifyHasEntry(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyHasEntry,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::has-entry` signal for using the `connect(signal:)` methods
    static var notifyHasEntrySignal: ComboBoxSignalName { .notifyHasEntry }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::has-frame` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyHasFrame` signal is emitted
    @discardableResult @inlinable func onNotifyHasFrame(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyHasFrame,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::has-frame` signal for using the `connect(signal:)` methods
    static var notifyHasFrameSignal: ComboBoxSignalName { .notifyHasFrame }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::id-column` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyIdColumn` signal is emitted
    @discardableResult @inlinable func onNotifyIdColumn(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyIdColumn,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::id-column` signal for using the `connect(signal:)` methods
    static var notifyIdColumnSignal: ComboBoxSignalName { .notifyIdColumn }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::model` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyModel` signal is emitted
    @discardableResult @inlinable func onNotifyModel(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyModel,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::model` signal for using the `connect(signal:)` methods
    static var notifyModelSignal: ComboBoxSignalName { .notifyModel }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::popup-fixed-width` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPopupFixedWidth` signal is emitted
    @discardableResult @inlinable func onNotifyPopupFixedWidth(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPopupFixedWidth,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::popup-fixed-width` signal for using the `connect(signal:)` methods
    static var notifyPopupFixedWidthSignal: ComboBoxSignalName { .notifyPopupFixedWidth }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::popup-shown` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyPopupShown` signal is emitted
    @discardableResult @inlinable func onNotifyPopupShown(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: ComboBoxRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<ComboBoxRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(ComboBoxRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyPopupShown,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::popup-shown` signal for using the `connect(signal:)` methods
    static var notifyPopupShownSignal: ComboBoxSignalName { .notifyPopupShown }
    
}

// MARK: ComboBox Class: ComboBoxProtocol extension (methods and fields)
public extension ComboBoxProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkComboBox` instance.
    @inlinable var combo_box_ptr: UnsafeMutablePointer<GtkComboBox>! { return ptr?.assumingMemoryBound(to: GtkComboBox.self) }

    /// Returns the index of the currently active item.
    /// 
    /// If the model is a non-flat treemodel, and the active item is not
    /// an immediate child of the root of the tree, this function returns
    /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
    /// [struct`Gtk.TreePath`] of the active item.
    @inlinable func getActive() -> Int {
        let rv = Int(gtk_combo_box_get_active(combo_box_ptr))
        return rv
    }

    /// Returns the ID of the active row of `combo_box`.
    /// 
    /// This value is taken from the active row and the column specified
    /// by the [property`Gtk.ComboBox:id-column`] property of `combo_box`
    /// (see [method`Gtk.ComboBox.set_id_column`]).
    /// 
    /// The returned value is an interned string which means that you can
    /// compare the pointer by value to other interned strings and that you
    /// must not free it.
    /// 
    /// If the [property`Gtk.ComboBox:id-column`] property of `combo_box` is
    /// not set, or if no row is active, or if the active row has a `nil`
    /// ID value, then `nil` is returned.
    @inlinable func getActiveId() -> String! {
        let rv = gtk_combo_box_get_active_id(combo_box_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Sets `iter` to point to the currently active item.
    /// 
    /// If no item is active, `iter` is left unchanged.
    @inlinable func getActive<TreeIterT: TreeIterProtocol>(iter: TreeIterT) -> Bool {
        let rv = ((gtk_combo_box_get_active_iter(combo_box_ptr, iter.tree_iter_ptr)) != 0)
        return rv
    }

    /// Returns whether the combo box sets the dropdown button
    /// sensitive or not when there are no items in the model.
    @inlinable func getButtonSensitivity() -> GtkSensitivityType {
        let rv = gtk_combo_box_get_button_sensitivity(combo_box_ptr)
        return rv
    }

    /// Gets the child widget of `combo_box`.
    @inlinable func getChild() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_combo_box_get_child(combo_box_ptr))) else { return nil }
        return rv
    }

    /// Returns the column which `combo_box` is using to get the strings
    /// from to display in the internal entry.
    @inlinable func getEntryTextColumn() -> Int {
        let rv = Int(gtk_combo_box_get_entry_text_column(combo_box_ptr))
        return rv
    }

    /// Returns whether the combo box has an entry.
    @inlinable func getHasEntry() -> Bool {
        let rv = ((gtk_combo_box_get_has_entry(combo_box_ptr)) != 0)
        return rv
    }

    /// Returns the column which `combo_box` is using to get string IDs
    /// for values from.
    @inlinable func getIdColumn() -> Int {
        let rv = Int(gtk_combo_box_get_id_column(combo_box_ptr))
        return rv
    }

    /// Returns the `GtkTreeModel` of `combo_box`.
    @inlinable func getModel() -> TreeModelRef! {
        let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_combo_box_get_model(combo_box_ptr)))
        return rv
    }

    /// Gets whether the popup uses a fixed width.
    @inlinable func getPopupFixedWidth() -> Bool {
        let rv = ((gtk_combo_box_get_popup_fixed_width(combo_box_ptr)) != 0)
        return rv
    }

    /// Returns the current row separator function.
    @inlinable func getRowSeparatorFunc() -> GtkTreeViewRowSeparatorFunc! {
        let rv = gtk_combo_box_get_row_separator_func(combo_box_ptr)
        return rv
    }

    /// Hides the menu or dropdown list of `combo_box`.
    /// 
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    @inlinable func popdown() {
        gtk_combo_box_popdown(combo_box_ptr)
    
    }

    /// Pops up the menu or dropdown list of `combo_box`.
    /// 
    /// This function is mostly intended for use by accessibility technologies;
    /// applications should have little use for it.
    /// 
    /// Before calling this, `combo_box` must be mapped, or nothing will happen.
    @inlinable func popup() {
        gtk_combo_box_popup(combo_box_ptr)
    
    }

    /// Pops up the menu of `combo_box`.
    /// 
    /// Note that currently this does not do anything with the device, as it was
    /// previously only used for list-mode combo boxes, and those were removed
    /// in GTK 4. However, it is retained in case similar functionality is added
    /// back later.
    @inlinable func popupFor<DeviceT: Gdk.DeviceProtocol>(device: DeviceT) {
        gtk_combo_box_popup_for_device(combo_box_ptr, device.device_ptr)
    
    }

    /// Sets the active item of `combo_box` to be the item at `index`.
    @inlinable func setActive(index: Int) {
        gtk_combo_box_set_active(combo_box_ptr, gint(index))
    
    }

    /// Changes the active row of `combo_box` to the one that has an ID equal to
    /// `active_id`.
    /// 
    /// If `active_id` is `nil`, the active row is unset. Rows having
    /// a `nil` ID string cannot be made active by this function.
    /// 
    /// If the [property`Gtk.ComboBox:id-column`] property of `combo_box` is
    /// unset or if no row has the given ID then the function does nothing
    /// and returns `false`.
    @inlinable func set(activeId: UnsafePointer<CChar>? = nil) -> Bool {
        let rv = ((gtk_combo_box_set_active_id(combo_box_ptr, activeId)) != 0)
        return rv
    }

    /// Sets the current active item to be the one referenced by `iter`.
    /// 
    /// If `iter` is `nil`, the active item is unset.
    @inlinable func setActive(iter: TreeIterRef? = nil) {
        gtk_combo_box_set_active_iter(combo_box_ptr, iter?.tree_iter_ptr)
    
    }
    /// Sets the current active item to be the one referenced by `iter`.
    /// 
    /// If `iter` is `nil`, the active item is unset.
    @inlinable func setActive<TreeIterT: TreeIterProtocol>(iter: TreeIterT?) {
        gtk_combo_box_set_active_iter(combo_box_ptr, iter?.tree_iter_ptr)
    
    }

    /// Sets whether the dropdown button of the combo box should update
    /// its sensitivity depending on the model contents.
    @inlinable func setButton(sensitivity: GtkSensitivityType) {
        gtk_combo_box_set_button_sensitivity(combo_box_ptr, sensitivity)
    
    }

    /// Sets the child widget of `combo_box`.
    @inlinable func set(child: WidgetRef? = nil) {
        gtk_combo_box_set_child(combo_box_ptr, child?.widget_ptr)
    
    }
    /// Sets the child widget of `combo_box`.
    @inlinable func set<WidgetT: WidgetProtocol>(child: WidgetT?) {
        gtk_combo_box_set_child(combo_box_ptr, child?.widget_ptr)
    
    }

    /// Sets the model column which `combo_box` should use to get strings
    /// from to be `text_column`.
    /// 
    /// For this column no separate
    /// [class`Gtk.CellRenderer`] is needed.
    /// 
    /// The column `text_column` in the model of `combo_box` must be of
    /// type `G_TYPE_STRING`.
    /// 
    /// This is only relevant if `combo_box` has been created with
    /// [property`Gtk.ComboBox:has-entry`] as `true`.
    @inlinable func setEntry(textColumn: Int) {
        gtk_combo_box_set_entry_text_column(combo_box_ptr, gint(textColumn))
    
    }

    /// Sets the model column which `combo_box` should use to get string IDs
    /// for values from.
    /// 
    /// The column `id_column` in the model of `combo_box` must be of type
    /// `G_TYPE_STRING`.
    @inlinable func set(idColumn: Int) {
        gtk_combo_box_set_id_column(combo_box_ptr, gint(idColumn))
    
    }

    /// Sets the model used by `combo_box` to be `model`.
    /// 
    /// Will unset a previously set model (if applicable). If model is `nil`,
    /// then it will unset the model.
    /// 
    /// Note that this function does not clear the cell renderers, you have to
    /// call [method`Gtk.CellLayout.clear`] yourself if you need to set up different
    /// cell renderers for the new model.
    @inlinable func set(model: TreeModelRef? = nil) {
        gtk_combo_box_set_model(combo_box_ptr, model?.tree_model_ptr)
    
    }
    /// Sets the model used by `combo_box` to be `model`.
    /// 
    /// Will unset a previously set model (if applicable). If model is `nil`,
    /// then it will unset the model.
    /// 
    /// Note that this function does not clear the cell renderers, you have to
    /// call [method`Gtk.CellLayout.clear`] yourself if you need to set up different
    /// cell renderers for the new model.
    @inlinable func set<TreeModelT: TreeModelProtocol>(model: TreeModelT?) {
        gtk_combo_box_set_model(combo_box_ptr, model?.tree_model_ptr)
    
    }

    /// Specifies whether the popup’s width should be a fixed width.
    /// 
    /// If `fixed` is `true`, the popup's width is set to match the
    /// allocated width of the combo box.
    @inlinable func setPopupFixedWidth(fixed: Bool) {
        gtk_combo_box_set_popup_fixed_width(combo_box_ptr, gboolean((fixed) ? 1 : 0))
    
    }

    /// Sets the row separator function, which is used to determine
    /// whether a row should be drawn as a separator.
    /// 
    /// If the row separator function is `nil`, no separators are drawn.
    /// This is the default value.
    @inlinable func setRowSeparatorFunc(`func`: GtkTreeViewRowSeparatorFunc? = nil, data: gpointer! = nil, destroy: GDestroyNotify? = nil) {
        gtk_combo_box_set_row_separator_func(combo_box_ptr, `func`, data, destroy)
    
    }
    /// The item which is currently active.
    /// 
    /// If the model is a non-flat treemodel, and the active item is not an
    /// immediate child of the root of the tree, this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
    /// [struct`Gtk.TreePath`] of the active item.
    @inlinable var active: Int {
        /// Returns the index of the currently active item.
        /// 
        /// If the model is a non-flat treemodel, and the active item is not
        /// an immediate child of the root of the tree, this function returns
        /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
        /// [struct`Gtk.TreePath`] of the active item.
        get {
            let rv = Int(gtk_combo_box_get_active(combo_box_ptr))
            return rv
        }
        /// Sets the active item of `combo_box` to be the item at `index`.
        nonmutating set {
            gtk_combo_box_set_active(combo_box_ptr, gint(newValue))
        }
    }

    /// Returns the ID of the active row of `combo_box`.
    /// 
    /// This value is taken from the active row and the column specified
    /// by the [property`Gtk.ComboBox:id-column`] property of `combo_box`
    /// (see [method`Gtk.ComboBox.set_id_column`]).
    /// 
    /// The returned value is an interned string which means that you can
    /// compare the pointer by value to other interned strings and that you
    /// must not free it.
    /// 
    /// If the [property`Gtk.ComboBox:id-column`] property of `combo_box` is
    /// not set, or if no row is active, or if the active row has a `nil`
    /// ID value, then `nil` is returned.
    @inlinable var activeId: String! {
        /// Returns the ID of the active row of `combo_box`.
        /// 
        /// This value is taken from the active row and the column specified
        /// by the [property`Gtk.ComboBox:id-column`] property of `combo_box`
        /// (see [method`Gtk.ComboBox.set_id_column`]).
        /// 
        /// The returned value is an interned string which means that you can
        /// compare the pointer by value to other interned strings and that you
        /// must not free it.
        /// 
        /// If the [property`Gtk.ComboBox:id-column`] property of `combo_box` is
        /// not set, or if no row is active, or if the active row has a `nil`
        /// ID value, then `nil` is returned.
        get {
            let rv = gtk_combo_box_get_active_id(combo_box_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Changes the active row of `combo_box` to the one that has an ID equal to
        /// `active_id`.
        /// 
        /// If `active_id` is `nil`, the active row is unset. Rows having
        /// a `nil` ID string cannot be made active by this function.
        /// 
        /// If the [property`Gtk.ComboBox:id-column`] property of `combo_box` is
        /// unset or if no row has the given ID then the function does nothing
        /// and returns `false`.
        nonmutating set {
            _ = gtk_combo_box_set_active_id(combo_box_ptr, newValue)
        }
    }

    /// Returns whether the combo box sets the dropdown button
    /// sensitive or not when there are no items in the model.
    @inlinable var buttonSensitivity: GtkSensitivityType {
        /// Returns whether the combo box sets the dropdown button
        /// sensitive or not when there are no items in the model.
        get {
            let rv = gtk_combo_box_get_button_sensitivity(combo_box_ptr)
            return rv
        }
        /// Sets whether the dropdown button of the combo box should update
        /// its sensitivity depending on the model contents.
        nonmutating set {
            gtk_combo_box_set_button_sensitivity(combo_box_ptr, newValue)
        }
    }

    /// The child widget.
    @inlinable var child: WidgetRef! {
        /// Gets the child widget of `combo_box`.
        get {
            guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_combo_box_get_child(combo_box_ptr))) else { return nil }
            return rv
        }
        /// Sets the child widget of `combo_box`.
        nonmutating set {
            gtk_combo_box_set_child(combo_box_ptr, UnsafeMutablePointer<GtkWidget>(newValue?.widget_ptr))
        }
    }

    /// Returns the column which `combo_box` is using to get the strings
    /// from to display in the internal entry.
    @inlinable var entryTextColumn: Int {
        /// Returns the column which `combo_box` is using to get the strings
        /// from to display in the internal entry.
        get {
            let rv = Int(gtk_combo_box_get_entry_text_column(combo_box_ptr))
            return rv
        }
        /// Sets the model column which `combo_box` should use to get strings
        /// from to be `text_column`.
        /// 
        /// For this column no separate
        /// [class`Gtk.CellRenderer`] is needed.
        /// 
        /// The column `text_column` in the model of `combo_box` must be of
        /// type `G_TYPE_STRING`.
        /// 
        /// This is only relevant if `combo_box` has been created with
        /// [property`Gtk.ComboBox:has-entry`] as `true`.
        nonmutating set {
            gtk_combo_box_set_entry_text_column(combo_box_ptr, gint(newValue))
        }
    }

    /// Returns whether the combo box has an entry.
    @inlinable var hasEntry: Bool {
        /// Returns whether the combo box has an entry.
        get {
            let rv = ((gtk_combo_box_get_has_entry(combo_box_ptr)) != 0)
            return rv
        }
    }

    /// Returns the column which `combo_box` is using to get string IDs
    /// for values from.
    @inlinable var idColumn: Int {
        /// Returns the column which `combo_box` is using to get string IDs
        /// for values from.
        get {
            let rv = Int(gtk_combo_box_get_id_column(combo_box_ptr))
            return rv
        }
        /// Sets the model column which `combo_box` should use to get string IDs
        /// for values from.
        /// 
        /// The column `id_column` in the model of `combo_box` must be of type
        /// `G_TYPE_STRING`.
        nonmutating set {
            gtk_combo_box_set_id_column(combo_box_ptr, gint(newValue))
        }
    }

    /// The model from which the combo box takes its values.
    @inlinable var model: TreeModelRef! {
        /// Returns the `GtkTreeModel` of `combo_box`.
        get {
            let rv = TreeModelRef(gconstpointer: gconstpointer(gtk_combo_box_get_model(combo_box_ptr)))
            return rv
        }
        /// Sets the model used by `combo_box` to be `model`.
        /// 
        /// Will unset a previously set model (if applicable). If model is `nil`,
        /// then it will unset the model.
        /// 
        /// Note that this function does not clear the cell renderers, you have to
        /// call [method`Gtk.CellLayout.clear`] yourself if you need to set up different
        /// cell renderers for the new model.
        nonmutating set {
            gtk_combo_box_set_model(combo_box_ptr, UnsafeMutablePointer<GtkTreeModel>(newValue?.tree_model_ptr))
        }
    }

    /// Gets whether the popup uses a fixed width.
    @inlinable var popupFixedWidth: Bool {
        /// Gets whether the popup uses a fixed width.
        get {
            let rv = ((gtk_combo_box_get_popup_fixed_width(combo_box_ptr)) != 0)
            return rv
        }
        /// Specifies whether the popup’s width should be a fixed width.
        /// 
        /// If `fixed` is `true`, the popup's width is set to match the
        /// allocated width of the combo box.
        nonmutating set {
            gtk_combo_box_set_popup_fixed_width(combo_box_ptr, gboolean((newValue) ? 1 : 0))
        }
    }

    /// Returns the current row separator function.
    @inlinable var rowSeparatorFunc: GtkTreeViewRowSeparatorFunc! {
        /// Returns the current row separator function.
        get {
            let rv = gtk_combo_box_get_row_separator_func(combo_box_ptr)
            return rv
        }
    }

    @inlinable var parentInstance: GtkWidget {
        get {
            let rv = combo_box_ptr.pointee.parent_instance
            return rv
        }
    }

}



// MARK: - ComboBoxText Class

/// A `GtkComboBoxText` is a simple variant of `GtkComboBox` for text-only
/// use cases.
/// 
/// ![An example GtkComboBoxText](combo-box-text.png)
/// 
/// `GtkComboBoxText` hides the model-view complexity of `GtkComboBox`.
/// 
/// To create a `GtkComboBoxText`, use [ctor`Gtk.ComboBoxText.new`] or
/// [ctor`Gtk.ComboBoxText.new_with_entry`].
/// 
/// You can add items to a `GtkComboBoxText` with
/// [method`Gtk.ComboBoxText.append_text`],
/// [method`Gtk.ComboBoxText.insert_text`] or
/// [method`Gtk.ComboBoxText.prepend_text`] and remove options with
/// [method`Gtk.ComboBoxText.remove`].
/// 
/// If the `GtkComboBoxText` contains an entry (via the
/// [property`Gtk.ComboBox:has-entry`] property), its contents can be retrieved
/// using [method`Gtk.ComboBoxText.get_active_text`].
/// 
/// You should not call [method`Gtk.ComboBox.set_model`] or attempt to pack more
/// cells into this combo box via its [iface`Gtk.CellLayout`] interface.
/// 
/// # GtkComboBoxText as GtkBuildable
/// 
/// The `GtkComboBoxText` implementation of the `GtkBuildable` interface supports
/// adding items directly using the &lt;items&gt; element and specifying &lt;item&gt;
/// elements for each item. Each &lt;item&gt; element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying `GtkComboBoxText` items:
/// ```xml
/// &lt;object class="GtkComboBoxText"&gt;
///   &lt;items&gt;
///     &lt;item translatable="yes" id="factory"&gt;Factory&lt;/item&gt;
///     &lt;item translatable="yes" id="home"&gt;Home&lt;/item&gt;
///     &lt;item translatable="yes" id="subway"&gt;Subway&lt;/item&gt;
///   &lt;/items&gt;
/// &lt;/object&gt;
/// ```
/// 
/// # CSS nodes
/// 
/// ```
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
/// 
/// `GtkComboBoxText` has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
///
/// The `ComboBoxTextProtocol` protocol exposes the methods and properties of an underlying `GtkComboBoxText` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ComboBoxText`.
/// Alternatively, use `ComboBoxTextRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ComboBoxTextProtocol: ComboBoxProtocol {
        /// Untyped pointer to the underlying `GtkComboBoxText` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkComboBoxText` instance.
    var combo_box_text_ptr: UnsafeMutablePointer<GtkComboBoxText>! { get }

    /// Required Initialiser for types conforming to `ComboBoxTextProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkComboBoxText` is a simple variant of `GtkComboBox` for text-only
/// use cases.
/// 
/// ![An example GtkComboBoxText](combo-box-text.png)
/// 
/// `GtkComboBoxText` hides the model-view complexity of `GtkComboBox`.
/// 
/// To create a `GtkComboBoxText`, use [ctor`Gtk.ComboBoxText.new`] or
/// [ctor`Gtk.ComboBoxText.new_with_entry`].
/// 
/// You can add items to a `GtkComboBoxText` with
/// [method`Gtk.ComboBoxText.append_text`],
/// [method`Gtk.ComboBoxText.insert_text`] or
/// [method`Gtk.ComboBoxText.prepend_text`] and remove options with
/// [method`Gtk.ComboBoxText.remove`].
/// 
/// If the `GtkComboBoxText` contains an entry (via the
/// [property`Gtk.ComboBox:has-entry`] property), its contents can be retrieved
/// using [method`Gtk.ComboBoxText.get_active_text`].
/// 
/// You should not call [method`Gtk.ComboBox.set_model`] or attempt to pack more
/// cells into this combo box via its [iface`Gtk.CellLayout`] interface.
/// 
/// # GtkComboBoxText as GtkBuildable
/// 
/// The `GtkComboBoxText` implementation of the `GtkBuildable` interface supports
/// adding items directly using the &lt;items&gt; element and specifying &lt;item&gt;
/// elements for each item. Each &lt;item&gt; element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying `GtkComboBoxText` items:
/// ```xml
/// &lt;object class="GtkComboBoxText"&gt;
///   &lt;items&gt;
///     &lt;item translatable="yes" id="factory"&gt;Factory&lt;/item&gt;
///     &lt;item translatable="yes" id="home"&gt;Home&lt;/item&gt;
///     &lt;item translatable="yes" id="subway"&gt;Subway&lt;/item&gt;
///   &lt;/items&gt;
/// &lt;/object&gt;
/// ```
/// 
/// # CSS nodes
/// 
/// ```
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
/// 
/// `GtkComboBoxText` has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
///
/// The `ComboBoxTextRef` type acts as a lightweight Swift reference to an underlying `GtkComboBoxText` instance.
/// It exposes methods that can operate on this data type through `ComboBoxTextProtocol` conformance.
/// Use `ComboBoxTextRef` only as an `unowned` reference to an existing `GtkComboBoxText` instance.
///
public struct ComboBoxTextRef: ComboBoxTextProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkComboBoxText` instance.
    /// For type-safe access, use the generated, typed pointer `combo_box_text_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ComboBoxTextRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkComboBoxText>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkComboBoxText>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkComboBoxText>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkComboBoxText>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ComboBoxTextProtocol`
    @inlinable init<T: ComboBoxTextProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ComboBoxTextProtocol>(_ other: T) -> ComboBoxTextRef { ComboBoxTextRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkComboBoxText`.
    @inlinable init() {
        let rv = gtk_combo_box_text_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new `GtkComboBoxText` with an entry.
    @inlinable static func comboBoxTextNewWithEntry() -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_combo_box_text_new_with_entry())) else { return nil }
        return rv
    }
}

/// A `GtkComboBoxText` is a simple variant of `GtkComboBox` for text-only
/// use cases.
/// 
/// ![An example GtkComboBoxText](combo-box-text.png)
/// 
/// `GtkComboBoxText` hides the model-view complexity of `GtkComboBox`.
/// 
/// To create a `GtkComboBoxText`, use [ctor`Gtk.ComboBoxText.new`] or
/// [ctor`Gtk.ComboBoxText.new_with_entry`].
/// 
/// You can add items to a `GtkComboBoxText` with
/// [method`Gtk.ComboBoxText.append_text`],
/// [method`Gtk.ComboBoxText.insert_text`] or
/// [method`Gtk.ComboBoxText.prepend_text`] and remove options with
/// [method`Gtk.ComboBoxText.remove`].
/// 
/// If the `GtkComboBoxText` contains an entry (via the
/// [property`Gtk.ComboBox:has-entry`] property), its contents can be retrieved
/// using [method`Gtk.ComboBoxText.get_active_text`].
/// 
/// You should not call [method`Gtk.ComboBox.set_model`] or attempt to pack more
/// cells into this combo box via its [iface`Gtk.CellLayout`] interface.
/// 
/// # GtkComboBoxText as GtkBuildable
/// 
/// The `GtkComboBoxText` implementation of the `GtkBuildable` interface supports
/// adding items directly using the &lt;items&gt; element and specifying &lt;item&gt;
/// elements for each item. Each &lt;item&gt; element can specify the “id”
/// corresponding to the appended text and also supports the regular
/// translation attributes “translatable”, “context” and “comments”.
/// 
/// Here is a UI definition fragment specifying `GtkComboBoxText` items:
/// ```xml
/// &lt;object class="GtkComboBoxText"&gt;
///   &lt;items&gt;
///     &lt;item translatable="yes" id="factory"&gt;Factory&lt;/item&gt;
///     &lt;item translatable="yes" id="home"&gt;Home&lt;/item&gt;
///     &lt;item translatable="yes" id="subway"&gt;Subway&lt;/item&gt;
///   &lt;/items&gt;
/// &lt;/object&gt;
/// ```
/// 
/// # CSS nodes
/// 
/// ```
/// combobox
/// ╰── box.linked
///     ├── entry.combo
///     ├── button.combo
///     ╰── window.popup
/// ```
/// 
/// `GtkComboBoxText` has a single CSS node with name combobox. It adds
/// the style class .combo to the main CSS nodes of its entry and button
/// children, and the .linked class to the node of its internal box.
///
/// The `ComboBoxText` type acts as a reference-counted owner of an underlying `GtkComboBoxText` instance.
/// It provides the methods that can operate on this data type through `ComboBoxTextProtocol` conformance.
/// Use `ComboBoxText` as a strong reference or owner of a `GtkComboBoxText` instance.
///
open class ComboBoxText: ComboBox, ComboBoxTextProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkComboBoxText>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkComboBoxText>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkComboBoxText>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkComboBoxText>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkComboBoxText`.
    /// i.e., ownership is transferred to the `ComboBoxText` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkComboBoxText>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ComboBoxTextProtocol`
    /// Will retain `GtkComboBoxText`.
    /// - Parameter other: an instance of a related type that implements `ComboBoxTextProtocol`
    @inlinable public init<T: ComboBoxTextProtocol>(comboBoxText other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ComboBoxTextProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkComboBoxText`.
    @inlinable override public init() {
        let rv = gtk_combo_box_text_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new `GtkComboBoxText` with an entry.
    @inlinable public static func comboBoxTextNewWithEntry() -> Widget! {
        guard let rv = Widget(gconstpointer: gconstpointer(gtk_combo_box_text_new_with_entry())) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum ComboBoxTextPropertyName: String, PropertyNameProtocol {
    /// The item which is currently active.
    /// 
    /// If the model is a non-flat treemodel, and the active item is not an
    /// immediate child of the root of the tree, this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
    /// [struct`Gtk.TreePath`] of the active item.
    case active = "active"
    /// The value of the ID column of the active row.
    case activeId = "active-id"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case buttonSensitivity = "button-sensitivity"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// The model column to associate with strings from the entry.
    /// 
    /// This is property only relevant if the combo was created with
    /// [property`Gtk.ComboBox:has-entry`] is `true`.
    case entryTextColumn = "entry-text-column"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the combo box has an entry.
    case hasEntry = "has-entry"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// The `has-frame` property controls whether a frame is drawn around the entry.
    case hasFrame = "has-frame"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// The model column that provides string IDs for the values
    /// in the model, if != -1.
    case idColumn = "id-column"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// The model from which the combo box takes its values.
    case model = "model"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case popupFixedWidth = "popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// 
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup-shown`.
    case popupShown = "popup-shown"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension ComboBoxTextProtocol {
    /// Bind a `ComboBoxTextPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ComboBoxTextPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ComboBoxText property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ComboBoxTextPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ComboBoxText property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ComboBoxTextPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ComboBoxTextSignalName: String, SignalNameProtocol {
    /// Emitted when the active item is changed.
    /// 
    /// The can be due to the user selecting a different item from the list,
    /// or due to a call to [method`Gtk.ComboBox.set_active_iter`]. It will
    /// also be emitted while typing into the entry of a combo box with an entry.
    case changed = "changed"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted to allow changing how the text in a combo box's entry is displayed.
    /// 
    /// See [property`Gtk.ComboBox:has-entry`].
    /// 
    /// Connect a signal handler which returns an allocated string representing
    /// `path`. That string will then be used to set the text in the combo box's
    /// entry. The default signal handler uses the text from the
    /// [property`Gtk.ComboBox:entry-text-column`] model column.
    /// 
    /// Here's an example signal handler which fetches data from the model and
    /// displays it in the entry.
    /// ```c
    /// static char *
    /// format_entry_text_callback (GtkComboBox *combo,
    ///                             const char *path,
    ///                             gpointer     user_data)
    /// {
    ///   GtkTreeIter iter;
    ///   GtkTreeModel model;
    ///   double       value;
    /// 
    ///   model = gtk_combo_box_get_model (combo);
    /// 
    ///   gtk_tree_model_get_iter_from_string (model, &iter, path);
    ///   gtk_tree_model_get (model, &iter,
    ///                       THE_DOUBLE_VALUE_COLUMN, &value,
    ///                       -1);
    /// 
    ///   return g_strdup_printf ("`g`", value);
    /// }
    /// ```
    case formatEntryText = "format-entry-text"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted to move the active selection.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    case moveActive = "move-active"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted to popdown the combo box list.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are Alt+Up and Escape.
    case popdown = "popdown"
    /// Emitted to popup the combo box list.
    /// 
    /// This is an [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is Alt+Down.
    case popup = "popup"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The item which is currently active.
    /// 
    /// If the model is a non-flat treemodel, and the active item is not an
    /// immediate child of the root of the tree, this property has the value
    /// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
    /// [struct`Gtk.TreePath`] of the active item.
    case notifyActive = "notify::active"
    /// The value of the ID column of the active row.
    case notifyActiveId = "notify::active-id"
    /// Whether the dropdown button is sensitive when
    /// the model is empty.
    case notifyButtonSensitivity = "notify::button-sensitivity"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// The model column to associate with strings from the entry.
    /// 
    /// This is property only relevant if the combo was created with
    /// [property`Gtk.ComboBox:has-entry`] is `true`.
    case notifyEntryTextColumn = "notify::entry-text-column"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the combo box has an entry.
    case notifyHasEntry = "notify::has-entry"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// The `has-frame` property controls whether a frame is drawn around the entry.
    case notifyHasFrame = "notify::has-frame"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// The model column that provides string IDs for the values
    /// in the model, if != -1.
    case notifyIdColumn = "notify::id-column"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// The model from which the combo box takes its values.
    case notifyModel = "notify::model"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the popup's width should be a fixed width matching the
    /// allocated width of the combo box.
    case notifyPopupFixedWidth = "notify::popup-fixed-width"
    /// Whether the combo boxes dropdown is popped up.
    /// 
    /// Note that this property is mainly useful, because
    /// it allows you to connect to notify`popup-shown`.
    case notifyPopupShown = "notify::popup-shown"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: ComboBoxText has no signals
// MARK: ComboBoxText Class: ComboBoxTextProtocol extension (methods and fields)
public extension ComboBoxTextProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkComboBoxText` instance.
    @inlinable var combo_box_text_ptr: UnsafeMutablePointer<GtkComboBoxText>! { return ptr?.assumingMemoryBound(to: GtkComboBoxText.self) }

    /// Appends `text` to the list of strings stored in `combo_box`.
    /// 
    /// If `id` is non-`nil` then it is used as the ID of the row.
    /// 
    /// This is the same as calling [method`Gtk.ComboBoxText.insert`]
    /// with a position of -1.
    @inlinable func append(id: UnsafePointer<CChar>? = nil, text: UnsafePointer<CChar>!) {
        gtk_combo_box_text_append(combo_box_text_ptr, id, text)
    
    }

    /// Appends `text` to the list of strings stored in `combo_box`.
    /// 
    /// This is the same as calling [method`Gtk.ComboBoxText.insert_text`]
    /// with a position of -1.
    @inlinable func append(text: UnsafePointer<CChar>!) {
        gtk_combo_box_text_append_text(combo_box_text_ptr, text)
    
    }

    /// Returns the currently active string in `combo_box`.
    /// 
    /// If no row is currently selected, `nil` is returned.
    /// If `combo_box` contains an entry, this function will
    /// return its contents (which will not necessarily
    /// be an item from the list).
    @inlinable func getActiveText() -> String! {
        let rv = gtk_combo_box_text_get_active_text(combo_box_text_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Inserts `text` at `position` in the list of strings stored in `combo_box`.
    /// 
    /// If `id` is non-`nil` then it is used as the ID of the row.
    /// See [property`Gtk.ComboBox:id-column`].
    /// 
    /// If `position` is negative then `text` is appended.
    @inlinable func insert(position: Int, id: UnsafePointer<CChar>? = nil, text: UnsafePointer<CChar>!) {
        gtk_combo_box_text_insert(combo_box_text_ptr, gint(position), id, text)
    
    }

    /// Inserts `text` at `position` in the list of strings stored in `combo_box`.
    /// 
    /// If `position` is negative then `text` is appended.
    /// 
    /// This is the same as calling [method`Gtk.ComboBoxText.insert`]
    /// with a `nil` ID string.
    @inlinable func insertText(position: Int, text: UnsafePointer<CChar>!) {
        gtk_combo_box_text_insert_text(combo_box_text_ptr, gint(position), text)
    
    }

    /// Prepends `text` to the list of strings stored in `combo_box`.
    /// 
    /// If `id` is non-`nil` then it is used as the ID of the row.
    /// 
    /// This is the same as calling [method`Gtk.ComboBoxText.insert`]
    /// with a position of 0.
    @inlinable func prepend(id: UnsafePointer<CChar>? = nil, text: UnsafePointer<CChar>!) {
        gtk_combo_box_text_prepend(combo_box_text_ptr, id, text)
    
    }

    /// Prepends `text` to the list of strings stored in `combo_box`.
    /// 
    /// This is the same as calling [method`Gtk.ComboBoxText.insert_text`]
    /// with a position of 0.
    @inlinable func prepend(text: UnsafePointer<CChar>!) {
        gtk_combo_box_text_prepend_text(combo_box_text_ptr, text)
    
    }

    /// Removes the string at `position` from `combo_box`.
    @inlinable func remove(position: Int) {
        gtk_combo_box_text_remove(combo_box_text_ptr, gint(position))
    
    }

    /// Removes all the text entries from the combo box.
    @inlinable func removeAll() {
        gtk_combo_box_text_remove_all(combo_box_text_ptr)
    
    }
    /// Returns the currently active string in `combo_box`.
    /// 
    /// If no row is currently selected, `nil` is returned.
    /// If `combo_box` contains an entry, this function will
    /// return its contents (which will not necessarily
    /// be an item from the list).
    @inlinable var activeText: String! {
        /// Returns the currently active string in `combo_box`.
        /// 
        /// If no row is currently selected, `nil` is returned.
        /// If `combo_box` contains an entry, this function will
        /// return its contents (which will not necessarily
        /// be an item from the list).
        get {
            let rv = gtk_combo_box_text_get_active_text(combo_box_text_ptr).map({ String(cString: $0) })
            return rv
        }
    }


}



// MARK: - ConstantExpression Class

/// A constant value in a `GtkExpression`.
///
/// The `ConstantExpressionProtocol` protocol exposes the methods and properties of an underlying `GtkConstantExpression` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstantExpression`.
/// Alternatively, use `ConstantExpressionRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstantExpressionProtocol: ExpressionProtocol {
        /// Untyped pointer to the underlying `GtkConstantExpression` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstantExpression` instance.
    var constant_expression_ptr: UnsafeMutablePointer<GtkConstantExpression>! { get }

    /// Required Initialiser for types conforming to `ConstantExpressionProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A constant value in a `GtkExpression`.
///
/// The `ConstantExpressionRef` type acts as a lightweight Swift reference to an underlying `GtkConstantExpression` instance.
/// It exposes methods that can operate on this data type through `ConstantExpressionProtocol` conformance.
/// Use `ConstantExpressionRef` only as an `unowned` reference to an existing `GtkConstantExpression` instance.
///
public struct ConstantExpressionRef: ConstantExpressionProtocol {
        /// Untyped pointer to the underlying `GtkConstantExpression` instance.
    /// For type-safe access, use the generated, typed pointer `constant_expression_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstantExpressionRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstantExpression>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstantExpression>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstantExpression>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstantExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstantExpressionProtocol`
    @inlinable init<T: ConstantExpressionProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// A constant value in a `GtkExpression`.
///
/// The `ConstantExpression` type acts as a reference-counted owner of an underlying `GtkConstantExpression` instance.
/// It provides the methods that can operate on this data type through `ConstantExpressionProtocol` conformance.
/// Use `ConstantExpression` as a strong reference or owner of a `GtkConstantExpression` instance.
///
open class ConstantExpression: Expression, ConstantExpressionProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstantExpression>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstantExpression>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstantExpression>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstantExpression>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstantExpression`.
    /// i.e., ownership is transferred to the `ConstantExpression` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstantExpression>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstantExpressionProtocol`
    /// Will retain `GtkConstantExpression`.
    /// - Parameter other: an instance of a related type that implements `ConstantExpressionProtocol`
    @inlinable public init<T: ConstantExpressionProtocol>(constantExpression other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable override public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstantExpressionProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

// MARK: no ConstantExpression properties

// MARK: no ConstantExpression signals

// MARK: ConstantExpression has no signals
// MARK: ConstantExpression Class: ConstantExpressionProtocol extension (methods and fields)
public extension ConstantExpressionProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstantExpression` instance.
    @inlinable var constant_expression_ptr: UnsafeMutablePointer<GtkConstantExpression>! { return ptr?.assumingMemoryBound(to: GtkConstantExpression.self) }

    /// Gets the value that a constant expression evaluates to.
    @inlinable func getValue() -> GLibObject.ValueRef! {
        let rv = GLibObject.ValueRef(gtk_constant_expression_get_value(expression_ptr))
        return rv
    }
    /// Gets the value that a constant expression evaluates to.
    @inlinable var value: GLibObject.ValueRef! {
        /// Gets the value that a constant expression evaluates to.
        get {
            let rv = GLibObject.ValueRef(gtk_constant_expression_get_value(expression_ptr))
            return rv
        }
    }


}



// MARK: - Constraint Class

/// `GtkConstraint` describes a constraint between attributes of two widgets,
///  expressed as a linear equation.
/// 
/// The typical equation for a constraint is:
/// 
/// ```
///   target.target_attr = source.source_attr × multiplier + constant
/// ```
/// 
/// Each `GtkConstraint` is part of a system that will be solved by a
/// [class`Gtk.ConstraintLayout`] in order to allocate and position each
/// child widget or guide.
/// 
/// The source and target, as well as their attributes, of a `GtkConstraint`
/// instance are immutable after creation.
///
/// The `ConstraintProtocol` protocol exposes the methods and properties of an underlying `GtkConstraint` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Constraint`.
/// Alternatively, use `ConstraintRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintProtocol: GLibObject.ObjectProtocol {
        /// Untyped pointer to the underlying `GtkConstraint` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraint` instance.
    var constraint_ptr: UnsafeMutablePointer<GtkConstraint>! { get }

    /// Required Initialiser for types conforming to `ConstraintProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkConstraint` describes a constraint between attributes of two widgets,
///  expressed as a linear equation.
/// 
/// The typical equation for a constraint is:
/// 
/// ```
///   target.target_attr = source.source_attr × multiplier + constant
/// ```
/// 
/// Each `GtkConstraint` is part of a system that will be solved by a
/// [class`Gtk.ConstraintLayout`] in order to allocate and position each
/// child widget or guide.
/// 
/// The source and target, as well as their attributes, of a `GtkConstraint`
/// instance are immutable after creation.
///
/// The `ConstraintRef` type acts as a lightweight Swift reference to an underlying `GtkConstraint` instance.
/// It exposes methods that can operate on this data type through `ConstraintProtocol` conformance.
/// Use `ConstraintRef` only as an `unowned` reference to an existing `GtkConstraint` instance.
///
public struct ConstraintRef: ConstraintProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkConstraint` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraint>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraint>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraint>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraint>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintProtocol`
    @inlinable init<T: ConstraintProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ConstraintProtocol>(_ other: T) -> ConstraintRef { ConstraintRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new constraint representing a relation between a layout
    /// attribute on a source and a layout attribute on a target.
    @inlinable init<ConstraintTargetT: ConstraintTargetProtocol>( target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, source: ConstraintTargetT?, sourceAttribute: GtkConstraintAttribute, multiplier: CDouble, constant: CDouble, strength: Int) {
        let rv = gtk_constraint_new(target?.constraint_target_ptr, targetAttribute, relation, source?.constraint_target_ptr, sourceAttribute, multiplier, constant, gint(strength))
        ptr = UnsafeMutableRawPointer(rv)
    }

    /// Creates a new constraint representing a relation between a layout
    /// attribute on a target and a constant value.
    @inlinable init<ConstraintTargetT: ConstraintTargetProtocol>(constant target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: CDouble, strength: Int) {
        let rv = gtk_constraint_new_constant(target?.constraint_target_ptr, targetAttribute, relation, constant, gint(strength))
        ptr = UnsafeMutableRawPointer(rv)
    }
    /// Creates a new constraint representing a relation between a layout
    /// attribute on a target and a constant value.
    @inlinable static func new<ConstraintTargetT: ConstraintTargetProtocol>(constant target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: CDouble, strength: Int) -> ConstraintRef! {
        guard let rv = ConstraintRef(gconstpointer: gconstpointer(gtk_constraint_new_constant(target?.constraint_target_ptr, targetAttribute, relation, constant, gint(strength)))) else { return nil }
        return rv
    }
}

/// `GtkConstraint` describes a constraint between attributes of two widgets,
///  expressed as a linear equation.
/// 
/// The typical equation for a constraint is:
/// 
/// ```
///   target.target_attr = source.source_attr × multiplier + constant
/// ```
/// 
/// Each `GtkConstraint` is part of a system that will be solved by a
/// [class`Gtk.ConstraintLayout`] in order to allocate and position each
/// child widget or guide.
/// 
/// The source and target, as well as their attributes, of a `GtkConstraint`
/// instance are immutable after creation.
///
/// The `Constraint` type acts as a reference-counted owner of an underlying `GtkConstraint` instance.
/// It provides the methods that can operate on this data type through `ConstraintProtocol` conformance.
/// Use `Constraint` as a strong reference or owner of a `GtkConstraint` instance.
///
open class Constraint: GLibObject.Object, ConstraintProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraint>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraint>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraint>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraint>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstraint`.
    /// i.e., ownership is transferred to the `Constraint` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraint>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstraintProtocol`
    /// Will retain `GtkConstraint`.
    /// - Parameter other: an instance of a related type that implements `ConstraintProtocol`
    @inlinable public init<T: ConstraintProtocol>(constraint other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new constraint representing a relation between a layout
    /// attribute on a source and a layout attribute on a target.
    @inlinable public init<ConstraintTargetT: ConstraintTargetProtocol>( target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, source: ConstraintTargetT?, sourceAttribute: GtkConstraintAttribute, multiplier: CDouble, constant: CDouble, strength: Int) {
        let rv = gtk_constraint_new(target?.constraint_target_ptr, targetAttribute, relation, source?.constraint_target_ptr, sourceAttribute, multiplier, constant, gint(strength))
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new constraint representing a relation between a layout
    /// attribute on a target and a constant value.
    @inlinable public init<ConstraintTargetT: ConstraintTargetProtocol>(constant target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: CDouble, strength: Int) {
        let rv = gtk_constraint_new_constant(target?.constraint_target_ptr, targetAttribute, relation, constant, gint(strength))
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }

    /// Creates a new constraint representing a relation between a layout
    /// attribute on a target and a constant value.
    @inlinable public static func new<ConstraintTargetT: ConstraintTargetProtocol>(constant target: ConstraintTargetT?, targetAttribute: GtkConstraintAttribute, relation: GtkConstraintRelation, constant: CDouble, strength: Int) -> Constraint! {
        guard let rv = Constraint(gconstpointer: gconstpointer(gtk_constraint_new_constant(target?.constraint_target_ptr, targetAttribute, relation, constant, gint(strength)))) else { return nil }
        if typeIsA(type: rv.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = rv.refSink() } 
        return rv
    }

}

public enum ConstraintPropertyName: String, PropertyNameProtocol {
    /// The constant value to be added to the [property`Gtk.Constraint:source-attribute`].
    case constant = "constant"
    /// The multiplication factor to be applied to
    /// the [property`Gtk.Constraint:source-attribute`].
    case multiplier = "multiplier"
    /// The order relation between the terms of the constraint.
    case relation = "relation"
    /// The source of the constraint.
    /// 
    /// The constraint will set the [property`Gtk.Constraint:target-attribute`]
    /// property of the target using the [property`Gtk.Constraint:source-attribute`]
    /// property of the source.
    case source = "source"
    /// The attribute of the [property`Gtk.Constraint:source`] read by the
    /// constraint.
    case sourceAttribute = "source-attribute"
    /// The strength of the constraint.
    /// 
    /// The strength can be expressed either using one of the symbolic values
    /// of the [enum`Gtk.ConstraintStrength`] enumeration, or any positive integer
    /// value.
    case strength = "strength"
    /// The target of the constraint.
    /// 
    /// The constraint will set the [property`Gtk.Constraint:target-attribute`]
    /// property of the target using the [property`Gtk.Constraint:source-attribute`]
    /// property of the source widget.
    case target = "target"
    /// The attribute of the [property`Gtk.Constraint:target`] set by the constraint.
    case targetAttribute = "target-attribute"
}

public extension ConstraintProtocol {
    /// Bind a `ConstraintPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ConstraintPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Constraint property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ConstraintPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Constraint property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ConstraintPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ConstraintSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The constant value to be added to the [property`Gtk.Constraint:source-attribute`].
    case notifyConstant = "notify::constant"
    /// The multiplication factor to be applied to
    /// the [property`Gtk.Constraint:source-attribute`].
    case notifyMultiplier = "notify::multiplier"
    /// The order relation between the terms of the constraint.
    case notifyRelation = "notify::relation"
    /// The source of the constraint.
    /// 
    /// The constraint will set the [property`Gtk.Constraint:target-attribute`]
    /// property of the target using the [property`Gtk.Constraint:source-attribute`]
    /// property of the source.
    case notifySource = "notify::source"
    /// The attribute of the [property`Gtk.Constraint:source`] read by the
    /// constraint.
    case notifySourceAttribute = "notify::source-attribute"
    /// The strength of the constraint.
    /// 
    /// The strength can be expressed either using one of the symbolic values
    /// of the [enum`Gtk.ConstraintStrength`] enumeration, or any positive integer
    /// value.
    case notifyStrength = "notify::strength"
    /// The target of the constraint.
    /// 
    /// The constraint will set the [property`Gtk.Constraint:target-attribute`]
    /// property of the target using the [property`Gtk.Constraint:source-attribute`]
    /// property of the source widget.
    case notifyTarget = "notify::target"
    /// The attribute of the [property`Gtk.Constraint:target`] set by the constraint.
    case notifyTargetAttribute = "notify::target-attribute"
}

// MARK: Constraint has no signals
// MARK: Constraint Class: ConstraintProtocol extension (methods and fields)
public extension ConstraintProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraint` instance.
    @inlinable var constraint_ptr: UnsafeMutablePointer<GtkConstraint>! { return ptr?.assumingMemoryBound(to: GtkConstraint.self) }

    /// Retrieves the constant factor added to the source attributes' value.
    @inlinable func getConstant() -> CDouble {
        let rv = gtk_constraint_get_constant(constraint_ptr)
        return rv
    }

    /// Retrieves the multiplication factor applied to the source
    /// attribute's value.
    @inlinable func getMultiplier() -> CDouble {
        let rv = gtk_constraint_get_multiplier(constraint_ptr)
        return rv
    }

    /// The order relation between the terms of the constraint.
    @inlinable func getRelation() -> GtkConstraintRelation {
        let rv = gtk_constraint_get_relation(constraint_ptr)
        return rv
    }

    /// Retrieves the [iface`Gtk.ConstraintTarget`] used as the source for the
    /// constraint.
    /// 
    /// If the source is set to `NULL` at creation, the constraint will use
    /// the widget using the [class`Gtk.ConstraintLayout`] as the source.
    @inlinable func getSource() -> ConstraintTargetRef! {
        let rv = ConstraintTargetRef(gconstpointer: gconstpointer(gtk_constraint_get_source(constraint_ptr)))
        return rv
    }

    /// Retrieves the attribute of the source to be read by the constraint.
    @inlinable func getSourceAttribute() -> GtkConstraintAttribute {
        let rv = gtk_constraint_get_source_attribute(constraint_ptr)
        return rv
    }

    /// Retrieves the strength of the constraint.
    @inlinable func getStrength() -> Int {
        let rv = Int(gtk_constraint_get_strength(constraint_ptr))
        return rv
    }

    /// Retrieves the [iface`Gtk.ConstraintTarget`] used as the target for
    /// the constraint.
    /// 
    /// If the targe is set to `NULL` at creation, the constraint will use
    /// the widget using the [class`Gtk.ConstraintLayout`] as the target.
    @inlinable func getTarget() -> ConstraintTargetRef! {
        let rv = ConstraintTargetRef(gconstpointer: gconstpointer(gtk_constraint_get_target(constraint_ptr)))
        return rv
    }

    /// Retrieves the attribute of the target to be set by the constraint.
    @inlinable func getTargetAttribute() -> GtkConstraintAttribute {
        let rv = gtk_constraint_get_target_attribute(constraint_ptr)
        return rv
    }
    /// The constant value to be added to the [property`Gtk.Constraint:source-attribute`].
    @inlinable var constant: CDouble {
        /// Retrieves the constant factor added to the source attributes' value.
        get {
            let rv = gtk_constraint_get_constant(constraint_ptr)
            return rv
        }
    }

    /// Checks whether the constraint is attached to a [class`Gtk.ConstraintLayout`],
    /// and it is contributing to the layout.
    @inlinable var isAttached: Bool {
        /// Checks whether the constraint is attached to a [class`Gtk.ConstraintLayout`],
        /// and it is contributing to the layout.
        get {
            let rv = ((gtk_constraint_is_attached(constraint_ptr)) != 0)
            return rv
        }
    }

    /// Checks whether the constraint describes a relation between an attribute
    /// on the [property`Gtk.Constraint:target`] and a constant value.
    @inlinable var isConstant: Bool {
        /// Checks whether the constraint describes a relation between an attribute
        /// on the [property`Gtk.Constraint:target`] and a constant value.
        get {
            let rv = ((gtk_constraint_is_constant(constraint_ptr)) != 0)
            return rv
        }
    }

    /// Checks whether the constraint is a required relation for solving the
    /// constraint layout.
    @inlinable var isRequired: Bool {
        /// Checks whether the constraint is a required relation for solving the
        /// constraint layout.
        get {
            let rv = ((gtk_constraint_is_required(constraint_ptr)) != 0)
            return rv
        }
    }

    /// The multiplication factor to be applied to
    /// the [property`Gtk.Constraint:source-attribute`].
    @inlinable var multiplier: CDouble {
        /// Retrieves the multiplication factor applied to the source
        /// attribute's value.
        get {
            let rv = gtk_constraint_get_multiplier(constraint_ptr)
            return rv
        }
    }

    /// The order relation between the terms of the constraint.
    @inlinable var relation: GtkConstraintRelation {
        /// The order relation between the terms of the constraint.
        get {
            let rv = gtk_constraint_get_relation(constraint_ptr)
            return rv
        }
    }

    /// The source of the constraint.
    /// 
    /// The constraint will set the [property`Gtk.Constraint:target-attribute`]
    /// property of the target using the [property`Gtk.Constraint:source-attribute`]
    /// property of the source.
    @inlinable var source: ConstraintTargetRef! {
        /// Retrieves the [iface`Gtk.ConstraintTarget`] used as the source for the
        /// constraint.
        /// 
        /// If the source is set to `NULL` at creation, the constraint will use
        /// the widget using the [class`Gtk.ConstraintLayout`] as the source.
        get {
            let rv = ConstraintTargetRef(gconstpointer: gconstpointer(gtk_constraint_get_source(constraint_ptr)))
            return rv
        }
    }

    /// Retrieves the attribute of the source to be read by the constraint.
    @inlinable var sourceAttribute: GtkConstraintAttribute {
        /// Retrieves the attribute of the source to be read by the constraint.
        get {
            let rv = gtk_constraint_get_source_attribute(constraint_ptr)
            return rv
        }
    }

    /// The strength of the constraint.
    /// 
    /// The strength can be expressed either using one of the symbolic values
    /// of the [enum`Gtk.ConstraintStrength`] enumeration, or any positive integer
    /// value.
    @inlinable var strength: Int {
        /// Retrieves the strength of the constraint.
        get {
            let rv = Int(gtk_constraint_get_strength(constraint_ptr))
            return rv
        }
    }

    /// The target of the constraint.
    /// 
    /// The constraint will set the [property`Gtk.Constraint:target-attribute`]
    /// property of the target using the [property`Gtk.Constraint:source-attribute`]
    /// property of the source widget.
    @inlinable var target: ConstraintTargetRef! {
        /// Retrieves the [iface`Gtk.ConstraintTarget`] used as the target for
        /// the constraint.
        /// 
        /// If the targe is set to `NULL` at creation, the constraint will use
        /// the widget using the [class`Gtk.ConstraintLayout`] as the target.
        get {
            let rv = ConstraintTargetRef(gconstpointer: gconstpointer(gtk_constraint_get_target(constraint_ptr)))
            return rv
        }
    }

    /// Retrieves the attribute of the target to be set by the constraint.
    @inlinable var targetAttribute: GtkConstraintAttribute {
        /// Retrieves the attribute of the target to be set by the constraint.
        get {
            let rv = gtk_constraint_get_target_attribute(constraint_ptr)
            return rv
        }
    }


}



// MARK: - ConstraintGuide Class

/// A `GtkConstraintGuide` is an invisible layout element in a
/// `GtkConstraintLayout`.
/// 
/// The `GtkConstraintLayout` treats guides like widgets. They
/// can be used as the source or target of a `GtkConstraint`.
/// 
/// Guides have a minimum, maximum and natural size. Depending
/// on the constraints that are applied, they can act like a
/// guideline that widgets can be aligned to, or like *flexible
/// space*.
/// 
/// Unlike a `GtkWidget`, a `GtkConstraintGuide` will not be drawn.
///
/// The `ConstraintGuideProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintGuide` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintGuide`.
/// Alternatively, use `ConstraintGuideRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintGuideProtocol: GLibObject.ObjectProtocol, ConstraintTargetProtocol {
        /// Untyped pointer to the underlying `GtkConstraintGuide` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintGuide` instance.
    var constraint_guide_ptr: UnsafeMutablePointer<GtkConstraintGuide>! { get }

    /// Required Initialiser for types conforming to `ConstraintGuideProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A `GtkConstraintGuide` is an invisible layout element in a
/// `GtkConstraintLayout`.
/// 
/// The `GtkConstraintLayout` treats guides like widgets. They
/// can be used as the source or target of a `GtkConstraint`.
/// 
/// Guides have a minimum, maximum and natural size. Depending
/// on the constraints that are applied, they can act like a
/// guideline that widgets can be aligned to, or like *flexible
/// space*.
/// 
/// Unlike a `GtkWidget`, a `GtkConstraintGuide` will not be drawn.
///
/// The `ConstraintGuideRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintGuide` instance.
/// It exposes methods that can operate on this data type through `ConstraintGuideProtocol` conformance.
/// Use `ConstraintGuideRef` only as an `unowned` reference to an existing `GtkConstraintGuide` instance.
///
public struct ConstraintGuideRef: ConstraintGuideProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkConstraintGuide` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_guide_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintGuideRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintGuide>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintGuide>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintGuide>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintGuide>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintGuideProtocol`
    @inlinable init<T: ConstraintGuideProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ConstraintGuideProtocol>(_ other: T) -> ConstraintGuideRef { ConstraintGuideRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkConstraintGuide` object.
    @inlinable init() {
        let rv = gtk_constraint_guide_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A `GtkConstraintGuide` is an invisible layout element in a
/// `GtkConstraintLayout`.
/// 
/// The `GtkConstraintLayout` treats guides like widgets. They
/// can be used as the source or target of a `GtkConstraint`.
/// 
/// Guides have a minimum, maximum and natural size. Depending
/// on the constraints that are applied, they can act like a
/// guideline that widgets can be aligned to, or like *flexible
/// space*.
/// 
/// Unlike a `GtkWidget`, a `GtkConstraintGuide` will not be drawn.
///
/// The `ConstraintGuide` type acts as a reference-counted owner of an underlying `GtkConstraintGuide` instance.
/// It provides the methods that can operate on this data type through `ConstraintGuideProtocol` conformance.
/// Use `ConstraintGuide` as a strong reference or owner of a `GtkConstraintGuide` instance.
///
open class ConstraintGuide: GLibObject.Object, ConstraintGuideProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraintGuide>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraintGuide>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraintGuide>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraintGuide>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstraintGuide`.
    /// i.e., ownership is transferred to the `ConstraintGuide` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraintGuide>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstraintGuideProtocol`
    /// Will retain `GtkConstraintGuide`.
    /// - Parameter other: an instance of a related type that implements `ConstraintGuideProtocol`
    @inlinable public init<T: ConstraintGuideProtocol>(constraintGuide other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintGuideProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkConstraintGuide` object.
    @inlinable public init() {
        let rv = gtk_constraint_guide_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

public enum ConstraintGuidePropertyName: String, PropertyNameProtocol {
    /// The maximum height of the guide.
    case maxHeight = "max-height"
    /// The maximum width of the guide.
    case maxWidth = "max-width"
    /// The minimum height of the guide.
    case minHeight = "min-height"
    /// The minimum width of the guide.
    case minWidth = "min-width"
    /// A name that identifies the `GtkConstraintGuide`, for debugging.
    case name = "name"
    /// The preferred, or natural, height of the guide.
    case natHeight = "nat-height"
    /// The preferred, or natural, width of the guide.
    case natWidth = "nat-width"
    /// The `GtkConstraintStrength` to be used for the constraint on
    /// the natural size of the guide.
    case strength = "strength"
}

public extension ConstraintGuideProtocol {
    /// Bind a `ConstraintGuidePropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ConstraintGuidePropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ConstraintGuide property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ConstraintGuidePropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ConstraintGuide property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ConstraintGuidePropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ConstraintGuideSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The maximum height of the guide.
    case notifyMaxHeight = "notify::max-height"
    /// The maximum width of the guide.
    case notifyMaxWidth = "notify::max-width"
    /// The minimum height of the guide.
    case notifyMinHeight = "notify::min-height"
    /// The minimum width of the guide.
    case notifyMinWidth = "notify::min-width"
    /// A name that identifies the `GtkConstraintGuide`, for debugging.
    case notifyName = "notify::name"
    /// The preferred, or natural, height of the guide.
    case notifyNatHeight = "notify::nat-height"
    /// The preferred, or natural, width of the guide.
    case notifyNatWidth = "notify::nat-width"
    /// The `GtkConstraintStrength` to be used for the constraint on
    /// the natural size of the guide.
    case notifyStrength = "notify::strength"
}

// MARK: ConstraintGuide has no signals
// MARK: ConstraintGuide Class: ConstraintGuideProtocol extension (methods and fields)
public extension ConstraintGuideProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintGuide` instance.
    @inlinable var constraint_guide_ptr: UnsafeMutablePointer<GtkConstraintGuide>! { return ptr?.assumingMemoryBound(to: GtkConstraintGuide.self) }

    /// Gets the maximum size of `guide`.
    @inlinable func getMaxSize(width: UnsafeMutablePointer<gint>? = nil, height: UnsafeMutablePointer<gint>? = nil) {
        gtk_constraint_guide_get_max_size(constraint_guide_ptr, width, height)
    
    }

    /// Gets the minimum size of `guide`.
    @inlinable func getMinSize(width: UnsafeMutablePointer<gint>? = nil, height: UnsafeMutablePointer<gint>? = nil) {
        gtk_constraint_guide_get_min_size(constraint_guide_ptr, width, height)
    
    }

    /// Retrieves the name set using `gtk_constraint_guide_set_name()`.
    @inlinable func getName() -> String! {
        let rv = gtk_constraint_guide_get_name(constraint_guide_ptr).map({ String(cString: $0) })
        return rv
    }

    /// Gets the natural size of `guide`.
    @inlinable func getNatSize(width: UnsafeMutablePointer<gint>? = nil, height: UnsafeMutablePointer<gint>? = nil) {
        gtk_constraint_guide_get_nat_size(constraint_guide_ptr, width, height)
    
    }

    /// Retrieves the strength set using `gtk_constraint_guide_set_strength()`.
    @inlinable func getStrength() -> GtkConstraintStrength {
        let rv = gtk_constraint_guide_get_strength(constraint_guide_ptr)
        return rv
    }

    /// Sets the maximum size of `guide`.
    /// 
    /// If `guide` is attached to a `GtkConstraintLayout`,
    /// the constraints will be updated to reflect the new size.
    @inlinable func setMaxSize(width: Int, height: Int) {
        gtk_constraint_guide_set_max_size(constraint_guide_ptr, gint(width), gint(height))
    
    }

    /// Sets the minimum size of `guide`.
    /// 
    /// If `guide` is attached to a `GtkConstraintLayout`,
    /// the constraints will be updated to reflect the new size.
    @inlinable func setMinSize(width: Int, height: Int) {
        gtk_constraint_guide_set_min_size(constraint_guide_ptr, gint(width), gint(height))
    
    }

    /// Sets a name for the given `GtkConstraintGuide`.
    /// 
    /// The name is useful for debugging purposes.
    @inlinable func set(name: UnsafePointer<CChar>? = nil) {
        gtk_constraint_guide_set_name(constraint_guide_ptr, name)
    
    }

    /// Sets the natural size of `guide`.
    /// 
    /// If `guide` is attached to a `GtkConstraintLayout`,
    /// the constraints will be updated to reflect the new size.
    @inlinable func setNatSize(width: Int, height: Int) {
        gtk_constraint_guide_set_nat_size(constraint_guide_ptr, gint(width), gint(height))
    
    }

    /// Sets the strength of the constraint on the natural size of the
    /// given `GtkConstraintGuide`.
    @inlinable func set(strength: GtkConstraintStrength) {
        gtk_constraint_guide_set_strength(constraint_guide_ptr, strength)
    
    }
    /// A name that identifies the `GtkConstraintGuide`, for debugging.
    @inlinable var name: String! {
        /// Retrieves the name set using `gtk_constraint_guide_set_name()`.
        get {
            let rv = gtk_constraint_guide_get_name(constraint_guide_ptr).map({ String(cString: $0) })
            return rv
        }
        /// Sets a name for the given `GtkConstraintGuide`.
        /// 
        /// The name is useful for debugging purposes.
        nonmutating set {
            gtk_constraint_guide_set_name(constraint_guide_ptr, newValue)
        }
    }

    /// The `GtkConstraintStrength` to be used for the constraint on
    /// the natural size of the guide.
    @inlinable var strength: GtkConstraintStrength {
        /// Retrieves the strength set using `gtk_constraint_guide_set_strength()`.
        get {
            let rv = gtk_constraint_guide_get_strength(constraint_guide_ptr)
            return rv
        }
        /// Sets the strength of the constraint on the natural size of the
        /// given `GtkConstraintGuide`.
        nonmutating set {
            gtk_constraint_guide_set_strength(constraint_guide_ptr, newValue)
        }
    }


}



// MARK: - ConstraintLayout Class

/// A layout manager using constraints to describe relations between widgets.
/// 
/// `GtkConstraintLayout` is a layout manager that uses relations between
/// widget attributes, expressed via [class`Gtk.Constraint`] instances, to
/// measure and allocate widgets.
/// 
/// ### How do constraints work
/// 
/// Constraints are objects defining the relationship between attributes
/// of a widget; you can read the description of the [class`Gtk.Constraint`]
/// class to have a more in depth definition.
/// 
/// By taking multiple constraints and applying them to the children of
/// a widget using `GtkConstraintLayout`, it's possible to describe
/// complex layout policies; each constraint applied to a child or to the parent
/// widgets contributes to the full description of the layout, in terms of
/// parameters for resolving the value of each attribute.
/// 
/// It is important to note that a layout is defined by the totality of
/// constraints; removing a child, or a constraint, from an existing layout
/// without changing the remaining constraints may result in an unstable
/// or unsolvable layout.
/// 
/// Constraints have an implicit "reading order"; you should start describing
/// each edge of each child, as well as their relationship with the parent
/// container, from the top left (or top right, in RTL languages), horizontally
/// first, and then vertically.
/// 
/// A constraint-based layout with too few constraints can become "unstable",
/// that is: have more than one solution. The behavior of an unstable layout
/// is undefined.
/// 
/// A constraint-based layout with conflicting constraints may be unsolvable,
/// and lead to an unstable layout. You can use the [property`Gtk.Constraint:strength`]
/// property of [class`Gtk.Constraint`] to "nudge" the layout towards a solution.
/// 
/// ### GtkConstraintLayout as GtkBuildable
/// 
/// `GtkConstraintLayout` implements the [iface`Gtk.Buildable`] interface and
/// has a custom "constraints" element which allows describing constraints in
/// a [class`Gtk.Builder`] UI file.
/// 
/// An example of a UI definition fragment specifying a constraint:
/// 
/// ```xml
///   &lt;object class="GtkConstraintLayout"&gt;
///     &lt;constraints&gt;
///       &lt;constraint target="button" target-attribute="start"
///                   relation="eq"
///                   source="super" source-attribute="start"
///                   constant="12"
///                   strength="required" /&gt;
///       &lt;constraint target="button" target-attribute="width"
///                   relation="ge"
///                   constant="250"
///                   strength="strong" /&gt;
///     &lt;/constraints&gt;
///   &lt;/object&gt;
/// ```
/// 
/// The definition above will add two constraints to the GtkConstraintLayout:
/// 
///  - a required constraint between the leading edge of "button" and
///    the leading edge of the widget using the constraint layout, plus
///    12 pixels
///  - a strong, constant constraint making the width of "button" greater
///    than, or equal to 250 pixels
/// 
/// The "target" and "target-attribute" attributes are required.
/// 
/// The "source" and "source-attribute" attributes of the "constraint"
/// element are optional; if they are not specified, the constraint is
/// assumed to be a constant.
/// 
/// The "relation" attribute is optional; if not specified, the constraint
/// is assumed to be an equality.
/// 
/// The "strength" attribute is optional; if not specified, the constraint
/// is assumed to be required.
/// 
/// The "source" and "target" attributes can be set to "super" to indicate
/// that the constraint target is the widget using the GtkConstraintLayout.
/// 
/// There can be "constant" and "multiplier" attributes.
/// 
/// Additionally, the "constraints" element can also contain a description
/// of the `GtkConstraintGuides` used by the layout:
/// 
/// ```xml
///   &lt;constraints&gt;
///     &lt;guide min-width="100" max-width="500" name="hspace"/&gt;
///     &lt;guide min-height="64" nat-height="128" name="vspace" strength="strong"/&gt;
///   &lt;/constraints&gt;
/// ```
/// 
/// The "guide" element has the following optional attributes:
/// 
///   - "min-width", "nat-width", and "max-width", describe the minimum,
///     natural, and maximum width of the guide, respectively
///   - "min-height", "nat-height", and "max-height", describe the minimum,
///     natural, and maximum height of the guide, respectively
///   - "strength" describes the strength of the constraint on the natural
///     size of the guide; if not specified, the constraint is assumed to
///     have a medium strength
///   - "name" describes a name for the guide, useful when debugging
/// 
/// ### Using the Visual Format Language
/// 
/// Complex constraints can be described using a compact syntax called VFL,
/// or *Visual Format Language*.
/// 
/// The Visual Format Language describes all the constraints on a row or
/// column, typically starting from the leading edge towards the trailing
/// one. Each element of the layout is composed by "views", which identify
/// a [iface`Gtk.ConstraintTarget`].
/// 
/// For instance:
/// 
/// ```
///   [button]-[textField]
/// ```
/// 
/// Describes a constraint that binds the trailing edge of "button" to the
/// leading edge of "textField", leaving a default space between the two.
/// 
/// Using VFL is also possible to specify predicates that describe constraints
/// on attributes like width and height:
/// 
/// ```
///   // Width must be greater than, or equal to 50
///   [`button(>=50)`]
/// 
///   // Width of button1 must be equal to width of button2
///   [`button1(==button2)`]
/// ```
/// 
/// The default orientation for a VFL description is horizontal, unless
/// otherwise specified:
/// 
/// ```
///   // horizontal orientation, default attribute: width
///   H:[`button(>=150)`]
/// 
///   // vertical orientation, default attribute: height
///   V:[`button1(==button2)`]
/// ```
/// 
/// It's also possible to specify multiple predicates, as well as their
/// strength:
/// 
/// ```
///   // minimum width of button must be 150
///   // natural width of button can be 250
///   [`button(>=150@required, ==250@medium)`]
/// ```
/// 
/// Finally, it's also possible to use simple arithmetic operators:
/// 
/// ```
///   // width of button1 must be equal to width of button2
///   // divided by 2 plus 12
///   [`button1(button2 / 2 + 12)`]
/// ```
///
/// The `ConstraintLayoutProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintLayout` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintLayout`.
/// Alternatively, use `ConstraintLayoutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintLayoutProtocol: LayoutManagerProtocol, BuildableProtocol {
        /// Untyped pointer to the underlying `GtkConstraintLayout` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintLayout` instance.
    var constraint_layout_ptr: UnsafeMutablePointer<GtkConstraintLayout>! { get }

    /// Required Initialiser for types conforming to `ConstraintLayoutProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// A layout manager using constraints to describe relations between widgets.
/// 
/// `GtkConstraintLayout` is a layout manager that uses relations between
/// widget attributes, expressed via [class`Gtk.Constraint`] instances, to
/// measure and allocate widgets.
/// 
/// ### How do constraints work
/// 
/// Constraints are objects defining the relationship between attributes
/// of a widget; you can read the description of the [class`Gtk.Constraint`]
/// class to have a more in depth definition.
/// 
/// By taking multiple constraints and applying them to the children of
/// a widget using `GtkConstraintLayout`, it's possible to describe
/// complex layout policies; each constraint applied to a child or to the parent
/// widgets contributes to the full description of the layout, in terms of
/// parameters for resolving the value of each attribute.
/// 
/// It is important to note that a layout is defined by the totality of
/// constraints; removing a child, or a constraint, from an existing layout
/// without changing the remaining constraints may result in an unstable
/// or unsolvable layout.
/// 
/// Constraints have an implicit "reading order"; you should start describing
/// each edge of each child, as well as their relationship with the parent
/// container, from the top left (or top right, in RTL languages), horizontally
/// first, and then vertically.
/// 
/// A constraint-based layout with too few constraints can become "unstable",
/// that is: have more than one solution. The behavior of an unstable layout
/// is undefined.
/// 
/// A constraint-based layout with conflicting constraints may be unsolvable,
/// and lead to an unstable layout. You can use the [property`Gtk.Constraint:strength`]
/// property of [class`Gtk.Constraint`] to "nudge" the layout towards a solution.
/// 
/// ### GtkConstraintLayout as GtkBuildable
/// 
/// `GtkConstraintLayout` implements the [iface`Gtk.Buildable`] interface and
/// has a custom "constraints" element which allows describing constraints in
/// a [class`Gtk.Builder`] UI file.
/// 
/// An example of a UI definition fragment specifying a constraint:
/// 
/// ```xml
///   &lt;object class="GtkConstraintLayout"&gt;
///     &lt;constraints&gt;
///       &lt;constraint target="button" target-attribute="start"
///                   relation="eq"
///                   source="super" source-attribute="start"
///                   constant="12"
///                   strength="required" /&gt;
///       &lt;constraint target="button" target-attribute="width"
///                   relation="ge"
///                   constant="250"
///                   strength="strong" /&gt;
///     &lt;/constraints&gt;
///   &lt;/object&gt;
/// ```
/// 
/// The definition above will add two constraints to the GtkConstraintLayout:
/// 
///  - a required constraint between the leading edge of "button" and
///    the leading edge of the widget using the constraint layout, plus
///    12 pixels
///  - a strong, constant constraint making the width of "button" greater
///    than, or equal to 250 pixels
/// 
/// The "target" and "target-attribute" attributes are required.
/// 
/// The "source" and "source-attribute" attributes of the "constraint"
/// element are optional; if they are not specified, the constraint is
/// assumed to be a constant.
/// 
/// The "relation" attribute is optional; if not specified, the constraint
/// is assumed to be an equality.
/// 
/// The "strength" attribute is optional; if not specified, the constraint
/// is assumed to be required.
/// 
/// The "source" and "target" attributes can be set to "super" to indicate
/// that the constraint target is the widget using the GtkConstraintLayout.
/// 
/// There can be "constant" and "multiplier" attributes.
/// 
/// Additionally, the "constraints" element can also contain a description
/// of the `GtkConstraintGuides` used by the layout:
/// 
/// ```xml
///   &lt;constraints&gt;
///     &lt;guide min-width="100" max-width="500" name="hspace"/&gt;
///     &lt;guide min-height="64" nat-height="128" name="vspace" strength="strong"/&gt;
///   &lt;/constraints&gt;
/// ```
/// 
/// The "guide" element has the following optional attributes:
/// 
///   - "min-width", "nat-width", and "max-width", describe the minimum,
///     natural, and maximum width of the guide, respectively
///   - "min-height", "nat-height", and "max-height", describe the minimum,
///     natural, and maximum height of the guide, respectively
///   - "strength" describes the strength of the constraint on the natural
///     size of the guide; if not specified, the constraint is assumed to
///     have a medium strength
///   - "name" describes a name for the guide, useful when debugging
/// 
/// ### Using the Visual Format Language
/// 
/// Complex constraints can be described using a compact syntax called VFL,
/// or *Visual Format Language*.
/// 
/// The Visual Format Language describes all the constraints on a row or
/// column, typically starting from the leading edge towards the trailing
/// one. Each element of the layout is composed by "views", which identify
/// a [iface`Gtk.ConstraintTarget`].
/// 
/// For instance:
/// 
/// ```
///   [button]-[textField]
/// ```
/// 
/// Describes a constraint that binds the trailing edge of "button" to the
/// leading edge of "textField", leaving a default space between the two.
/// 
/// Using VFL is also possible to specify predicates that describe constraints
/// on attributes like width and height:
/// 
/// ```
///   // Width must be greater than, or equal to 50
///   [`button(>=50)`]
/// 
///   // Width of button1 must be equal to width of button2
///   [`button1(==button2)`]
/// ```
/// 
/// The default orientation for a VFL description is horizontal, unless
/// otherwise specified:
/// 
/// ```
///   // horizontal orientation, default attribute: width
///   H:[`button(>=150)`]
/// 
///   // vertical orientation, default attribute: height
///   V:[`button1(==button2)`]
/// ```
/// 
/// It's also possible to specify multiple predicates, as well as their
/// strength:
/// 
/// ```
///   // minimum width of button must be 150
///   // natural width of button can be 250
///   [`button(>=150@required, ==250@medium)`]
/// ```
/// 
/// Finally, it's also possible to use simple arithmetic operators:
/// 
/// ```
///   // width of button1 must be equal to width of button2
///   // divided by 2 plus 12
///   [`button1(button2 / 2 + 12)`]
/// ```
///
/// The `ConstraintLayoutRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintLayout` instance.
/// It exposes methods that can operate on this data type through `ConstraintLayoutProtocol` conformance.
/// Use `ConstraintLayoutRef` only as an `unowned` reference to an existing `GtkConstraintLayout` instance.
///
public struct ConstraintLayoutRef: ConstraintLayoutProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkConstraintLayout` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_layout_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintLayoutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintLayout>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintLayout>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintLayout>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutProtocol`
    @inlinable init<T: ConstraintLayoutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ConstraintLayoutProtocol>(_ other: T) -> ConstraintLayoutRef { ConstraintLayoutRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkConstraintLayout` layout manager.
    @inlinable init() {
        let rv = gtk_constraint_layout_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// A layout manager using constraints to describe relations between widgets.
/// 
/// `GtkConstraintLayout` is a layout manager that uses relations between
/// widget attributes, expressed via [class`Gtk.Constraint`] instances, to
/// measure and allocate widgets.
/// 
/// ### How do constraints work
/// 
/// Constraints are objects defining the relationship between attributes
/// of a widget; you can read the description of the [class`Gtk.Constraint`]
/// class to have a more in depth definition.
/// 
/// By taking multiple constraints and applying them to the children of
/// a widget using `GtkConstraintLayout`, it's possible to describe
/// complex layout policies; each constraint applied to a child or to the parent
/// widgets contributes to the full description of the layout, in terms of
/// parameters for resolving the value of each attribute.
/// 
/// It is important to note that a layout is defined by the totality of
/// constraints; removing a child, or a constraint, from an existing layout
/// without changing the remaining constraints may result in an unstable
/// or unsolvable layout.
/// 
/// Constraints have an implicit "reading order"; you should start describing
/// each edge of each child, as well as their relationship with the parent
/// container, from the top left (or top right, in RTL languages), horizontally
/// first, and then vertically.
/// 
/// A constraint-based layout with too few constraints can become "unstable",
/// that is: have more than one solution. The behavior of an unstable layout
/// is undefined.
/// 
/// A constraint-based layout with conflicting constraints may be unsolvable,
/// and lead to an unstable layout. You can use the [property`Gtk.Constraint:strength`]
/// property of [class`Gtk.Constraint`] to "nudge" the layout towards a solution.
/// 
/// ### GtkConstraintLayout as GtkBuildable
/// 
/// `GtkConstraintLayout` implements the [iface`Gtk.Buildable`] interface and
/// has a custom "constraints" element which allows describing constraints in
/// a [class`Gtk.Builder`] UI file.
/// 
/// An example of a UI definition fragment specifying a constraint:
/// 
/// ```xml
///   &lt;object class="GtkConstraintLayout"&gt;
///     &lt;constraints&gt;
///       &lt;constraint target="button" target-attribute="start"
///                   relation="eq"
///                   source="super" source-attribute="start"
///                   constant="12"
///                   strength="required" /&gt;
///       &lt;constraint target="button" target-attribute="width"
///                   relation="ge"
///                   constant="250"
///                   strength="strong" /&gt;
///     &lt;/constraints&gt;
///   &lt;/object&gt;
/// ```
/// 
/// The definition above will add two constraints to the GtkConstraintLayout:
/// 
///  - a required constraint between the leading edge of "button" and
///    the leading edge of the widget using the constraint layout, plus
///    12 pixels
///  - a strong, constant constraint making the width of "button" greater
///    than, or equal to 250 pixels
/// 
/// The "target" and "target-attribute" attributes are required.
/// 
/// The "source" and "source-attribute" attributes of the "constraint"
/// element are optional; if they are not specified, the constraint is
/// assumed to be a constant.
/// 
/// The "relation" attribute is optional; if not specified, the constraint
/// is assumed to be an equality.
/// 
/// The "strength" attribute is optional; if not specified, the constraint
/// is assumed to be required.
/// 
/// The "source" and "target" attributes can be set to "super" to indicate
/// that the constraint target is the widget using the GtkConstraintLayout.
/// 
/// There can be "constant" and "multiplier" attributes.
/// 
/// Additionally, the "constraints" element can also contain a description
/// of the `GtkConstraintGuides` used by the layout:
/// 
/// ```xml
///   &lt;constraints&gt;
///     &lt;guide min-width="100" max-width="500" name="hspace"/&gt;
///     &lt;guide min-height="64" nat-height="128" name="vspace" strength="strong"/&gt;
///   &lt;/constraints&gt;
/// ```
/// 
/// The "guide" element has the following optional attributes:
/// 
///   - "min-width", "nat-width", and "max-width", describe the minimum,
///     natural, and maximum width of the guide, respectively
///   - "min-height", "nat-height", and "max-height", describe the minimum,
///     natural, and maximum height of the guide, respectively
///   - "strength" describes the strength of the constraint on the natural
///     size of the guide; if not specified, the constraint is assumed to
///     have a medium strength
///   - "name" describes a name for the guide, useful when debugging
/// 
/// ### Using the Visual Format Language
/// 
/// Complex constraints can be described using a compact syntax called VFL,
/// or *Visual Format Language*.
/// 
/// The Visual Format Language describes all the constraints on a row or
/// column, typically starting from the leading edge towards the trailing
/// one. Each element of the layout is composed by "views", which identify
/// a [iface`Gtk.ConstraintTarget`].
/// 
/// For instance:
/// 
/// ```
///   [button]-[textField]
/// ```
/// 
/// Describes a constraint that binds the trailing edge of "button" to the
/// leading edge of "textField", leaving a default space between the two.
/// 
/// Using VFL is also possible to specify predicates that describe constraints
/// on attributes like width and height:
/// 
/// ```
///   // Width must be greater than, or equal to 50
///   [`button(>=50)`]
/// 
///   // Width of button1 must be equal to width of button2
///   [`button1(==button2)`]
/// ```
/// 
/// The default orientation for a VFL description is horizontal, unless
/// otherwise specified:
/// 
/// ```
///   // horizontal orientation, default attribute: width
///   H:[`button(>=150)`]
/// 
///   // vertical orientation, default attribute: height
///   V:[`button1(==button2)`]
/// ```
/// 
/// It's also possible to specify multiple predicates, as well as their
/// strength:
/// 
/// ```
///   // minimum width of button must be 150
///   // natural width of button can be 250
///   [`button(>=150@required, ==250@medium)`]
/// ```
/// 
/// Finally, it's also possible to use simple arithmetic operators:
/// 
/// ```
///   // width of button1 must be equal to width of button2
///   // divided by 2 plus 12
///   [`button1(button2 / 2 + 12)`]
/// ```
///
/// The `ConstraintLayout` type acts as a reference-counted owner of an underlying `GtkConstraintLayout` instance.
/// It provides the methods that can operate on this data type through `ConstraintLayoutProtocol` conformance.
/// Use `ConstraintLayout` as a strong reference or owner of a `GtkConstraintLayout` instance.
///
open class ConstraintLayout: LayoutManager, ConstraintLayoutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraintLayout>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraintLayout>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraintLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraintLayout>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstraintLayout`.
    /// i.e., ownership is transferred to the `ConstraintLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraintLayout>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutProtocol`
    /// Will retain `GtkConstraintLayout`.
    /// - Parameter other: an instance of a related type that implements `ConstraintLayoutProtocol`
    @inlinable public init<T: ConstraintLayoutProtocol>(constraintLayout other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkConstraintLayout` layout manager.
    @inlinable public init() {
        let rv = gtk_constraint_layout_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no ConstraintLayout properties

public enum ConstraintLayoutSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: ConstraintLayout has no signals
// MARK: ConstraintLayout Class: ConstraintLayoutProtocol extension (methods and fields)
public extension ConstraintLayoutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintLayout` instance.
    @inlinable var constraint_layout_ptr: UnsafeMutablePointer<GtkConstraintLayout>! { return ptr?.assumingMemoryBound(to: GtkConstraintLayout.self) }

    /// Adds a constraint to the layout manager.
    /// 
    /// The [property`Gtk.Constraint:source`] and [property`Gtk.Constraint:target`]
    /// properties of `constraint` can be:
    /// 
    ///  - set to `NULL` to indicate that the constraint refers to the
    ///    widget using `layout`
    ///  - set to the [class`Gtk.Widget`] using `layout`
    ///  - set to a child of the [class`Gtk.Widget`] using `layout`
    ///  - set to a [class`Gtk.ConstraintGuide`] that is part of `layout`
    /// 
    /// The `layout` acquires the ownership of `constraint` after calling
    /// this function.
    @inlinable func add<ConstraintT: ConstraintProtocol>(constraint: ConstraintT) {
        gtk_constraint_layout_add_constraint(constraint_layout_ptr, constraint.constraint_ptr)
    
    }


    // *** addConstraintsFromDescription() is not available because it has a varargs (...) parameter!


    /// Creates a list of constraints from a VFL description.
    /// 
    /// The Visual Format Language, VFL, is based on Apple's AutoLayout [VFL](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html).
    /// 
    /// The `views` dictionary is used to match [iface`Gtk.ConstraintTarget`]
    /// instances to the symbolic view name inside the VFL.
    /// 
    /// The VFL grammar is:
    /// 
    /// ```
    ///        &lt;visualFormatString&gt; = (&lt;orientation&gt;)?
    ///                               (&lt;superview&gt;&lt;connection&gt;)?
    ///                               &lt;view&gt;`(<connection><view>)`*
    ///                               (&lt;connection&gt;&lt;superview&gt;)?
    ///               &lt;orientation&gt; = 'H' | 'V'
    ///                 &lt;superview&gt; = '|'
    ///                &lt;connection&gt; = '' | '-' &lt;predicateList&gt; '-' | '-'
    ///             &lt;predicateList&gt; = &lt;simplePredicate&gt; | &lt;predicateListWithParens&gt;
    ///           &lt;simplePredicate&gt; = &lt;metricName&gt; | &lt;positiveNumber&gt;
    ///   &lt;predicateListWithParens&gt; = '(' &lt;predicate&gt; (',' &lt;predicate&gt;)* ')'
    ///                 &lt;predicate&gt; = (&lt;relation&gt;)? &lt;objectOfPredicate&gt; (&lt;operatorList&gt;)? ('@' &lt;priority&gt;)?
    ///                  &lt;relation&gt; = '==' | '&lt;=' | '&gt;='
    ///         &lt;objectOfPredicate&gt; = &lt;constant&gt; | &lt;viewName&gt; | ('.' &lt;attributeName&gt;)?
    ///                  &lt;priority&gt; = &lt;positiveNumber&gt; | 'required' | 'strong' | 'medium' | 'weak'
    ///                  &lt;constant&gt; = &lt;number&gt;
    ///              &lt;operatorList&gt; = (&lt;multiplyOperator&gt;)? (&lt;addOperator&gt;)?
    ///          &lt;multiplyOperator&gt; = [ '*' | '/' ] &lt;positiveNumber&gt;
    ///               &lt;addOperator&gt; = [ '+' | '-' ] &lt;positiveNumber&gt;
    ///                  &lt;viewName&gt; = [A-Za-z_]([A-Za-z0-9_]*) // A C identifier
    ///                &lt;metricName&gt; = [A-Za-z_]([A-Za-z0-9_]*) // A C identifier
    ///             &lt;attributeName&gt; = 'top' | 'bottom' | 'left' | 'right' | 'width' | 'height' |
    ///                               'start' | 'end' | 'centerX' | 'centerY' | 'baseline'
    ///            &lt;positiveNumber&gt; // A positive real number parseable by `g_ascii_strtod()`
    ///                    &lt;number&gt; // A real number parseable by `g_ascii_strtod()`
    /// ```
    /// 
    /// **Note**: The VFL grammar used by GTK is slightly different than the one
    /// defined by Apple, as it can use symbolic values for the constraint's
    /// strength instead of numeric values; additionally, GTK allows adding
    /// simple arithmetic operations inside predicates.
    /// 
    /// Examples of VFL descriptions are:
    /// 
    /// ```
    ///   // Default spacing
    ///   [button]-[textField]
    /// 
    ///   // Width constraint
    ///   [`button(>=50)`]
    /// 
    ///   // Connection to super view
    ///   |-50-[purpleBox]-50-|
    /// 
    ///   // Vertical layout
    ///   V:[topField]-10-[bottomField]
    /// 
    ///   // Flush views
    ///   [maroonView](#blueView)
    /// 
    ///   // Priority
    ///   [`button(100@strong)`]
    /// 
    ///   // Equal widths
    ///   [`button1(==button2)`]
    /// 
    ///   // Multiple predicates
    ///   [`flexibleButton(>=70,<=100)`]
    /// 
    ///   // A complete line of layout
    ///   |-[find]-[findNext]-[`findField(>=20)`]-|
    /// 
    ///   // Operators
    ///   [`button1(button2 / 3 + 50)`]
    /// 
    ///   // Named attributes
    ///   [`button1(==button2.height)`]
    /// ```
    @inlinable func addConstraintsFromDescriptionv<HashTableT: GLib.HashTableProtocol>(lines: UnsafePointer<UnsafePointer<CChar>?>!, nLines: Int, hspacing: Int, vspacing: Int, views: HashTableT) throws -> GLib.ListRef! {
        var error: UnsafeMutablePointer<GError>?
        let rv = GLib.ListRef(gtk_constraint_layout_add_constraints_from_descriptionv(constraint_layout_ptr, lines, gsize(nLines), gint(hspacing), gint(vspacing), views.hash_table_ptr, &error))
        if let error = error { throw GLibError(error) }
        return rv
    }

    /// Adds a guide to `layout`.
    /// 
    /// A guide can be used as the source or target of constraints,
    /// like a widget, but it is not visible.
    /// 
    /// The `layout` acquires the ownership of `guide` after calling
    /// this function.
    @inlinable func add<ConstraintGuideT: ConstraintGuideProtocol>(guide: ConstraintGuideT) {
        gtk_constraint_layout_add_guide(constraint_layout_ptr, guide.constraint_guide_ptr)
    
    }

    /// Returns a `GListModel` to track the constraints that are
    /// part of the layout.
    /// 
    /// Calling this function will enable extra internal bookkeeping
    /// to track constraints and emit signals on the returned listmodel.
    /// It may slow down operations a lot.
    /// 
    /// Applications should try hard to avoid calling this function
    /// because of the slowdowns.
    @inlinable func observeConstraints() -> GIO.ListModelRef! {
        let rv = GIO.ListModelRef(gtk_constraint_layout_observe_constraints(constraint_layout_ptr))
        return rv
    }

    /// Returns a `GListModel` to track the guides that are
    /// part of the layout.
    /// 
    /// Calling this function will enable extra internal bookkeeping
    /// to track guides and emit signals on the returned listmodel.
    /// It may slow down operations a lot.
    /// 
    /// Applications should try hard to avoid calling this function
    /// because of the slowdowns.
    @inlinable func observeGuides() -> GIO.ListModelRef! {
        let rv = GIO.ListModelRef(gtk_constraint_layout_observe_guides(constraint_layout_ptr))
        return rv
    }

    /// Removes all constraints from the layout manager.
    @inlinable func removeAllConstraints() {
        gtk_constraint_layout_remove_all_constraints(constraint_layout_ptr)
    
    }

    /// Removes `constraint` from the layout manager,
    /// so that it no longer influences the layout.
    @inlinable func remove<ConstraintT: ConstraintProtocol>(constraint: ConstraintT) {
        gtk_constraint_layout_remove_constraint(constraint_layout_ptr, constraint.constraint_ptr)
    
    }

    /// Removes `guide` from the layout manager,
    /// so that it no longer influences the layout.
    @inlinable func remove<ConstraintGuideT: ConstraintGuideProtocol>(guide: ConstraintGuideT) {
        gtk_constraint_layout_remove_guide(constraint_layout_ptr, guide.constraint_guide_ptr)
    
    }


}



// MARK: - ConstraintLayoutChild Class

/// `GtkLayoutChild` subclass for children in a `GtkConstraintLayout`.
///
/// The `ConstraintLayoutChildProtocol` protocol exposes the methods and properties of an underlying `GtkConstraintLayoutChild` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `ConstraintLayoutChild`.
/// Alternatively, use `ConstraintLayoutChildRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol ConstraintLayoutChildProtocol: LayoutChildProtocol {
        /// Untyped pointer to the underlying `GtkConstraintLayoutChild` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkConstraintLayoutChild` instance.
    var constraint_layout_child_ptr: UnsafeMutablePointer<GtkConstraintLayoutChild>! { get }

    /// Required Initialiser for types conforming to `ConstraintLayoutChildProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkLayoutChild` subclass for children in a `GtkConstraintLayout`.
///
/// The `ConstraintLayoutChildRef` type acts as a lightweight Swift reference to an underlying `GtkConstraintLayoutChild` instance.
/// It exposes methods that can operate on this data type through `ConstraintLayoutChildProtocol` conformance.
/// Use `ConstraintLayoutChildRef` only as an `unowned` reference to an existing `GtkConstraintLayoutChild` instance.
///
public struct ConstraintLayoutChildRef: ConstraintLayoutChildProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkConstraintLayoutChild` instance.
    /// For type-safe access, use the generated, typed pointer `constraint_layout_child_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension ConstraintLayoutChildRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkConstraintLayoutChild>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkConstraintLayoutChild>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkConstraintLayoutChild>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkConstraintLayoutChild>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutChildProtocol`
    @inlinable init<T: ConstraintLayoutChildProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: ConstraintLayoutChildProtocol>(_ other: T) -> ConstraintLayoutChildRef { ConstraintLayoutChildRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

    }

/// `GtkLayoutChild` subclass for children in a `GtkConstraintLayout`.
///
/// The `ConstraintLayoutChild` type acts as a reference-counted owner of an underlying `GtkConstraintLayoutChild` instance.
/// It provides the methods that can operate on this data type through `ConstraintLayoutChildProtocol` conformance.
/// Use `ConstraintLayoutChild` as a strong reference or owner of a `GtkConstraintLayoutChild` instance.
///
open class ConstraintLayoutChild: LayoutChild, ConstraintLayoutChildProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkConstraintLayoutChild>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkConstraintLayoutChild>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkConstraintLayoutChild>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkConstraintLayoutChild>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkConstraintLayoutChild`.
    /// i.e., ownership is transferred to the `ConstraintLayoutChild` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkConstraintLayoutChild>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `ConstraintLayoutChildProtocol`
    /// Will retain `GtkConstraintLayoutChild`.
    /// - Parameter other: an instance of a related type that implements `ConstraintLayoutChildProtocol`
    @inlinable public init<T: ConstraintLayoutChildProtocol>(constraintLayoutChild other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `ConstraintLayoutChildProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }



}

public enum ConstraintLayoutChildPropertyName: String, PropertyNameProtocol {
    /// The widget that is associated to the `GtkLayoutChild` instance.
    case childWidget = "child-widget"
    /// The layout manager that created the `GtkLayoutChild` instance.
    case layoutManager = "layout-manager"
}

public extension ConstraintLayoutChildProtocol {
    /// Bind a `ConstraintLayoutChildPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: ConstraintLayoutChildPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a ConstraintLayoutChild property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: ConstraintLayoutChildPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a ConstraintLayoutChild property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: ConstraintLayoutChildPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum ConstraintLayoutChildSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// The widget that is associated to the `GtkLayoutChild` instance.
    case notifyChildWidget = "notify::child-widget"
    /// The layout manager that created the `GtkLayoutChild` instance.
    case notifyLayoutManager = "notify::layout-manager"
}

// MARK: ConstraintLayoutChild has no signals
// MARK: ConstraintLayoutChild Class: ConstraintLayoutChildProtocol extension (methods and fields)
public extension ConstraintLayoutChildProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkConstraintLayoutChild` instance.
    @inlinable var constraint_layout_child_ptr: UnsafeMutablePointer<GtkConstraintLayoutChild>! { return ptr?.assumingMemoryBound(to: GtkConstraintLayoutChild.self) }



}



// MARK: - CssProvider Class

/// `GtkCssProvider` is an object implementing the `GtkStyleProvider` interface
/// for CSS.
/// 
/// It is able to parse CSS-like input in order to style widgets.
/// 
/// An application can make GTK parse a specific CSS style sheet by calling
/// [method`Gtk.CssProvider.load_from_file`] or
/// [method`Gtk.CssProvider.load_from_resource`]
/// and adding the provider with [method`Gtk.StyleContext.add_provider`] or
/// [func`Gtk.StyleContext.add_provider_for_display`].
/// 
/// In addition, certain files will be read when GTK is initialized.
/// First, the file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it
/// exists. Then, GTK loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// where `THEME` is the name of the current theme (see the
/// [property`Gtk.Settings:gtk-theme-name`] setting), `VARIANT` is the
/// variant to load (see the
/// [property`Gtk.Settings:gtk-application-prefer-dark-theme`] setting),
/// `DATADIR` is the prefix configured when GTK was compiled (unless
/// overridden by the `GTK_DATA_PREFIX` environment variable), and
/// `VERSION` is the GTK version number. If no file is found for the
/// current version, GTK tries older versions all the way back to 4.0.
/// 
/// To track errors while loading CSS, connect to the
/// [signal`Gtk.CssProvider::parsing-error`] signal.
///
/// The `CssProviderProtocol` protocol exposes the methods and properties of an underlying `GtkCssProvider` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CssProvider`.
/// Alternatively, use `CssProviderRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CssProviderProtocol: GLibObject.ObjectProtocol, StyleProviderProtocol {
        /// Untyped pointer to the underlying `GtkCssProvider` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCssProvider` instance.
    var css_provider_ptr: UnsafeMutablePointer<GtkCssProvider>! { get }

    /// Required Initialiser for types conforming to `CssProviderProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCssProvider` is an object implementing the `GtkStyleProvider` interface
/// for CSS.
/// 
/// It is able to parse CSS-like input in order to style widgets.
/// 
/// An application can make GTK parse a specific CSS style sheet by calling
/// [method`Gtk.CssProvider.load_from_file`] or
/// [method`Gtk.CssProvider.load_from_resource`]
/// and adding the provider with [method`Gtk.StyleContext.add_provider`] or
/// [func`Gtk.StyleContext.add_provider_for_display`].
/// 
/// In addition, certain files will be read when GTK is initialized.
/// First, the file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it
/// exists. Then, GTK loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// where `THEME` is the name of the current theme (see the
/// [property`Gtk.Settings:gtk-theme-name`] setting), `VARIANT` is the
/// variant to load (see the
/// [property`Gtk.Settings:gtk-application-prefer-dark-theme`] setting),
/// `DATADIR` is the prefix configured when GTK was compiled (unless
/// overridden by the `GTK_DATA_PREFIX` environment variable), and
/// `VERSION` is the GTK version number. If no file is found for the
/// current version, GTK tries older versions all the way back to 4.0.
/// 
/// To track errors while loading CSS, connect to the
/// [signal`Gtk.CssProvider::parsing-error`] signal.
///
/// The `CssProviderRef` type acts as a lightweight Swift reference to an underlying `GtkCssProvider` instance.
/// It exposes methods that can operate on this data type through `CssProviderProtocol` conformance.
/// Use `CssProviderRef` only as an `unowned` reference to an existing `GtkCssProvider` instance.
///
public struct CssProviderRef: CssProviderProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCssProvider` instance.
    /// For type-safe access, use the generated, typed pointer `css_provider_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CssProviderRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCssProvider>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCssProvider>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCssProvider>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCssProvider>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CssProviderProtocol`
    @inlinable init<T: CssProviderProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CssProviderProtocol>(_ other: T) -> CssProviderRef { CssProviderRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Returns a newly created `GtkCssProvider`.
    @inlinable init() {
        let rv = gtk_css_provider_new()
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCssProvider` is an object implementing the `GtkStyleProvider` interface
/// for CSS.
/// 
/// It is able to parse CSS-like input in order to style widgets.
/// 
/// An application can make GTK parse a specific CSS style sheet by calling
/// [method`Gtk.CssProvider.load_from_file`] or
/// [method`Gtk.CssProvider.load_from_resource`]
/// and adding the provider with [method`Gtk.StyleContext.add_provider`] or
/// [func`Gtk.StyleContext.add_provider_for_display`].
/// 
/// In addition, certain files will be read when GTK is initialized.
/// First, the file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it
/// exists. Then, GTK loads the first existing file among
/// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
/// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
/// where `THEME` is the name of the current theme (see the
/// [property`Gtk.Settings:gtk-theme-name`] setting), `VARIANT` is the
/// variant to load (see the
/// [property`Gtk.Settings:gtk-application-prefer-dark-theme`] setting),
/// `DATADIR` is the prefix configured when GTK was compiled (unless
/// overridden by the `GTK_DATA_PREFIX` environment variable), and
/// `VERSION` is the GTK version number. If no file is found for the
/// current version, GTK tries older versions all the way back to 4.0.
/// 
/// To track errors while loading CSS, connect to the
/// [signal`Gtk.CssProvider::parsing-error`] signal.
///
/// The `CssProvider` type acts as a reference-counted owner of an underlying `GtkCssProvider` instance.
/// It provides the methods that can operate on this data type through `CssProviderProtocol` conformance.
/// Use `CssProvider` as a strong reference or owner of a `GtkCssProvider` instance.
///
open class CssProvider: GLibObject.Object, CssProviderProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCssProvider>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCssProvider>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCssProvider>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCssProvider>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCssProvider`.
    /// i.e., ownership is transferred to the `CssProvider` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCssProvider>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CssProviderProtocol`
    /// Will retain `GtkCssProvider`.
    /// - Parameter other: an instance of a related type that implements `CssProviderProtocol`
    @inlinable public init<T: CssProviderProtocol>(cssProvider other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CssProviderProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Returns a newly created `GtkCssProvider`.
    @inlinable public init() {
        let rv = gtk_css_provider_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no CssProvider properties

public enum CssProviderSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Signals that a parsing error occurred.
    /// 
    /// The `path`, `line` and `position` describe the actual location of
    /// the error as accurately as possible.
    /// 
    /// Parsing errors are never fatal, so the parsing will resume after
    /// the error. Errors may however cause parts of the given data or
    /// even all of it to not be parsed at all. So it is a useful idea
    /// to check that the parsing succeeds by connecting to this signal.
    /// 
    /// Note that this signal may be emitted at any time as the css provider
    /// may opt to defer parsing parts or all of the input to a later time
    /// than when a loading function was called.
    case parsingError = "parsing-error"

}

// MARK: CssProvider signals
public extension CssProviderProtocol {
    /// Connect a Swift signal handler to the given, typed `CssProviderSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CssProviderSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `CssProviderSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: CssProviderSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Signals that a parsing error occurred.
    /// 
    /// The `path`, `line` and `position` describe the actual location of
    /// the error as accurately as possible.
    /// 
    /// Parsing errors are never fatal, so the parsing will resume after
    /// the error. Errors may however cause parts of the given data or
    /// even all of it to not be parsed at all. So it is a useful idea
    /// to check that the parsing succeeds by connecting to this signal.
    /// 
    /// Note that this signal may be emitted at any time as the css provider
    /// may opt to defer parsing parts or all of the input to a later time
    /// than when a loading function was called.
    /// - Note: This represents the underlying `parsing-error` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter section: section the error happened in
    /// - Parameter error: The parsing error
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `parsingError` signal is emitted
    @discardableResult @inlinable func onParsingError(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: CssProviderRef, _ section: CssSectionRef, _ error: GLib.ErrorRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder3<CssProviderRef, CssSectionRef, GLib.ErrorRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, arg2, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(CssProviderRef(raw: unownedSelf), CssSectionRef(raw: arg1), GLib.ErrorRef(raw: arg2))
            return output
        }
        return connect(
            signal: .parsingError,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `parsing-error` signal for using the `connect(signal:)` methods
    static var parsingErrorSignal: CssProviderSignalName { .parsingError }
    
    
}

// MARK: CssProvider Class: CssProviderProtocol extension (methods and fields)
public extension CssProviderProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCssProvider` instance.
    @inlinable var css_provider_ptr: UnsafeMutablePointer<GtkCssProvider>! { return ptr?.assumingMemoryBound(to: GtkCssProvider.self) }

    /// Loads `data` into `css_provider`.
    /// 
    /// This clears any previously loaded information.
    @inlinable func load(from data: UnsafePointer<CChar>!, length: gssize) {
        gtk_css_provider_load_from_data(css_provider_ptr, data, length)
    
    }

    /// Loads the data contained in `file` into `css_provider`.
    /// 
    /// This clears any previously loaded information.
    @inlinable func load<FileT: GIO.FileProtocol>(from file: FileT) {
        gtk_css_provider_load_from_file(css_provider_ptr, file.file_ptr)
    
    }

    /// Loads the data contained in `path` into `css_provider`.
    /// 
    /// This clears any previously loaded information.
    @inlinable func load(from path: UnsafePointer<CChar>!) {
        gtk_css_provider_load_from_path(css_provider_ptr, path)
    
    }

    /// Loads the data contained in the resource at `resource_path` into
    /// the `css_provider`.
    /// 
    /// This clears any previously loaded information.
    @inlinable func loadFromResource(resourcePath: UnsafePointer<CChar>!) {
        gtk_css_provider_load_from_resource(css_provider_ptr, resourcePath)
    
    }

    /// Loads a theme from the usual theme paths.
    /// 
    /// The actual process of finding the theme might change between
    /// releases, but it is guaranteed that this function uses the same
    /// mechanism to load the theme that GTK uses for loading its own theme.
    @inlinable func loadNamed(name: UnsafePointer<CChar>!, variant: UnsafePointer<CChar>? = nil) {
        gtk_css_provider_load_named(css_provider_ptr, name, variant)
    
    }

    /// Converts the `provider` into a string representation in CSS
    /// format.
    /// 
    /// Using [method`Gtk.CssProvider.load_from_data`] with the return
    /// value from this function on a new provider created with
    /// [ctor`Gtk.CssProvider.new`] will basically create a duplicate
    /// of this `provider`.
    @inlinable func toString() -> String! {
        let rv = gtk_css_provider_to_string(css_provider_ptr).map({ String(cString: $0) })
        return rv
    }

    @inlinable var parentInstance: GObject {
        get {
            let rv = css_provider_ptr.pointee.parent_instance
            return rv
        }
    }

}



// MARK: - CustomFilter Class

/// `GtkCustomFilter` determines whether to include items with a callback.
///
/// The `CustomFilterProtocol` protocol exposes the methods and properties of an underlying `GtkCustomFilter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CustomFilter`.
/// Alternatively, use `CustomFilterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CustomFilterProtocol: FilterProtocol {
        /// Untyped pointer to the underlying `GtkCustomFilter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCustomFilter` instance.
    var custom_filter_ptr: UnsafeMutablePointer<GtkCustomFilter>! { get }

    /// Required Initialiser for types conforming to `CustomFilterProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCustomFilter` determines whether to include items with a callback.
///
/// The `CustomFilterRef` type acts as a lightweight Swift reference to an underlying `GtkCustomFilter` instance.
/// It exposes methods that can operate on this data type through `CustomFilterProtocol` conformance.
/// Use `CustomFilterRef` only as an `unowned` reference to an existing `GtkCustomFilter` instance.
///
public struct CustomFilterRef: CustomFilterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCustomFilter` instance.
    /// For type-safe access, use the generated, typed pointer `custom_filter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CustomFilterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCustomFilter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCustomFilter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCustomFilter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCustomFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CustomFilterProtocol`
    @inlinable init<T: CustomFilterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CustomFilterProtocol>(_ other: T) -> CustomFilterRef { CustomFilterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new filter using the given `match_func` to filter
    /// items.
    /// 
    /// If `match_func` is `nil`, the filter matches all items.
    /// 
    /// If the filter func changes its filtering behavior,
    /// `gtk_filter_changed()` needs to be called.
    @inlinable init( matchFunc: GtkCustomFilterFunc? = nil, userData: gpointer! = nil, userDestroy: GDestroyNotify?) {
        let rv = gtk_custom_filter_new(matchFunc, userData, userDestroy)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCustomFilter` determines whether to include items with a callback.
///
/// The `CustomFilter` type acts as a reference-counted owner of an underlying `GtkCustomFilter` instance.
/// It provides the methods that can operate on this data type through `CustomFilterProtocol` conformance.
/// Use `CustomFilter` as a strong reference or owner of a `GtkCustomFilter` instance.
///
open class CustomFilter: Filter, CustomFilterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCustomFilter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCustomFilter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCustomFilter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCustomFilter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCustomFilter`.
    /// i.e., ownership is transferred to the `CustomFilter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCustomFilter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CustomFilterProtocol`
    /// Will retain `GtkCustomFilter`.
    /// - Parameter other: an instance of a related type that implements `CustomFilterProtocol`
    @inlinable public init<T: CustomFilterProtocol>(customFilter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomFilterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new filter using the given `match_func` to filter
    /// items.
    /// 
    /// If `match_func` is `nil`, the filter matches all items.
    /// 
    /// If the filter func changes its filtering behavior,
    /// `gtk_filter_changed()` needs to be called.
    @inlinable public init( matchFunc: GtkCustomFilterFunc? = nil, userData: gpointer! = nil, userDestroy: GDestroyNotify?) {
        let rv = gtk_custom_filter_new(matchFunc, userData, userDestroy)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no CustomFilter properties

public enum CustomFilterSignalName: String, SignalNameProtocol {
    /// Emitted whenever the filter changed.
    /// 
    /// Users of the filter should then check items again via
    /// [method`Gtk.Filter.match`].
    /// 
    /// `GtkFilterListModel` handles this signal automatically.
    /// 
    /// Depending on the `change` parameter, not all items need
    /// to be checked, but only some. Refer to the [enum`Gtk.FilterChange`]
    /// documentation for details.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: CustomFilter has no signals
// MARK: CustomFilter Class: CustomFilterProtocol extension (methods and fields)
public extension CustomFilterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCustomFilter` instance.
    @inlinable var custom_filter_ptr: UnsafeMutablePointer<GtkCustomFilter>! { return ptr?.assumingMemoryBound(to: GtkCustomFilter.self) }

    /// Sets the function used for filtering items.
    /// 
    /// If `match_func` is `nil`, the filter matches all items.
    /// 
    /// If the filter func changes its filtering behavior,
    /// `gtk_filter_changed()` needs to be called.
    /// 
    /// If a previous function was set, its `user_destroy` will be
    /// called now.
    @inlinable func setFilterFunc(matchFunc: GtkCustomFilterFunc? = nil, userData: gpointer! = nil, userDestroy: GDestroyNotify?) {
        gtk_custom_filter_set_filter_func(custom_filter_ptr, matchFunc, userData, userDestroy)
    
    }


}



// MARK: - CustomLayout Class

/// `GtkCustomLayout` uses closures for size negotiation.
/// 
/// A `GtkCustomLayout `uses closures matching to the old `GtkWidget`
/// virtual functions for size negotiation, as a convenience API to
/// ease the porting towards the corresponding `GtkLayoutManager
/// virtual functions.
///
/// The `CustomLayoutProtocol` protocol exposes the methods and properties of an underlying `GtkCustomLayout` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CustomLayout`.
/// Alternatively, use `CustomLayoutRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CustomLayoutProtocol: LayoutManagerProtocol {
        /// Untyped pointer to the underlying `GtkCustomLayout` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCustomLayout` instance.
    var custom_layout_ptr: UnsafeMutablePointer<GtkCustomLayout>! { get }

    /// Required Initialiser for types conforming to `CustomLayoutProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCustomLayout` uses closures for size negotiation.
/// 
/// A `GtkCustomLayout `uses closures matching to the old `GtkWidget`
/// virtual functions for size negotiation, as a convenience API to
/// ease the porting towards the corresponding `GtkLayoutManager
/// virtual functions.
///
/// The `CustomLayoutRef` type acts as a lightweight Swift reference to an underlying `GtkCustomLayout` instance.
/// It exposes methods that can operate on this data type through `CustomLayoutProtocol` conformance.
/// Use `CustomLayoutRef` only as an `unowned` reference to an existing `GtkCustomLayout` instance.
///
public struct CustomLayoutRef: CustomLayoutProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCustomLayout` instance.
    /// For type-safe access, use the generated, typed pointer `custom_layout_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CustomLayoutRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCustomLayout>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCustomLayout>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCustomLayout>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCustomLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CustomLayoutProtocol`
    @inlinable init<T: CustomLayoutProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CustomLayoutProtocol>(_ other: T) -> CustomLayoutRef { CustomLayoutRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new legacy layout manager.
    /// 
    /// Legacy layout managers map to the old `GtkWidget` size negotiation
    /// virtual functions, and are meant to be used during the transition
    /// from layout containers to layout manager delegates.
    @inlinable init( requestMode: GtkCustomRequestModeFunc? = nil, measure: GtkCustomMeasureFunc?, allocate: GtkCustomAllocateFunc?) {
        let rv = gtk_custom_layout_new(requestMode, measure, allocate)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCustomLayout` uses closures for size negotiation.
/// 
/// A `GtkCustomLayout `uses closures matching to the old `GtkWidget`
/// virtual functions for size negotiation, as a convenience API to
/// ease the porting towards the corresponding `GtkLayoutManager
/// virtual functions.
///
/// The `CustomLayout` type acts as a reference-counted owner of an underlying `GtkCustomLayout` instance.
/// It provides the methods that can operate on this data type through `CustomLayoutProtocol` conformance.
/// Use `CustomLayout` as a strong reference or owner of a `GtkCustomLayout` instance.
///
open class CustomLayout: LayoutManager, CustomLayoutProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCustomLayout>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCustomLayout>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCustomLayout>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCustomLayout>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCustomLayout`.
    /// i.e., ownership is transferred to the `CustomLayout` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCustomLayout>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CustomLayoutProtocol`
    /// Will retain `GtkCustomLayout`.
    /// - Parameter other: an instance of a related type that implements `CustomLayoutProtocol`
    @inlinable public init<T: CustomLayoutProtocol>(customLayout other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomLayoutProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new legacy layout manager.
    /// 
    /// Legacy layout managers map to the old `GtkWidget` size negotiation
    /// virtual functions, and are meant to be used during the transition
    /// from layout containers to layout manager delegates.
    @inlinable public init( requestMode: GtkCustomRequestModeFunc? = nil, measure: GtkCustomMeasureFunc?, allocate: GtkCustomAllocateFunc?) {
        let rv = gtk_custom_layout_new(requestMode, measure, allocate)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no CustomLayout properties

public enum CustomLayoutSignalName: String, SignalNameProtocol {
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: CustomLayout has no signals
// MARK: CustomLayout Class: CustomLayoutProtocol extension (methods and fields)
public extension CustomLayoutProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCustomLayout` instance.
    @inlinable var custom_layout_ptr: UnsafeMutablePointer<GtkCustomLayout>! { return ptr?.assumingMemoryBound(to: GtkCustomLayout.self) }



}



// MARK: - CustomSorter Class

/// `GtkCustomSorter` is a `GtkSorter` implementation that sorts via a callback
/// function.
///
/// The `CustomSorterProtocol` protocol exposes the methods and properties of an underlying `GtkCustomSorter` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `CustomSorter`.
/// Alternatively, use `CustomSorterRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol CustomSorterProtocol: SorterProtocol {
        /// Untyped pointer to the underlying `GtkCustomSorter` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkCustomSorter` instance.
    var custom_sorter_ptr: UnsafeMutablePointer<GtkCustomSorter>! { get }

    /// Required Initialiser for types conforming to `CustomSorterProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// `GtkCustomSorter` is a `GtkSorter` implementation that sorts via a callback
/// function.
///
/// The `CustomSorterRef` type acts as a lightweight Swift reference to an underlying `GtkCustomSorter` instance.
/// It exposes methods that can operate on this data type through `CustomSorterProtocol` conformance.
/// Use `CustomSorterRef` only as an `unowned` reference to an existing `GtkCustomSorter` instance.
///
public struct CustomSorterRef: CustomSorterProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkCustomSorter` instance.
    /// For type-safe access, use the generated, typed pointer `custom_sorter_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension CustomSorterRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkCustomSorter>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkCustomSorter>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkCustomSorter>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkCustomSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `CustomSorterProtocol`
    @inlinable init<T: CustomSorterProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: CustomSorterProtocol>(_ other: T) -> CustomSorterRef { CustomSorterRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new `GtkSorter` that works by calling
    /// `sort_func` to compare items.
    /// 
    /// If `sort_func` is `nil`, all items are considered equal.
    @inlinable init( sortFunc: GCompareDataFunc? = nil, userData: gpointer! = nil, userDestroy: GDestroyNotify? = nil) {
        let rv = gtk_custom_sorter_new(sortFunc, userData, userDestroy)
        ptr = UnsafeMutableRawPointer(rv)
    }
}

/// `GtkCustomSorter` is a `GtkSorter` implementation that sorts via a callback
/// function.
///
/// The `CustomSorter` type acts as a reference-counted owner of an underlying `GtkCustomSorter` instance.
/// It provides the methods that can operate on this data type through `CustomSorterProtocol` conformance.
/// Use `CustomSorter` as a strong reference or owner of a `GtkCustomSorter` instance.
///
open class CustomSorter: Sorter, CustomSorterProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkCustomSorter>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkCustomSorter>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkCustomSorter>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkCustomSorter>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkCustomSorter`.
    /// i.e., ownership is transferred to the `CustomSorter` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkCustomSorter>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `CustomSorterProtocol`
    /// Will retain `GtkCustomSorter`.
    /// - Parameter other: an instance of a related type that implements `CustomSorterProtocol`
    @inlinable public init<T: CustomSorterProtocol>(customSorter other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `CustomSorterProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new `GtkSorter` that works by calling
    /// `sort_func` to compare items.
    /// 
    /// If `sort_func` is `nil`, all items are considered equal.
    @inlinable public init( sortFunc: GCompareDataFunc? = nil, userData: gpointer! = nil, userDestroy: GDestroyNotify? = nil) {
        let rv = gtk_custom_sorter_new(sortFunc, userData, userDestroy)
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


}

// MARK: no CustomSorter properties

public enum CustomSorterSignalName: String, SignalNameProtocol {
    /// Emitted whenever the sorter changed.
    /// 
    /// Users of the sorter should then update the sort order
    /// again via `gtk_sorter_compare()`.
    /// 
    /// [class`Gtk.SortListModel`] handles this signal automatically.
    /// 
    /// Depending on the `change` parameter, it may be possible to update
    /// the sort order without a full resorting. Refer to the
    /// [enum`Gtk.SorterChange`] documentation for details.
    case changed = "changed"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"

}

// MARK: CustomSorter has no signals
// MARK: CustomSorter Class: CustomSorterProtocol extension (methods and fields)
public extension CustomSorterProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkCustomSorter` instance.
    @inlinable var custom_sorter_ptr: UnsafeMutablePointer<GtkCustomSorter>! { return ptr?.assumingMemoryBound(to: GtkCustomSorter.self) }

    /// Sets (or unsets) the function used for sorting items.
    /// 
    /// If `sort_func` is `nil`, all items are considered equal.
    /// 
    /// If the sort func changes its sorting behavior,
    /// `gtk_sorter_changed()` needs to be called.
    /// 
    /// If a previous function was set, its `user_destroy` will be
    /// called now.
    @inlinable func set(sortFunc: GCompareDataFunc? = nil, userData: gpointer! = nil, userDestroy: GDestroyNotify?) {
        gtk_custom_sorter_set_sort_func(custom_sorter_ptr, sortFunc, userData, userDestroy)
    
    }


}



// MARK: - Dialog Class

/// Dialogs are a convenient way to prompt the user for a small amount
/// of input.
/// 
/// ![An example GtkDialog](dialog.png)
/// 
/// Typical uses are to display a message, ask a question, or anything else
/// that does not require extensive effort on the user’s part.
/// 
/// The main area of a `GtkDialog` is called the "content area", and is yours
/// to populate with widgets such a `GtkLabel` or `GtkEntry`, to present
/// your information, questions, or tasks to the user.
/// 
/// In addition, dialogs allow you to add "action widgets". Most commonly,
/// action widgets are buttons. Depending on the platform, action widgets may
/// be presented in the header bar at the top of the window, or at the bottom
/// of the window. To add action widgets, create your `GtkDialog` using
/// [ctor`Gtk.Dialog.new_with_buttons`], or use
/// [method`Gtk.Dialog.add_button`], [method`Gtk.Dialog.add_buttons`],
/// or [method`Gtk.Dialog.add_action_widget`].
/// 
/// `GtkDialogs` uses some heuristics to decide whether to add a close
/// button to the window decorations. If any of the action buttons use
/// the response ID `GTK_RESPONSE_CLOSE` or `GTK_RESPONSE_CANCEL`, the
/// close button is omitted.
/// 
/// Clicking a button that was added as an action widget will emit the
/// [signal`Gtk.Dialog::response`] signal with a response ID that you specified.
/// GTK will never assign a meaning to positive response IDs; these are
/// entirely user-defined. But for convenience, you can use the response
/// IDs in the [enum`Gtk.ResponseType`] enumeration (these all have values
/// less than zero). If a dialog receives a delete event, the
/// [signal`Gtk.Dialog::response`] signal will be emitted with the
/// `GTK_RESPONSE_DELETE_EVENT` response ID.
/// 
/// Dialogs are created with a call to [ctor`Gtk.Dialog.new`] or
/// [ctor`Gtk.Dialog.new_with_buttons`]. The latter is recommended; it allows
/// you to set the dialog title, some convenient flags, and add buttons.
/// 
/// A “modal” dialog (that is, one which freezes the rest of the application
/// from user input), can be created by calling [method`Gtk.Window.set_modal`]
/// on the dialog. When using [ctor`Gtk.Dialog.new_with_buttons`], you can also
/// pass the `GTK_DIALOG_MODAL` flag to make a dialog modal.
/// 
/// For the simple dialog in the following example, a [class`Gtk.MessageDialog`]
/// would save some effort. But you’d need to create the dialog contents manually
/// if you had more than a simple message in the dialog.
/// 
/// An example for simple `GtkDialog` usage:
/// 
/// ```c
/// // Function to open a dialog box with a message
/// void
/// quick_message (GtkWindow *parent, char *message)
/// {
///  GtkWidget *dialog, *label, *content_area;
///  GtkDialogFlags flags;
/// 
///  // Create the widgets
///  flags = GTK_DIALOG_DESTROY_WITH_PARENT;
///  dialog = gtk_dialog_new_with_buttons ("Message",
///                                        parent,
///                                        flags,
///                                        `_("_OK")`,
///                                        GTK_RESPONSE_NONE,
///                                        NULL);
///  content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
///  label = gtk_label_new (message);
/// 
///  // Ensure that the dialog box is destroyed when the user responds
/// 
///  g_signal_connect_swapped (dialog,
///                            "response",
///                            G_CALLBACK (gtk_window_destroy),
///                            dialog);
/// 
///  // Add the label, and show everything we’ve added
/// 
///  gtk_box_append (GTK_BOX (content_area), label);
///  gtk_widget_show (dialog);
/// }
/// ```
/// 
/// # GtkDialog as GtkBuildable
/// 
/// The `GtkDialog` implementation of the `GtkBuildable` interface exposes the
/// `content_area` as an internal child with the name “content_area”.
/// 
/// `GtkDialog` supports a custom `&lt;action-widgets&gt;` element, which can contain
/// multiple `&lt;action-widget&gt;` elements. The “response” attribute specifies a
/// numeric response, and the content of the element is the id of widget
/// (which should be a child of the dialogs `action_area`). To mark a response
/// as default, set the “default” attribute of the `&lt;action-widget&gt;` element
/// to true.
/// 
/// `GtkDialog` supports adding action widgets by specifying “action” as
/// the “type” attribute of a `&lt;child&gt;` element. The widget will be added
/// either to the action area or the headerbar of the dialog, depending
/// on the “use-header-bar” property. The response id has to be associated
/// with the action widget using the `&lt;action-widgets&gt;` element.
/// 
/// An example of a `GtkDialog` UI definition fragment:
/// 
/// ```xml
/// &lt;object class="GtkDialog" id="dialog1"&gt;
///   &lt;child type="action"&gt;
///     &lt;object class="GtkButton" id="button_cancel"/&gt;
///   &lt;/child&gt;
///   &lt;child type="action"&gt;
///     &lt;object class="GtkButton" id="button_ok"&gt;
///     &lt;/object&gt;
///   &lt;/child&gt;
///   &lt;action-widgets&gt;
///     &lt;action-widget response="cancel"&gt;button_cancel&lt;/action-widget&gt;
///     &lt;action-widget response="ok" default="true"&gt;button_ok&lt;/action-widget&gt;
///   &lt;/action-widgets&gt;
/// &lt;/object&gt;
/// ```
/// 
/// # Accessibility
/// 
/// `GtkDialog` uses the `GTK_ACCESSIBLE_ROLE_DIALOG` role.
///
/// The `DialogProtocol` protocol exposes the methods and properties of an underlying `GtkDialog` instance.
/// The default implementation of these can be found in the protocol extension below.
/// For a concrete class that implements these methods and properties, see `Dialog`.
/// Alternatively, use `DialogRef` as a lighweight, `unowned` reference if you already have an instance you just want to use.
///
public protocol DialogProtocol: WindowProtocol {
        /// Untyped pointer to the underlying `GtkDialog` instance.
    var ptr: UnsafeMutableRawPointer! { get }

    /// Typed pointer to the underlying `GtkDialog` instance.
    var dialog_ptr: UnsafeMutablePointer<GtkDialog>! { get }

    /// Required Initialiser for types conforming to `DialogProtocol`
    init(raw: UnsafeMutableRawPointer)
}

/// Dialogs are a convenient way to prompt the user for a small amount
/// of input.
/// 
/// ![An example GtkDialog](dialog.png)
/// 
/// Typical uses are to display a message, ask a question, or anything else
/// that does not require extensive effort on the user’s part.
/// 
/// The main area of a `GtkDialog` is called the "content area", and is yours
/// to populate with widgets such a `GtkLabel` or `GtkEntry`, to present
/// your information, questions, or tasks to the user.
/// 
/// In addition, dialogs allow you to add "action widgets". Most commonly,
/// action widgets are buttons. Depending on the platform, action widgets may
/// be presented in the header bar at the top of the window, or at the bottom
/// of the window. To add action widgets, create your `GtkDialog` using
/// [ctor`Gtk.Dialog.new_with_buttons`], or use
/// [method`Gtk.Dialog.add_button`], [method`Gtk.Dialog.add_buttons`],
/// or [method`Gtk.Dialog.add_action_widget`].
/// 
/// `GtkDialogs` uses some heuristics to decide whether to add a close
/// button to the window decorations. If any of the action buttons use
/// the response ID `GTK_RESPONSE_CLOSE` or `GTK_RESPONSE_CANCEL`, the
/// close button is omitted.
/// 
/// Clicking a button that was added as an action widget will emit the
/// [signal`Gtk.Dialog::response`] signal with a response ID that you specified.
/// GTK will never assign a meaning to positive response IDs; these are
/// entirely user-defined. But for convenience, you can use the response
/// IDs in the [enum`Gtk.ResponseType`] enumeration (these all have values
/// less than zero). If a dialog receives a delete event, the
/// [signal`Gtk.Dialog::response`] signal will be emitted with the
/// `GTK_RESPONSE_DELETE_EVENT` response ID.
/// 
/// Dialogs are created with a call to [ctor`Gtk.Dialog.new`] or
/// [ctor`Gtk.Dialog.new_with_buttons`]. The latter is recommended; it allows
/// you to set the dialog title, some convenient flags, and add buttons.
/// 
/// A “modal” dialog (that is, one which freezes the rest of the application
/// from user input), can be created by calling [method`Gtk.Window.set_modal`]
/// on the dialog. When using [ctor`Gtk.Dialog.new_with_buttons`], you can also
/// pass the `GTK_DIALOG_MODAL` flag to make a dialog modal.
/// 
/// For the simple dialog in the following example, a [class`Gtk.MessageDialog`]
/// would save some effort. But you’d need to create the dialog contents manually
/// if you had more than a simple message in the dialog.
/// 
/// An example for simple `GtkDialog` usage:
/// 
/// ```c
/// // Function to open a dialog box with a message
/// void
/// quick_message (GtkWindow *parent, char *message)
/// {
///  GtkWidget *dialog, *label, *content_area;
///  GtkDialogFlags flags;
/// 
///  // Create the widgets
///  flags = GTK_DIALOG_DESTROY_WITH_PARENT;
///  dialog = gtk_dialog_new_with_buttons ("Message",
///                                        parent,
///                                        flags,
///                                        `_("_OK")`,
///                                        GTK_RESPONSE_NONE,
///                                        NULL);
///  content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
///  label = gtk_label_new (message);
/// 
///  // Ensure that the dialog box is destroyed when the user responds
/// 
///  g_signal_connect_swapped (dialog,
///                            "response",
///                            G_CALLBACK (gtk_window_destroy),
///                            dialog);
/// 
///  // Add the label, and show everything we’ve added
/// 
///  gtk_box_append (GTK_BOX (content_area), label);
///  gtk_widget_show (dialog);
/// }
/// ```
/// 
/// # GtkDialog as GtkBuildable
/// 
/// The `GtkDialog` implementation of the `GtkBuildable` interface exposes the
/// `content_area` as an internal child with the name “content_area”.
/// 
/// `GtkDialog` supports a custom `&lt;action-widgets&gt;` element, which can contain
/// multiple `&lt;action-widget&gt;` elements. The “response” attribute specifies a
/// numeric response, and the content of the element is the id of widget
/// (which should be a child of the dialogs `action_area`). To mark a response
/// as default, set the “default” attribute of the `&lt;action-widget&gt;` element
/// to true.
/// 
/// `GtkDialog` supports adding action widgets by specifying “action” as
/// the “type” attribute of a `&lt;child&gt;` element. The widget will be added
/// either to the action area or the headerbar of the dialog, depending
/// on the “use-header-bar” property. The response id has to be associated
/// with the action widget using the `&lt;action-widgets&gt;` element.
/// 
/// An example of a `GtkDialog` UI definition fragment:
/// 
/// ```xml
/// &lt;object class="GtkDialog" id="dialog1"&gt;
///   &lt;child type="action"&gt;
///     &lt;object class="GtkButton" id="button_cancel"/&gt;
///   &lt;/child&gt;
///   &lt;child type="action"&gt;
///     &lt;object class="GtkButton" id="button_ok"&gt;
///     &lt;/object&gt;
///   &lt;/child&gt;
///   &lt;action-widgets&gt;
///     &lt;action-widget response="cancel"&gt;button_cancel&lt;/action-widget&gt;
///     &lt;action-widget response="ok" default="true"&gt;button_ok&lt;/action-widget&gt;
///   &lt;/action-widgets&gt;
/// &lt;/object&gt;
/// ```
/// 
/// # Accessibility
/// 
/// `GtkDialog` uses the `GTK_ACCESSIBLE_ROLE_DIALOG` role.
///
/// The `DialogRef` type acts as a lightweight Swift reference to an underlying `GtkDialog` instance.
/// It exposes methods that can operate on this data type through `DialogProtocol` conformance.
/// Use `DialogRef` only as an `unowned` reference to an existing `GtkDialog` instance.
///
public struct DialogRef: DialogProtocol, GWeakCapturing {
        /// Untyped pointer to the underlying `GtkDialog` instance.
    /// For type-safe access, use the generated, typed pointer `dialog_ptr` property instead.
    public let ptr: UnsafeMutableRawPointer!
}

public extension DialogRef {
    /// Designated initialiser from the underlying `C` data type
    @inlinable init(_ p: UnsafeMutablePointer<GtkDialog>) {
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type
    @inlinable init(_ p: UnsafePointer<GtkDialog>) {
        ptr = UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: p))
    }

    /// Conditional initialiser from an optional pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafeMutablePointer<GtkDialog>?) {
        guard let p = maybePointer else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable pointer to the underlying `C` data type
    @inlinable init!(_ maybePointer: UnsafePointer<GtkDialog>?) {
        guard let p = UnsafeMutablePointer(mutating: maybePointer) else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional `gpointer`
    @inlinable init!(gpointer g: gpointer?) {
        guard let p = g else { return nil }
        ptr = UnsafeMutableRawPointer(p)
    }

    /// Conditional initialiser from an optional, non-mutable `gconstpointer`
    @inlinable init!(gconstpointer g: gconstpointer?) {
        guard let p = UnsafeMutableRawPointer(mutating: g) else { return nil }
        ptr = p
    }

    /// Reference intialiser for a related type that implements `DialogProtocol`
    @inlinable init<T: DialogProtocol>(_ other: T) {
        ptr = other.ptr
    }

    /// This factory is syntactic sugar for setting weak pointers wrapped in `GWeak<T>`
    @inlinable static func unowned<T: DialogProtocol>(_ other: T) -> DialogRef { DialogRef(other) }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    @inlinable init<T>(cPointer: UnsafeMutablePointer<T>) {
        ptr = UnsafeMutableRawPointer(cPointer)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    @inlinable init<T>(constPointer: UnsafePointer<T>) {
        ptr = UnsafeMutableRawPointer(mutating: UnsafeRawPointer(constPointer))
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    @inlinable init(mutating raw: UnsafeRawPointer) {
        ptr = UnsafeMutableRawPointer(mutating: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    @inlinable init(raw: UnsafeMutableRawPointer) {
        ptr = raw
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    @inlinable init(opaquePointer: OpaquePointer) {
        ptr = UnsafeMutableRawPointer(opaquePointer)
    }

        /// Creates a new dialog box.
    /// 
    /// Widgets should not be packed into the `GtkWindow`
    /// directly, but into the `content_area` and `action_area`,
    /// as described above.
    @inlinable init() {
        let rv = gtk_dialog_new()
        ptr = UnsafeMutableRawPointer(rv)
    }


    // *** newWithButtons() is not available because it has a varargs (...) parameter!


    // *** newWithButtons() is not available because it has a varargs (...) parameter!

}

/// Dialogs are a convenient way to prompt the user for a small amount
/// of input.
/// 
/// ![An example GtkDialog](dialog.png)
/// 
/// Typical uses are to display a message, ask a question, or anything else
/// that does not require extensive effort on the user’s part.
/// 
/// The main area of a `GtkDialog` is called the "content area", and is yours
/// to populate with widgets such a `GtkLabel` or `GtkEntry`, to present
/// your information, questions, or tasks to the user.
/// 
/// In addition, dialogs allow you to add "action widgets". Most commonly,
/// action widgets are buttons. Depending on the platform, action widgets may
/// be presented in the header bar at the top of the window, or at the bottom
/// of the window. To add action widgets, create your `GtkDialog` using
/// [ctor`Gtk.Dialog.new_with_buttons`], or use
/// [method`Gtk.Dialog.add_button`], [method`Gtk.Dialog.add_buttons`],
/// or [method`Gtk.Dialog.add_action_widget`].
/// 
/// `GtkDialogs` uses some heuristics to decide whether to add a close
/// button to the window decorations. If any of the action buttons use
/// the response ID `GTK_RESPONSE_CLOSE` or `GTK_RESPONSE_CANCEL`, the
/// close button is omitted.
/// 
/// Clicking a button that was added as an action widget will emit the
/// [signal`Gtk.Dialog::response`] signal with a response ID that you specified.
/// GTK will never assign a meaning to positive response IDs; these are
/// entirely user-defined. But for convenience, you can use the response
/// IDs in the [enum`Gtk.ResponseType`] enumeration (these all have values
/// less than zero). If a dialog receives a delete event, the
/// [signal`Gtk.Dialog::response`] signal will be emitted with the
/// `GTK_RESPONSE_DELETE_EVENT` response ID.
/// 
/// Dialogs are created with a call to [ctor`Gtk.Dialog.new`] or
/// [ctor`Gtk.Dialog.new_with_buttons`]. The latter is recommended; it allows
/// you to set the dialog title, some convenient flags, and add buttons.
/// 
/// A “modal” dialog (that is, one which freezes the rest of the application
/// from user input), can be created by calling [method`Gtk.Window.set_modal`]
/// on the dialog. When using [ctor`Gtk.Dialog.new_with_buttons`], you can also
/// pass the `GTK_DIALOG_MODAL` flag to make a dialog modal.
/// 
/// For the simple dialog in the following example, a [class`Gtk.MessageDialog`]
/// would save some effort. But you’d need to create the dialog contents manually
/// if you had more than a simple message in the dialog.
/// 
/// An example for simple `GtkDialog` usage:
/// 
/// ```c
/// // Function to open a dialog box with a message
/// void
/// quick_message (GtkWindow *parent, char *message)
/// {
///  GtkWidget *dialog, *label, *content_area;
///  GtkDialogFlags flags;
/// 
///  // Create the widgets
///  flags = GTK_DIALOG_DESTROY_WITH_PARENT;
///  dialog = gtk_dialog_new_with_buttons ("Message",
///                                        parent,
///                                        flags,
///                                        `_("_OK")`,
///                                        GTK_RESPONSE_NONE,
///                                        NULL);
///  content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
///  label = gtk_label_new (message);
/// 
///  // Ensure that the dialog box is destroyed when the user responds
/// 
///  g_signal_connect_swapped (dialog,
///                            "response",
///                            G_CALLBACK (gtk_window_destroy),
///                            dialog);
/// 
///  // Add the label, and show everything we’ve added
/// 
///  gtk_box_append (GTK_BOX (content_area), label);
///  gtk_widget_show (dialog);
/// }
/// ```
/// 
/// # GtkDialog as GtkBuildable
/// 
/// The `GtkDialog` implementation of the `GtkBuildable` interface exposes the
/// `content_area` as an internal child with the name “content_area”.
/// 
/// `GtkDialog` supports a custom `&lt;action-widgets&gt;` element, which can contain
/// multiple `&lt;action-widget&gt;` elements. The “response” attribute specifies a
/// numeric response, and the content of the element is the id of widget
/// (which should be a child of the dialogs `action_area`). To mark a response
/// as default, set the “default” attribute of the `&lt;action-widget&gt;` element
/// to true.
/// 
/// `GtkDialog` supports adding action widgets by specifying “action” as
/// the “type” attribute of a `&lt;child&gt;` element. The widget will be added
/// either to the action area or the headerbar of the dialog, depending
/// on the “use-header-bar” property. The response id has to be associated
/// with the action widget using the `&lt;action-widgets&gt;` element.
/// 
/// An example of a `GtkDialog` UI definition fragment:
/// 
/// ```xml
/// &lt;object class="GtkDialog" id="dialog1"&gt;
///   &lt;child type="action"&gt;
///     &lt;object class="GtkButton" id="button_cancel"/&gt;
///   &lt;/child&gt;
///   &lt;child type="action"&gt;
///     &lt;object class="GtkButton" id="button_ok"&gt;
///     &lt;/object&gt;
///   &lt;/child&gt;
///   &lt;action-widgets&gt;
///     &lt;action-widget response="cancel"&gt;button_cancel&lt;/action-widget&gt;
///     &lt;action-widget response="ok" default="true"&gt;button_ok&lt;/action-widget&gt;
///   &lt;/action-widgets&gt;
/// &lt;/object&gt;
/// ```
/// 
/// # Accessibility
/// 
/// `GtkDialog` uses the `GTK_ACCESSIBLE_ROLE_DIALOG` role.
///
/// The `Dialog` type acts as a reference-counted owner of an underlying `GtkDialog` instance.
/// It provides the methods that can operate on this data type through `DialogProtocol` conformance.
/// Use `Dialog` as a strong reference or owner of a `GtkDialog` instance.
///
open class Dialog: Window, DialogProtocol {
        /// Designated initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafeMutablePointer<GtkDialog>) {
        super.init(cPointer: op)
    }

    /// Designated initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(_ op: UnsafePointer<GtkDialog>) {
        super.init(raw: UnsafeMutableRawPointer(UnsafeMutablePointer(mutating: op)))
    }

    /// Optional initialiser from a non-mutating `gpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: gpointer to the underlying object
    @inlinable override public init!(gpointer op: gpointer?) {
        guard let p = UnsafeMutableRawPointer(op) else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a non-mutating `gconstpointer` to
    /// the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable override public init!(gconstpointer op: gconstpointer?) {
        guard let p = op else { return nil }
        super.init(raw: p)
    }

    /// Optional initialiser from a constant pointer to the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafePointer<GtkDialog>?) {
        guard let p = UnsafeMutablePointer(mutating: op) else { return nil }
        super.init(cPointer: p)
    }

    /// Optional initialiser from the underlying `C` data type.
    /// This creates an instance without performing an unbalanced retain
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init!(_ op: UnsafeMutablePointer<GtkDialog>?) {
        guard let p = op else { return nil }
        super.init(cPointer: p)
    }

    /// Designated initialiser from the underlying `C` data type.
    /// Will retain `GtkDialog`.
    /// i.e., ownership is transferred to the `Dialog` instance.
    /// - Parameter op: pointer to the underlying object
    @inlinable public init(retaining op: UnsafeMutablePointer<GtkDialog>) {
        super.init(retainingCPointer: op)
    }

    /// Reference intialiser for a related type that implements `DialogProtocol`
    /// Will retain `GtkDialog`.
    /// - Parameter other: an instance of a related type that implements `DialogProtocol`
    @inlinable public init<T: DialogProtocol>(dialog other: T) {
        super.init(retainingRaw: other.ptr)
    }

    /// Unsafe typed initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(cPointer p: UnsafeMutablePointer<T>) {
        super.init(cPointer: p)
    }

    /// Unsafe typed, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter cPointer: pointer to the underlying object
    @inlinable override public init<T>(retainingCPointer cPointer: UnsafeMutablePointer<T>) {
        super.init(retainingCPointer: cPointer)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter p: raw pointer to the underlying object
    @inlinable override public init(raw p: UnsafeRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    @inlinable override public init(retainingRaw raw: UnsafeRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter p: mutable raw pointer to the underlying object
    @inlinable public required init(raw p: UnsafeMutableRawPointer) {
        super.init(raw: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter raw: mutable raw pointer to the underlying object
    @inlinable required public init(retainingRaw raw: UnsafeMutableRawPointer) {
        super.init(retainingRaw: raw)
    }

    /// Unsafe untyped initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(opaquePointer p: OpaquePointer) {
        super.init(opaquePointer: p)
    }

    /// Unsafe untyped, retaining initialiser.
    /// **Do not use unless you know the underlying data type the pointer points to conforms to `DialogProtocol`.**
    /// - Parameter p: opaque pointer to the underlying object
    @inlinable override public init(retainingOpaquePointer p: OpaquePointer) {
        super.init(retainingOpaquePointer: p)
    }

    /// Creates a new dialog box.
    /// 
    /// Widgets should not be packed into the `GtkWindow`
    /// directly, but into the `content_area` and `action_area`,
    /// as described above.
    @inlinable override public init() {
        let rv = gtk_dialog_new()
        super.init(gpointer: gpointer(rv))
        if typeIsA(type: self.type, isAType: InitiallyUnownedClassRef.metatypeReference) { _ = self.refSink() } 
    }


    // *** newWithButtons() is not available because it has a varargs (...) parameter!



    // *** newWithButtons() is not available because it has a varargs (...) parameter!


}

public enum DialogPropertyName: String, PropertyNameProtocol {
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case application = "application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case canFocus = "can-focus"
    /// Whether the widget can receive pointer events.
    case canTarget = "can-target"
    /// The child widget.
    case child = "child"
    /// A list of css classes applied to this widget.
    case cssClasses = "css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case cssName = "css-name"
    /// The cursor used by `widget`.
    case cursor = "cursor"
    /// Whether the window should have a frame (also known as *decorations*).
    case decorated = "decorated"
    /// The default height of the window.
    case defaultHeight = "default-height"
    /// The default widget.
    case defaultWidget = "default-widget"
    /// The default width of the window.
    case defaultWidth = "default-width"
    /// Whether the window frame should have a close button.
    case deletable = "deletable"
    /// If this window should be destroyed when the parent is destroyed.
    case destroyWithParent = "destroy-with-parent"
    /// The display that will display this window.
    case display = "display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case focusOnClick = "focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case focusVisible = "focus-visible"
    /// The focus widget.
    case focusWidget = "focus-widget"
    /// Whether this widget itself will accept the input focus.
    case focusable = "focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.fullscreen`] or [method`Gtk.Window.unfullscreen`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case fullscreened = "fullscreened"
    /// How to distribute horizontal space if widget gets extra space.
    case halign = "halign"
    /// Whether the window frame should handle F10 for activating
    /// menubars.
    case handleMenubarAccel = "handle-menubar-accel"
    /// Whether the widget is the default widget.
    case hasDefault = "has-default"
    /// Whether the widget has the input focus.
    case hasFocus = "has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case hasTooltip = "has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case heightRequest = "height-request"
    /// Whether to expand horizontally.
    case hexpand = "hexpand"
    /// Whether to use the `hexpand` property.
    case hexpandSet = "hexpand-set"
    /// If this window should be hidden when the users clicks the close button.
    case hideOnClose = "hide-on-close"
    /// Specifies the name of the themed icon to use as the window icon.
    /// 
    /// See [class`Gtk.IconTheme`] for more details.
    case iconName = "icon-name"
    /// Whether the toplevel is the currently active window.
    case isActive = "is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case layoutManager = "layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginBottom = "margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginEnd = "margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginStart = "margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case marginTop = "margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.maximize`] or [method`Gtk.Window.unmaximize`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case maximized = "maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case mnemonicsVisible = "mnemonics-visible"
    /// If `true`, the window is modal.
    case modal = "modal"
    /// The name of the widget.
    case name = "name"
    /// The requested opacity of the widget.
    case opacity = "opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case overflow = "overflow"
    /// The parent widget of this widget.
    case parent = "parent"
    /// Whether the widget will receive the default action when it is focused.
    case receivesDefault = "receives-default"
    /// If `true`, users can resize the window.
    case resizable = "resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case root = "root"
    /// The scale factor of the widget.
    case scaleFactor = "scale-factor"
    /// Whether the widget responds to input.
    case sensitive = "sensitive"
    /// A write-only property for setting window's startup notification identifier.
    case startupId = "startup-id"
    /// The title of the window.
    case title = "title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipMarkup = "tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case tooltipText = "tooltip-text"
    /// The transient parent of the window.
    case transientFor = "transient-for"
    /// `true` if the dialog uses a headerbar for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    /// 
    /// ## Creating a dialog with headerbar
    /// 
    /// Builtin `GtkDialog` subclasses such as [class`Gtk.ColorChooserDialog`]
    /// set this property according to platform conventions (using the
    /// [property`Gtk.Settings:gtk-dialogs-use-header`] setting).
    /// 
    /// Here is how you can achieve the same:
    /// 
    /// ```c
    /// g_object_get (settings, "gtk-dialogs-use-header", &header, NULL);
    /// dialog = g_object_new (GTK_TYPE_DIALOG, header, TRUE, NULL);
    /// ```
    case useHeaderBar = "use-header-bar"
    /// How to distribute vertical space if widget gets extra space.
    case valign = "valign"
    /// Whether to expand vertically.
    case vexpand = "vexpand"
    /// Whether to use the `vexpand` property.
    case vexpandSet = "vexpand-set"
    /// Whether the widget is visible.
    case visible = "visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case widthRequest = "width-request"
}

public extension DialogProtocol {
    /// Bind a `DialogPropertyName` source property to a given target object.
    /// - Parameter source_property: the source property to bind
    /// - Parameter target: the target object to bind to
    /// - Parameter target_property: the target property to bind to
    /// - Parameter flags: the flags to pass to the `Binding`
    /// - Parameter transform_from: `ValueTransformer` to use for forward transformation
    /// - Parameter transform_to: `ValueTransformer` to use for backwards transformation
    /// - Returns: binding reference or `nil` in case of an error
    @discardableResult @inlinable func bind<Q: PropertyNameProtocol, T: GLibObject.ObjectProtocol>(property source_property: DialogPropertyName, to target: T, _ target_property: Q, flags f: BindingFlags = .default, transformFrom transform_from: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }, transformTo transform_to: @escaping GLibObject.ValueTransformer = { $0.transform(destValue: $1) }) -> BindingRef! {
        func _bind(_ source: UnsafePointer<gchar>, to t: T, _ target_property: UnsafePointer<gchar>, flags f: BindingFlags = .default, holder: BindingClosureHolder, transformFrom transform_from: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean, transformTo transform_to: @convention(c) @escaping (gpointer, gpointer, gpointer, gpointer) -> gboolean) -> BindingRef! {
            let holder = UnsafeMutableRawPointer(Unmanaged.passRetained(holder).toOpaque())
            let from = unsafeBitCast(transform_from, to: BindingTransformFunc.self)
            let to   = unsafeBitCast(transform_to,   to: BindingTransformFunc.self)
            let rv = GLibObject.ObjectRef(raw: ptr).bindPropertyFull(sourceProperty: source, target: t, targetProperty: target_property, flags: f, transformTo: to, transformFrom: from, userData: holder) {
                if let swift = UnsafeRawPointer($0) {
                    let holder = Unmanaged<GLibObject.SignalHandlerClosureHolder>.fromOpaque(swift)
                    holder.release()
                }
            }
            return rv.map { BindingRef($0) }
        }

        let rv = _bind(source_property.name, to: target, target_property.name, flags: f, holder: BindingClosureHolder(transform_from, transform_to), transformFrom: {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_from(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }) {
            let ptr = UnsafeRawPointer($3)
            let holder = Unmanaged<BindingClosureHolder>.fromOpaque(ptr).takeUnretainedValue()
            return holder.transform_to(GLibObject.ValueRef(raw: $1), GLibObject.ValueRef(raw: $2)) ? 1 : 0
        }
        return rv
    }

    /// Get the value of a Dialog property
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func get(property: DialogPropertyName) -> GLibObject.Value {
        let v = GLibObject.Value()
        g_object_get_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
        return v
    }

    /// Set the value of a Dialog property.
    /// *Note* that this will only have an effect on properties that are writable and not construct-only!
    /// - Parameter property: the property to get the value for
    /// - Returns: the value of the named property
    @inlinable func set(property: DialogPropertyName, value v: GLibObject.Value) {
        g_object_set_property(ptr.assumingMemoryBound(to: GObject.self), property.rawValue, v.value_ptr)
    }
}

public enum DialogSignalName: String, SignalNameProtocol {
    /// Emitted when the user activates the default widget
    /// of `window`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    case activateDefault = "activate-default"
    /// Emitted when the user activates the currently focused
    /// widget of `window`.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    case activateFocus = "activate-focus"
    /// Emitted when the user uses a keybinding to close the dialog.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is the Escape key.
    case close = "close"
    /// Emitted when the user clicks on the close button of the window.
    case closeRequest = "close-request"
    /// Signals that all holders of a reference to the widget should release
    /// the reference that they hold.
    /// 
    /// May result in finalization of the widget if all references are released.
    /// 
    /// This signal is not suitable for saving widget state.
    case destroy = "destroy"
    /// Emitted when the text direction of a widget changes.
    case directionChanged = "direction-changed"
    /// Emitted when the user enables or disables interactive debugging.
    /// 
    /// When `toggle` is `true`, interactive debugging is toggled on or off,
    /// when it is `false`, the debugger will be pointed at the widget
    /// under the pointer.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default bindings for this signal are Ctrl-Shift-I
    /// and Ctrl-Shift-D.
    case enableDebugging = "enable-debugging"
    /// Emitted when `widget` is hidden.
    case hide = "hide"
    /// Emitted if keyboard navigation fails.
    /// 
    /// See [method`Gtk.Widget.keynav_failed`] for details.
    case keynavFailed = "keynav-failed"
    /// emitted when the set of accelerators or mnemonics that
    /// are associated with `window` changes.
    case keysChanged = "keys-changed"
    /// Emitted when `widget` is going to be mapped.
    /// 
    /// A widget is mapped when the widget is visible (which is controlled with
    /// [property`Gtk.Widget:visible`]) and all its parents up to the toplevel widget
    /// are also visible.
    /// 
    /// The `map` signal can be used to determine whether a widget will be drawn,
    /// for instance it can resume an animation that was stopped during the
    /// emission of [signal`Gtk.Widget::unmap`].
    case map = "map"
    /// Emitted when a widget is activated via a mnemonic.
    /// 
    /// The default handler for this signal activates `widget` if `group_cycling`
    /// is `false`, or just makes `widget` grab focus if `group_cycling` is `true`.
    case mnemonicActivate = "mnemonic-activate"
    /// Emitted when the focus is moved.
    case moveFocus = "move-focus"
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    case notify = "notify"
    /// Emitted when the widgets tooltip is about to be shown.
    /// 
    /// This happens when the [property`Gtk.Widget:has-tooltip`] property
    /// is `true` and the hover timeout has expired with the cursor hovering
    /// "above" `widget`; or emitted when `widget` got focus in keyboard mode.
    /// 
    /// Using the given coordinates, the signal handler should determine
    /// whether a tooltip should be shown for `widget`. If this is the case
    /// `true` should be returned, `false` otherwise.  Note that if
    /// `keyboard_mode` is `true`, the values of `x` and `y` are undefined and
    /// should not be used.
    /// 
    /// The signal handler is free to manipulate `tooltip` with the therefore
    /// destined function calls.
    case queryTooltip = "query-tooltip"
    /// Emitted when `widget` is associated with a `GdkSurface`.
    /// 
    /// This means that [method`Gtk.Widget.realize`] has been called
    /// or the widget has been mapped (that is, it is going to be drawn).
    case realize = "realize"
    /// Emitted when an action widget is clicked.
    /// 
    /// The signal is also emitted when the dialog receives a
    /// delete event, and when [method`Gtk.Dialog.response`] is called.
    /// On a delete event, the response ID is `GTK_RESPONSE_DELETE_EVENT`.
    /// Otherwise, it depends on which action widget was clicked.
    case response = "response"
    /// Emitted when `widget` is shown.
    case show = "show"
    /// Emitted when the widget state changes.
    /// 
    /// See [method`Gtk.Widget.get_state_flags`].
    case stateFlagsChanged = "state-flags-changed"
    /// Emitted when `widget` is going to be unmapped.
    /// 
    /// A widget is unmapped when either it or any of its parents up to the
    /// toplevel widget have been set as hidden.
    /// 
    /// As `unmap` indicates that a widget will not be shown any longer,
    /// it can be used to, for example, stop an animation on the widget.
    case unmap = "unmap"
    /// Emitted when the `GdkSurface` associated with `widget` is destroyed.
    /// 
    /// This means that [method`Gtk.Widget.unrealize`] has been called
    /// or the widget has been unmapped (that is, it is going to be hidden).
    case unrealize = "unrealize"
    /// The `GtkApplication` associated with the window.
    /// 
    /// The application will be kept alive for at least as long as it
    /// has any windows associated with it (see `g_application_hold()`
    /// for a way to keep it alive without windows).
    /// 
    /// Normally, the connection between the application and the window
    /// will remain until the window is destroyed, but you can explicitly
    /// remove it by setting the :application property to `nil`.
    case notifyApplication = "notify::application"
    /// Whether the widget or any of its descendents can accept
    /// the input focus.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCanFocus = "notify::can-focus"
    /// Whether the widget can receive pointer events.
    case notifyCanTarget = "notify::can-target"
    /// The child widget.
    case notifyChild = "notify::child"
    /// A list of css classes applied to this widget.
    case notifyCssClasses = "notify::css-classes"
    /// The name of this widget in the CSS tree.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyCssName = "notify::css-name"
    /// The cursor used by `widget`.
    case notifyCursor = "notify::cursor"
    /// Whether the window should have a frame (also known as *decorations*).
    case notifyDecorated = "notify::decorated"
    /// The default height of the window.
    case notifyDefaultHeight = "notify::default-height"
    /// The default widget.
    case notifyDefaultWidget = "notify::default-widget"
    /// The default width of the window.
    case notifyDefaultWidth = "notify::default-width"
    /// Whether the window frame should have a close button.
    case notifyDeletable = "notify::deletable"
    /// If this window should be destroyed when the parent is destroyed.
    case notifyDestroyWithParent = "notify::destroy-with-parent"
    /// The display that will display this window.
    case notifyDisplay = "notify::display"
    /// Whether the widget should grab focus when it is clicked with the mouse.
    /// 
    /// This property is only relevant for widgets that can take focus.
    case notifyFocusOnClick = "notify::focus-on-click"
    /// Whether 'focus rectangles' are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input
    /// and should not be set by applications.
    case notifyFocusVisible = "notify::focus-visible"
    /// The focus widget.
    case notifyFocusWidget = "notify::focus-widget"
    /// Whether this widget itself will accept the input focus.
    case notifyFocusable = "notify::focusable"
    /// Whether the window is fullscreen.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.fullscreen`] or [method`Gtk.Window.unfullscreen`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case notifyFullscreened = "notify::fullscreened"
    /// How to distribute horizontal space if widget gets extra space.
    case notifyHalign = "notify::halign"
    /// Whether the window frame should handle F10 for activating
    /// menubars.
    case notifyHandleMenubarAccel = "notify::handle-menubar-accel"
    /// Whether the widget is the default widget.
    case notifyHasDefault = "notify::has-default"
    /// Whether the widget has the input focus.
    case notifyHasFocus = "notify::has-focus"
    /// Enables or disables the emission of the `query-tooltip` signal on `widget`.
    /// 
    /// A value of `true` indicates that `widget` can have a tooltip, in this case
    /// the widget will be queried using [signal`Gtk.Widget::query-tooltip`] to
    /// determine whether it will provide a tooltip or not.
    case notifyHasTooltip = "notify::has-tooltip"
    /// Override for height request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyHeightRequest = "notify::height-request"
    /// Whether to expand horizontally.
    case notifyHexpand = "notify::hexpand"
    /// Whether to use the `hexpand` property.
    case notifyHexpandSet = "notify::hexpand-set"
    /// If this window should be hidden when the users clicks the close button.
    case notifyHideOnClose = "notify::hide-on-close"
    /// Specifies the name of the themed icon to use as the window icon.
    /// 
    /// See [class`Gtk.IconTheme`] for more details.
    case notifyIconName = "notify::icon-name"
    /// Whether the toplevel is the currently active window.
    case notifyIsActive = "notify::is-active"
    /// The `GtkLayoutManager` instance to use to compute the preferred size
    /// of the widget, and allocate its children.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyLayoutManager = "notify::layout-manager"
    /// Margin on bottom side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginBottom = "notify::margin-bottom"
    /// Margin on end of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginEnd = "notify::margin-end"
    /// Margin on start of widget, horizontally.
    /// 
    /// This property supports left-to-right and right-to-left text
    /// directions.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginStart = "notify::margin-start"
    /// Margin on top side of widget.
    /// 
    /// This property adds margin outside of the widget's normal size
    /// request, the margin will be added in addition to the size from
    /// [method`Gtk.Widget.set_size_request`] for example.
    case notifyMarginTop = "notify::margin-top"
    /// Whether the window is maximized.
    /// 
    /// Setting this property is the equivalent of calling
    /// [method`Gtk.Window.maximize`] or [method`Gtk.Window.unmaximize`];
    /// either operation is asynchronous, which means you will need to
    /// connect to the `notify` signal in order to know whether the
    /// operation was successful.
    case notifyMaximized = "notify::maximized"
    /// Whether mnemonics are currently visible in this window.
    /// 
    /// This property is maintained by GTK based on user input,
    /// and should not be set by applications.
    case notifyMnemonicsVisible = "notify::mnemonics-visible"
    /// If `true`, the window is modal.
    case notifyModal = "notify::modal"
    /// The name of the widget.
    case notifyName = "notify::name"
    /// The requested opacity of the widget.
    case notifyOpacity = "notify::opacity"
    /// How content outside the widget's content area is treated.
    /// 
    /// This property is meant to be set by widget implementations,
    /// typically in their instance init function.
    case notifyOverflow = "notify::overflow"
    /// The parent widget of this widget.
    case notifyParent = "notify::parent"
    /// Whether the widget will receive the default action when it is focused.
    case notifyReceivesDefault = "notify::receives-default"
    /// If `true`, users can resize the window.
    case notifyResizable = "notify::resizable"
    /// The `GtkRoot` widget of the widget tree containing this widget.
    /// 
    /// This will be `nil` if the widget is not contained in a root widget.
    case notifyRoot = "notify::root"
    /// The scale factor of the widget.
    case notifyScaleFactor = "notify::scale-factor"
    /// Whether the widget responds to input.
    case notifySensitive = "notify::sensitive"
    /// A write-only property for setting window's startup notification identifier.
    case notifyStartupId = "notify::startup-id"
    /// The title of the window.
    case notifyTitle = "notify::title"
    /// Sets the text of tooltip to be the given string, which is marked up
    /// with Pango markup.
    /// 
    /// Also see [method`Gtk.Tooltip.set_markup`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipMarkup = "notify::tooltip-markup"
    /// Sets the text of tooltip to be the given string.
    /// 
    /// Also see [method`Gtk.Tooltip.set_text`].
    /// 
    /// This is a convenience property which will take care of getting the
    /// tooltip shown if the given string is not `nil`:
    /// [property`Gtk.Widget:has-tooltip`] will automatically be set to `true`
    /// and there will be taken care of [signal`Gtk.Widget::query-tooltip`] in
    /// the default signal handler.
    /// 
    /// Note that if both [property`Gtk.Widget:tooltip-text`] and
    /// [property`Gtk.Widget:tooltip-markup`] are set, the last one wins.
    case notifyTooltipText = "notify::tooltip-text"
    /// The transient parent of the window.
    case notifyTransientFor = "notify::transient-for"
    /// `true` if the dialog uses a headerbar for action buttons
    /// instead of the action-area.
    /// 
    /// For technical reasons, this property is declared as an integer
    /// property, but you should only set it to `true` or `false`.
    /// 
    /// ## Creating a dialog with headerbar
    /// 
    /// Builtin `GtkDialog` subclasses such as [class`Gtk.ColorChooserDialog`]
    /// set this property according to platform conventions (using the
    /// [property`Gtk.Settings:gtk-dialogs-use-header`] setting).
    /// 
    /// Here is how you can achieve the same:
    /// 
    /// ```c
    /// g_object_get (settings, "gtk-dialogs-use-header", &header, NULL);
    /// dialog = g_object_new (GTK_TYPE_DIALOG, header, TRUE, NULL);
    /// ```
    case notifyUseHeaderBar = "notify::use-header-bar"
    /// How to distribute vertical space if widget gets extra space.
    case notifyValign = "notify::valign"
    /// Whether to expand vertically.
    case notifyVexpand = "notify::vexpand"
    /// Whether to use the `vexpand` property.
    case notifyVexpandSet = "notify::vexpand-set"
    /// Whether the widget is visible.
    case notifyVisible = "notify::visible"
    /// Override for width request of the widget.
    /// 
    /// If this is -1, the natural request will be used.
    case notifyWidthRequest = "notify::width-request"
}

// MARK: Dialog signals
public extension DialogProtocol {
    /// Connect a Swift signal handler to the given, typed `DialogSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - handler: The Swift signal handler (function or callback) to invoke on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DialogSignalName, flags f: ConnectFlags = ConnectFlags(0), handler h: @escaping SignalHandler) -> Int {
        connect(s, flags: f, handler: h)
    }
    
    
    /// Connect a C signal handler to the given, typed `DialogSignalName` signal
    /// - Parameters:
    ///   - signal: The signal to connect
    ///   - flags: The connection flags to use
    ///   - data: A pointer to user data to provide to the callback
    ///   - destroyData: A `GClosureNotify` C function to destroy the data pointed to by `userData`
    ///   - signalHandler: The C function to be called on the given signal
    /// - Returns: The signal handler ID (always greater than 0 for successful connections)
    @inlinable @discardableResult func connect(signal s: DialogSignalName, flags f: ConnectFlags = ConnectFlags(0), data userData: gpointer!, destroyData destructor: GClosureNotify? = nil, signalHandler h: @escaping GCallback) -> Int {
        connectSignal(s, flags: f, data: userData, destroyData: destructor, handler: h)
    }
    
    
    /// Emitted when the user uses a keybinding to close the dialog.
    /// 
    /// This is a [keybinding signal](class.SignalAction.html).
    /// 
    /// The default binding for this signal is the Escape key.
    /// - Note: This represents the underlying `close` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `close` signal is emitted
    @discardableResult @inlinable func onClose(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DialogRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder<DialogRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer) -> Void = { unownedSelf, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(DialogRef(raw: unownedSelf))
            return output
        }
        return connect(
            signal: .close,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `close` signal for using the `connect(signal:)` methods
    static var closeSignal: DialogSignalName { .close }
    
    /// Emitted when an action widget is clicked.
    /// 
    /// The signal is also emitted when the dialog receives a
    /// delete event, and when [method`Gtk.Dialog.response`] is called.
    /// On a delete event, the response ID is `GTK_RESPONSE_DELETE_EVENT`.
    /// Otherwise, it depends on which action widget was clicked.
    /// - Note: This represents the underlying `response` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter responseId: the response ID
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `response` signal is emitted
    @discardableResult @inlinable func onResponse(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DialogRef, _ responseId: Int) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<DialogRef, Int, Void>
        let cCallback: @convention(c) (gpointer, gint, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(DialogRef(raw: unownedSelf), Int(arg1))
            return output
        }
        return connect(
            signal: .response,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `response` signal for using the `connect(signal:)` methods
    static var responseSignal: DialogSignalName { .response }
    
    /// The notify signal is emitted on an object when one of its properties has
    /// its value set through `g_object_set_property()`, `g_object_set()`, et al.
    /// 
    /// Note that getting this signal doesn’t itself guarantee that the value of
    /// the property has actually changed. When it is emitted is determined by the
    /// derived GObject class. If the implementor did not create the property with
    /// `G_PARAM_EXPLICIT_NOTIFY`, then any call to `g_object_set_property()` results
    /// in `notify` being emitted, even if the new value is the same as the old.
    /// If they did pass `G_PARAM_EXPLICIT_NOTIFY`, then this signal is emitted only
    /// when they explicitly call `g_object_notify()` or `g_object_notify_by_pspec()`,
    /// and common practice is to do that only when the value has actually changed.
    /// 
    /// This signal is typically used to obtain change notification for a
    /// single property, by specifying the property name as a detail in the
    /// `g_signal_connect()` call, like this:
    /// 
    /// (C Language Example):
    /// ```C
    /// g_signal_connect (text_view->buffer, "notify::paste-target-list",
    ///                   G_CALLBACK (gtk_text_view_target_list_notify),
    ///                   text_view)
    /// ```
    /// 
    /// It is important to note that you must use
    /// [canonical parameter names](#canonical-parameter-names) as
    /// detail strings for the notify signal.
    /// - Note: This represents the underlying `notify::use-header-bar` signal
    /// - Parameter flags: Flags
    /// - Parameter unownedSelf: Reference to instance of self
    /// - Parameter pspec: the `GParamSpec` of the property which changed.
    /// - Parameter handler: The signal handler to call
    /// Run the given callback whenever the `notifyUseHeaderBar` signal is emitted
    @discardableResult @inlinable func onNotifyUseHeaderBar(flags: ConnectFlags = ConnectFlags(0), handler: @escaping ( _ unownedSelf: DialogRef, _ pspec: ParamSpecRef) -> Void ) -> Int {
        typealias SwiftHandler = GLib.ClosureHolder2<DialogRef, ParamSpecRef, Void>
        let cCallback: @convention(c) (gpointer, gpointer, gpointer) -> Void = { unownedSelf, arg1, userData in
            let holder = Unmanaged<SwiftHandler>.fromOpaque(userData).takeUnretainedValue()
            let output: Void = holder.call(DialogRef(raw: unownedSelf), ParamSpecRef(raw: arg1))
            return output
        }
        return connect(
            signal: .notifyUseHeaderBar,
            flags: flags,
            data: Unmanaged.passRetained(SwiftHandler(handler)).toOpaque(),
            destroyData: { userData, _ in UnsafeRawPointer(userData).flatMap(Unmanaged<SwiftHandler>.fromOpaque(_:))?.release() },
            signalHandler: unsafeBitCast(cCallback, to: GCallback.self)
        )
    }
    
    /// Typed `notify::use-header-bar` signal for using the `connect(signal:)` methods
    static var notifyUseHeaderBarSignal: DialogSignalName { .notifyUseHeaderBar }
    
}

// MARK: Dialog Class: DialogProtocol extension (methods and fields)
public extension DialogProtocol {
    /// Return the stored, untyped pointer as a typed pointer to the `GtkDialog` instance.
    @inlinable var dialog_ptr: UnsafeMutablePointer<GtkDialog>! { return ptr?.assumingMemoryBound(to: GtkDialog.self) }

    /// Adds an activatable widget to the action area of a `GtkDialog`.
    /// 
    /// GTK connects a signal handler that will emit the
    /// [signal`Gtk.Dialog::response`] signal on the dialog when the widget
    /// is activated. The widget is appended to the end of the dialog’s action
    /// area.
    /// 
    /// If you want to add a non-activatable widget, simply pack it into
    /// the `action_area` field of the `GtkDialog` struct.
    @inlinable func addActionWidget<WidgetT: WidgetProtocol>(child: WidgetT, responseId: Int) {
        gtk_dialog_add_action_widget(dialog_ptr, child.widget_ptr, gint(responseId))
    
    }

    /// Adds a button with the given text.
    /// 
    /// GTK arranges things so that clicking the button will emit the
    /// [signal`Gtk.Dialog::response`] signal with the given `response_id`.
    /// The button is appended to the end of the dialog’s action area.
    /// The button widget is returned, but usually you don’t need it.
    @inlinable func addButton(buttonText: UnsafePointer<CChar>!, responseId: Int) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_dialog_add_button(dialog_ptr, buttonText, gint(responseId)))) else { return nil }
        return rv
    }


    // *** addButtons() is not available because it has a varargs (...) parameter!


    /// Returns the content area of `dialog`.
    @inlinable func getContentArea() -> BoxRef! {
        let rv = BoxRef(gconstpointer: gconstpointer(gtk_dialog_get_content_area(dialog_ptr)))
        return rv
    }

    /// Returns the header bar of `dialog`.
    /// 
    /// Note that the headerbar is only used by the dialog if the
    /// [property`Gtk.Dialog:use-header-bar`] property is `true`.
    @inlinable func getHeaderBar() -> HeaderBarRef! {
        let rv = HeaderBarRef(gconstpointer: gconstpointer(gtk_dialog_get_header_bar(dialog_ptr)))
        return rv
    }

    /// Gets the response id of a widget in the action area
    /// of a dialog.
    @inlinable func getResponseFor<WidgetT: WidgetProtocol>(widget: WidgetT) -> Int {
        let rv = Int(gtk_dialog_get_response_for_widget(dialog_ptr, widget.widget_ptr))
        return rv
    }

    /// Gets the widget button that uses the given response ID in the action area
    /// of a dialog.
    @inlinable func getWidgetForResponse(responseId: Int) -> WidgetRef! {
        guard let rv = WidgetRef(gconstpointer: gconstpointer(gtk_dialog_get_widget_for_response(dialog_ptr, gint(responseId)))) else { return nil }
        return rv
    }

    /// Emits the `response` signal with the given response ID.
    /// 
    /// Used to indicate that the user has responded to the dialog in some way.
    @inlinable func response(responseId: Int) {
        gtk_dialog_response(dialog_ptr, gint(responseId))
    
    }

    /// Sets the default widget for the dialog based on the response ID.
    /// 
    /// Pressing “Enter” normally activates the default widget.
    @inlinable func setDefaultResponse(responseId: Int) {
        gtk_dialog_set_default_response(dialog_ptr, gint(responseId))
    
    }

    /// A convenient way to sensitize/desensitize dialog buttons.
    /// 
    /// Calls `gtk_widget_set_sensitive (widget, `setting`)`
    /// for each widget in the dialog’s action area with the given `response_id`.
    @inlinable func setResponseSensitive(responseId: Int, setting: Bool) {
        gtk_dialog_set_response_sensitive(dialog_ptr, gint(responseId), gboolean((setting) ? 1 : 0))
    
    }
    /// Returns the content area of `dialog`.
    @inlinable var contentArea: BoxRef! {
        /// Returns the content area of `dialog`.
        get {
            let rv = BoxRef(gconstpointer: gconstpointer(gtk_dialog_get_content_area(dialog_ptr)))
            return rv
        }
    }

    /// Returns the header bar of `dialog`.
    /// 
    /// Note that the headerbar is only used by the dialog if the
    /// [property`Gtk.Dialog:use-header-bar`] property is `true`.
    @inlinable var headerBar: HeaderBarRef! {
        /// Returns the header bar of `dialog`.
        /// 
        /// Note that the headerbar is only used by the dialog if the
        /// [property`Gtk.Dialog:use-header-bar`] property is `true`.
        get {
            let rv = HeaderBarRef(gconstpointer: gconstpointer(gtk_dialog_get_header_bar(dialog_ptr)))
            return rv
        }
    }

    @inlinable var parentInstance: GtkWindow {
        get {
            let rv = dialog_ptr.pointee.parent_instance
            return rv
        }
    }

}



